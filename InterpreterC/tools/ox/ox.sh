
# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
#
# Wrapped by Kurt Bischoff <bischoff@flash> on Sat Apr 16 20:55:37 1994
#
# This archive contains:
#	oxDistG1.04	
#
# Existing files will not be overwritten.
# Error checking via wc(1) will be performed.
# Error checking via sum(1) will be performed.

LANG=""; export LANG
PATH=/bin:/usr/bin:$PATH; export PATH

if sum -r </dev/null >/dev/null 2>&1
then
	sumopt='-r'
else
	sumopt=''
fi

echo mkdir - oxDistG1.04
mkdir oxDistG1.04

if test -f oxDistG1.04/.expand
then
	echo Ok to overwrite existing file oxDistG1.04/.expand\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/.expand
	if test -f oxDistG1.04/.expand
	then
		echo Error: could not remove oxDistG1.04/.expand, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/.expand
cat >oxDistG1.04/.expand <<'@EOF'
#

# cd oxSource 
  # make
# cd ..

chmod -R 700 gppl
cd gppl
make
cd gct
foreach i (711sol2 fact fib hs math mod primes prmfact qsort selSort subArrSort)
  cd $i
  make
  cd ..
end
cd ..
cd ..

chmod -R 700 demo
cd demo
foreach i (calc bintrans traverse convHand/before convHand/after oxTutEGs/eg1 oxTutEGs/eg2 oxTutEGs/eg3  oxTutEGs/eg4 oxTutEGs/eg5)
  pushd $i 
  make
  popd 
end
cd ..


@EOF
set `sum $sumopt <oxDistG1.04/.expand`; if test $1 -ne 55451
then
	echo ERROR: oxDistG1.04/.expand checksum is $1 should be 55451
fi
set `wc -lwc <oxDistG1.04/.expand`
if test $1$2$3 != 2866392
then
	echo ERROR: wc results of oxDistG1.04/.expand are $* should be 28 66 392
fi

chmod 755 oxDistG1.04/.expand

if test -f oxDistG1.04/README
then
	echo Ok to overwrite existing file oxDistG1.04/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/README
	if test -f oxDistG1.04/README
	then
		echo Error: could not remove oxDistG1.04/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/README
cat >oxDistG1.04/README <<'@EOF'
This file contains a description of the contents of version G1.04
of the Ox Distribution Package.  The present directory should
contain the following regular files:

      README        --this file
      COPYRIGHT     --legal notices
      whatOxIs      --general description of Ox
      whatsNew      --things new to this distribution
      register      --how to register as an Ox site or Ox user

and the following directories:

     demo  docs  gppl  source  grammars

The source code for Ox is in the `source' directory.  To install
Ox on your machine, type `cd source' and follow the instructions
in that directory's README file.

The `docs' directory contains the Ox User Reference Manual and
the Ox Tutorial Introduction, in LaTeX device-independent and
PostScript formats.  That directory also contains Ox's on-line
manual.

Some small examples of evaluators built using Ox (including most
of those from the reference manual and the tutorial) are to be
found in the `demo' directory.  See the README file in that
directory.

Ox code for a compiler for a small (80 grammar rules) block-
structured imperative programming language named GPPL is found in
the `gppl' directory.  That directory also contains a document
describing GPPL and its Ox implementation.  The source code
together with the documentation are suitable for instructional
and experimental use.  See the README file in the `gppl'
directory.

The `grammars' directory has Yacc/Lex parsers for popular
languages, converted for use with Ox.  These are included: C,
C++, Ada, Pascal, and FORTRAN.

*****************************************************************
       Ox source code and documentation are copyrighted:

       Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
                      All rights reserved.

Public distribution of Ox (for instance, placing it on an
anonymous-ftp archive or on a CD-ROM) requires permission from
the author.

THIS SOFTWARE IS PROVIDED FOR USE "AS IS" AND WITHOUT ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.
*****************************************************************
@EOF
set `sum $sumopt <oxDistG1.04/README`; if test $1 -ne 65442
then
	echo ERROR: oxDistG1.04/README checksum is $1 should be 65442
fi
set `wc -lwc <oxDistG1.04/README`
if test $1$2$3 != 553022192
then
	echo ERROR: wc results of oxDistG1.04/README are $* should be 55 302 2192
fi

chmod 755 oxDistG1.04/README

if test -f oxDistG1.04/COPYRIGHT
then
	echo Ok to overwrite existing file oxDistG1.04/COPYRIGHT\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/COPYRIGHT
	if test -f oxDistG1.04/COPYRIGHT
	then
		echo Error: could not remove oxDistG1.04/COPYRIGHT, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/COPYRIGHT
cat >oxDistG1.04/COPYRIGHT <<'@EOF'
  -------------------------------------------------------------
            Ox and its documentation are copyrighted:

       Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff.
                      All rights reserved.
  _____________________________________________________________



The author of Ox is Kurt M. Bischoff.

The following policies are intended to contribute to the sane
evolution of Ox.  Your views and ideas about that evolution are
welcome.

     * Use of Ox is free.

     * Code generated by Ox is the property of the individual or
     organization using Ox: the author of Ox puts no claim on
     code generated by Ox.

     * You may not sell this version or any modification of this
     version of Ox, nor may you distribute it publicly (for
     instance, by placing it in an anonymous-ftp archive, or on a
     CD-ROM).  It is strongly suggested that those wanting Ox
     obtain it by anonymous ftp from the /pub/ox directory on
     ftp.cs.iastate.edu.

The existing syntax and semantics of Ox are stable.  Certain
extensions of these are under consideration.  Your ideas for
extending Ox are welcome.

Communications regarding Ox should be sent to:

      ox-project@cs.iastate.edu

THIS SOFTWARE IS PROVIDED FOR USE "AS IS" AND WITHOUT ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.
@EOF
set `sum $sumopt <oxDistG1.04/COPYRIGHT`; if test $1 -ne 13478
then
	echo ERROR: oxDistG1.04/COPYRIGHT checksum is $1 should be 13478
fi
set `wc -lwc <oxDistG1.04/COPYRIGHT`
if test $1$2$3 != 401951414
then
	echo ERROR: wc results of oxDistG1.04/COPYRIGHT are $* should be 40 195 1414
fi

chmod 755 oxDistG1.04/COPYRIGHT

if test -f oxDistG1.04/whatOxIs
then
	echo Ok to overwrite existing file oxDistG1.04/whatOxIs\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/whatOxIs
	if test -f oxDistG1.04/whatOxIs
	then
		echo Error: could not remove oxDistG1.04/whatOxIs, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/whatOxIs
cat >oxDistG1.04/whatOxIs <<'@EOF'
                       This announces Ox:

             An Attribute Grammar Compiling System
                           based on
                        Yacc, Lex, and C

Ox generalizes the function of Yacc in the way that attribute
grammars generalize context-free grammars.  Ordinary Yacc and Lex
specifications may be augmented with definitions of synthesized
and inherited attributes written in C syntax.  Ox checks these
specifications for consistency and completeness, and generates
from them a program that builds and decorates attributed parse
trees.  Ox accepts a most general class of attribute grammars.
The user may specify postdecoration traversals for easy ordering
of side effects such as code generation.  Ox handles the tedious
and error-prone details of writing code for parse-tree
management, so its use eases problems of security and
maintainability associated with that aspect of translator
development.

Ox is a Yacc/Lex/C preprocessor, and is designed to bring
attribute grammars to the mainstream of Unix-based language
development.  Ox inherits all of the familiar syntax and
semantics of Yacc, Lex, and C, so it is a good choice for
language designers, experimenters, and developers familiar with
those tools.  It is relatively easy to convert programs between
Ox code and "pure Yacc/Lex/C" code.  Ox is carefully engineered
for reliability, portability, compatibility, simplicity, and
efficiency.  Ox can be used with Bison, Flex, and C++.

Use of Ox is free.  Code generated by Ox is the property of the
Ox user.  The distribution is available by anonymous ftp from the
directory `/pub/ox' on:

     ftp.cs.iastate.edu

The Ox G1.04 distribution includes:

     * source code (Ox is written in Yacc, Lex, and C)

     * tutorial introduction (new, informal, 19 pages).  This
     emphasizes examples and helps you cover the main points
     quickly.  If you already know Yacc, Lex, and AGs, you are
     soon ready to begin using Ox with your favorite Yacc/Lex
     parser.

     * user reference manual (indexed, up-to-date, 57 pages)

     * on-line manual

     * small examples (files containing all of the examples from
     the user reference manual and the tutorial introduction)

     * Ox-ready Yacc/Lex parsers for C, C++, Pascal, Ada, and
     FORTRAN

     * a large example (block-structured imperative-language
     compiler suitable for instruction and experimentation) with
     documentation

Ox is designed and implemented by Kurt Bischoff, in association
with Kelvin Nilsen, Department of Computer Science, Iowa State
University.  Questions about Ox should be sent to:

     ox-request@cs.iastate.edu

 -------------
 Kurt Bischoff, bischoff@cs.iastate.edu
Sat Apr 16 20:05:07 CDT 1994
@EOF
set `sum $sumopt <oxDistG1.04/whatOxIs`; if test $1 -ne 9186
then
	echo ERROR: oxDistG1.04/whatOxIs checksum is $1 should be 9186
fi
set `wc -lwc <oxDistG1.04/whatOxIs`
if test $1$2$3 != 693822734
then
	echo ERROR: wc results of oxDistG1.04/whatOxIs are $* should be 69 382 2734
fi

chmod 755 oxDistG1.04/whatOxIs

if test -f oxDistG1.04/whatsNew
then
	echo Ok to overwrite existing file oxDistG1.04/whatsNew\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/whatsNew
	if test -f oxDistG1.04/whatsNew
	then
		echo Error: could not remove oxDistG1.04/whatsNew, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/whatsNew
cat >oxDistG1.04/whatsNew <<'@EOF'
             Differences between Ox G1.03 and G1.04
                         April 16, 1994
             --------------------------------------
If you tend to have trouble with cycles, you should upgrade to
this version.

     * Vast increase in the amount of useful information reported
     by the generated evaluator upon detection of a cycle.

     * Improved clarity of messages issued by Ox upon detection
     of incomplete or inconsistent attribute definition section.

     * Increased the default sizes of data structures for parse-
     tree management in the generated evaluator.

     * Fixed incorrect declaration of yyyerror under -I option.

     * Fixed incorrect behavior (regarding storage of dependee
     counts) of the generated evaluator upon detection of a
     cycle.



             Differences between Ox G1.02 and G1.03
                        February 8, 1994
             --------------------------------------
     * Fixed bug wherein Ox was not accepting the C++ reserved
     word `class' in attribute declarations.



             Differences between Ox G1.01 and G1.02
                        February 7, 1994
             --------------------------------------
This is mainly a bug-fix release.  Almost all of the bugs were of
the kind observed during the running of Ox, rather than during
running of the generated evaluator.  Thanks to those who sent bug
reports.

     * Fixed -S option, which wasn't correctly stripping @autoinh
     and @autosyn constructs from the Y-file.

     * Fixed minor incompatibilities regarding use with C++.

     * Fixed minor incompatibilities regarding use with Bison.

     * Fixed incorrect reporting of line numbers upon
     unterminated strings, comments, C-code sections, etc.

     * Eliminated various causes of segmentation faults that
     occurred when Ox tried to continue after its data structures
     became incorrect due to errors in the Y-file.

     * Disabled the use of nested macros, pending resolution of a
     bug that results in a segmentation fault.

     * Fixed bug wherein Ox produced (for grammars of more than
     255 grammar rules) evaluators that falsely reported cycles
     in the parse tree, possibly followed by a segmentation
     fault.

     * Fixed bug that caused a segmentation fault in the
     generated evaluator for parse trees with cycles.

     * Improved reporting in case of cycle detection--now prints
     the number of the grammar rule that labels the root of a
     subtree in which a cycle is detected.



     Changes, improvements, inclusions new to version G1.01
                        November 14, 1993
     ------------------------------------------------------
     * Ox Tutorial Introduction (19 pages).  This new paper uses
     examples and an informal style to quickly familiarize the
     reader with the main features of Ox.

     * (updated) Ox User Reference Manual (57 pages).  Includes
     coverage of features added since December 1992.  An index
     has been added, and coverage of certain features has been
     expanded.

     * Files containing all examples from the tutorial and the
     reference manual, ready to test and modify.

     * Ox grammars for popular languages.  Included are Yacc/Lex
     grammars for C, C++, Ada, Pascal, and FORTRAN that have been
     converted (mainly by modifying Makefiles) for use with Ox.

     * compatible names for Ox's output files:  Ox now outputs
     files with the the names `oxout.y' and `oxout.l', instead of
     `ox.out.y' and `ox.out.l'.  This is to make Ox translators
     more easily portable to operating systems (such as DOS) that
     have file-naming rules that are more restrictive than those
     of Unix.

     * minor bug fixes.
@EOF
set `sum $sumopt <oxDistG1.04/whatsNew`; if test $1 -ne 5396
then
	echo ERROR: oxDistG1.04/whatsNew checksum is $1 should be 5396
fi
set `wc -lwc <oxDistG1.04/whatsNew`
if test $1$2$3 != 975043745
then
	echo ERROR: wc results of oxDistG1.04/whatsNew are $* should be 97 504 3745
fi

chmod 755 oxDistG1.04/whatsNew

if test -f oxDistG1.04/register
then
	echo Ok to overwrite existing file oxDistG1.04/register\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/register
	if test -f oxDistG1.04/register
	then
		echo Error: could not remove oxDistG1.04/register, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/register
cat >oxDistG1.04/register <<'@EOF'
This tells how to register as an Ox user or Ox site.  You should
register if you have questions or suggestions, want to report a
bug, or want to receive general information or information about
updates.

To register, please send a short description (a few lines or so)
of each of the following:

     The purpose(s) for which you are using or expect to be using
     Ox, and the approximate number of users.

     Your company and/or academic affiliation(s), if applicable.

     The hardware and software environment(s) in which you run Ox
     and the evaluators it generates.

to:

     ox-request@cs.iastate.edu
@EOF
set `sum $sumopt <oxDistG1.04/register`; if test $1 -ne 50708
then
	echo ERROR: oxDistG1.04/register checksum is $1 should be 50708
fi
set `wc -lwc <oxDistG1.04/register`
if test $1$2$3 != 1996616
then
	echo ERROR: wc results of oxDistG1.04/register are $* should be 19 96 616
fi

chmod 755 oxDistG1.04/register

echo mkdir - oxDistG1.04/source
mkdir oxDistG1.04/source

if test -f oxDistG1.04/source/README
then
	echo Ok to overwrite existing file oxDistG1.04/source/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/README
	if test -f oxDistG1.04/source/README
	then
		echo Error: could not remove oxDistG1.04/source/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/README
cat >oxDistG1.04/source/README <<'@EOF'
The present directory contains Ox's source code.  To produce an
executable file `ox', you need yacc, lex, make and a C compiler.
Just follow these easy steps:


Configuring Ox (optional)

     Some may wish to do a custom configuration of Ox according
     to the comments in the file `mDeps.h'.  In particular, those
     running Ox on 64-bit architectures such as DEC Alpha must,
     before proceeding, make the simple modification described in
     that file.  For 32-bit architectures, the default
     configuration will work, so those just wanting to get
     started can skip modification of `mDeps.h', and go to the
     next step.


Making ox

     Remain in the present directory and type:

          make ox

     This step may take a few minutes or more, and leaves an
     executable file on `ox'.  It is normal to see a message
     like:

          diff y.tab.h y.tab.h.bak > y.tab.h.diff 2>&1
          *** Error code 1 (ignored)

     during the make.


Putting ox on your path

     Move or copy the file `ox' that you just built to wherever
     you want it.  (Set the execute permissions appropriately and
     make sure that `ox' can be found via your path.)


Cleaning up (optional)

     You can remove from the present directory the object-file
     clutter produced above by doing:

          make clean

If you need to reconfigure Ox or build it again, follow these
instructions again from the beginning.


*****************************************************************
       Ox source code and documentation are copyrighted:

       Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
                      All rights reserved.

Public distribution of Ox (for instance, placing it on an
anonymous-ftp archive or on a CD-ROM) requires permission from
the author.

THIS SOFTWARE IS PROVIDED FOR USE "AS IS" AND WITHOUT ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.
*****************************************************************
@EOF
set `sum $sumopt <oxDistG1.04/source/README`; if test $1 -ne 27310
then
	echo ERROR: oxDistG1.04/source/README checksum is $1 should be 27310
fi
set `wc -lwc <oxDistG1.04/source/README`
if test $1$2$3 != 662882058
then
	echo ERROR: wc results of oxDistG1.04/source/README are $* should be 66 288 2058
fi

chmod 755 oxDistG1.04/source/README

if test -f oxDistG1.04/source/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/source/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/Makefile
	if test -f oxDistG1.04/source/Makefile
	then
		echo Error: could not remove oxDistG1.04/source/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/Makefile
cat >oxDistG1.04/source/Makefile <<'@EOF'
# $Header: Makefile,v 5.10 94/04/16 20:23:32 bischoff Exp $ 

#              copyright (c) 1992, 1993  Kurt M. Bischoff
#
# You may modify this file for the purpose of adapting Ox to your hardware
# or software environment.
 
CC=cc

SHELL= /bin/sh

ox: ytab.o symTrans.o outMgr.o depGs.o joinTabs.o ctc.o opts.o \
     scan.o lexyy1.o lexyy2.o lexyy3.o lexyy4.o lexyy5.o mac.o trav.o \
     treeShow.o xtreeshw.o
	$(CC) -o ox ytab.o lexyy1.o lexyy2.o lexyy3.o lexyy4.o lexyy5.o \
	scan.o symTrans.o outMgr.o depGs.o joinTabs.o ctc.o opts.o \
	mac.o trav.o treeShow.o xtreeshw.o

medyy : medyy.l 
	lex medyy.l; $(CC) -o medyy lex.yy.c -ll 

medi : medi.l 
	lex medi.l; $(CC) -o medi lex.yy.c -ll  

lexyy1.c : agc1.l medyy 
	lex agc1.l; ./medyy lex.yy.c lexyy1.c 1 

lexyy2.c : agc2.l medyy medi  
	lex agc2.l; ./medi lex.yy.c lex.yyM2.c ; ./medyy lex.yyM2.c lexyy2.c 2

lexyy3.c : agc3.l medyy medi  
	lex agc3.l; ./medi lex.yy.c lex.yyM3.c ; ./medyy lex.yyM3.c lexyy3.c 3

lexyy4.c : agc4.l medyy medi  
	lex agc4.l; ./medyy lex.yy.c lexyy4.c 4  

lexyy5.c : agc5.l medyy medi  
	lex agc5.l; ./medi lex.yy.c lex.yyM5.c ; ./medyy lex.yyM5.c lexyy5.c 5

lexyy1.o : lexyy1.c glob.h scan.h opts.h outMgr.h symTrans.h ctc.h
	$(CC) -c lexyy1.c   

lexyy2.o : lexyy2.c glob.h scan.h outMgr.h trav.h depGs.h \
                    symTrans.h mac.h opts.h
	$(CC) -c lexyy2.c  

lexyy3.o : lexyy3.c glob.h scan.h outMgr.h depGs.h opts.hh \
                    opts.h symTrans.h mac.h joinTabs.h
	$(CC) -c lexyy3.c   

lexyy4.o : lexyy4.c glob.h scan.h opts.hh opts.h outMgr.h
	$(CC) -c lexyy4.c   

lexyy5.o : lexyy5.c glob.h scan.h outMgr.h depGs.h opts.hh \
                    opts.h symTrans.h mac.h joinTabs.h
	$(CC) -c lexyy5.c   

scan.h : ytab.h.bak 
	touch scan.h	

scan.o : scan.c glob.h opts.hh opts.h symTrans.h
	$(CC) -c scan.c  

ytab.c ytab.h: agc.y 
	yacc -dv agc.y
	mv y.tab.c ytab.c
	mv y.tab.h ytab.h
	-diff ytab.h ytab.h.bak > ytab.h.diff 2>&1 
	if test -s ytab.h.diff; then cp ytab.h ytab.h.bak; fi
	rm ytab.h.diff

symTrans.o: symTrans.c glob.h opts.hh opts.h scan.h joinTabs.h
	$(CC) -c symTrans.c 

depGs.o: depGs.c glob.h opts.hh opts.h trav.h symTrans.h \
                 joinTabs.h scan.h outMgr.h
	$(CC) -c depGs.c 

outMgr.o: outMgr.c glob.h opts.hh opts.h symTrans.h mac.h joinTabs.h scan.h
	$(CC) -c outMgr.c 

joinTabs.o: joinTabs.c glob.h opts.h depGs.h symTrans.h ctc.h \
	treeShow.h xtreeshw.h
	$(CC) -c joinTabs.c 

ytab.o: ytab.c glob.h opts.hh opts.h trav.h outMgr.h depGs.h \
               symTrans.h ctc.h joinTabs.h scan.h
	$(CC) -c ytab.c  

ctc.o: ctc.c glob.h opts.h trav.h symTrans.h joinTabs.h
	$(CC) -c ctc.c 

opts.o: opts.c opts.hh mDeps.h trav.h patchlvl.h \
               mac.h depGs.h symTrans.h outMgr.h
	$(CC) -c opts.c 

mac.o: mac.c opts.hh
	$(CC) -c mac.c 

trav.o: trav.c glob.h opts.hh symTrans.h joinTabs.h outMgr.h 
	$(CC) -c trav.c 

treeShow.o: treeShow.c 
	$(CC) -c treeShow.c 

xtreeshw.o: xtreeshw.c 
	$(CC) -c xtreeshw.c 

clean: 
	rm *.o ytab.c ytab.h lexyy*.c y.output medyy medi  

cleaner: clean
	rm ox

LC:
	lint -hx ctc.c depGs.c joinTabs.c opts.c \
             outMgr.c scan.c symTrans.c mac.c \
	     ytab.c lexyy[12345].c trav.c treeShow.c xtreeshw.c



@EOF
set `sum $sumopt <oxDistG1.04/source/Makefile`; if test $1 -ne 46730
then
	echo ERROR: oxDistG1.04/source/Makefile checksum is $1 should be 46730
fi
set `wc -lwc <oxDistG1.04/source/Makefile`
if test $1$2$3 != 1214283224
then
	echo ERROR: wc results of oxDistG1.04/source/Makefile are $* should be 121 428 3224
fi

chmod 755 oxDistG1.04/source/Makefile

if test -f oxDistG1.04/source/agc.y
then
	echo Ok to overwrite existing file oxDistG1.04/source/agc.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/agc.y
	if test -f oxDistG1.04/source/agc.y
	then
		echo Error: could not remove oxDistG1.04/source/agc.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/agc.y
cat >oxDistG1.04/source/agc.y <<'@EOF'
/* $Header: agc.y,v 5.10 94/04/16 20:23:49 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

%token ID  
%token IDCOLON  /* identifier (but not literal) followed by colon */   
%token NUM  /* [0-9]+ */ 

	/* reserved words:  %type => TYPE,  %left => LEFT, etc.  */  
%token LEFT RIGHT NONASSOC TOKEN PREC TYPE START UNION 
%token MARK MARK2  /* the %% mark */  
%token LCURL  /* the %{ mark */  

	/* tokens of (yox - yacc) */ 
%token STRUCT UNIONC ENUM ATTRIBUTES LBRACE RBRACE ATMACRO ATEND
%token ATTRAV PREORDER POSTORDER LEFTTORIGHT RIGHTTOLEFT DISABLE
%token AUTOSYN AUTOINH ATWARN
%token TRAVID
%token ATI ATCAPI ATM ATE ATID 
%token PRUNE DECORATE 
%token CHAR CLASS SHORT INT LONG SIGNED UNSIGNED TFLOAT DOUBLE VOID 
%token EOSF RETURN  

%start spec   

%{ 
#include <stdio.h> 

#include "glob.h" 
#include "opts.hh" 
#include "opts.h" 
#include "trav.h"
#include "outMgr.h"
#include "depGs.h"
#include "symTrans.h"
#include "ctc.h"
#include "joinTabs.h"
#include "scan.h"
%} 

%% 
spec 	: 	specG 	
		EOSF 
		specL specLseq 
		{organizeTables(); 
		} 
	; 

specG	:	defs 	MARK 	
		{setupDumNodeSym(); 
		 printSASheader();
		 suppressPruning |= someTravEnabled();
		} 
		rules  	
		{printSAStrailer(); 
		} 
		root_attrb_ref_section 
		{fprintf(temp1Out,"} /* yyyExecuteRRsection */ \n"); 
		}  
		tail     
		{flushLAbuffer(LA1,outG);} 
	; 

tail 	:       {fprintf(yoxOutG,"\n%%%%\n");} 
	|  	{beginTT();}  MARK  
	;  
 
root_attrb_ref_section  
	: 	
	; 

defs	:	
	|	defs def 
	; 

def 	:	START ID {installStartSym(startSymLexeme);}  
	|	UNION {line = *plineno;}      
 	|	LCURL {beginCC(); line = *plineno;}    
	|	rword tag nlistT   
	|	TYPE tag nlist   
	|	attrb_modifier	autoIDseq
	|	ATTRIBUTES 
		{initForAttrbDeclList();} 
		'{' attribute_decl_list '}' 
                {afterAttrbDeclList();} 
              	grammar_symbol_list 
	|	ATMACRO	ID	
		{initMacroDef(IDbuffer);}
		'('	macroFrmPrmList	')'	
		ATEND	
		{terminateMacroDef();}
	|	ATTRAV 	
		{clearTravBuf();}
		travSpecSeq	
		travIDseq	
	; 

rword	: 	TOKEN
	|	LEFT 
	| 	RIGHT 
	|	NONASSOC
	; 
	
tag 	:	 
	|	'<'  ID  '>'  
	; 

nlist 	: 	ID 
	| 	nlist ID 
	|	nlist  ','  ID 
	; 

nlistT 	: 	nmnoT 
	| 	nlistT nmnoT 
	|	nlistT  ','  nmnoT 
	; 

nmnoT 	:	ID {installGsymAsTokenIfNew(IDbuffer);} 
                /* yacc will catch the error later */     
	|	NUM 
	; 

autoIDseq
	:
	|	autoIDseq	ID	
		{stringAutoDef(IDbuffer,autoSyn,autoInh,autoWarning);}
	;

attribute_decl_list  
	: 
	| 	attribute_decl_list attribute_decl   
	; 

attribute_decl  
	:	attrb_modifier_opt type_specifier id_seq stars ID 
		{bufferAnAttrbID(IDbuffer,autoSyn,autoInh,autoWarning);} 
		field_length_spec 
		';' 
	|	VOID id_seq2 ID  
		{bufferAnAttrbID(IDbuffer,autoSyn,autoInh,autoWarning);} 
		';' 
	; 

attrb_modifier_opt
	: 	{autoSyn = 0;
		 autoInh = 0;
                 autoWarning = 0;
		}
	|	attrb_modifier
	;

attrb_modifier
	:	{autoSyn = 1;
		 autoInh = 0;
		}
	 	AUTOSYN	atWarnOpt 
	|	{autoSyn = 0;
		 autoInh = 1;
		}
	 	AUTOINH	atWarnOpt 
	;

atWarnOpt
	:		{autoWarning = 0;}
	|	ATWARN	{autoWarning = 1;}
	;

type_specifier
	: STRUCT ID   
	| UNIONC ID 
	| ENUM ID
	| CLASS ID
	| ID  	
	| type_keyword_list
	; 

type_keyword_list 
	: 	type_keyword
	|	type_keyword_list type_keyword 
	; 

type_keyword 
	: CHAR | SHORT | INT | LONG | TFLOAT 
	| DOUBLE | SIGNED | UNSIGNED 
	;

id_seq 	:	
	|	id_seq stars ID 
		{bufferAnAttrbID(IDbuffer,autoSyn,autoInh,autoWarning);} 
		','  
	; 

id_seq2	:	
	|	id_seq2 ID 
		{bufferAnAttrbID(IDbuffer,autoSyn,autoInh,autoWarning);} 
		','  
	; 

stars 	: 
	| 	stars '*'  
	;

field_length_spec 
	:	
	|	':' NUM 
	;  
	
grammar_symbol_list 
	:	
	|	grammar_symbol_list ID 
		{installGsymAfterAttrbDeclList(IDbuffer);}  
	;

macroFrmPrmList
	:	
	|	macroFrmPrmList	ID	','
		{installMacroFrmPrm(IDbuffer);}
	;

travSpecSeq
	:	
	|	travSpecSeq	travSpec
	;

travIDseq
	:	
	|	travIDseq	ID	
		{newTrav(IDbuffer);}
	;

travSpec
	:	PREORDER	{travBuf.PRE = 1;}
	|	POSTORDER	{travBuf.POST = 1;}
	|	LEFTTORIGHT	{travBuf.LR = 1;}
	|	RIGHTTOLEFT	{travBuf.RL = 1;}
	|	DISABLE		{travBuf.DA = 1;}
	;
	
rules 	:	IDCOLON 
		{prodBufferPointer2 = 0; errorProd = 0; incProdNumSeq(); 
                 putSymbolInProdBuffer2(installGsymAsNontermIfNew(IDbuffer)); 
                } 
		rbody attrb_def_section  
	|	rules rule  
	; 

rule 	:	IDCOLON  
		{prodBufferPointer2 = 0; errorProd = 0; incProdNumSeq();  
                 putSymbolInProdBuffer2(installGsymAsNontermIfNew(IDbuffer)); 
                } 
 		rbody attrb_def_section  
	| 	'|'  
		{prodBufferPointer2 = 1; errorProd = 0; incProdNumSeq();  
		} 
		rbody attrb_def_section  
	; 

rbody 	: 
	|	rbody ID 
		{if (IDbuffer[0] != '\'')  
                    putSymbolInProdBuffer2(installGsymAsNontermIfNew(IDbuffer));
                    else 
                    putSymbolInProdBuffer2(installGsymAsTokenIfNew(IDbuffer));  
                }  
	|	rbody PREC ID   
	|	rbody act  
	; 

act  	: 	{beginAA(); line = *plineno; nLbraces = 1;} 
		'{' 
		'}'         
	; 

attrb_def_section 
	: 	{initLDG();} 
		a_d_s_body 
		{/* showDepGraph(stderr); */
                 checkAttrbsSynOrInh();
		 /* showDepGraph(stderr); */
                 doPruneCondChecks(); 
                 /* showSymInfoForProd(); */
                 printProd();
		 if (errorProd) fprintf(yoxOutG,"{yyyYok=0;if(0){");  
		    else        fprintf(yoxOutG,"{if(yyyYok){");  
		 printIntNodeGenInvocation();    
		 ldgTopSort();  
                 outputTravCodePerProd();
		 conveyLocalDepGraphInfo();  
		 fprintf(yoxOutG,"}}");   
   		 flushLAbuffer(LA1,outG);  
		}   
	|	attrb_def_section ';' 
	; 

a_d_s_body 
	: 	
	|	LBRACE 
		{pruneRequested = 0; 
		 decorationRequested = 0;
                } 
		nodeCmdList 
		attrb_def_list 
		RBRACE   
	;

nodeCmdList 
	: 
	|	nodeCmd nodeCmdList 
	; 

nodeCmd 
	:	PRUNE 	{pruneRequested = 1;}  
	|	DECORATE  {decorationRequested = 1;}  
	; 

attrb_def_list 
	:	
	|	attrb_def_list trav_segm 
	|	attrb_def_list attrb_def {processAdepSpec();}  
	; 

attrb_def:	ATI ID 
		{memberDepend(bufPosInProd,bufAttrbNum,1,1); 
		} 
		im_dependee_ref_seq 

	|	ATCAPI ID 
		{memberDepend(bufPosInProd,bufAttrbNum,1,1); 
		} 
		mm_dependee_ref_seq 

	|	ATM dependent_name_seq ';' mm_dependee_ref_seq 

	|	ATE dependent_name_seq ':' dependee_name_seq ';' ref_seq   

	; 

im_dependee_ref_seq  	/* im = implicit mode */
	:	
	|	im_dependee_ref_seq ID 
		{if (!memberDepend(bufPosInProd,bufAttrbNum,1,0))
		    memberDepend(bufPosInProd,bufAttrbNum,0,1);
		    else 
		    ywarning("implicit dependent depends on itself\n"); 
		} 
	;
 
mm_dependee_ref_seq 	/* mm = mixed mode */ 
	:	
	|	mm_dependee_ref_seq ID 
		{if (!memberDepend(bufPosInProd,bufAttrbNum,1,0))
		    memberDepend(bufPosInProd,bufAttrbNum,0,1);
		} 
	;
 
dependent_name_seq  
	:	ID 	
		{memberDepend(bufPosInProd,bufAttrbNum,1,1);} 
	|	dependent_name_seq ID 
		{if (memberDepend(bufPosInProd,bufAttrbNum,1,1)) 
                    yerror("duplicate dependent\n"); 
		} 
	; 
 
dependee_name_seq  
	:	
	|	dependee_name_seq ID 
		{if (memberDepend(bufPosInProd,bufAttrbNum,1,0)) 
                    yerror("attribute depends immediately on itself\n"); 
		    else 
		    {if (memberDepend(bufPosInProd,bufAttrbNum,0,1)) 
                        yerror("duplicate dependee\n"); 
                    } 
		} 
	; 
 
ref_seq : 
	|	ref_seq ID  
		{if (!memberDepend(bufPosInProd,bufAttrbNum,0,0) &&  
		     !memberDepend(bufPosInProd,bufAttrbNum,1,0) 
		    ) 
    yerror("in explicit mode, referred to attribute not named explicitly\n"); 
		}
	; 

trav_segm
	:	ATID
	|	ATID	'('	')'
	|	ATID	'('	')' 	'('	')'
	;

specLseq:
	|	specL	specLseq
	; 

specL 	:	MARK Lrules   		EOSF
	|	MARK Lrules MARK2 	EOSF
	|	     Lrules 		EOSF
	; 

Lrules 	: 	
	|	Lrules 
		RETURN 
		{prodBufferPointer2 = 0;  errorProd = 0;} 
		returnObject 
		';'    
		attrb_def_sectionL 
		{checkAttrbsSynOrInh();
		}
	;

returnObject 
	: 	
	|	ID 
		{putSymbolInProdBuffer2(installGsymAsTokenIfNew(IDbuffer));  
		 installLeafRefCountInitList();  
	 	 initLDG();
    		} 
	;

attrb_def_sectionL 
	:	 
	| 	LBRACE 
		ref_seqL 
		RBRACE 
	; 
	
ref_seqL  
	:	
	|	ref_seqL ID
		{
		 if (memberDepend(bufPosInProd,bufAttrbNum,1,1)) 
                    yerror("attribute multiply defined\n"); 
		 genImmCrefForAttrbRef(bufPosInProd,bufAttrbNum,0,
				       Lfile[currentLfile].outPtr 
				      );  
                 processAdepSpec(); 
		} 
	; 
 
%% 


main(argc,argv) 
  int argc; 
  char *argv[];  
{openIOfilesAndSetOptions(argc,argv);  
 if (stripOxConstructs)
    {fprintf(yoxOutG,"%%{\nvoid yyyerror(){}\n");
     fprintf(yoxOutG,"void yyyCheckForResizes(){}\n%%}\n");
     currentLfile++;
     scanInit4(); 
     yy4lex();
     closeIOfiles(); 
     return(0);
    }
 openTempFiles();  
 prepareDataStructures1(); 
 prepareDataStructures2(); 
 prepareDataStructuresMD(); 
 prepareDataStructuresMU(); 
 yyparse(); 
 closeIOfiles(); 
 rmTempFiles(); 
 if (removeOutput && !saveBadOutputs) rmOutputFiles(); 
 if (!buildHeaderFile) erasf(yoxOutFileStrH);   
 if (removeOutput)
    return(-1); 
    else 
    return(0); 
} 
 
/* First choice for determining the type of node to put on the tree at shift 
 * time is to find it in a well-formed object of a return statement.  Second
 * choice is to look at the grammar symbol in the first attribute reference 
 * of the attribute definition section if such section is nonempty.  If all
 * else fails, assume the node is attribute-less.  
 */ 

@EOF
set `sum $sumopt <oxDistG1.04/source/agc.y`; if test $1 -ne 1939
then
	echo ERROR: oxDistG1.04/source/agc.y checksum is $1 should be 1939
fi
set `wc -lwc <oxDistG1.04/source/agc.y`
if test $1$2$3 != 536133211737
then
	echo ERROR: wc results of oxDistG1.04/source/agc.y are $* should be 536 1332 11737
fi

chmod 755 oxDistG1.04/source/agc.y

if test -f oxDistG1.04/source/agc1.l
then
	echo Ok to overwrite existing file oxDistG1.04/source/agc1.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/agc1.l
	if test -f oxDistG1.04/source/agc1.l
	then
		echo Error: could not remove oxDistG1.04/source/agc1.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/agc1.l
cat >oxDistG1.04/source/agc1.l <<'@EOF'
%start YD YDSI ADECL MH MB LVA ADSL UU CC TRDECL 
 
 
%{
/* $Header: agc1.l,v 5.10 94/04/16 20:23:52 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include "glob.h"
#include "scan.h"
#include "opts.h"
#include "outMgr.h"
#include "symTrans.h"
#include "ctc.h"
%}
 
 
WS		[ \t\f]+
OPTWS		[ \t\f]*
NON_WS		[^ \t\f\n]

CHAR_CONST      ('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')    
DOT_NAME        ([a-zA-Z_.][a-zA-Z_0-9.]*) 

GS (('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')|([a-zA-Z_][a-zA-Z_0-9.]*)) 
ATTRB_NAME (('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')?([a-zA-Z_0-9.]+)) 
 
IDENT ([a-zA-Z][a-zA-Z0-9]*)

%%
<YD>[ \t\n\f]          charOut(*yytext,outG);          
<YD>\/\*               eatCommentAndEcho(outG,1);
<YD>\/\/.*\n           lexemeOut(outG);
<YD>{CHAR_CONST}       {lexemeOut(outG); 
                        IDbuffer = stringLookup((char *)yytext,yyleng,1); 
                        return(ID); 
                       }  
<YD>{DOT_NAME}         {if (!autoSyn && !autoInh) lexemeOut(outG); 
                        IDbuffer = stringLookup((char *)yytext,yyleng,1); 
                        return(ID); 
                       }  
<YD>[0-9]+             {lexemeOut(outG); return(NUM);} 
<YD>\%left             {lexemeOut(outG); return(LEFT);} 
<YD>\%right            {lexemeOut(outG); return(RIGHT);} 
<YD>\%nonassoc         {lexemeOut(outG); return(NONASSOC);} 
<YD>\%term             {lexemeOut(outG); return(TOKEN);} 
<YD>\%token            {lexemeOut(outG); return(TOKEN);} 
<YD>\%type             {lexemeOut(outG); return(TYPE);} 
<YD>\%start            {lexemeOut(outG); BEGIN YDSI; return(START);}  
<YDSI>[ \t\n\f]        charOut(*yytext,outG);           
<YDSI>\/\*             eatCommentAndEcho(outG,1);
<YDSI>\/\/.*\n         lexemeOut(outG);
<YDSI>{DOT_NAME}       {startSymLexeme = stringLookup((char *)yytext,yyleng,1); 
                        fprintf(yoxOutG,"%s",augNstr); 
                        BEGIN YD; 
                        return(ID);  
                       }  
<YD>\%union            {lexemeOut(outG); nLbraces = 0;
                        BEGIN UU; return(UNION); 
                       }
<YD,ADECL>@autosyn[ \n\t\f]  return(AUTOSYN); 
<YD,ADECL>@autoinh[ \n\t\f]  return(AUTOINH); 
<YD,ADECL>@warn[ \n\t\f]     return(ATWARN); 
<YD>@attributes[ \n\t\f]        {BEGIN ADECL; return(ATTRIBUTES);} 
<YD>@macro[ \n\t\f]             {BEGIN MH; return(ATMACRO);}
<YD>@traversal[ \n\t\f]         {BEGIN TRDECL; return(ATTRAV);}
<MH>[ \t\n\f]          ;
<MH>\/\*               eatCommentAndEcho(outG,1); 
<MH>\/\/.*\n           lexemeOut(outG);
<MH>{IDENT}            {IDbuffer = stringLookup((char *)yytext,yyleng,1); 
                        return(ID);
                       } 
<MH>\(                 return('(');
<MH>[,]                return(','); 
<MH>\)                 {BEGIN MB; return(')');}
<MH>.                  {yerror("character illegal in macro heading:");
                        fprintf(stderr," %o octal\n",*yytext);
                       }
<MB>\/\*               eatCommentAndEcho(outMB,1); 
<MB>\/\/.*\n           lexemeOut(outMB);
<MB>\"                 eatStringAndEcho(outMB); 
<MB>{CHAR_CONST}       lexemeOut(outMB); 
<MB>{IDENT}            {putIDinMacroDefBody(
                                stringLookup((char *)yytext,yyleng,1)
                                           );
                       }
<MB>\\@/end[ \n\t\f]            charOut('@',outMB);    
<MB>@end[ \n\t\f]               {BEGIN YD; return(ATEND);}  
<MB>.|\n               charOut(*yytext,outMB);    
<TRDECL>@postorder[ \n\t\f]     return(POSTORDER); 
<TRDECL>@preorder[ \n\t\f]      return(PREORDER);
<TRDECL>@lefttoright[ \n\t\f]   return(LEFTTORIGHT);
<TRDECL>@righttoleft[ \n\t\f]   return(RIGHTTOLEFT);
<TRDECL>@disable[ \n\t\f]       return(DISABLE);
<TRDECL>{IDENT}        {IDbuffer = stringLookup((char *)yytext,yyleng,1); 
                        return(ID);
                       } 
<LVA>{DOT_NAME}        {IDbuffer = stringLookup((char *)yytext,yyleng,1); 
                        return(ID);
                       } 
<YD>\%\%               {afterAllAttrbDecls();  
                        compilerTextCopy5();  
                        if (!buildHeaderFile) 
                           {
                            fprintf(yoxOutG,"\n%%{\n");  
                            appendToOutFile(yoxOutH,yoxOutFileStrH,yoxOutG); 
                            fprintf(yoxOutG,"\n%%}\n");  
                           } 
                        compilerTextCopy10();  
                        lexemeOut(outG); 
                        scanInit2(); 
                        return(MARK); 
                       } 
<YD>\%\{               {lexemeOut(outG); return(LCURL);} 
<YD>\<                 {charOut('<',outG); return('<');}   
<YD>\>                 {charOut('>',outG); return('>');}   
<YD>[,]                {charOut(',',outG); return(',');}   
<YD>\{                 {charOut('{',outG); return('{');}   
<YD>.                  {charOut(*yytext,outG);}
<UU>\{                 {charOut('{',outG); nLbraces++;}   
<UU>\}                 {charOut('}',outG); if (!(--nLbraces)) BEGIN YD;} 
<UU>\/\*               eatCommentAndEcho(outG,1); 
<UU>\/\/.*\n           lexemeOut(outG);
<UU>\"                 eatStringAndEcho(outG); 
<UU>{CHAR_CONST}       lexemeOut(outG);  
<UU>\n                 charOut('\n',outG);    
<UU>.                  charOut(*yytext,outG);    
<CC>\%\}               {lexemeOut(outG); BEGIN YD;}    
<CC>\"                 eatStringAndEcho(outG); 
<CC>{CHAR_CONST}       lexemeOut(outG);  
<CC>\/\*               eatCommentAndEcho(outG,1);  
<CC>\/\/.*\n           lexemeOut(outG);
<CC>.|\n               charOut(*yytext,outG);    
<ADECL>[ \t\n\f]       charOut(*yytext,outGandL);          
<ADECL>\/\*            eatCommentAndEcho(outGandL,1);
<ADECL>\/\/.*\n        lexemeOut(outGandL);
<ADECL>\{              {charOut('{',outGandL); return('{');}   
<ADECL>\}              {charOut('}',outGandL); BEGIN ADSL; return('}');}   
<ADECL>@void           {BEGIN LVA; return(VOID);} 
<LVA>{DOT_NAME}        {IDbuffer = stringLookup((char *)yytext,yyleng,1); 
                        return(ID);
                       } 
<LVA>[ \t\n\f]         charOut(*yytext,outGandL);  
<LVA>\/\*              eatCommentAndEcho(outGandL,1); 
<LVA>\/\/.*\n          lexemeOut(outGandL);
<LVA>[,]               return(','); 
<LVA>;                 {BEGIN ADECL; return(';');}  
<ADECL>struct          {lexemeOut(outGandL); return(STRUCT);}  
<ADECL>union           {lexemeOut(outGandL); return(UNIONC);}  
<ADECL>enum            {lexemeOut(outGandL); return(ENUM);}  
<ADECL>char            {lexemeOut(outGandL); return(CHAR);}  
<ADECL>class           {lexemeOut(outGandL); return(CLASS);}  
<ADECL>short           {lexemeOut(outGandL); return(SHORT);}  
<ADECL>int             {lexemeOut(outGandL); return(INT);}  
<ADECL>long            {lexemeOut(outGandL); return(LONG);}  
<ADECL>float           {lexemeOut(outGandL); return(TFLOAT);}  
<ADECL>double          {lexemeOut(outGandL); return(DOUBLE);}  
<ADECL>signed          {lexemeOut(outGandL); return(SIGNED);}  
<ADECL>unsigned        {lexemeOut(outGandL); return(UNSIGNED);}  
<ADECL>{DOT_NAME}      {IDbuffer = stringLookup((char *)yytext,yyleng,1); 
		        lexemeOut(outGandL); 
                        return(ID);  
		       }  
<ADECL>[,]             {charOut(',',outGandL); return(',');}   
<ADECL>:               {charOut(':',outGandL); return(':');}   
<ADECL>[0-9]+          {lexemeOut(outGandL); return(NUM);} 
<ADECL>;               {charOut(';',outGandL); return(';');}   
<ADECL>\*              {charOut('*',outGandL); return('*');}   
<ADECL>.               {charOut(*yytext,outGandL); 
                        yerror("syntax error AD.\n");
                       }
<ADSL>{GS}             {IDbuffer = stringLookup((char *)yytext,yyleng,1); 
                        return(ID);   
                       }
<ADSL,TRDECL>[ \t\n\f] charOut(*yytext,outG);   
<ADSL,TRDECL>\/\*      eatCommentAndEcho(outG,1);
<ADSL,TRDECL>\/\/.*\n  lexemeOut(outG);
<ADSL,TRDECL>.         {unput(*yytext); BEGIN YD;}   
%%   

void scanInit1() 
  {whichScanner = 1;  
   plineno = &yylineno; 
   ptext = (char *)yytext; 
   pleng = &yyleng; 
   BEGIN YD; 
   yyin = yoxInG; 
   inFileStr = yoxInFileStrG; 
  } 

void beginCC() {BEGIN CC;}   

int yyScnState() {return (yybgin-yysvec-1);}

yywrap() 
  {
   if (yyScnState() == UU) 
      {yerror("error: unterminated yacc union declaration.\n");
       fprintf(stderr,"union began at line %5d\n",line);  
       goto err1;  
      } 
   if (yyScnState() == CC) 
      {yerror("error: unterminated yacc C code section.\n");
       fprintf(stderr,"  section began with %%{ at line %5d\n",line); 
       goto err1;  
      }  
   scanInit2(); 
   return(0);  
err1:
   rmTempFiles();
   exit(-1);
  } 




/** YDSI is used to intercept the lexeme of the start symbol for the purpose 
  * of augmenting the grammar. 
  *  
  * ADSL is separate from SS to avoid echoing the grammar symbols that 
  * appear in attribute declaration sections.  In state SS, when a closing 
  * curly brace is seen, it is at the end of an attribute declaration list.  
  * The only other such braces are seen at the ends of actions or unions, 
  * but these are seen in state AA or UU.  
  *  
  * UU is for echoing unions.  Its curly-brace-balancing strategy 
  * is similar to that of AA.  
  * 
  * CC is for echoing sections of C code between "%{" and "%}". 
  * 
*/ 

@EOF
set `sum $sumopt <oxDistG1.04/source/agc1.l`; if test $1 -ne 65153
then
	echo ERROR: oxDistG1.04/source/agc1.l checksum is $1 should be 65153
fi
set `wc -lwc <oxDistG1.04/source/agc1.l`
if test $1$2$3 != 289100211814
then
	echo ERROR: wc results of oxDistG1.04/source/agc1.l are $* should be 289 1002 11814
fi

chmod 755 oxDistG1.04/source/agc1.l

if test -f oxDistG1.04/source/agc2.l
then
	echo Ok to overwrite existing file oxDistG1.04/source/agc2.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/agc2.l
	if test -f oxDistG1.04/source/agc2.l
	then
		echo Error: could not remove oxDistG1.04/source/agc2.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/agc2.l
cat >oxDistG1.04/source/agc2.l <<'@EOF'
%start YR YR1 AA LAAA LAAA1 
%start DL CL TT MUI TRAV1 TRVACT TRVCOND
%start EOSFRET  

%{
/* $Header: agc2.l,v 5.10 94/04/16 20:23:56 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include "glob.h"  
#include "scan.h" 
#include "outMgr.h"
#include "trav.h"
#include "depGs.h"
#include "symTrans.h"
#include "mac.h"
#include "opts.h"

int yyStartCondTemp; 
int startCondTempT; 
int nLparensT;
enum {oCond,dCond,action} travState;
%}
 
 
WS		[ \t\f]+
OPTWS		[ \t\f]*
NON_WS		[^ \t\f\n]

CHAR_CONST      ('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')    
DOT_NAME        ([a-zA-Z_.][a-zA-Z_0-9.]*) 

GS (('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')|([a-zA-Z_][a-zA-Z_0-9.]*)) 
ATTRB_NAME (('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')?([a-zA-Z_0-9.]+)) 

IDENT ([a-zA-Z][a-zA-Z0-9]*)
%%
<EOSFRET>x             {scanScanInit(); return(EOSF);}
<YR>[ \t\n\f]          {flushLAbuffer(LA1,outG); charOut(*yytext,outG);}  
<YR>\/\*               {flushLAbuffer(LA1,outG); eatCommentAndEcho(outG,1);}
<YR>\/\/.*\n           {flushLAbuffer(LA1,outG); lexemeOut(outG);}
<YR>{CHAR_CONST}       {flushLAbuffer(LA1,outG); lexemeOut(outG);
                        IDbuffer = stringLookup((char *)yytext,yyleng,1); 
                        return(ID); 
                       }  
<YR>{DOT_NAME}         {IDbuffer = stringLookup((char *)yytext,yyleng,1); 
		        lexemeOut(LA1); 
		        BEGIN YR1;
		       }  
<YR1>[ \t\n\f]         charOut(*yytext,LA1);  
<YR1>\/\*              eatCommentAndEcho(LA1,1);
<YR1>\/\/.*\n          lexemeOut(LA1);
<YR1>:                 {charOut(':',LA1); 
                        if (!alreadyAugmented) 
                           {printAugmentationProduction(); 
                            flushLAbuffer(LA1,outG); 
                           } 
                        BEGIN YR; 
                        return(IDCOLON); 
                       }    
<YR1>.                 {flushLAbuffer(LA1,outG);  
                        unput(*yytext); BEGIN YR; return(ID); 
                       }   
<YR>\%prec             {flushLAbuffer(LA1,outG); lexemeOut(outG); 
                        return(PREC); 
                       } 
<YR>\%\%               {charOut('\n',LA1); 
                        lexemeOut(LA1); 
                        return(MARK); 
                       } 
<YR>\|                 {charOut('|',LA1); return('|'); 
                       }   
<YR>\{                 {flushLAbuffer(LA1,outG); charOut('{',outG); 
                        return('{'); 
		       }   
<YR>;                  {charOut(';',LA1); 
                        return(';'); 
                       }   
<YR>@\{                {BEGIN DL; line = yylineno; return(LBRACE);}
<YR>.                  {charOut(*yytext,outG); 
                        yerror("syntax error in rules section.\n");
                       }
<AA>\{                 {charOut('{',outG); nLbraces++;}   
<AA>\}                 {nLbraces--; 
			if (nLbraces == 0) 
			   {BEGIN LAAA;
                            charOut('}',LA1);  
			    return('}');
			   } 
                           else 
			   charOut('}',outG); 
		       } 
<AA>'\{'               lexemeOut(outG);  
<AA>'\}'               lexemeOut(outG);  
<AA>\/\*               eatCommentAndEcho(outG,1); 
<AA>\/\/.*\n           lexemeOut(outG);
<AA>\"                 eatStringAndEcho(outG); 
<AA>\\\"               lexemeOut(outG);   
<AA>\n                 charOut('\n',outG);    
<AA>.                  charOut(*yytext,outG);  
<LAAA>\/\*             eatCommentAndEcho(LA1,1);  
<LAAA>\/\/.*\n         lexemeOut(LA1);
<LAAA>[ \n\t\f]        charOut(*yytext,LA1);  
<LAAA>{CHAR_CONST}     {IDbuffer = stringLookup((char *)yytext,yyleng,1); 
                        flushLAbuffer(LA1,outG); lexemeOut(outG); BEGIN YR; 
                        return(ID);  
                       }  
<LAAA>{DOT_NAME}       {IDbuffer = stringLookup((char *)yytext,yyleng,1); 
		        lexemeOut(LA1);  
		        BEGIN LAAA1;
		       }  
<LAAA1>\/\*            eatCommentAndEcho(LA1,1);
<LAAA1>\/\/.*\n        lexemeOut(LA1);
<LAAA1>[ \t\n\f]       charOut(*yytext,LA1);  
<LAAA1>:               {charOut(':',LA1); BEGIN YR; return(IDCOLON); 
                       }    
<LAAA1>.               {flushLAbuffer(LA1,outG); unput(*yytext); 
                        BEGIN YR; return(ID);
                       }
<LAAA>@\{              {BEGIN DL; line = yylineno; return(LBRACE);
                       }
<LAAA>\%\%             {charOut('\n',LA1); 
			lexemeOut(LA1); BEGIN TT; return(MARK); 
                       }  
<LAAA>\%prec           {flushLAbuffer(LA1,outG); 
                        lexemeOut(outG); BEGIN YR; return(PREC); 
                       }  
<LAAA>;                {charOut(';',LA1); BEGIN YR; return(';');
                       }  
<LAAA>\{               {flushLAbuffer(LA1,outG); charOut('{',outG); BEGIN AA; 
			yerror("consecutive actions not permitted.\n"); 
			return('{'); 
                       }  
<LAAA>\|               {charOut('|',LA1); BEGIN YR; return('|'); 
                       }  
<LAAA>.                {flushLAbuffer(LA1,outG); 
			yerror("syntax error after action.\n");
                       }  
<DL>\/\*               eatCommentAndEcho(rsB,1); 
<DL>\/\/.*\n           lexemeOut(rsB);
<DL>[ \n\t\f]+         ;   
<DL>@prune             /* return(PRUNE) */  ; 
<DL>@decorate          /* return(DECORATE) */  ;  
<DL>@\}                {BEGIN YR; return(RBRACE);}
<DL>@\{                {yerror("unexpected \"@{\".  Missing \"@}\"?\n");}
<DL>:                  return(':');  
<DL>;                  {BEGIN CL; 
                        return(';'); 
                       }  
<DL,CL,TRVACT>@[eim]   {if (yyScnState() == TRVACT) wrapUpTravAction();
                        switch(yytext[1])
                          {case 'e': BEGIN DL;
                                     return(ATE);
                                     break;  
                           case 'i': BEGIN CL; 
                                     return(ATI);
                                     break;  
                           case 'm': BEGIN DL;
                                     return(ATM);
                                     break;  
                          } 
                       }   
<DL,CL,TRVACT>@{IDENT} {if (yyScnState() == TRVACT) wrapUpTravAction();
                        if (!strcmp(yytext+1,"revorder"))
                           {if (yyScnState() != TRVACT)
                               {yerror("misplaced @revorder\n");
                               }
                            startTravOrderCond(); nLparensT = 0; 
                            travState = oCond; BEGIN TRVCOND;
                           }
                        else if (!strcmp(yytext+1,"revdirection"))
                           {if (yyScnState() != TRVACT)
                               {yerror("misplaced @revdirection\n");
                               }
                            startTravDirCond();   nLparensT = 0; 
                            travState = dCond; BEGIN TRVCOND;
                           }
                        else
                           {IDbuffer = stringLookup((char *)(yytext+1),
                                                    yyleng-1,1
                                                   );
                            currentTrav = travLookup(IDbuffer); 
                            startTravAction();
                            BEGIN TRVACT; 
                            return(ATID);
                           }
                       }
<CL>\/\*               eatCommentAndEcho(rsB,1); 
<CL>\/\/.*\n           lexemeOut(rsB);
<CL>\"                 eatStringAndEcho(rsB); 
<CL>{CHAR_CONST}       lexemeOut(rsB);    
<CL>@\}                {BEGIN YR; return(RBRACE);}
<CL>@\{                {yerror("unexpected \"@{\".  Missing \"@}\"?\n");}
<CL>\$\$               {lexemeOut(rsB); hasYaccPvarRefGlob = 1;} 
<CL>\$\-?[0-9]+        {lexemeOut(rsB); hasYaccPvarRefGlob = 1;} 
<CL>(\n|.)             charOut(*yytext,rsB);  
<TRVACT>[ \n\t\f\v]+   lexemeOut(rsB);
<DL,CL,TRVACT,TRVCOND>{IDENT}        {
                        IDbuffer = stringLookup((char *)yytext,yyleng,1);
                        if (macroInterpSetup1IfMacro(IDbuffer)) 
                           {nLparens = 0; 
                            yyStartCondTemp = yyScnState(); 
                            BEGIN MUI; 
                           }
                           else 
                           {if (yyScnState() == DL) 
                              {yerror("misplaced identifier:\n");
                                fprintf(stderr,"  %s\n",yytext);
                               }
                               else
                               lexemeOut(rsB); 
                           }
                       }
<DL>{ATTRB_NAME}       {scanAttrbName((char *)yytext,yyleng); 
                        transAttrbNameToNumPair(); 
                        return(ID); 
                       }     
<DL>.                  {yerror("syntax error in dependency expression.\n");   
                        BEGIN CL; 
                        return(';'); 
                       }  
<TRVACT>@\}            {wrapUpTravAction(); BEGIN YR; return(RBRACE);}
<TRVACT>@\{            {yerror("unexpected \"@{\".  Missing \"@}\"?\n");}
<TRVACT>.              charOut(*yytext,rsB);
<TRVCOND,TRVACT>\/\*           eatCommentAndEcho(rsB,1); 
<TRVCOND,TRVACT>\/\/.*\n       lexemeOut(rsB);
<TRVCOND,TRVACT>\"             eatStringAndEcho(rsB); 
<TRVCOND,TRVACT>{CHAR_CONST}   lexemeOut(rsB);    
<TRVCOND>\(            {lexemeOut(rsB); nLparensT++;
                        if (nLparensT == 1) return('(');
                       }
<TRVCOND>\)            {nLparensT--; 
                        lexemeOut(rsB);
                        if (nLparensT == 0)
                           {switch(travState)
                              {case oCond: wrapUpTravOrderCond(); break;
                               case dCond: wrapUpTravDirCond(); break;
                              }
                            startTravAction();
                            BEGIN TRVACT; 
                            return(')');
                           }
                       }
<TRVCOND>.|\n          charOut(*yytext,rsB);
<TRVCOND,TRVACT>\$\$       {
                        yerror("yacc pseudovariable in traversal mode\n"); 
                       } 
<TRVCOND,TRVACT>\$\-?[0-9]+   {
                        yerror("yacc pseudovariable in traversal mode\n"); 
                       } 
<CL,TRVACT,TRVCOND>@{ATTRB_NAME}   {
                        scanAttrbName((char *)(yytext + 1),yyleng - 1); 
                        transAttrbNameToNumPair(); 
                        putAttrbNumPairInRefSegBuffer(bufPosInProd,bufAttrbNum);
                        startCondTempT = yyScnState(); 
                        BEGIN TRAV1;
                        if (startCondTempT == CL) return (ID);
                       }     
<TRAV1>@               BEGIN startCondTempT;
<TRAV1>[ \n\t\f\v]+    {fatal("whitespace in attribute reference.\n");
                        /* BEGIN startCondTempT; */
		       }  
<TRAV1>.               {fatal("syntax error in attribute reference.\n");
                        /* BEGIN startCondTempT; */
		       }  
<MUI>\(                {if (++nLparens != 1) 
                           yerror("unbalanced parentheses in macro use.\n");
                       }
<MUI>\)                {if (--nLparens != 0) 
                           yerror("unbalanced parentheses in macro use.\n");
                           else 
                           {macroInterpSetup2(yysbuf,yysptr); 
                            BEGIN yyStartCondTemp;
                           }
                       }
<MUI>[,]               terminateActualParam(); 
<MUI>\\\\              putCharInMacroActParam('\\');  
<MUI>\\[,]             putCharInMacroActParam(',');  
<MUI>\\\(              putCharInMacroActParam('(');  
<MUI>\\\)              putCharInMacroActParam(')');  
<MUI>\\           yerror("misuse of \'\\\' escape character in macro use.\n"); 
<MUI>.|\n              putCharInMacroActParam(*yytext);  
<TT>\n|.               charOut(*yytext,outG); 
%%   



void scanInit2() 
  {whichScanner = 2; 
   yylineno = *plineno; 
   plineno = &yylineno; 
   ptext = (char *)yytext; 
   pleng = &yyleng; 
   BEGIN YR; 
   yyin = yoxInG; 
  } 



void beginAA() {BEGIN AA;}   
void beginTT() {BEGIN TT;}   
 
int yyScnState() {return (yybgin-yysvec-1);} 

yywrap() 
  {
   if (yyScnState() == AA)  
      {yerror("error: unterminated yacc action.\n");   
       fprintf(stderr,"action began at line %5d\n",line);  
       goto err1;  
      } 
   unput('x');
   BEGIN EOSFRET; 
   return 0; 

err1: 
   rmTempFiles();
   exit(-1);
  } 




/** YR1 is used for looking ahead after seeing an identifier to see if it is 
  * followed by a colon.    
  * 
  * AA is used for copying a yacc action.  The main idea is to keep echoing 
  * until the opening curly brace is paired.  Curly braces in strings, 
  * comments, and character constants are ignored.   
  * 
  * After the closing curly brace is detected in state AA, it has to be 
  * decided whether the action just scanned is the last thing (grammar 
  * symbol, action, or precedence) other than an attribute definitions 
  * section,  
  * vertical bar, or semicolon, in the current rulebody (RHS).  If it is 
  * the last thing, then some code that generates a parse tree node upon 
  * reduction by the present production has to be inserted before printing the 
  * closing brace of the action.  Note that yacc doesn't permit two 
  * adjacent actions in a given rulebody.  If it isn't the last thing, 
  * then the generation of such code will appear in a later action.  If 
  * the last thing in a rulebody isn't an action, then a left curly brace, 
  * the node-generating code, and a right curly brace will be generated,  
  * while everything else is echoed.  An action could be followed by 
  * whitespace, comments, and identifier, more whitespace and comments, 
  * and finally by a colon, and it can't be known until the colon is seen 
  * that the action was the last thing in the rulebody.  So it all has to 
  * be buffered.  This is the purpose of the LAAA (lookahead after action) 
  * and LAAA1 states, and of the lookahead buffer array and file and 
  * their associated routines, LAAA1 is analogous to SS1.  
  *  
  * TT is for echoing the tail section. 
  *  
  * DL is for reading attribute dependencies (explicit, mixed, implicit). 
  * 
  * CL is entered upon leaving DL.  CL is for reading attribute reference 
  * sections. 
  * The appropriate C reference to a 
  * C variable is substituted for the attribute name.   
  *  
*/ 

@EOF
set `sum $sumopt <oxDistG1.04/source/agc2.l`; if test $1 -ne 16374
then
	echo ERROR: oxDistG1.04/source/agc2.l checksum is $1 should be 16374
fi
set `wc -lwc <oxDistG1.04/source/agc2.l`
if test $1$2$3 != 418144717061
then
	echo ERROR: wc results of oxDistG1.04/source/agc2.l are $* should be 418 1447 17061
fi

chmod 755 oxDistG1.04/source/agc2.l

if test -f oxDistG1.04/source/agc3.l
then
	echo Ok to overwrite existing file oxDistG1.04/source/agc3.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/agc3.l
	if test -f oxDistG1.04/source/agc3.l
	then
		echo Error: could not remove oxDistG1.04/source/agc3.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/agc3.l
cat >oxDistG1.04/source/agc3.l <<'@EOF'
%start EOSFRET LD LRP LRRE LRRE1 LRA LRAAD LRAAR LRAAR1 LRAAD1 LUS MUI 
 
%{
/* $Header: agc3.l,v 5.10 94/04/16 20:23:59 bischoff Exp $ */ 
 
/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */
  
#include "glob.h" 
#include "scan.h" 
#include "outMgr.h"
#include "depGs.h"
#include "opts.hh"
#include "opts.h"
#include "symTrans.h"
#include "mac.h"
#include "joinTabs.h"

#define dangRet "ambiguous form of return of token.\n" 
#define multRet "  multiple tokens in object of return statement.\n"  
static int retObjectSeen; 
static int nLparMac; 
static FILE *tempForTrash;
int yyStartCondTemp; 
%}
 
 
WS		[ \t\f]+
OPTWS		[ \t\f]*
NON_WS		[^ \t\f\n]

CHAR_CONST      ('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')    

GS (('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')|([a-zA-Z_][a-zA-Z_0-9.]*)) 
ATTRB_NAME (('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')?([a-zA-Z_0-9.]+)) 
 
IDENT ([a-zA-Z][a-zA-Z0-9]*)
%%
<EOSFRET>x             {scanScanInit(); return EOSF;}
<LD>^\%\%(.*)          {BEGIN LRP; 
                        if (!buildHeaderFile) 
                           {fprintf(Lfile[currentLfile].outPtr,"\n%%{\n"); 
                            appendToOutFile(yoxOutH,yoxOutFileStrH,
                                            Lfile[currentLfile].outPtr
                                           ); 
                            fprintf(Lfile[currentLfile].outPtr,"\n%%}\n"); 
                           } 
                        lexemeOut(outL); 
                        return(MARK);
                       }  
<LD>\n|.               charOut(*yytext,outL);    
<LRP>.*\n/{NON_WS}     {lexemeOut(outL); BEGIN LRRE; nLbraces = 0;}  
<LRP>.*\n              lexemeOut(outL);  
<LRRE>^\%\%.*\n        {BEGIN LUS; lexemeOut(outL); return(MARK2); }  
<LRRE>{WS}\%\{         {lexemeOut(outL); BEGIN LRRE1; line = yylineno;}   
<LRRE>{OPTWS}\n        lexemeOut(outL);  
<LRRE1>\%\}.*          {lexemeOut(outL); BEGIN LRRE;}   
<LRRE1>\/\*            eatCommentAndEcho(outL,1); 
<LRRE1>\/\/.*\n        lexemeOut(outL);
<LRRE1>\"              eatStringAndEcho(outL); 
<LRRE1>{CHAR_CONST}    lexemeOut(outL);  
<LRRE1>\n              charOut('\n',outL);   
<LRRE1>.               charOut(*yytext,outL);   
<LRRE>{WS}\|.*\n       lexemeOut(outL);   
<LRRE>{WS}             {lexemeOut(outL); BEGIN LRA; line = yylineno;}  
<LRRE>^{OPTWS}"/*"     {lexemeOut(outL); /* descendant of the culprit */  
                        eatCommentAndEcho(outL,0); 
                       }
<LRRE>^{OPTWS}\/\/.*\n lexemeOut(outL); /* descendant of the culprit */  
<LRRE>"["([^\\\]\n]|(\\([ntvbrfa\\?]|([0-7]{1,3}))))+"]" lexemeOut(outL); 
<LRRE>.                charOut(*yytext,outL);     
<LRA>\/\*              eatCommentAndEcho(outL,1); 
<LRA>\/\/.*\n          {lexemeOut(outL); if (nLbraces == 0) BEGIN LRRE;} 
<LRA>\"                eatStringAndEcho(outL); 
<LRA>{CHAR_CONST}      lexemeOut(outL);  
<LRA>\{                {charOut('{',outL); nLbraces++;}
<LRA>\}                {charOut('}',outL); nLbraces--;} 
<LRA>.                 charOut(*yytext,outL);   
<LRA>\n                {charOut('\n',outL); if (nLbraces == 0) BEGIN LRRE;} 
<LRA>return            {charOut('{',outL); 
                        lexemeOut(LA1); 
                        retObjectSeen = 0; 
                        nLparens = 0; 
                        BEGIN LRAAR; 
                        return(RETURN);
                       } 
<LRAAR>\/\*            eatCommentAndEcho(LA1,1); 
<LRAAR>\"              eatStringAndEcho(LA1); 
<LRAAR>{WS}            lexemeOut(LA1); 
<LRAAR>\(              {charOut('(',LA1); nLparens++;} 
<LRAAR>\)              {charOut(')',LA1); 
                        if ((--nLparens) < 0) yerror("unmatched \')\'\n"); 
                       } 
<LRAAR>{GS}            {int symTabInd; 

                        lexemeOut(LA1); 
                        if (yytext[0] == '\'') 
                           {if (retObjectSeen) 
                               {if (atLeastOneSymHasAttrbs) 
                                   {ywarning(dangRet);
                                    fprintf(stderr,multRet);
                                   }
                               }
                               else 
                               {retObjectSeen = 1; 
                                IDbuffer = stringLookup((char *)yytext,
                                                        yyleng,1
                                                       );  
                                return(ID); 
                               }
                           } 
                        else if ((IDbuffer = stringLookup((char *)yytext,
                                                          yyleng,0)
                                                         ) 
                                 == 
                                 ((char *)NULL)
                                )
                           ;
                        else if ((symTabInd = gSymLookup(IDbuffer)) == -1) 
                           ;
                        else if (gSymTable[symTabInd].symNum < 0)  
                           {yerror("to return nonterminal");
                            fprintf(stderr," %s as token.\n",IDbuffer);
                            if (!retObjectSeen) 
                               {retObjectSeen = 1; 
                                return(ID); 
                               }
                           }
                        else if (gSymTable[symTabInd].symNum == 0)  
                           {ywarning("to return attributed symbol");
                            fprintf(stderr," %s\n  not declared by %%token.\n",
                                    IDbuffer
                                   );
                            if (!retObjectSeen) 
                               {retObjectSeen = 1; 
                                return(ID); 
                               }
                           }
                        else
                           {if (retObjectSeen) 
                               {if (atLeastOneSymHasAttrbs) 
                                   {ywarning(dangRet);
                                    fprintf(stderr,multRet);
                                   }
                               }
                               else
                               {retObjectSeen = 1; 
                                return(ID); 
                               }
                           } 
                       } 
<LRAAR>\/\/.*\n        | 
<LRAAR>\n              {if (nLbraces == 0) 
                           {yerror("return statement broken by line feed\n"); 
                            unput('\n'); 
                            BEGIN LRA;  
                           } 
                           else  
                           lexemeOut(LA1); 
                       } 
<LRAAR>;               {charOut(';',LA1); 
                        BEGIN LRAAR1; 
                        if (!retObjectSeen) 
                           {if (atLeastOneSymHasAttrbs) ywarning(dangRet);}
                        if (!nLparens) 
                           {charOut('}',LA1); 
                            return(';'); 
                           } 
                       } 
<LRAAR>.               charOut(*yytext,LA1); 
<LRAAR1>\/\*           eatCommentAndEcho(LA1,1); 
<LRAAR1>{WS}           lexemeOut(LA1); 
<LRAAR1>@\{            {BEGIN LRAAD; 
                        if (neutralizeSemActions) 
                           {tempForTrash = Lfile[currentLfile].outPtr;  
                            Lfile[currentLfile].outPtr = tempTrashOut;  
                           }
                        return(LBRACE);
                       }   
<LRAAR1>\/\/.*\n       | 
<LRAAR1>\n             {if (nLbraces == 0) 
                          {if (!prodBufferPointer2) /* last chance */  
                             {if (atLeastOneSymHasAttrbs)
                                 fprintf(stderr, 
                                "  unknown node type--assuming no attributes.\n"
                                        );
                              putSymbolInProdBuffer2(gSymLookup(dumNodeSym)); 
                              installLeafRefCountInitList();  
                              initLDG();
                             } 
                           flushLAbuffer(LA1,outL); 
                           unput('\n'); 
                           BEGIN LRA;  
                          } 
                          else  
                          lexemeOut(LA1); 
                       } 
<LRAAR1>.              {if (!prodBufferPointer2) /* last chance */  
                          {if (atLeastOneSymHasAttrbs)
                              ywarning(
                             "unknown node type--assuming no attributes.\n"
                                      );
                           putSymbolInProdBuffer2(gSymLookup(dumNodeSym)); 
                           installLeafRefCountInitList();  
                           initLDG();
                          } 
                        flushLAbuffer(LA1,outL); 
                        unput(*yytext); 
                        BEGIN LRA;  
                       } 
<LRAAD>\/\*            eatCommentAndEcho(outL,1); 
<LRAAD>\/\/.*\n        lexemeOut(outL);
<LRAAD>\"              eatStringAndEcho(outL); 
<LRAAD>{CHAR_CONST}    lexemeOut(outL); 
<LRAAD>{IDENT}         {IDbuffer = stringLookup((char *)yytext,yyleng,1);
                        if (macroInterpSetup1IfMacro(IDbuffer)) 
                           {nLparMac = 0; 
                            BEGIN MUI; 
                            yyStartCondTemp = LRAAD; 
                           }
                           else 
                           lexemeOut(outL); 
                       }   
<LRAAD>{WS}            lexemeOut(outL); 
<LRAAD>@\}             {if (!prodBufferPointer2) /* last chance */  
                          {if (atLeastOneSymHasAttrbs)
                              ywarning(
                             "unknown node type--assuming no attributes.\n"
                                      );
                           putSymbolInProdBuffer2(gSymLookup(dumNodeSym)); 
                           installLeafRefCountInitList();  
                           initLDG();
                          } 
                        if (neutralizeSemActions) 
                           fprintf(Lfile[currentLfile].outPtr," */ ");  
                        if (neutralizeSemActions) 
                            Lfile[currentLfile].outPtr = tempForTrash;  
                        flushLAbuffer(LA1,outL); 
                        BEGIN LRA;
                        return(RBRACE);
                       }   
<LRAAD>@\{             {yerror("unexpected \"@{\".  Missing \"@}\"?\n");}
<LRAAD>@               BEGIN LRAAD1; 
<LRAAD>\n|.            charOut(*yytext,outL); 
<LRAAD1>@              BEGIN LRAAD; 
<LRAAD1>{ATTRB_NAME}   {scanAttrbName((char *)yytext,yyleng); 
                        transAttrbNameToNumPair(); 
                        return(ID); 
                       }     
<LRAAD1>.              {unput(*yytext); 
                        yerror("attribute reference not terminated by @.\n"); 
	                BEGIN LRA;
		       } 
<MUI>\(                {if (++nLparMac != 1) 
                           yerror("unbalanced parentheses in macro use.\n");
                       }
<MUI>\)                {if (--nLparMac != 0) 
                           yerror("unbalanced parentheses in macro use.\n");
                           else 
                           {macroInterpSetup2(yysbuf,yysptr); 
                            BEGIN yyStartCondTemp;
                           }
                       }
<MUI>[,]               terminateActualParam(); 
<MUI>\\\\              putCharInMacroActParam('\\');  
<MUI>\\[,]             putCharInMacroActParam(',');  
<MUI>\\\(              putCharInMacroActParam('(');  
<MUI>\\\)              putCharInMacroActParam(')');  
<MUI>\\           yerror("misuse of \'\\\' escape character in macro use.\n"); 
<MUI>.|\n              putCharInMacroActParam(*yytext);  
<LUS>\n|.              charOut(*yytext,outL);   
%%   

void scanInit3() 
  {yylineno = 1; 
   plineno = &yylineno; 
   ptext = (char *)yytext; 
   pleng = &yyleng; 
   BEGIN LD; 
   yyin = Lfile[currentLfile].inPtr; 
   inFileStr = Lfile[currentLfile].inName; 
  } 


int yyScnState() {return (yybgin-yysvec-1);} 



yywrap() 
  {
   if (yyScnState() == LRRE1) 
      {yerror("error: unterminated lex code section.\n");
       fprintf(stderr, "section began at line %5d\n",line ); 
       goto err1;  
      } 
   if (yyScnState() == LRA) 
      {yerror("error: unterminated lex action.\n");   
       fprintf(stderr,"action began at line %5d\n",line);  
       goto err1; 
      }  
   if (yyScnState() == LRAAR) 
      yerror("error: identifier expected after \"return\".\n");   
   unput('x');
   BEGIN EOSFRET;
   return 0;

err1:
   rmTempFiles();
   exit(-1);
  } 


/* LD LRP LRRE LRRE1 LRA LRAAR LRAAR1 LRAAD LRAAD1 LUS are start 
 * conditions of the scanner 
 * that pertain to scanning and parsing the lexical specification (which 
 * is written in a lex-like syntax).  The main problem is for the scanner 
 * to know when it is looking at a lex action, and to look for 
 * at signs inside such actions, and to ignore at signs elsewhere.   
 *  
 * LD is for echoing the lex definitions section.  
 * 
 * LRP is for echoing the prolog of the lex rules section.   
 * 
 * LRRE is for echoing and detecting the ends of lex regular expressions. 
 * lex r.e.'s are terminated and lex actions are initiated by whitespace.  
 *
 * LRRE1 is for echoing C code sections, indented and delimited by "%{" and 
 * "%}".   
 * 
 * LRA is for looking for attribute references inside of actions in the lex 
 * rules section, and for looking for the ends of such actions.  A lex action 
 * is terminated by the first newline outside of properly paired curly 
 * braces. 
 * 
 * LRAAR is for finding the name of the first grammar symbol seen   
 * after the "return" reserved word in a lex action.  Everything from the
 * return up to its terminating semicolon is put in a lookahead buffer 
 * along with a closing curly brace until the attributes definition section 
 * (if any) is processed.  The semicolon sends this scanner into LRAAR1.   
 * 
 * In LRAAR1, a newline outside of curly braces or anything else  
 * except whitespace and comments means that no attribute definition 
 * section follows the return, and the lookahead buffer (which contains 
 * the return and its object) is flushed.  @{ causes a change to LRAAD.   
 *  
 * LUS is for echoing the optional user subroutines section found after 
 * the second "%%" in the lexical specification.   
 *
*/ 

/* Lexemes suitable for grammar symbols are 1)identifiers previously declared
 * as tokens, or 2)character constants. 
 *
 * If exactly one lexeme suitable for a grammar symbol appears between 
 * return and ; a node of that type will be put on the tree just before 
 * each time said return is executed.  
 *
 * If no such lexeme appears there, a warning is issued.  If there is not a 
 * non-empty attribute definition section, the type of the dummy node symbol 
 * is used and another warning is issued.  
 * 
 * If more than one suitable lexeme appears, the first such is assumed for the
 * node type, and subsequent ones generate a warning.    
 */ 

@EOF
set `sum $sumopt <oxDistG1.04/source/agc3.l`; if test $1 -ne 47858
then
	echo ERROR: oxDistG1.04/source/agc3.l checksum is $1 should be 47858
fi
set `wc -lwc <oxDistG1.04/source/agc3.l`
if test $1$2$3 != 421150017717
then
	echo ERROR: wc results of oxDistG1.04/source/agc3.l are $* should be 421 1500 17717
fi

chmod 755 oxDistG1.04/source/agc3.l

if test -f oxDistG1.04/source/agc4.l
then
	echo Ok to overwrite existing file oxDistG1.04/source/agc4.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/agc4.l
	if test -f oxDistG1.04/source/agc4.l
	then
		echo Error: could not remove oxDistG1.04/source/agc4.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/agc4.l
cat >oxDistG1.04/source/agc4.l <<'@EOF'
%start GEN ADECL AADECL ADS MAC TRDECL
%start LD LRP LRRE LRRE1 LRA LRAAD LUS  
 
%{
/* $Header: agc4.l,v 5.10 94/04/16 20:24:02 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include "glob.h"
#include "scan.h"
#include "opts.hh"
#include "opts.h"
#include "outMgr.h"
%}

WS		[ \t\f]+
OPTWS		[ \t\f]*
NON_WS		[^ \t\f\n]
GS (('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')|([a-zA-Z_][a-zA-Z_0-9.]*)) 
IDENT ([a-zA-Z][a-zA-Z0-9]*)

%%
<GEN>\/\*                    eatCommentAndEcho(outG,1); 
<GEN>\/\/.*\n                lexemeOut(outG);
<GEN>\"                      eatStringAndEcho(outG); 
<GEN>\\\"                    lexemeOut(outG);   
<GEN>.|\n                    charOut(yytext[0],outG);
<GEN>@attributes             if (yyin == yoxInG) BEGIN ADECL;
<GEN>@macro                  if (yyin == yoxInG) BEGIN MAC;
<GEN>@traversal              if (yyin == yoxInG) BEGIN TRDECL;
<GEN>@autoinh                if (yyin == yoxInG) BEGIN TRDECL;
<GEN>@autosyn                if (yyin == yoxInG) BEGIN TRDECL;
<GEN>@\{                     BEGIN ADS;
<ADECL,MAC,ADS>\/\*          eatCommentAndEcho(nowhere,1); 
<ADECL,MAC,ADS>\/\/.*\n      ;
<MAC,ADS>\"                  eatStringAndEcho(nowhere); 
<MAC,ADS>\\\"                ;   
<ADECL>\}                    BEGIN AADECL;
<AADECL>\/\*                 eatCommentAndEcho(outG,1); 
<AADECL>\/\/.*\n             lexemeOut(outG);
<AADECL>{GS}                 ;
<AADECL>[ \t\n\f\v]          ;    
<AADECL>.                    {unput(*yytext); BEGIN GEN;}   
<MAC>\\@/end                 ;    
<MAC>@end                    BEGIN GEN; 
<TRDECL>\/\*                 eatCommentAndEcho(outG,1); 
<TRDECL>\/\/.*\n             lexemeOut(outG);
<TRDECL>[ \t\n\f\v]          charOut(*yytext,outG);    
<TRDECL>@postorder           ;
<TRDECL>@preorder            ;
<TRDECL>@lefttoright         ;
<TRDECL>@righttoleft         ;
<TRDECL>@disable             ;
<TRDECL>@warn                ;
<TRDECL>{IDENT}              ;
<TRDECL>.                    {unput(*yytext); BEGIN GEN;}   
<ADS>@\}                     BEGIN GEN;
<ADS>@\{                     {yerror("unexpected \"@{\".  Missing \"@}\"?\n");}
<ADECL,MAC,ADS>.|\n          ;    
<LD>(\%\%)(.*)               {BEGIN LRP; lexemeOut(outL); }  
<LD>.|\n                     charOut(*yytext,outL);    
<LRP>.*\n/{NON_WS}           {lexemeOut(outL); BEGIN LRRE; nLbraces = 0;}  
<LRP>.*\n                    lexemeOut(outL);  
<LRRE>^\%\%.*\n              {BEGIN LUS; lexemeOut(outL); }  
<LRRE>{WS}\%\{               {lexemeOut(outL); BEGIN LRRE1;}   
<LRRE>{OPTWS}\n              lexemeOut(outL);  
<LRRE1>\%\}.*                {lexemeOut(outL); BEGIN LRRE;}   
<LRRE,LRRE1,LRA>\/\*         eatCommentAndEcho(outL,1); 
<LRRE,LRRE1,LRA>\/\/.*\n     lexemeOut(outL);
<LRRE1,LRA>\\\"              lexemeOut(outL);  
<LRRE1>\"                    eatStringAndEcho(outL); 
<LRRE1>.|\n                  charOut(*yytext,outL);   
<LRRE>{WS}\|.*\n             lexemeOut(outL);   
<LRRE>{WS}                   {lexemeOut(outL); nLbraces = 0; 
                              BEGIN LRA; line = yylineno;
                             }  
<LRRE>(^({OPTWS}))/"/*"      lexemeOut(outL); /* the culprit */  
<LRRE>^{WS}([^/\n]|"/"[^*\n])*("/"?)\n	{
                             yerror("indented code found outside of action\n");
                                        } 
<LRRE>"["([^\\\]\n]|(\\([ntvbrfa\\?]|([0-7]{1,3}))))+"]" lexemeOut(outL); 
<LRRE>.                      charOut(*yytext,outL); 
<LRA>\"                      eatStringAndEcho(outL); 
<LRA>@\{                     BEGIN LRAAD; 
<LRA>\{                      {charOut('{',outL); nLbraces++;}
<LRA>\}                      {charOut('}',outL); nLbraces--;} 
<LRA>{GS}                    lexemeOut(outL);/* don't count  '{' or '}' */ 
<LRA>.                       charOut(*yytext,outL);  
<LRA>\n                      {charOut('\n',outL); if(nLbraces == 0) BEGIN LRRE;}
<LRAAD>\/\*                  eatCommentAndEcho(nowhere,1); 
<LRAAD>\/\/.*\n              ;
<LRAAD>\"                    eatStringAndEcho(nowhere); 
<LRAAD>\\\"                  ; 
<LRAAD>@\}                   BEGIN LRA;
<LRAAD>@\{                   {yerror("unexpected \"@{\".  Missing \"@}\"?\n");}
<LRAAD>.|\n                  ; 
<LUS>\n|.                    charOut(*yytext,outL);   
%%
void scanInit4()
  {
   whichScanner = 4;
   plineno = &yylineno; 
   ptext = (char *)yytext; 
   pleng = &yyleng; 
   BEGIN GEN; 
   yyin = yoxInG; 
   inFileStr = yoxInFileStrG; 
  } 

int yyScnState() {return (yybgin-yysvec-1);}

int yywrap()
  {
   if (yyin != yoxInG) currentLfile++; 
   if (currentLfile == nLfiles) 
      return(1);  
      else 
      {BEGIN LD;
       yylineno = 1; 
       yyin = Lfile[currentLfile].inPtr; 
       inFileStr = Lfile[currentLfile].inName; 
       return(0);  
      }
err1:
   rmTempFiles();
   exit(-1);
  } 

@EOF
set `sum $sumopt <oxDistG1.04/source/agc4.l`; if test $1 -ne 59190
then
	echo ERROR: oxDistG1.04/source/agc4.l checksum is $1 should be 59190
fi
set `wc -lwc <oxDistG1.04/source/agc4.l`
if test $1$2$3 != 1857177138
then
	echo ERROR: wc results of oxDistG1.04/source/agc4.l are $* should be 185 717 7138
fi

chmod 755 oxDistG1.04/source/agc4.l

if test -f oxDistG1.04/source/agc5.l
then
	echo Ok to overwrite existing file oxDistG1.04/source/agc5.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/agc5.l
	if test -f oxDistG1.04/source/agc5.l
	then
		echo Error: could not remove oxDistG1.04/source/agc5.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/agc5.l
cat >oxDistG1.04/source/agc5.l <<'@EOF'
%start EOSFRET LRA LRAAD LRAAR LRAAR1 LRAAD1 LUS MUI 
 
%{
/* $Header: agc5.l,v 5.10 94/04/16 20:24:04 bischoff Exp $ */ 
 
/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */
  
#include "glob.h" 
#include "scan.h" 
#include "outMgr.h"
#include "depGs.h"
#include "opts.hh" 
#include "opts.h" 
#include "symTrans.h"
#include "mac.h"
#include "joinTabs.h"

#define dangRet "ambiguous form of return of token.\n" 
#define multRet "  multiple tokens in object of return statement.\n"
static int retObjectSeen; 
static int nLparMac; 
static FILE *tempForTrash;
int yyStartCondTemp; 
%}
 
 
WS		[ \t\f]+
OPTWS		[ \t\f]*
NON_WS		[^ \t\f\n]

CHAR_CONST      ('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')    

GS (('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')|([a-zA-Z_][a-zA-Z_0-9.]*)) 
ATTRB_NAME (('([^\\'\n]|(\\([ntvbrfa\\?'"]|([0-7]{1,3}))))')?([a-zA-Z_0-9.]+)) 
 
IDENT ([a-zA-Z][a-zA-Z0-9]*)
%%
<EOSFRET>x             {scanScanInit(); return(EOSF);}
<LRA>\/\*              eatCommentAndEcho(outL,1); 
<LRA>\/\/.*\n          lexemeOut(outL);
<LRA>\"                eatStringAndEcho(outL); 
<LRA>{CHAR_CONST}      lexemeOut(outL);  
<LRA>.|\n              charOut(*yytext,outL);
<LRA>return            {charOut('{',outL); 
                        lexemeOut(LA1); 
                        retObjectSeen = 0; 
                        nLparens = 0; 
                        BEGIN LRAAR; 
                        return(RETURN);
                       } 
<LRAAR>\/\*            eatCommentAndEcho(LA1,1); 
<LRAAR>\/\/.*\n        lexemeOut(LA1);
<LRAAR>\"              eatStringAndEcho(LA1); 
<LRAAR>{WS}            lexemeOut(LA1); 
<LRAAR>\(              {charOut('(',LA1); nLparens++;} 
<LRAAR>\)              {charOut(')',LA1); 
                        if ((--nLparens) < 0) yerror("unmatched \')\'\n"); 
                       } 
<LRAAR>{GS}            {int symTabInd; 
                        
                        lexemeOut(LA1); 
                        if (yytext[0] == '\'') 
                           {if (retObjectSeen) 
                               {if (atLeastOneSymHasAttrbs) 
                                   {ywarning(dangRet);
                                    fprintf(stderr,multRet);
                                   }
                               }
                               else 
                               {retObjectSeen = 1; 
                                IDbuffer = stringLookup((char *)yytext,
                                                        yyleng,1
                                                       );  
                                return(ID); 
                               }
                           } 
                        else if ((IDbuffer = stringLookup((char *)yytext,
                                                          yyleng,0)
                                                         ) 
                                 == 
                                 ((char *)NULL)
                                )
                           ;
                        else if ((symTabInd = gSymLookup(IDbuffer)) == -1) 
                           ;
                        else if (gSymTable[symTabInd].symNum < 0)  
                           {yerror("to return nonterminal");
                            fprintf(stderr," %s as token.\n",IDbuffer);
                            if (!retObjectSeen) 
                               {retObjectSeen = 1; 
                                return(ID); 
                               }
                           }
                        else if (gSymTable[symTabInd].symNum == 0)  
                           {ywarning("to return attributed symbol");
                            fprintf(stderr," %s\n  not declared by %%token.\n",
                                    IDbuffer
                                   );
                            if (!retObjectSeen) 
                               {retObjectSeen = 1; 
                                return(ID); 
                               }
                           }
                        else
                           {if (retObjectSeen) 
                               {if (atLeastOneSymHasAttrbs) 
                                   {ywarning(dangRet);
                                    fprintf(stderr,multRet);
                                   }
                               }
                               else
                               {retObjectSeen = 1; 
                                return(ID); 
                               }
                           } 
                       } 
<LRAAR>;               {charOut(';',LA1); 
                        BEGIN LRAAR1; 
                        if (!retObjectSeen)
                           {if (atLeastOneSymHasAttrbs) ywarning(dangRet);}
                        if (!nLparens) 
                           {charOut('}',LA1); 
                            return(';'); 
                           } 
                       } 
<LRAAR>.|\n            charOut(*yytext,LA1); 
<LRAAR1>\/\*           eatCommentAndEcho(LA1,1); 
<LRAAR1>\/\/.*\n       lexemeOut(LA1);
<LRAAR1>{WS}           lexemeOut(LA1); 
<LRAAR1>\n             lexemeOut(LA1); 
<LRAAR1>@\{            {BEGIN LRAAD; 
                        if (neutralizeSemActions) 
                           {tempForTrash = Lfile[currentLfile].outPtr;  
                            Lfile[currentLfile].outPtr = tempTrashOut;  
                           }
                        return(LBRACE);
                       }   
<LRAAR1>.              {if (!prodBufferPointer2) /* last chance */  
                          {ywarning(
                             "unknown node type--assuming no attributes.\n"
                                   );
                           putSymbolInProdBuffer2(gSymLookup(dumNodeSym)); 
                           installLeafRefCountInitList();  
                           initLDG();
                          } 
                        flushLAbuffer(LA1,outL); 
                        unput(*yytext); 
                        BEGIN LRA;  
                       } 
<LRAAD>\/\*            eatCommentAndEcho(outL,1); 
<LRAAD>\/\/.*\n        lexemeOut(outL);
<LRAAD>\"              eatStringAndEcho(outL); 
<LRAAD>{CHAR_CONST}    lexemeOut(outL); 
<LRAAD>{IDENT}         {IDbuffer = stringLookup((char *)yytext,yyleng,1);
                        if (macroInterpSetup1IfMacro(IDbuffer)) 
                           {nLparMac = 0; 
                            BEGIN MUI; 
                            yyStartCondTemp = LRAAD; 
                           }
                           else 
                           lexemeOut(outL); 
                       }   
<LRAAD>{WS}            lexemeOut(outL); 
<LRAAD>@\}             {if (!prodBufferPointer2) /* last chance */  
                          {ywarning(
                             "unknown node type--assuming no attributes.\n"
                                   );
                           putSymbolInProdBuffer2(gSymLookup(dumNodeSym)); 
                           installLeafRefCountInitList();  
                           initLDG();
                          } 
                        if (neutralizeSemActions) 
                           fprintf(Lfile[currentLfile].outPtr," */ ");  
                        if (neutralizeSemActions) 
                            Lfile[currentLfile].outPtr = tempForTrash;  
                        flushLAbuffer(LA1,outL); 
                        BEGIN LRA;
                        return(RBRACE);
                       }   
<LRAAD>@\{             {yerror("unexpected \"@{\".  Missing \"@}\"?\n");}
<LRAAD>@               BEGIN LRAAD1; 
<LRAAD>\n|.            charOut(*yytext,outL); 
<LRAAD1>@              BEGIN LRAAD; 
<LRAAD1>{ATTRB_NAME}   {scanAttrbName((char *)yytext,yyleng); 
                        transAttrbNameToNumPair(); 
                        return(ID); 
                       }     
<LRAAD1>.              {unput(*yytext); 
                        yerror("attribute reference not terminated by @.\n"); 
	                BEGIN LRA;
		       } 
<MUI>\(                {if (++nLparMac != 1) 
                           yerror("unbalanced parentheses in macro use.\n");
                       }
<MUI>\)                {if (--nLparMac != 0) 
                           yerror("unbalanced parentheses in macro use.\n");
                           else 
                           {macroInterpSetup2(yysbuf,yysptr); 
                            BEGIN yyStartCondTemp;
                           }
                       }
<MUI>[,]               terminateActualParam(); 
<MUI>\\\\              putCharInMacroActParam('\\');  
<MUI>\\[,]             putCharInMacroActParam(',');  
<MUI>\\\(              putCharInMacroActParam('(');  
<MUI>\\\)              putCharInMacroActParam(')');  
<MUI>\\           yerror("misuse of \'\\\' escape character in macro use.\n"); 
<MUI>.|\n              putCharInMacroActParam(*yytext);  
<LUS>\n|.              charOut(*yytext,outL);   
%%   

void scanInit5() 
  {yylineno = 1; 
   plineno = &yylineno; 
   ptext = (char *)yytext; 
   pleng = &yyleng; 
   BEGIN LRA; 
   yyin = Lfile[currentLfile].inPtr; 
   inFileStr = Lfile[currentLfile].inName; 
   if (!buildHeaderFile) 
      appendToOutFile(yoxOutH,yoxOutFileStrH,
                      Lfile[currentLfile].outPtr
                     ); 
  } 


int yyScnState() {return (yybgin-yysvec-1);} 



yywrap() 
  {
   if (yyScnState() == LRAAR) 
      yerror("error: identifier expected after \"return\".\n");   
   unput('x');
   BEGIN EOSFRET;
   return 0;

err1:
   rmTempFiles();
   exit(-1);
  } 


/* LRA LRAAR LRAAR1 LRAAD LRAAD1 LUS are start 
 * conditions of the scanner 
 * that pertain to scanning and parsing the lexical specification (which 
 * is written in a lex-like syntax).  The main problem is for the scanner 
 * to know when it is looking at a lex action, and to look for 
 * at signs inside such actions, and to ignore at signs elsewhere.   
 *  
 * LRA is for looking for attribute references inside of actions in the lex 
 * rules section, and for looking for the ends of such actions.  A lex action 
 * is terminated by the first newline outside of properly paired curly 
 * braces. 
 * 
 * LRAAR is for finding the name of the first grammar symbol seen   
 * after the "return" reserved word in a lex action.  Everything from the
 * return up to its terminating semicolon is put in a lookahead buffer 
 * along with a closing curly brace until the attributes definition section 
 * (if any) is processed.  The semicolon sends this scanner into LRAAR1.   
 * 
 * In LRAAR1, anything other than whitespace, \n, comments or @{ 
 * means that no attribute definition 
 * section follows the return, and the lookahead buffer (which contains 
 * the return and its object) is flushed.  @{ causes a change to LRAAD.   
 *  
 * LUS is for echoing the optional user subroutines section found after 
 * the second "%%" in the lexical specification.   
 *
*/ 

/* Lexemes suitable for grammar symbols are 1)identifiers previously declared
 * as tokens, or 2)character constants. 
 *
 * If exactly one lexeme suitable for a grammar symbol appears between 
 * return and ; a node of that type will be put on the tree just before 
 * each time said return is executed.  
 *
 * If no such lexeme appears there, a warning is issued.  If there is not a 
 * non-empty attribute definition section, the type of the dummy node symbol 
 * is used and another warning is issued.  
 * 
 * If more than one suitable lexeme appears, the first such is assumed for the
 * node type, and subsequent ones generate a warning.    
 */ 

@EOF
set `sum $sumopt <oxDistG1.04/source/agc5.l`; if test $1 -ne 59526
then
	echo ERROR: oxDistG1.04/source/agc5.l checksum is $1 should be 59526
fi
set `wc -lwc <oxDistG1.04/source/agc5.l`
if test $1$2$3 != 344123013939
then
	echo ERROR: wc results of oxDistG1.04/source/agc5.l are $* should be 344 1230 13939
fi

chmod 755 oxDistG1.04/source/agc5.l

if test -f oxDistG1.04/source/ctc.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/ctc.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/ctc.c
	if test -f oxDistG1.04/source/ctc.c
	then
		echo Error: could not remove oxDistG1.04/source/ctc.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/ctc.c
cat >oxDistG1.04/source/ctc.c <<'@EOF'
/* $Header: ctc.c,v 5.10 94/04/16 20:24:07 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <stdio.h> 
#include <limits.h> 

#include "opts.h" 
#include "glob.h"
#include "trav.h"
#include "symTrans.h"
#include "joinTabs.h"

#define DEBCTC 0 

/* minimum (for any system) size of UCHAR_MAX  */
#define UCHAR_MAX_MIN 255 



void printStringArray(arr,sizeofArr,fp) 
  char **arr; 
  int sizeofArr;
  FILE *fp;  
  {int i,j,cond; 

   for (i=0;i<(sizeofArr/sizeof(char *));i++)  
       {if ((arr[i][0] == '@') &&
            (arr[i][1] == '@')
           ) 
           {j = 2; cond = 1;
            while (arr[i][j] != '@')
              {if (!(((arr[i][j] == 's') && showStackOps) 
                     || 
                     ((arr[i][j] == 'u') && showPTsizeStats) 
                     ||
                     ((arr[i][j] == 'c') && !suppressCycleReports) 
                     ||
                     ((arr[i][j] == 'C') && !ansiNotKR) 
                     ||
                     ((arr[i][j] == 'A') && ansiNotKR) 
                     ||
                     ((arr[i][j] == 'T') && treeShow) 
                     ||
                     ((arr[i][j] == 't') && xTreeShow)
                    )
                  ) 
                  cond = 0;
               j++;
              }
            if (cond) fprintf(fp,arr[i]+j+1); 
           }
           else 
           fprintf(fp,arr[i]); 
       }
  } 



void printStorageSizes() 
  { 
   fprintf(yoxOutG,
"                                                      /*custom*/  \n"
          ); 
fprintf(yoxOutG,"long yyyMaxNbytesNodeStg = %d; \n",maxNbytesNodeStg); 
fprintf(yoxOutG,"long yyyMaxNrefCounts =    %d; \n",maxNrefCounts); 
fprintf(yoxOutG,"long yyyMaxNchildren =     %d; \n",maxNchildren);
fprintf(yoxOutG,"long yyyMaxStackSize =     %d; \n",maxStackSize); 
fprintf(yoxOutG,"long yyySSALspaceSize =    %d; \n",SSALspaceSize);
fprintf(yoxOutG,"long yyyRSmaxSize =        %d; \n",RSmaxSize);
fprintf(yoxOutG,"long yyyTravStackMaxSize = %d; \n",travStackMaxSize);
fprintf(yoxOutG,"\n");
  } 



static char *ct17[] = { 
/*"yyyGNT *yyyCLempty; \n",*/
/*"#define yyyclLAMBDA (&yyyCLempty)\n",*/
"\n",
"struct yyyTB yyyTermBuffer; \n",
"\n",
"char *yyyNodeAndStackSpace; \n",
"\n",
"char *yyyNodeSpace;\n",
"char *yyyNextNodeSpace; \n",
"char *yyyAfterNodeSpace; \n",
"\n",
"\n",
" \n",
"struct yyyGenNode **yyyChildListSpace;  \n",
"struct yyyGenNode **yyyNextCLspace; \n",
"struct yyyGenNode **yyyAfterChildListSpace; \n",
"\n",
"\n",
"\n",
"yyyRCT *yyyRefCountListSpace;\n",
"yyyRCT *yyyNextRCLspace;  \n",
"yyyRCT *yyyAfterRefCountListSpace;   \n",
"\n",
"\n",
"\n",
"struct yyySolvedSAlistCell {yyyWAT attrbNum; \n",
"                            long next; \n",
"                           }; \n",
"#define yyyLambdaSSAL 0 \n",
"long yyySSALCfreeList = yyyLambdaSSAL; \n",
"long yyyNewSSALC = 1; \n",
" \n",
"struct yyySolvedSAlistCell *yyySSALspace; \n",
"\n",
"\n",
" \n",
"struct yyyStackItem {struct yyyGenNode *node; \n",
"                     long solvedSAlist; \n",
"                     struct yyyGenNode *oldestNode; \n", 
"@@T@                     long STIwidth; \n", 
"@@T@                     long rootNIOx; \n", 
"@@T@                     long STIleftEdge; \n", 
"@@T@                     struct yyyNIO *oldestNIO; \n", 
"@@t@                     Widget NIO; \n",
"                    };  \n",
"\n",
"long yyyNbytesStackStg; \n",
"struct yyyStackItem *yyyStack; \n",
"struct yyyStackItem *yyyAfterStack; \n",
"struct yyyStackItem *yyyStackTop; \n",
"\n",
"\n",
"\n",
"struct yyyRSitem {yyyGNT *node; \n",
"                  yyyWST whichSym; \n",
"                  yyyWAT wa;  \n",
"                 };  \n",
"\n",
"struct yyyRSitem *yyyRS;  \n",
"struct yyyRSitem *yyyRSTop;  \n",
"struct yyyRSitem *yyyAfterRS;  \n",
" \n",
"\n", 
}; 




void compilerTextCopy1() 
  {
   printStorageSizes(); 
   printStringArray(ct17,sizeof(ct17),yoxOutG); 
  } 
/**********************************************************************/ 



static char *ct24[] = { 
"\n",
"@@C@void yyyfatal(msg)\n",
"@@C@  char *msg; \n",
"@@A@void yyyfatal(char *msg)\n",
"{fprintf(stderr,msg);exit(-1);} \n",
"\n",
"\n",
"\n",
"#define yyyNSof   \'n\' \n",
"#define yyyRCof   \'r\' \n",
"#define yyyCLof   \'c\' \n",
"#define yyySof    \'s\' \n",
"#define yyySSALof \'S\' \n",
"#define yyyRSof   \'q\' \n",
"#define yyyTSof   \'t\' \n",
"\n",
"\n",
"\n",
"@@C@void yyyHandleOverflow(which) \n",
"@@C@  char which; \n",
"@@A@void yyyHandleOverflow(char which) \n",
"  {char *msg1,*msg2; \n",
"   long  oldSize,newSize; \n",
"   switch(which) \n",
"     {\n",
"      case yyyNSof   : \n",
"           msg1 = \"node storage overflow: \";\n",
"           oldSize = yyyMaxNbytesNodeStg; \n", 
"           break; \n",
"      case yyyRCof   : \n",
"           msg1 = \"dependee count overflow: \";\n",
"           oldSize = yyyMaxNrefCounts; \n", 
"           break; \n",
"      case yyyCLof   : \n",
"           msg1 = \"child list overflow: \";\n",
"           oldSize = yyyMaxNchildren; \n", 
"           break; \n",
"      case yyySof    : \n",
"           msg1 = \"parse-tree stack overflow: \";\n",
"           oldSize = yyyMaxStackSize; \n", 
"           break; \n",
"      case yyySSALof : \n",
"           msg1 = \"SSAL overflow: \";\n",
"           oldSize = yyySSALspaceSize; \n", 
"           break; \n",
"      case yyyRSof   : \n",
"           msg1 = \"ready set overflow: \";\n",
"           oldSize = yyyRSmaxSize; \n", 
"           break; \n",
"      case yyyTSof   : \n",
"           msg1 = \"traversal stack overflow: \";\n",
"           oldSize = yyyTravStackMaxSize; \n", 
"           break; \n",
"      default        :;  \n",
"     }\n",
"   newSize = (3*oldSize)/2; \n", 
"   if (newSize < 100) newSize = 100; \n",
"   fprintf(stderr,msg1); \n", 
"   fprintf(stderr,\"size was %%d.\\n\",oldSize); \n", 
"   if (yyyPermitUserAlloc) \n", 
"      msg2 = \"     Try -Y%%c%%d option.\\n\"; \n", 
"      else \n", 
"      msg2 = \"     Have to modify evaluator:  -Y%%c%%d.\\n\"; \n", 
"   fprintf(stderr,msg2,which,newSize); \n", 
"   exit(-1); \n",
"  }\n",
"\n",
"\n",
"\n",
}; /* ct24 */



static char *ct27[] = { 
"@@C@void yyySignalEnts(node,startP,stopP) \n",
"@@C@  register yyyGNT *node; \n",
"@@C@  register yyyFT *startP,*stopP;  \n",
"@@A@void yyySignalEnts(register yyyGNT *node,\n",
"@@A@                   register yyyFT *startP,register yyyFT *stopP) \n",
"  {register yyyGNT *dumNode; \n",
#if DEBCTC 
"   fprintf(stderr,\"in yyySignalEnts: node: %%x \",node);\n", 
"   fprintf(stderr,\"ent list bounds: %%d %%d;  \\n\",\n",
"                  startP-yyyEntL,stopP-yyyEntL \n",
"          ); \n",
#endif
"\n", 
"   while (startP < stopP)  \n",
"     {\n",
"      if (!(*startP)) dumNode = node;  \n",
"         else dumNode = (node->cL)[(*startP)-1];   \n",
#if DEBCTC 
"      fprintf(stderr,\"%%s %%x attrb %%d         /****/   to %%d\\n\",\n", 
"                     \"decrementing ref count of node \",\n",  
"                     dumNode,*(startP+1), \n",
"                     (dumNode->refCountList)[*(startP+1)] - 1\n",
"             );\n", 
#endif
"      if (!(--((dumNode->refCountList)[*(startP+1)]\n",
"              ) \n",
"           )\n",
"         ) \n",
"         { \n",
"          if (++yyyRSTop == yyyAfterRS) \n",
"             {yyyHandleOverflow(yyyRSof); \n",
"              break; \n",
"             }\n",
"          yyyRSTop->node = dumNode; \n",
"          yyyRSTop->whichSym = *startP;  \n",
"          yyyRSTop->wa = *(startP+1);  \n",
#if DEBCTC 
"  fprintf(stderr,\"readying:  node: %%x  whichSym: %%d  wa: %%d\\n\",\n",
"          dumNode,*startP,*(startP+1)\n",
"         ); \n",
#endif
"         }  \n",
"      startP += 2;  \n",
"     }  \n",
"  } \n",
}; /* ct27 */



void compilerTextCopy2() 
  { 
   fprintf(yoxOutG,"\n#define yyyPermitUserAlloc "); 
   fprintf(yoxOutG,(genEvUserCLoptsCode?" 1 \n\n" : " 0 \n\n")); 
   printStringArray(ct24,sizeof(ct24),yoxOutG);  
   printStringArray(ct27,sizeof(ct27),yoxOutG); 
  } 
/**********************************************************************/ 




static char *ct30[] = { 
"\n\n\n",
"@@C@void yyyYoxInit()                                  /*stock*/  \n",
"@@A@void yyyYoxInit()                                  /*stock*/  \n",
"  { \n",
"\n",
"   yyyNodeSizeCalc(); \n",
"\n",
"   if ((yyyTermBuffer.snBufPtr = \n",
"@@C@        (char *) malloc((yyyBiggestNodeSize + sizeof(yyyCopyType)))\n",
"@@A@        (char *) malloc((size_t)(yyyBiggestNodeSize + sizeof(yyyCopyType)))\n",
"       )  \n",
"       == \n",
"       ((char *) NULL) \n",
"      )   \n",
"      yyyfatal(\"malloc error in yyyTermBuffer allocation\\n\");  \n",
"  \n",
"  \n",
"   yyyNbytesStackStg = yyyMaxStackSize*sizeof(struct yyyStackItem); \n",
"   yyyNbytesStackStg = ",
"((yyyNbytesStackStg/yyyAlignSize)+1)*yyyAlignSize;  \n",
"   if ((yyyNodeAndStackSpace = \n",
"@@C@        (char *) malloc((yyyNbytesStackStg + \n",
"@@A@        (char *) malloc((size_t)(yyyNbytesStackStg + \n",
"                                 yyyMaxNbytesNodeStg + \n",
"                                 yyyGNSz + \n",
"                                 yyyBiggestNodeSize + \n",
"                                 sizeof(yyyCopyType) \n",
"                                )\n",
"                       )\n",
"       )  \n",
"       == \n",
"       ((char *) NULL) \n",
"      )   \n",
"      yyyfatal(\"malloc error in ox node and stack space allocation\\n\");\n",
"   yyyStack = (struct yyyStackItem *) yyyNodeAndStackSpace; \n",
"   yyyAfterStack = yyyStack + yyyMaxStackSize;  \n",
"   yyyNodeSpace = yyyNodeAndStackSpace + yyyNbytesStackStg;\n",
"   yyyAfterNodeSpace = yyyNodeSpace + yyyMaxNbytesNodeStg;\n",
" \n",
#if DEBCTC 
"   fprintf(stderr,\"yyyNodeSpace == %%x\\n\",yyyNextNodeSpace); \n",
#endif
" \n",
"   if ((yyyRS = (struct yyyRSitem *) \n",
"@@C@         malloc(((yyyRSmaxSize+1)*sizeof(struct yyyRSitem)))\n",
"@@A@         malloc((size_t)((yyyRSmaxSize+1)*sizeof(struct yyyRSitem)))\n",
"       )  \n",
"       == \n",
"       ((struct yyyRSitem *) NULL) \n",
"      )   \n",
"      yyyfatal(\"malloc error in ox ready set space allocation\\n\");  \n",
"   yyyRS++; \n",
"   yyyAfterRS = yyyRS + yyyRSmaxSize; \n",
"\n",
" \n",
"   if ((yyyChildListSpace = \n",
"@@C@        (yyyGNT **) malloc((yyyMaxNchildren*sizeof(yyyGNT *)))\n",
"@@A@        (yyyGNT **) malloc((size_t)(yyyMaxNchildren*sizeof(yyyGNT *)))\n",
"       )  \n",
"       == \n",
"       ((yyyGNT **) NULL) \n",
"      )   \n",
"      yyyfatal(\"malloc error in ox child list space allocation\\n\");  \n",
"   yyyAfterChildListSpace = yyyChildListSpace + yyyMaxNchildren; \n",
"\n",
" \n",
"   if ((yyyRefCountListSpace = \n",
"@@C@        (yyyRCT *) malloc((yyyMaxNrefCounts * sizeof(yyyRCT)))\n",
"@@A@        (yyyRCT *) malloc((size_t)(yyyMaxNrefCounts * sizeof(yyyRCT)))\n",
"       )  \n",
"       == \n",
"       ((yyyRCT *) NULL) \n",
"      )   \n",
"      yyyfatal(\"malloc error in ox reference ",
"count list space allocation\\n\");  \n",
"   yyyAfterRefCountListSpace = yyyRefCountListSpace + yyyMaxNrefCounts;  \n",
"  \n",
" \n",
"   if ((yyySSALspace = (struct yyySolvedSAlistCell *) \n",
"@@C@          malloc(((yyySSALspaceSize+1) * \n",
"@@A@          malloc((size_t)((yyySSALspaceSize+1) * \n",
"                          sizeof(struct yyySolvedSAlistCell))\n",
"                         ) \n",
"       ) \n",
"       == \n",
"       ((struct yyySolvedSAlistCell *) NULL) \n",
"      ) \n",
"      yyyfatal(\"malloc error in stack solved list space allocation\\n\"); \n",
"@@T@   yyyDebugInit();\n",
"@@t@   yyyDebugInit();\n",
"  } /* yyyYoxInit */ \n",
"\n",
"\n",
"\n",
"@@C@void yyyYoxReset() \n",
"@@A@void yyyYoxReset() \n",
"  { \n",
"   yyyTermBuffer.isEmpty = 1; \n",
"   yyyStackTop = yyyStack; \n",
"   while (yyyStackTop != yyyAfterStack) \n",
"     (yyyStackTop++)->solvedSAlist = yyyLambdaSSAL; \n",
"   yyyStackTop = yyyStack - 1; \n",
"   yyyNextNodeSpace = yyyNodeSpace; \n",
"   yyyRSTop = yyyRS - 1; \n",
"   yyyNextCLspace = yyyChildListSpace;\n",
"   yyyNextRCLspace = yyyRefCountListSpace; \n",
"@@T@   yyyDebugReset();\n",
"@@t@   yyyDebugReset();\n",
"@@T@   yyyPTSshowToScreen();\n",
"  }  \n",
"\n",
"\n",
"\n",
"@@C@void yyyDecorate() \n",
"@@A@void yyyDecorate() \n",
"  { \n",
#if DEBCTC 
"   fprintf(stderr,\"\\n\\n\\ndecorating\\n\"); \n",
"   fprintf(stderr,\"/******************************************/\\n\"); \n",
#endif
"   while (yyyRSTop >= yyyRS) \n",
"@@u@     { \n",
"      yyySolveAndSignal();  \n",
"@@u@      yyyDecSolvedInstCount++;\n",
"@@u@     } \n",
"  } \n",
"\n",
"\n",
"\n",
"@@C@void yyyShift() \n",
"@@A@void yyyShift() \n",
"  {yyyRCT *rcPdum; \n",
"   register yyyCopyType *CTp1,*CTp2,*CTp3; \n",
"   register yyyWAT *startP,*stopP;  \n",
"@@s@int sh2,jj;\n",
"\n",
"   if ((++yyyStackTop) == yyyAfterStack) \n",
"      yyyHandleOverflow(yyySof);\n",
"@@T@   yyyMakeLNIOshift();\n",
"@@t@   yyyMakeLNIOshift();\n",
"@@T@   yyyCheckBreakpoints(1);\n",
"   CTp2 = (yyyCopyType *)(yyyStackTop->oldestNode = \n", 
"                          yyyStackTop->node = \n", 
"                          (yyyGNT *)yyyNextNodeSpace \n", 
"                         ); \n",
"   yyyTermBuffer.isEmpty = 1;\n",  
/* "   if (!yyyTermBuffer.typeNum) return; \n", */  
"   ((yyyGNT *)CTp2)->parent = (void *)yyyStackTop; \n",
"   ((yyyGNT *)CTp2)->cL = yyyNextCLspace;  \n",
"   rcPdum = ((yyyGNT *)CTp2)->refCountList = yyyNextRCLspace;  \n",
"   ((yyyGNT *)CTp2)->prodNum = 0; \n", 
"   if ((yyyNextRCLspace += yyyTermBuffer.nAttrbs) \n", 
"       > \n", 
"       yyyAfterRefCountListSpace \n", 
"      ) \n",
"      yyyHandleOverflow(yyyRCof); \n",
"   startP = yyyTermBuffer.startP;  \n",
"   stopP = yyyTermBuffer.stopP;  \n",
"   while (startP < stopP) rcPdum[*(startP++)] = 0; \n",
"   if ((yyyNextNodeSpace += yyyNdPrSz[yyyTermBuffer.typeNum]) \n", 
"       > \n", 
"       yyyAfterNodeSpace \n", 
"      ) \n",
"      yyyHandleOverflow(yyyNSof);  \n",
"   CTp1 = (yyyCopyType *)(yyyTermBuffer.snBufPtr); \n",
"   CTp2 = (yyyCopyType *)(((char *)CTp2) + yyyGNSz); \n", 
"   CTp3 = CTp2 + yyyNdCopySz[yyyTermBuffer.typeNum]; \n",
"   while (CTp2 < CTp3) *CTp2++ = *CTp1++; \n", 
"@@s@sh2 = yyyStackTop-yyyStack+1; \n",
"@@s@fprintf(stderr,\"Shift\"); \n",
"@@s@for (jj=0;jj<sh2;jj++) \n",
"@@s@    fprintf(stderr,\"%%5d\",(yyyStack[jj].node)->prodNum); \n",
"@@s@fprintf(stderr,\"\\n\"); \n",
"  } \n",
"\n",
"\n",
"\n",
"@@C@void yyyGenIntNode() \n",
"@@A@void yyyGenIntNode() \n",
"  {register yyyWST i;\n",
"   register struct yyyStackItem *stDum;  \n",
"   register yyyGNT *gnpDum; \n", 
"\n",
"@@s@int sh2,jj; \n",
"@@u@   yyyIntInstanceCount += yyyNattrbs; yyyIntNodeCount++;\n",
"   if ((stDum = (yyyStackTop -= (yyyRHSlength-1))) >= yyyAfterStack) \n",
"      yyyHandleOverflow(yyySof);\n",
"   yyySTsn = ((char *)(yyySTN = (yyyGNT *)yyyNextNodeSpace)) + yyyGNSz; \n",
"   yyySTN->parent       =  (void *)yyyStackTop;  \n",
"   yyySTN->cL           =  yyyNextCLspace; \n",
"   yyySTN->refCountList =  yyyNextRCLspace; \n",
"   yyySTN->prodNum      =  yyyProdNum; \n",
"   if ((yyyNextCLspace+yyyRHSlength) > yyyAfterChildListSpace) \n",
"      yyyHandleOverflow(yyyCLof); \n",
"   for (i=1;i<=yyyRHSlength;i++) \n",
"     {gnpDum = *(yyyNextCLspace++) = (stDum++)->node;  \n",
"      gnpDum->whichSym = i;  \n",
"      gnpDum->parent = (void *)yyyNextNodeSpace; \n",
"     } \n",
/* "   yyySTN->parent       =  (void *)yyyStackTop; \n", */ 
"   if ((yyyNextRCLspace += yyyNattrbs) > yyyAfterRefCountListSpace) \n",
"      yyyHandleOverflow(yyyRCof); \n",
"   if ((yyyNextNodeSpace += yyyNdPrSz[yyyTypeNum]) > yyyAfterNodeSpace) \n",
"      yyyHandleOverflow(yyyNSof);  \n",
"@@s@yyyStackTop->node = yyySTN;\n",
"@@s@sh2 = yyyStackTop-yyyStack+1; \n",
"@@s@fprintf(stderr,\"R    \",sh2); \n",
"@@s@for (jj=0;jj<sh2;jj++) \n",
"@@s@    fprintf(stderr,\"%%5d\",(yyyStack[jj].node)->prodNum); \n",
"@@s@fprintf(stderr,\"\\n\"); \n",
"  } \n",
"\n",
"\n",
"\n",
"#define yyyDECORfREQ 50 \n",
"\n",
"\n",
"\n",
}; /* ct30 */



static char *ct33[] = { 
"@@C@void yyyAdjustINRC(startP,stopP) \n",
"@@C@  register yyyFT *startP,*stopP;\n",
"@@A@void yyyAdjustINRC(register yyyFT *startP, register yyyFT *stopP) \n",
"  {yyyWST i;\n",
"   long SSALptr,SSALptrHead,*cPtrPtr; \n",
"   long *pL; \n",
"   struct yyyStackItem *stDum;  \n",
"   yyyGNT *gnpDum; \n", 
"   long iTemp;\n",
"   register yyyFT *nextP;\n",
"   static unsigned short intNodeCount = yyyDECORfREQ;\n",
"\n",
#if DEBCTC 
"   fprintf(stderr,\"initializing ref counts IN %%d %%d \\n\",\n",
"                  startP-yyyRCIL,\n",
"                  stopP-yyyRCIL\n",
"          );\n",
#endif
"   nextP = startP;\n",  
"   while (nextP < stopP) \n",
"     {if ((*nextP) == yyyR)  \n",
"         {(yyySTN->refCountList)[*(nextP+1)] = *(nextP+2);\n",
#if DEBCTC 
"   fprintf(stderr,\"      %%x %%d %%d\\n\",yyySTN,*(nextP+1),*(nextP+2)); \n",
#endif
"         } \n", 
"         else \n",
"         {(((yyySTN->cL)[*nextP])->refCountList)[*(nextP+1)] = *(nextP+2);\n",
#if DEBCTC 
"   fprintf(stderr,\"      %%x %%d %%d\\n\",(yyySTN->cL)[*nextP],\n",
"                  *(nextP+1),\n",
"                  *(nextP+2)\n",
"          );\n",
#endif
"         } \n", 
"      nextP += 3;  \n",
"     }\n",
"   pL = yyyIIEL + yyyIIIEL[yyyProdNum]; \n",
"   stDum = yyyStackTop;  \n",
"   for (i=1;i<=yyyRHSlength;i++) \n",
"     {pL++; \n",
"      SSALptrHead = SSALptr = *(cPtrPtr = &((stDum++)->solvedSAlist)); \n",
"      if (SSALptr != yyyLambdaSSAL) \n",
"         {*cPtrPtr = yyyLambdaSSAL; \n",
"          do \n",
"            {\n",
"             iTemp = (*pL+yyySSALspace[SSALptr].attrbNum);\n",
#if DEBCTC 
"             fprintf(stderr,\"%%s  %%d %%d\",\n",
"                            \"\\nsignalling ents of SSA: \\n\",\n",
"                            i,\n",
"                            yyySSALspace[SSALptr].attrbNum \n",
"                    );  \n",
#endif
"             yyySignalEnts(yyySTN,\n",
"                           yyyEntL + yyyIEL[iTemp],\n",
"                           yyyEntL + yyyIEL[iTemp+1]\n",
"                          );  \n",
"             SSALptr = *(cPtrPtr = &(yyySSALspace[SSALptr].next)); \n",
"            } \n",
"            while (SSALptr != yyyLambdaSSAL);  \n",
"          *cPtrPtr = yyySSALCfreeList;  \n",
"          yyySSALCfreeList = SSALptrHead;  \n",
"         } \n",
"     } \n",
"   nextP = startP + 2;\n",  
"   while (nextP < stopP) \n",
"     {if (!(*nextP))\n",  
"         {if ((*(nextP-2)) == yyyR)  \n",
"             {pL = &(yyyStackTop->solvedSAlist); \n",
"              if (yyySSALCfreeList == yyyLambdaSSAL) \n",
"                 {yyySSALspace[yyyNewSSALC].next = *pL; \n",
"                  if ((*pL = yyyNewSSALC++) == yyySSALspaceSize) \n",
"                     yyyHandleOverflow(yyySSALof); \n",
"                 }  \n",
"                 else\n",
"                 {iTemp = yyySSALCfreeList; \n",
"                  yyySSALCfreeList = yyySSALspace[yyySSALCfreeList].next; \n",
"                  yyySSALspace[iTemp].next = *pL; \n",
"                  *pL = iTemp;  \n",
"                 } \n",
"              yyySSALspace[*pL].attrbNum = *(nextP-1); \n",
"             } \n",
"             else \n",
"             {if ((gnpDum = (yyySTN->cL)[*(nextP-2)])->prodNum != 0)\n", 
"                 {\n", 
"                  iTemp = yyyIIEL[yyyIIIEL[gnpDum->prodNum]] + *(nextP-1);\n",
#if DEBCTC 
"                  fprintf(stderr,\"%%s\",\n",
"                                 \"\\nsignalling ents of 0-init IN: \\n\"\n",
"                         );  \n",
#endif
"                  yyySignalEnts(gnpDum, \n",
"                                yyyEntL + yyyIEL[iTemp],  \n", 
"                                yyyEntL + yyyIEL[iTemp+1] \n",
"                               );    \n",
"                 }  \n",
"             } \n",
"         } \n",
"      nextP += 3; \n", 
"     } \n",
"   yyyStackTop->node = yyySTN;\n", 
"   if (!yyyRHSlength) yyyStackTop->oldestNode = yyySTN; \n",
"   if (!--intNodeCount) \n",
"      {intNodeCount = yyyDECORfREQ; \n",
"       yyyDecorate(); \n",
"      } \n",
"  } \n",
"\n",
"\n",
"\n",
"@@C@void yyyPrune(prodNum) \n",
"@@C@  long prodNum;\n",
"@@A@void yyyPrune(long prodNum) \n",
"  {  \n",
"   int i,n; \n",
"   register char *cp1,*cp2;  \n", 
"   register yyyRCT *rcp1,*rcp2,*rcp3;  \n", 
"   long cycleSum = 0;\n",
"   long nNZrc = 0;\n",
"   yyyRCT *tempNextRCLspace;\n",
"   \n",
"   yyyDecorate();\n",
/* "   if ((yyyStackTop->oldestNode) == (yyyStackTop->node)) return; \n", */ 
"@@u@if ((yyyTempUsed = (yyyNextRCLspace - yyyRefCountListSpace)) > \n",  
"@@u@    yyyMaxNrefCountsUsed \n", 
"@@u@   ) \n",  
"@@u@   yyyMaxNrefCountsUsed = yyyTempUsed;  \n",  
"@@u@    \n",  
"@@u@if ((yyyTempUsed = (yyyNextCLspace - yyyChildListSpace)) > \n",  
"@@u@    yyyMaxNchildrenUsed \n", 
"@@u@   ) \n",  
"@@u@   yyyMaxNchildrenUsed = yyyTempUsed;  \n",  
"@@u@    \n",  
"@@u@if ((yyyTempUsed = (yyyNextNodeSpace - yyyNodeSpace)) > \n",  
"@@u@    yyyMaxNnodeBytesUsed \n", 
"@@u@   ) \n",  
"@@u@   yyyMaxNnodeBytesUsed = yyyTempUsed;  \n",  
"@@u@    \n",  
"   tempNextRCLspace = yyyNextRCLspace;\n", 
"   yyyNextRCLspace = \n", 
"     (rcp1 = rcp2 = (yyyStackTop->oldestNode)->refCountList) + yyyNattrbs;\n",
"   rcp3 = (yyyStackTop->node)->refCountList; \n",
"   while (rcp2 < rcp3) \n", 
"     if (*rcp2++) {cycleSum += *(rcp2 - 1); nNZrc++;} \n",
"   if (nNZrc) \n",
"      {\n",
"@@c@       fprintf(stderr,\"\\n\\n\\n----------\\n\");\n",
"@@c@       fprintf(stderr,\n",
"@@c@         \"cycle detected during pruning of a subtree\\n\");\n",
"@@c@       fprintf(stderr,\n",
"@@c@         \"  at whose root production %%d is applied.\\n\",prodNum);\n",
/* "@@c@       fprintf(stderr,\n", */
/* "@@c@       \"number of non-root attribute instances in subtree == %%d.\\n\",\n", */
/* "@@c@               rcp3 - rcp1 \n", */
/* "@@c@              ); \n", */
/* "@@c@       fprintf(stderr,\n", */
/* "@@c@               \"number of unsolved attribute instances == %%d.\\n\", \n", */
/* "@@c@               nNZrc \n", */
/* "@@c@              ); \n", */
/* "@@c@       fprintf(stderr,\n", */
/* "@@c@               \"total number of remaining dependencies == %%d.\\n\", \n", */
/* "@@c@               cycleSum\n", */
/* "@@c@              ); \n", */
/* "@@c@       fprintf(stderr,\"average number of remaining dependencies\\n\");\n", */
/* "@@c@       fprintf(stderr,\"  per unsolved instance == %%f.\\n\", \n", */
/* "@@c@               ((float)(cycleSum)/(float)(nNZrc)) \n", */
/* "@@c@              ); \n", */
"       yyyNextRCLspace = tempNextRCLspace; \n", 
"@@c@       fprintf(stderr,\n",
"@@c@         \"prune aborted: searching subtree for %%d unsolved instances:\\n\",\n",
"@@c@               nNZrc\n",
"@@c@              );\n",
"@@c@       yyyUnsolvedInstSearchTrav(yyyStackTop->node);\n",
"       return; \n",
"      }\n",
"   for (i=0;i<yyyNattrbs;i++) rcp1[i] = rcp3[i]; \n", 
"   yyyNextCLspace = (yyyStackTop->oldestNode)->cL; \n", 
"   yyyNextNodeSpace = (char *)(yyyStackTop->oldestNode) + \n", 
"                      (n = yyyNdPrSz[yyyTypeNum]);\n", 
"   cp1 = (char *)yyyStackTop->oldestNode; \n", 
"   cp2 = (char *)yyyStackTop->node; \n", 
"   for (i=0;i<n;i++) *cp1++ = *cp2++; \n", 
"   yyyStackTop->node = yyyStackTop->oldestNode; \n", 
"   (yyyStackTop->node)->refCountList = rcp1; \n", 
"   (yyyStackTop->node)->cL = yyyNextCLspace; \n", 
"  } \n",
"\n",
"\n",
"\n",
}; /* ct33 */



static char *ct37[] = {
"@@C@void yyyGenLeaf(nAttrbs,typeNum,startP,stopP) \n",
"@@C@  int nAttrbs,typeNum; \n",
"@@C@  yyyWAT *startP,*stopP; \n", 
"@@A@void yyyGenLeaf(int nAttrbs,int typeNum,yyyWAT *startP,yyyWAT *stopP) \n",
"  {\n",
#if DEBCTC 
"   fprintf(stderr,\"\\ngenerating leaf node: %%x  type number %%d\\n\",\n",
"                  yyyNextNodeSpace,\n",
"                  typeNum\n", 
"          );\n", 
#endif
"@@u@   yyyLeafInstanceCount += nAttrbs; yyyLeafNodeCount++;\n",
"@@u@   if (!nAttrbs) yyyAttrblessLeafNodeCount++;\n",
"   if  (!(yyyTermBuffer.isEmpty)) yyyShift(); \n",
"   yyyTermBuffer.isEmpty = 0;\n", 
"   yyyTermBuffer.typeNum = typeNum; \n", 
"   yyyTermBuffer.nAttrbs = nAttrbs; \n", 
"   yyyTermBuffer.startP = startP; \n", 
"   yyyTermBuffer.stopP = stopP; \n", 
"   \n", 
"  } \n",
"\n",
"\n",
"\n",
"@@C@void yyyerror()\n",
"@@A@void yyyerror()\n",
"  {yyyYok = 0; \n",
"  } \n",
"\n",
"\n",
"\n",
}; /* ct37 */



void compilerTextCopy3() 
  {printStringArray(ct30,sizeof(ct30),yoxOutG); 
   printStringArray(ct33,sizeof(ct33),yoxOutG); 
   printStringArray(ct37,sizeof(ct37),yoxOutG); 
   outputUserOptsCode(); 
  }



static char *ct4[] = { 
"} /* switch */ \n\n", 
"if (yyyws)  /* the just-solved instance was inherited. */ \n",
"   {if (yyyRSTopN->prodNum) \n",  
"       {yyyiDum = yyyIIEL[yyyIIIEL[yyyRSTopN->prodNum]] + yyywa;\n",
#if DEBCTC 
"        fprintf(stderr,\"%%s\",\n",
"                 \"\\nsignalling ents of attrb in yyyS.A.S. trailer: \\n\"\n",
"               );  \n",
#endif
"        yyySignalEnts(yyyRSTopN,yyyEntL + yyyIEL[yyyiDum],\n", 
"                                yyyEntL + yyyIEL[yyyiDum+1]\n",
"                     );\n",
"       }\n",
"   } \n",  
"   else     /* the just-solved instance was synthesized. */ \n",
"   {if ((char *)yyyRSTopNp >= yyyNodeSpace) /* node has a parent. */ \n",
"       {yyyiDum = yyyIIEL[yyyIIIEL[((yyyGNT *)yyyRSTopNp)->prodNum] + \n",
"                          yyyRSTopN->whichSym \n", 
"                         ] + \n", 
"                  yyywa;\n",
#if DEBCTC 
"        fprintf(stderr,\"%%s\",\n",
"                 \"\\nsignalling ents of attrb in yyyS.A.S. trailer: \\n\"\n",
"               );  \n",
#endif
"        yyySignalEnts((yyyGNT *)yyyRSTopNp,\n", 
"                      yyyEntL + yyyIEL[yyyiDum],\n", 
"                      yyyEntL + yyyIEL[yyyiDum+1] \n", 
"                     );\n",
"       } \n",
"       else   /* node is still on the stack--it has no parent yet. */ \n",
"       {yyypL = &(((struct yyyStackItem *)yyyRSTopNp)->solvedSAlist); \n",
"        if (yyySSALCfreeList == yyyLambdaSSAL) \n",
"           {yyySSALspace[yyyNewSSALC].next = *yyypL; \n",
"            if ((*yyypL = yyyNewSSALC++) == yyySSALspaceSize) \n",
"               yyyHandleOverflow(yyySSALof); \n",
"           }  \n",
"           else\n",
"           {yyyiDum = yyySSALCfreeList; \n",
"            yyySSALCfreeList = yyySSALspace[yyySSALCfreeList].next; \n",
"            yyySSALspace[yyyiDum].next = *yyypL; \n",
"            *yyypL = yyyiDum;  \n",
"           } \n",
"        yyySSALspace[*yyypL].attrbNum = yyywa; \n",
"       } \n",
"   }\n", 
"\n",
"} /* yyySolveAndSignal */ \n", 
"@@u@\n", 
"@@u@\n", 
"@@u@\n", 
"@@u@long yyyMaxNrefCountsUsed = 0; \n",
"@@u@long yyyMaxNchildrenUsed = 0; \n",
"@@u@long yyyMaxNnodeBytesUsed = 0; \n",
"@@u@long yyyTempUsed = 0; \n",
"@@u@long yyyIntInstanceCount = 0; long yyyIntNodeCount = 0;\n",
"@@u@long yyyLeafInstanceCount = 0; long yyyLeafNodeCount = 0;\n",
"@@u@long yyyAttrblessLeafNodeCount = 0;\n",
"@@u@long yyyDecSolvedInstCount = 0;\n",
"\n", 
"\n", 
"\n", 
};



static char *ct43[] = {
"@@C@void yyyExecuteRRsection()  {\n",
"@@A@void yyyExecuteRRsection()  {\n",
"   int yyyi; \n", 
"   long yyynRefCounts; \n", 
"@@u@ long yyyTotalPTstgUsed;\n",  
"   long cycleSum = 0;\n",
"   long nNZrc = 0;\n",
"\n",
#if DEBCTC 
"  fprintf(stderr,\"\\n\\n\\nin yyyExecuteRRsection \\n\");\n",
"  fprintf(stderr,\"\\n/******************************************/ \\n\");\n",
#endif
"   if (!yyyYok) return; \n", 
"@@u@if ((yyyTempUsed = (yyyNextRCLspace - yyyRefCountListSpace)) > \n",  
"@@u@    yyyMaxNrefCountsUsed \n", 
"@@u@   ) \n",  
"@@u@   yyyMaxNrefCountsUsed = yyyTempUsed;  \n",  
"@@u@    \n",  
"@@u@if ((yyyTempUsed = (yyyNextCLspace - yyyChildListSpace)) > \n",  
"@@u@    yyyMaxNchildrenUsed \n", 
"@@u@   ) \n",  
"@@u@   yyyMaxNchildrenUsed = yyyTempUsed;  \n",  
"@@u@    \n",  
"@@u@if ((yyyTempUsed = (yyyNextNodeSpace - yyyNodeSpace)) > \n",  
"@@u@    yyyMaxNnodeBytesUsed \n", 
"@@u@   ) \n",  
"@@u@   yyyMaxNnodeBytesUsed = yyyTempUsed;  \n",  
"@@u@    \n",  
"@@u@fprintf(stderr,\"Size of input: %%8d tokens\\n\\n\",\n",
"@@u@        yyyLeafNodeCount\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"Parse-tree Storage Maximum Usages:     \");\n",
"@@u@fprintf(stderr,\"    used/allocated\\n\"); \n",
"@@u@fprintf(stderr,\"     n: bytes of node storage:         %%8d/%%8d\\n\",\n",
"@@u@        yyyMaxNnodeBytesUsed,yyyMaxNbytesNodeStg\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"     c: number of child pointers:      %%8d/%%8d\\n\",\n",
"@@u@        yyyMaxNchildrenUsed,yyyMaxNchildren\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"     r: number of dependee counts:     %%8d/%%8d\\n\",\n",
"@@u@        yyyMaxNrefCountsUsed,yyyMaxNrefCounts\n", 
"@@u@       );\n", 
"@@u@        yyyTotalPTstgUsed = yyyMaxNnodeBytesUsed +\n", 
"@@u@        (yyyMaxNchildrenUsed * sizeof(yyyGNT *)) +\n", 
"@@u@        yyyMaxNrefCountsUsed;\n", 
"@@u@fprintf(stderr,\"Maximum Parse-tree Storage Used:       %%8d bytes\\n\",\n",
"@@u@        yyyTotalPTstgUsed\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"\\n\");\n",
"@@u@fprintf(stderr,\"%%8d attribute instances in %%8d leaf nodes \\n\",\n",
"@@u@        yyyLeafInstanceCount,yyyLeafNodeCount\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"%%8d attribute instances in %%8d interior nodes \\n\",\n",
"@@u@        yyyIntInstanceCount,yyyIntNodeCount\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"%%8d attribute instances in %%8d parse-tree nodes\\n\",\n",
"@@u@        yyyIntInstanceCount + yyyLeafInstanceCount,\n", 
"@@u@        yyyIntNodeCount + yyyLeafNodeCount\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\n",
"@@u@        \"%%8d attribute instances solved during decorations\\n\",\n",
"@@u@        yyyDecSolvedInstCount\n",
"@@u@       );\n", 
"@@u@if (yyyIntInstanceCount + yyyLeafInstanceCount)\n", 
"@@u@   fprintf(stderr,\"        %%8d/%%d = %%.3f \\n\",\n",
"@@u@           yyyDecSolvedInstCount,\n",
"@@u@           yyyIntInstanceCount + yyyLeafInstanceCount,\n", 
"@@u@           ((float)yyyDecSolvedInstCount)/\n",
"@@u@           ((float)(yyyIntInstanceCount + yyyLeafInstanceCount))\n", 
"@@u@          );\n", 
"@@u@fprintf(stderr,\"%%8d attributeless leaf nodes \\n\",\n",
"@@u@        yyyAttrblessLeafNodeCount\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"\\n\");\n",
"@@u@fprintf(stderr,\"# parse-tree nodes / # leaf nodes = %%5.2f \\n\",\n",
"@@u@        (yyyIntNodeCount + yyyLeafNodeCount) /\n", 
"@@u@        (float)yyyLeafNodeCount\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"# leaf attribute instances / \");\n",
"@@u@fprintf(stderr,\"# leaf nodes = %%5.2f\\n\",\n",
"@@u@        yyyLeafInstanceCount /\n", 
"@@u@        (float)yyyLeafNodeCount\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"# interior attribute instances / \");\n",
"@@u@fprintf(stderr,\"# interior nodes = %%5.2f\\n\",\n",
"@@u@        yyyIntInstanceCount /\n", 
"@@u@        (float)yyyIntNodeCount\n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"total # attribute instances / \");\n",
"@@u@fprintf(stderr,\"# parse-tree nodes = %%5.2f\\n\",\n",
"@@u@        (yyyIntInstanceCount + yyyLeafInstanceCount) /\n", 
"@@u@        (float)(yyyIntNodeCount + yyyLeafNodeCount) \n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"maximum parse-tree storage used /\");\n",
"@@u@fprintf(stderr,\" # parse-tree nodes = %%4.1f bytes\\n\",\n",
"@@u@        (float)yyyTotalPTstgUsed / \n", 
"@@u@        (yyyIntNodeCount + yyyLeafNodeCount) \n", 
"@@u@       );\n", 
"@@u@fprintf(stderr,\"maximum parse-tree storage used /\");\n",
"@@u@fprintf(stderr,\" # tokens = %%4.1f bytes\\n\",\n",
"@@u@        yyyTotalPTstgUsed / \n", 
"@@u@        (float)yyyLeafNodeCount \n", 
"@@u@       );\n", 
"   yyynRefCounts = yyyNextRCLspace - yyyRefCountListSpace; \n", 
"   for (yyyi=0;yyyi<yyynRefCounts;yyyi++) \n",
"     if (yyyRefCountListSpace[yyyi])\n",
"        {cycleSum += yyyRefCountListSpace[yyyi]; nNZrc++;} \n",
"   if (nNZrc) \n",
"      {\n",
"@@c@       fprintf(stderr,\"\\n\\n\\n**********\\n\");\n",
"@@c@       fprintf(stderr,\n",
"@@c@               \"cycle detected in completed parse tree\");\n",
"@@c@       fprintf(stderr,\n",
"@@c@               \" after decoration.\\n\");\n",
/* "@@c@       fprintf(stderr,\n", */
/* "@@c@               \"number of unsolved attribute instances == %%d.\\n\", \n", */
/* "@@c@               nNZrc \n", */
/* "@@c@              ); \n", */
/* "@@c@       fprintf(stderr,\n", */
/* "@@c@               \"total number of remaining dependencies == %%d.\\n\", \n", */
/* "@@c@               cycleSum\n", */
/* "@@c@              ); \n", */
/* "@@c@       fprintf(stderr,\"average number of remaining dependencies\\n\");\n", */
/* "@@c@       fprintf(stderr,\"  per unsolved instance == %%f.\\n\", \n", */
/* "@@c@               ((float)(cycleSum)/(float)(nNZrc)) \n", */
/* "@@c@              ); \n", */
"@@c@       fprintf(stderr,\n",
"@@c@         \"searching parse tree for %%d unsolved instances:\\n\",\n",
"@@c@               nNZrc\n",
"@@c@              );\n",
"@@c@       yyyUnsolvedInstSearchTravAux(yyyStackTop->node);\n",
"      }\n",
"   yyyDoTraversals();\n",
}; 



void printSAStrailer() 
  {printStringArray(ct4,sizeof(ct4),temp1Out); 
   printTravCode();
   printStringArray(ct43,sizeof(ct43),temp1Out); 
  }



static char *ct15[] = { 
"                                                      /*stock*/  \n",
"\n",
"@@t@#include <X11/StringDefs.h>\n",
"@@t@#include <X11/Intrinsic.h>\n",
"@@t@\n",
"@@t@#include <X11/Xaw/MenuButton.h>\n",
"@@t@#include <X11/Xaw/Tree.h>\n",
"@@t@#include <X11/Xaw/Viewport.h>\n",
"\n",
"\n",
"\n",
"struct yyyGenNode {void *parent;  \n",
"                   struct yyyGenNode **cL; /* child list */ \n",
"                   yyyRCT *refCountList; \n",
"                   yyyPNT prodNum;                      \n",
"                   yyyWST whichSym; /* which child of parent? */ \n",
"                  }; \n",
"\n",
"typedef struct yyyGenNode yyyGNT; \n",
"\n",
"\n",
"\n",
"struct yyyTB {int isEmpty; \n", 
"              int typeNum; \n",
"              int nAttrbs; \n",
"              char *snBufPtr; \n",
"              yyyWAT *startP,*stopP; \n",
"@@T@              char* NIOstr;\n",
"@@t@              char* NIOstr;\n",
"             };  \n",
"\n",
"\n",
"\n",
}; 



static char *ct5[] = { 
"\n",
"extern struct yyyTB yyyTermBuffer; \n", 
"extern yyyWAT yyyLRCIL[]; \n",
"@@C@extern void yyyGenLeaf(); \n", 
"@@A@extern void yyyGenLeaf(int nAttrbs,int typeNum,\n",
"@@A@                       yyyWAT *startP,yyyWAT *stopP\n",
"@@A@                      ); \n",
"@@TC@extern void yyyMakeLNIOlookahead(); \n", 
"@@TA@extern void yyyMakeLNIOlookahead(char *label); \n", 
"@@tC@extern void yyyMakeLNIOlookahead(); \n",
"@@tA@extern void yyyMakeLNIOlookahead(char *label); \n",
"\n"  
}; 



static char *ct1[] = {
"\n%%{\n",
/* "#include <string.h>\n", */
"#include <stdio.h>\n",
"@@A@#include <stdlib.h>\n",
"\n",
"int yyyYok = 1;\n",
"int yyyInitDone = 0;\n",
"char *yyySTsn;\n",
"yyyGNT *yyySTN;\n",
"int yyyGNSz = sizeof(yyyGNT);\n",
"int yyyProdNum,yyyRHSlength,yyyNattrbs,yyyTypeNum; \n",
"\n",
"extern yyyFT yyyRCIL[];\n",
"\n",
"void yyyExecuteRRsection();\n",
"void yyyYoxInit();\n",
"void yyyYoxReset();\n",
"void yyyDecorate();\n",
"void yyyGenIntNode();\n",
"@@C@void yyyAdjustINRC();\n",
"@@A@void yyyAdjustINRC(register yyyFT *,register yyyFT *);\n",
"@@C@void yyyPrune();\n",
"@@A@void yyyUnsolvedInstSearchTrav(yyyGNT *pNode);\n",
"@@C@void yyyUnsolvedInstSearchTrav();\n",
"@@A@void yyyUnsolvedInstSearchTravAux(yyyGNT *pNode);\n",
"@@C@void yyyUnsolvedInstSearchTravAux();\n",
"@@A@void yyyPrune(long prodNum);\n",
"void yyyerror();\n",
"void yyyShift();\n",
"\n",
"@@T@void yyyDebugInit();\n",
"@@T@void yyyMakeLNIOshift();\n",
"@@T@void yyyDebugAccept();\n",
"@@T@void yyyDebugReset();\n",
"@@TC@void yyyMakeINIOpreReduce();\n",
"@@TA@void yyyMakeINIOpreReduce(char *label);\n",
"@@T@void yyyMakeINIOpostReduce();\n",
"@@TC@void yyyCheckBreakpoints();\n",
"@@TA@void yyyCheckBreakpoints(int isShift);\n",
"@@TC@long yyyRoundFloatToLong();\n",
"@@TA@long yyyRoundFloatToLong(float f);\n",
"@@T@void yyyPTSshowToFile();\n",
"@@T@void yyyPTSshowToFileAux();\n",
"@@T@void yyyWriteStatusLine();\n",
"@@T@void yyyPTSshowToScreen();\n",
"@@T@void yyyDebugCleanup();\n",
"@@TC@void yyyInterpDebugCommand();\n",
"@@TA@void yyyInterpDebugCommand(int repeat);\n",

"@@t@void yyyDebugInit();\n",
"@@t@void yyyMakeLNIOshift();\n",
"@@t@void yyyDebugReset();\n",
"@@tC@void yyyMakeINIOpreReduce();\n",
"@@tA@void yyyMakeINIOpreReduce(char *label);\n",
"@@t@void yyyMakeINIOpostReduce();\n",
"@@t@void yyyXshowTree();\n",
"\n",
"\n",
"#define yyyRSU(NUM1,NUM2,NUM3,NUM4) \\\n",
"   yyyProdNum=NUM1;yyyRHSlength=NUM2;yyyNattrbs=NUM3;yyyTypeNum=NUM4;\\\n",
"   if ((yychar <= 0) && (!yyyTermBuffer.isEmpty)) yyyShift(); \n",
"%%}\n",
"\n",
"\n",
};



void compilerTextCopy5() 
  { 
fprintf(yoxOutH, 
"                                                      /*custom*/  \n"
       ); 
fprintf(yoxOutH,(WAmax < UCHAR_MAX_MIN)? 
                   "typedef unsigned char yyyWAT; \n":
                   "typedef unsigned short yyyWAT; \n" 
       ); 
fprintf(yoxOutH,(RCmax <= UCHAR_MAX_MIN)?
                   "typedef unsigned char yyyRCT; \n":
                   "typedef unsigned short yyyRCT; \n" 
       ); 
/* fprintf(yoxOutH,(prodNumSeq <= UCHAR_MAX_MIN)? */
fprintf(yoxOutH,(0)? 
                   "typedef unsigned char yyyPNT; \n":
                   "typedef unsigned short yyyPNT; \n" 
       ); 
fprintf(yoxOutH,(WSmax <= UCHAR_MAX_MIN)? 
                   "typedef unsigned char yyyWST; \n":
                   "typedef unsigned short yyyWST; \n" 
       ); 
   fprintf(yoxOutH,"\n#include <limits.h>\n");
   if (WSmax > UCHAR_MAX_MIN)
      fprintf(yoxOutH,"#define yyyR USHRT_MAX  \n\n");
      else
      fprintf(yoxOutH,"#define yyyR UCHAR_MAX  \n\n");
   fprintf(yoxOutH,
      " /* funny type; as wide as the widest of yyyWAT,yyyWST,yyyRCT  */ \n"
          );
/*   if ((WAmax >= UCHAR_MAX_MIN) ||  */
/*       (RCmax > UCHAR_MAX_MIN) ||  */
/*       (WSmax > UCHAR_MAX_MIN)*/
/*      )  */
   if (1)
      fprintf(yoxOutH,"typedef unsigned short yyyFT;\n\n");  
      else 
      fprintf(yoxOutH,"typedef unsigned char yyyFT;\n\n");  
   printStringArray(ct15,sizeof(ct15),yoxOutH);  
   printStringArray(ct5,sizeof(ct5),yoxOutH);  
  } 
/**********************************************************************/ 

void compilerTextCopy10() 
  {
   printStringArray(ct1,sizeof(ct1),yoxOutG);  
  }



static char *ct6[] = { 
"\n\n\n",
"@@C@void yyySolveAndSignal() {\n", 
"@@A@void yyySolveAndSignal() {\n", 
"register long yyyiDum,*yyypL;\n",
"register int yyyws,yyywa;\n",
"register yyyGNT *yyyRSTopN,*yyyRefN; \n",
"register void *yyyRSTopNp; \n",
"\n", 
"\nyyyRSTopNp = (yyyRSTopN = yyyRSTop->node)->parent;\n", 
"yyyRefN= (yyyws = (yyyRSTop->whichSym))?((yyyGNT *)yyyRSTopNp):yyyRSTopN;\n",
#if DEBCTC 
"\nfprintf(stderr,\"%%s\",\n",
"               \"\\nentering yyyS.A.S. switch: \\n\"\n",
"       );  \n\n",
#endif
"yyywa = yyyRSTop->wa; \n",
"yyyRSTop--;\n",
"switch(yyyRefN->prodNum) {\n",
};  



static char *ct7[] = {
"\n",
"\n",
"\n",
"#define yyySizeofProd(num) (yyyProdsInd[(num)+1] - yyyProdsInd[(num)])\n",
"\n",
"#define yyyGSoccurStr(prodNum,symPos) \\\n",
"   (yyyStringTab[yyyProds[yyyProdsInd[(prodNum)] + (symPos)][0]])\n",
"\n",
"#define yyySizeofSort(num) (yyySortsInd[(num)+1] - yyySortsInd[(num)])\n",
"\n",
"#define yyySortOf(prodNum,symPos) \\\n",
"  (yyyProds[yyyProdsInd[(prodNum)] + (symPos)][1]) \n",
"\n",
"#define yyyAttrbStr(prodNum,symPos,attrbNum)                      \\\n",
"  (yyyStringTab[yyySorts[yyySortsInd[yyySortOf(prodNum,symPos)] + \\\n",
"                         (attrbNum)                               \\\n",
"                        ]                                         \\\n",
"               ]                                                  \\\n",
"  )\n",
"\n",
"\n",
"\n",
"@@A@void yyyShowProd(int i)\n",
"@@C@void yyyShowProd(i)\n",
"@@C@  int i;\n",
"  {int j,nSyms;\n",
"\n",
"   nSyms = yyySizeofProd(i);\n",
"   for (j=0; j<nSyms; j++)\n",
"     {\n",
"      fprintf(stderr,\"%%s\",yyyGSoccurStr(i,j));\n",
"      if (j == 0) fprintf(stderr,\" : \"); else fprintf(stderr,\" \");\n",
"     }\n",
"   fprintf(stderr,\";\\n\");\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyShowProds()\n",
"  {int i; for (i=1; i<=yyyLastProdNum; i++) yyyShowProd(i);}\n",
"\n",
"\n",
"\n",
"void yyyShowSymsAndSorts()\n",
"  {int i; \n",
"\n",
"   for (i=1; i<=yyyLastProdNum; i++) \n",
"     {int j, nSyms;\n",
"\n",
"      fprintf(stderr,\n",
"              \"\\n\\n\\n---------------------------------- %%3.1d\\n\",i);\n",
"      /* yyyShowProd(i); */ \n",
"      nSyms = yyySizeofProd(i); \n",
"      for (j=0; j<nSyms; j++) \n",
"        {int k, sortSize;\n",
"\n",
"         fprintf(stderr,\"%%s\\n\",yyyGSoccurStr(i,j));\n",
"         sortSize = yyySizeofSort(yyySortOf(i,j));\n",
"         for (k=0; k<sortSize; k++) \n",
"            fprintf(stderr,\"  %%s\\n\",yyyAttrbStr(i,j,k));\n",
"         if (j == 0) fprintf(stderr,\"->\\n\"); \n",
"              else \n",
"              fprintf(stderr,\"\\n\"); \n",
"        }\n",
"     }\n",
"  }\n",
"\n",
"\n",
"\n",
"@@A@void yyyCheckNodeInstancesSolved(yyyGNT *np)\n",
"@@C@void yyyCheckNodeInstancesSolved(np)\n",
"@@C@  yyyGNT *np;\n",
"  {int mysort,sortSize,i,prodNum,symPos,inTerminalNode;\n",
"   int nUnsolvedInsts = 0;\n",
"\n",
"   if (np->prodNum != 0)\n",
"     {inTerminalNode = 0;\n",
"      prodNum = np->prodNum;\n",
"      symPos = 0;\n",
"     }\n",
"   else\n",
"     {inTerminalNode = 1;\n",
"      prodNum = ((yyyGNT *)(np->parent))->prodNum;\n",
"      symPos = np->whichSym;\n",
"     }\n",
"   mysort = yyySortOf(prodNum,symPos);\n",
"   sortSize = yyySizeofSort(mysort);\n",
"   for (i=0; i<sortSize; i++)\n",
"     if ((np->refCountList)[i] != 0) nUnsolvedInsts += 1;\n",
"   if (nUnsolvedInsts)\n",
"     {fprintf(stderr,\n",
"      \"\\nFound node that has %%d unsolved attribute instance(s).\\n\",\n",
"              nUnsolvedInsts\n",
"             );\n",
"      fprintf(stderr,\"Node is labeled \\\"%%s\\\".\\n\",\n",
"             yyyGSoccurStr(prodNum,symPos));\n",
"      if (inTerminalNode)\n",
"        {fprintf(stderr,\n",
"                 \"Node is terminal.  Its parent production is:\\n  \");\n",
"         yyyShowProd(prodNum);\n",
"        }\n",
"      else\n",
"        {fprintf(stderr,\"Node is nonterminal.  \");\n",
"         if (((char *)(np->parent)) >= yyyNodeSpace)\n",
"           {fprintf(stderr,\n",
"                    \"Node is %%dth child in its parent production:\\n  \",\n",
"                   np->whichSym\n",
"                  );\n",
"            yyyShowProd(((yyyGNT *)(np->parent))->prodNum);\n",
"           }\n",
"         fprintf(stderr,\n",
"                 \"Node is on left hand side of this production:\\n  \");\n",
"         yyyShowProd(np->prodNum);\n",
"        }\n",
"      fprintf(stderr,\"The following instances are unsolved:\\n\");\n",
"      for (i=0; i<sortSize; i++)\n",
"        if ((np->refCountList)[i] != 0)\n",
"          fprintf(stderr,\"     %%-16s still has %%1d dependencies.\\n\",\n",
"                  yyyAttrbStr(prodNum,symPos,i),(np->refCountList)[i]);\n",
"     }\n",
"  }\n",
"\n",
"\n",
"\n",
"@@A@void yyyUnsolvedInstSearchTravAux(yyyGNT *pNode)\n",
"@@C@void yyyUnsolvedInstSearchTravAux(pNode)\n",
"@@C@  yyyGNT *pNode;\n",
"  {yyyGNT **yyyCLpdum;\n",
"   int i;\n",
"  \n",
"   yyyCheckNodeInstancesSolved(pNode); \n",
"   yyyCLpdum = pNode->cL;\n",
"   while\n",
"     ((yyyCLpdum != yyyNextCLspace) && ((*yyyCLpdum)->parent == pNode))\n",
"     {\n",
"      yyyUnsolvedInstSearchTravAux(*yyyCLpdum);\n",
"      yyyCLpdum++;\n",
"     }\n",
"  }\n",
"\n",
"\n",
"\n",
"@@A@void yyyUnsolvedInstSearchTrav(yyyGNT *pNode)\n",
"@@C@void yyyUnsolvedInstSearchTrav(pNode)\n",
"@@C@  yyyGNT *pNode;\n",
"  {yyyGNT **yyyCLpdum;\n",
"   int i;\n",
"  \n",
"   yyyCLpdum = pNode->cL;\n",
"   while\n",
"     ((yyyCLpdum != yyyNextCLspace) && ((*yyyCLpdum)->parent == pNode))\n",
"     {\n",
"      yyyUnsolvedInstSearchTravAux(*yyyCLpdum);\n",
"      yyyCLpdum++;\n",
"     }\n",
"  }\n",
"\n",
"\n",
"\n",
};



void compilerTextCopy7(out)
  FILE *out;
  {
   printStringArray(ct7,sizeof(ct7),out);
  }



void printSASheader() 
  { 
   printStringArray(ct6,sizeof(ct6),temp1Out); 
  } 
/**********************************************************************/ 



@EOF
set `sum $sumopt <oxDistG1.04/source/ctc.c`; if test $1 -ne 58140
then
	echo ERROR: oxDistG1.04/source/ctc.c checksum is $1 should be 58140
fi
set `wc -lwc <oxDistG1.04/source/ctc.c`
if test $1$2$3 != 1400483046934
then
	echo ERROR: wc results of oxDistG1.04/source/ctc.c are $* should be 1400 4830 46934
fi

chmod 755 oxDistG1.04/source/ctc.c

if test -f oxDistG1.04/source/ctc.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/ctc.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/ctc.h
	if test -f oxDistG1.04/source/ctc.h
	then
		echo Error: could not remove oxDistG1.04/source/ctc.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/ctc.h
cat >oxDistG1.04/source/ctc.h <<'@EOF'
/* $Header: ctc.h,v 5.10 94/04/16 20:24:10 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

extern void printStringArray();
extern void compilerTextCopy1();
extern void compilerTextCopy2();
extern void compilerTextCopy3();
extern void compilerTextCopy10();
extern void compilerTextCopy5();
extern void compilerTextCopy7();
extern void printSAStrailer();
extern void printSASheader();
@EOF
set `sum $sumopt <oxDistG1.04/source/ctc.h`; if test $1 -ne 63360
then
	echo ERROR: oxDistG1.04/source/ctc.h checksum is $1 should be 63360
fi
set `wc -lwc <oxDistG1.04/source/ctc.h`
if test $1$2$3 != 704092676
then
	echo ERROR: wc results of oxDistG1.04/source/ctc.h are $* should be 70 409 2676
fi

chmod 755 oxDistG1.04/source/ctc.h

if test -f oxDistG1.04/source/depGs.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/depGs.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/depGs.c
	if test -f oxDistG1.04/source/depGs.c
	then
		echo Error: could not remove oxDistG1.04/source/depGs.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/depGs.c
cat >oxDistG1.04/source/depGs.c <<'@EOF'
/* $Header: depGs.c,v 5.10 94/04/16 20:24:12 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <stdio.h> 
#include <limits.h>  

#include "glob.h" 
#include "opts.hh" 
#include "opts.h" 
#include "trav.h"
#include "symTrans.h"
#include "joinTabs.h"
#include "scan.h"
#include "outMgr.h"
#include "treeShow.h"

#define G_DEBUG 1 

long *indToEntsByProdNum; 
long maxNterms = 1024; 
long *leafRefCountInitIndex;  
long *leafRefCountListLength;  
long eeCountInitSeq = 0;  
long attrbOccrSeq = 0;  
long leafRefCountInitSeq = 0; 
long entOccrSeq = 0; 

int permitCtimeCircTest = 1; 
int maxNentsPerDepSpec = 256; 
int maxNeesPerDepSpec = 256;



/* an increasing sequence of numbers of grammar symbol occurrences
*/
#define outTF stderr
#define firstGSoccur 0L
long gsOccurSeq = firstGSoccur;



/* for keeping track of the dependents in a dependency specification */ 
static int dependentSeq = 0; 
/* for keeping track of the dependees in a dependency specification */ 
static int dependeeSeq = 0; 


/* At the time I designed this, it seemed that it would be handy to store 
   both the local dependency graph and its inverse.  As I write this 
   comment, I don't know if they are both used.  --KB 
   The comments refer to both graphs as the LDG.  
 */
/* the space for storing lists of dependents in the LDG */ 
static struct attrbOccr *dependent; 
/* the space for storing lists of dependees in the LDG */ 
static struct attrbOccr *dependee; 




int hasYaccPvarRefGlob; 

static struct ldgAdjListHeads *ldgALhead;  
int maxNattrbOccrsPerProd = 2048;  

/* index of pointers to the first attribute occurrence in each symbol */ 
static long *ldgALheadInd; 

 
 
static struct ldgNodeStgType *ldgNodeStg; 
static long ldgNodeStgFree;  
int ldgNodeStgSize = 8192;  



/* Used in the consistency and completeness tests. 
   if (change is nonzero) 
       mark the occurrence as defined or undefined (depending on newVal) ;
   issue error message if setting it when already set; 
   return the truth value of "was it defined before calling this?".
 */
static int markOrCheckAttrbOccrDefd(symPos,attrbPos,change,newVal) 
  int symPos,attrbPos,change,newVal; 
  {unsigned int prev; 

   prev = ldgALhead[ldgALheadInd[symPos]+attrbPos].defdThisProd; 
   if (change) ldgALhead[ldgALheadInd[symPos]+attrbPos].defdThisProd = newVal; 
   if (change && newVal && prev) 
      {yerror("attribute occurrence multiply defined \n   "); 
       fprintf(stderr,"at position %d in production.       %s  %s\n",
               symPos,
               gSymTable[prodBuffer2[symPos].gSymTabInd].lexeme,  
               gSymTable[prodBuffer2[symPos].gSymTabInd].sortAAList[attrbPos].id
              );   
      }  
   return (prev);  
  } 



int pruneRequested; 
int decorationRequested; 

static struct attrbOccr *ldgTopSortQ;  
static long ldgTopSortQfront,ldgTopSortQrear; 
 
void prepareDataStructures2() 
  {int i; 

   if ((dependent = (struct attrbOccr *) malloc(maxNentsPerDepSpec * 
                                                sizeof(struct attrbOccr)
                                               )
       )  
       == 
       ((struct attrbOccr *) NULL) 
      )   
      fatal("malloc error in dependent list allocation\n"); 

 
   if ((dependee = (struct attrbOccr *) malloc(maxNeesPerDepSpec * 
                                               sizeof(struct attrbOccr)
                                              )
       )  
       == 
       ((struct attrbOccr *) NULL) 
      )   
      fatal("malloc error in dependee list allocation\n");  


   if ((ldgTopSortQ = (struct attrbOccr *) malloc(maxNattrbOccrsPerProd * 
                                                  sizeof(struct attrbOccr)
                                                 )
       )  
       == 
       ((struct attrbOccr *) NULL) 
      )   
      fatal("malloc error in ldgTopSortQ allocation\n");  


   if ((ldgALhead = (struct ldgAdjListHeads *) malloc(maxNattrbOccrsPerProd * 
                                               sizeof(struct ldgAdjListHeads)
                                                     )
       )  
       == 
       ((struct ldgAdjListHeads *) NULL) 
      )   
      fatal("malloc error in local dep graph adj list head allocation\n");  

   for (i=0;i<maxNattrbOccrsPerProd;i++) 
       {ldgALhead[i].defdThisProd = 0; 
        ldgALhead[i].hasYaccPvarRef = 0; 
        ldgALhead[i].inhFellowEnt = 0; 
        ldgALhead[i].synFellowEnt = 0; 
        ldgALhead[i].refTextStart = 0; 
        ldgALhead[i].refTextEnd = -1; 
        ldgALhead[i].entList = 0;  
        ldgALhead[i].eeList = 0; 
        ldgALhead[i].eeCount = -1; 
       } 

 
   if ((ldgNodeStg = 
       (struct ldgNodeStgType *) malloc(ldgNodeStgSize * 
                                        sizeof(struct ldgNodeStgType)
                                       )
       )  
       == 
       ((struct ldgNodeStgType *) NULL) 
      )   
      fatal("malloc error in local dep graph adj list space allocation\n");  


   if ((ldgALheadInd = (long *) malloc((maxProdLength+1) * sizeof(long)))  
       == 
       ((long *) NULL) 
      )   
      fatal("malloc error in local dep graph head index allocation\n");  


   if ((indToEntsByProdNum = (long *) malloc((maxNprods+1) * sizeof(long)))  
       == 
       ((long *) NULL) 
      )   
      fatal("malloc error in index to dependents by prod num allocation\n");  


   if ((refSegBuffer = (char *) malloc((refSegBufferSize) * sizeof(char)))  
       == 
       ((char *) NULL) 
      )   
      fatal("malloc error in reference segment buffer allocation\n");  


   if ((leafRefCountInitIndex = (long *) malloc((maxNterms+1) * sizeof(long)))  
       == 
       ((long *) NULL) 
      )   
      fatal("malloc error in allocation of leaf ref count init list stg\n");  
   for (i=0;i<maxNterms+1;i++) leafRefCountInitIndex[i] = -1; 


   if ((leafRefCountListLength= (long *) malloc((maxNterms+1) * sizeof(long)))  
       == 
       ((long *) NULL) 
      )   
      fatal("malloc error in allocation of leaf ref count list length stg\n");  
   for (i=0;i<maxNterms+1;i++) leafRefCountListLength[i] = 0; 

   if ((travArr = (struct trav *) malloc((1+maxNtravs) * sizeof(struct trav)))  
       == 
       ((struct trav *) NULL) 
      )   
      fatal("malloc error in allocation of traversal space\n");  
   travArr++;
   clearTravBuf();
   newTrav("undeclared");
   clearErrorTrav();

   if ((travSegBufArr = 
          (struct travSegBuf *) malloc((maxNtravSegBufs) * 
                                        sizeof(struct travSegBuf))
                                      )  
       == 
       ((struct travSegBuf *) NULL) 
      )   
      fatal("malloc error in allocation of traversal segment buffers\n");  
   lambdaTSB = travSegBufArr + maxNtravSegBufs;
   for (i=0; i<maxNtravSegBufs; i++)
     {travSegBufArr[i].orderRevCondStartPtr = 0; 
      travSegBufArr[i].orderRevCondStopPtr = 0; 
      travSegBufArr[i].actionStartPtr = 0; 
      travSegBufArr[i].actionStopPtr = 0; 
     } 
   travSegBufAvail = 0; 
  } 



/* Inserts an occurrence into the image of the dependency expression.
   Searches the dependee or dependent list (as specified by entNOTee)
   and remembers whether the occurrence is already in that list.
   The sorting and binary search are probably overkill, since Ox 
   presently is I/O-bound.
   Inserts the occurrence into the selected list if (insert != 0).
   Returns true if the occurrence was already in the given list.
 */ 
int memberDepend(symPos,attrbNum,entNOTee,insert) 
  int symPos,attrbNum,entNOTee,insert;  
  {struct attrbOccr *occrList; 
   int *seq,limit; 
   int i,lower,upper;
   int member=0; 

   if ((symPos == -1) || (attrbNum == -1)) return(0);  
   if (entNOTee) 
      {occrList=dependent; 
       seq = &dependentSeq; 
       limit=maxNentsPerDepSpec;    
       if (insert) markOrCheckAttrbOccrDefd(symPos,attrbNum,1,1); 
      }  
      else    
      {occrList=dependee; 
       seq = &dependeeSeq; 
       limit=maxNeesPerDepSpec;    
      }  
   lower = 0; 
   upper = *seq - 1; 
   while (lower <= upper) 
     {i = (lower+upper)/2; 
      if (symPos == occrList[i].symPos && 
          attrbNum == occrList[i].attrbNum 
         ) 
         {member = 1; break;}   
         else 
         {if (symPos < occrList[i].symPos ||    
              (symPos == occrList[i].symPos && 
               attrbNum < occrList[i].attrbNum 
              ) 
             )   
             lower = i+1; 
             else 
             upper = i-1; 
         }  
     } 
   if (insert && !member) 
      {if (limit == *seq) 
          {if (entNOTee) 
              handleOverflow(NPDS);  
              else  
              handleOverflow(EPDS); 
          }  
       for (i= *seq;i>lower;i--) occrList[i] = occrList[i-1];   
       occrList[lower].symPos = symPos; 
       occrList[lower].attrbNum = attrbNum; 
       (*seq)++; 
      }  
   return(member);  
  } 



/* get ready to start a new local dependency graph */
void initLDG() 
  {int i; 
   int ldgALheadIndSeq = 0;  

   for (i=0; i<prodBufferPointer2; i++) 
       {ldgALheadInd[i] = ldgALheadIndSeq; 
        ldgALheadIndSeq += gSymTable[prodBuffer2[i].gSymTabInd].nAttrbs; 
        if (ldgALheadIndSeq >= maxNattrbOccrsPerProd) 
           handleOverflow(AOPP);  
       }  
   ldgALheadInd[prodBufferPointer2] = ldgALheadIndSeq; 
   ldgNodeStgFree = 1; 
   nextRefSegBufferStart = 0;  
   refSegBufferPointer = 0;  
   ldgTopSortQfront = 0; 
   ldgTopSortQrear = -1; 
  } 



/* handle one dependency specification (done once for each @i, @e, or @m).
 */ 
void processAdepSpec() 
  {int i,j; 
   struct ldgAdjListHeads *pHead;
   long cdr,*lp; 

   if (dependentSeq == 0) 
     {
      fatal("confused by bad attribute definition\n");
     }
   pHead= &(ldgALhead[ldgALheadInd[dependent[0].symPos]+dependent[0].attrbNum]);
   pHead->refTextStart = nextRefSegBufferStart;  
   pHead->refTextEnd = refSegBufferPointer - 1; 
   pHead->hasYaccPvarRef = hasYaccPvarRefGlob; 
   for (i=0;i<dependentSeq;i++) 
       {if (dependent[i].symPos) 
           pHead->inhFellowEnt = 1; 
           else 
           pHead->synFellowEnt = 1; 
       }
   for (i=0;i<dependentSeq;i++) 
       {pHead = 
        &(ldgALhead[ldgALheadInd[dependent[i].symPos]+dependent[i].attrbNum]); 
        if ((pHead->eeCount = dependeeSeq)  == 0) 
           {ldgTopSortQ[++ldgTopSortQrear].symPos = dependent[i].symPos;  
            ldgTopSortQ[ldgTopSortQrear].attrbNum = dependent[i].attrbNum; 
           }  
        for (j=0;j<dependeeSeq;j++) 
            {if (ldgNodeStgFree == ldgNodeStgSize) 
                handleOverflow(LGNS);  
             cdr = pHead->eeList;   
             pHead->eeList = ldgNodeStgFree;   
             ldgNodeStg[pHead->eeList].node = dependee[j]; 
             ldgNodeStg[pHead->eeList].next = cdr; 
             ldgNodeStgFree++;  
            }  
       } 
   for (i=0;i<dependeeSeq;i++) 
       {lp = &(ldgALhead[ldgALheadInd[dependee[i].symPos] + 
                         dependee[i].attrbNum
                        ].entList);   
        while ((*lp != 0) && (ldgNodeStg[*lp].node.symPos == 0)) 
          lp = &(ldgNodeStg[*lp].next); 
        for (j=0;j<dependentSeq;j++) 
             {if (ldgNodeStgFree == ldgNodeStgSize) 
                 handleOverflow(LGNS);  
              cdr = *lp;  
              *lp = ldgNodeStgFree;   
              ldgNodeStg[*lp].node = dependent[j]; 
              ldgNodeStg[*lp].next = cdr; 
              ldgNodeStgFree++; 
             }  
       } 
   dependentSeq = 0;  
   dependeeSeq = 0; 
   hasYaccPvarRefGlob = 0;  
   nextRefSegBufferStart = refSegBufferPointer;  

   pHead= &(ldgALhead[ldgALheadInd[dependent[0].symPos]+dependent[0].attrbNum]);
  } 



void genAutoDef(symPos,attrbNum,warning)
  int symPos,attrbNum,warning;
  {int i,j,nA,spTemp,anTemp;
   struct gSym *homeSym,*dumSym;
   char *cp;
   int nFound = 0; 

   homeSym = &(gSymTable[prodBuffer2[symPos].gSymTabInd]);   
   cp = homeSym->sortAAList[attrbNum].id;

   if (symPos == 0)
      {for (i=1; i<prodBufferPointer2; i++) 
           {dumSym = &(gSymTable[prodBuffer2[i].gSymTabInd]);   
            nA = dumSym->nAttrbs;
            for (j=0; j<nA; j++)
                if (dumSym->sortAAList[j].id == cp)
                   {nFound++; 
                    spTemp = i;
                    anTemp = j;
                   }
           }
      }
      else
      {dumSym = &(gSymTable[prodBuffer2[0].gSymTabInd]);   
       nA = dumSym->nAttrbs;
       for (j=0; j<nA; j++)
           if (dumSym->sortAAList[j].id == cp) 
              {nFound++; 
               spTemp = 0;
               anTemp = j;
              }
      }
   if (nFound != 1) 
      {yerror("missing attribute definition or bad application\n");
       fprintf(stderr,"%s%s %s. %s%d.\n",
               "  of automatic copy rule: ",
               homeSym->lexeme,
               cp,
               " position: ",
               symPos
              );
       if (nFound == 0)
          fprintf(stderr,
              "  no opposite-side same-named attribute in this rule.\n"
                 );
          else
          fprintf(stderr,
              "  too many opposite-side same-named attributes in this rule.\n"
                 );
       if (symPos == 0)
          {fprintf(stderr,"  note @autosyn at line %d\n\n",
                   homeSym->sortAAList[attrbNum].autoDef.autoSynLineno 
                  );
          }
          else
          {fprintf(stderr,"  note @autoinh at line %d\n\n",
                   homeSym->sortAAList[attrbNum].autoDef.autoInhLineno 
                  );
          }
       return; 
      } 

   if (warning)
      {ywarning("missing attribute definition for\n");
       fprintf(stderr," %s %s.%s%d.\n",
               homeSym->lexeme,
               cp,
               " position: ",
               symPos
              );
       if (symPos == 0)
          {fprintf(stderr,
               "  supplying definition by virtue of @autosyn at line %d\n\n",
               homeSym->sortAAList[attrbNum].autoDef.autoSynLineno 
                  );
          }
          else
          {fprintf(stderr,
               "  supplying definition by virtue of @autoinh at line %d\n\n",
               homeSym->sortAAList[attrbNum].autoDef.autoInhLineno 
                  );
          }
      }

   putAttrbNumPairInRefSegBuffer(symPos,attrbNum); 
   stringOut(" = ",rsB);
   memberDepend(symPos,attrbNum,1,1);

   putAttrbNumPairInRefSegBuffer(spTemp,anTemp);
   stringOut(";\n",rsB);
   memberDepend(spTemp,anTemp,0,1);

   processAdepSpec();
   
   /* reset flag for processing the next rule */
   markOrCheckAttrbOccrDefd(symPos,attrbNum,1,0); 
  }


 
static int startSymMarkedSyn = 0;  

/* consistency and completeness check for one rule */
/* The calls markOrCheckAttrbOccrDefd(i,j,1,0) read whether instances
 * are defined in the present attribute reference section, then reset the data
 * structures they have read so that the data structures are ready for
 * processing the next attribute reference section.  Each call tests for 
 * presence of an explicit definition (as opposed to a copy rule generated 
 * automatically with @autosyn or @autoinh).
 */
void checkAttrbsSynOrInh() 
  {int i,j,nA,defdInThisProd,inh,RHS;
   struct gSym *pSym; 

   for (i=0; i<prodBufferPointer2; i++) 
       {RHS = i; 
        pSym = &(gSymTable[prodBuffer2[i].gSymTabInd]);   
        nA = pSym->nAttrbs;

        if (!RHS && !startSymMarkedSyn && (pSym->lexeme == startSymLexeme))
           {pSym->fileOfFirstOccr = inFileStr;
            pSym->lineOfFirstOccr = *plineno;
            for (j=0;j<nA;j++) 
                {if (pSym->sortAAList[j].autoDef.autoInhLineno != -1)
                    {yerror("@autoinh declared for attribute of start symbol:");
                     fprintf(stderr,"\n  %s %s near line %d.\n\n",
                             pSym->lexeme,
                             pSym->sortAAList[j].id,
                             pSym->sortAAList[j].autoDef.autoInhLineno
                            );
                    }
                 pSym->symAAList[j].IorSknown = 1; 
                 pSym->symAAList[j].InotS = 0; 
                } 
            startSymMarkedSyn = 1; 
           }

        if (pSym->lineOfFirstOccr == -1) 
           {pSym->fileOfFirstOccr = inFileStr;
            pSym->lineOfFirstOccr = *plineno;
            for (j=0;j<nA;j++) 
                {if (!pSym->symAAList[j].IorSknown) 
                    {pSym->symAAList[j].IorSknown = 1; 
                     defdInThisProd = markOrCheckAttrbOccrDefd(i,j,0,DONTCARE); 
                     if ((defdInThisProd && RHS) || (!defdInThisProd && !RHS))
                        pSym->symAAList[j].InotS = 1; 
                        else
                        pSym->symAAList[j].InotS = 0; 
                    }
                } 
           }

        for (j=0;j<nA;j++) 
            {defdInThisProd = markOrCheckAttrbOccrDefd(i,j,1,0); 
             inh = pSym->symAAList[j].InotS; 

             if (defdInThisProd) 
                {if (!RHS && inh)  
                    {if (pSym->sortAAList[j].autoDef.autoInhLineno != -1)
                        {yerror("@autoinh declaration near line ");
                         fprintf(stderr,"%d.\n",
                                 pSym->sortAAList[j].autoDef.autoInhLineno 
                                ); 
                        }
                        else
                        {yerror("attribute is inherited in the rule\n"); 
                         fprintf(stderr,"%s%d of %s.\n",
                                 "  that ends near line ",
                                 pSym->lineOfFirstOccr,  
                                 pSym->fileOfFirstOccr   
                                ); 
                        }
                     fprintf(stderr,"%s     %s   %s\n\n",
                             "  but synthesized on LHS of this rule. ",
                             pSym->lexeme,
                             pSym->sortAAList[j].id
                            ); 
                    } 
                 if (RHS && !inh)  
                    {if (pSym->sortAAList[j].autoDef.autoSynLineno != -1)
                        {yerror("@autosyn declaration near line ");
                         fprintf(stderr,"%d.\n",
                                 pSym->sortAAList[j].autoDef.autoSynLineno 
                                ); 
                        }
                        else
                        {yerror("attribute is synthesized in the rule\n"); 
                         fprintf(stderr,"%s%d of %s.\n",
                                 "  that ends near line ",
                                 pSym->lineOfFirstOccr,  
                                 pSym->fileOfFirstOccr  
                                ); 
                        }
                     fprintf(stderr,"%s%d%s     %s   %s\n\n",
                             "  but inherited at position ",
                             i, 
                             " of this rule.", 
                             pSym->lexeme,
                             pSym->sortAAList[j].id
                            ); 
                    } 
                }  
                else 
                {if (!RHS && !inh)  
                    {if (pSym->sortAAList[j].autoDef.autoSynLineno != -1)
                        genAutoDef(i,j,pSym->sortAAList[j].autoDef.autoWarn); 
                        else
                        {yerror("attribute is synthesized in the rule\n"); 
                         fprintf(stderr,"%s%d of %s.\n%s     %s   %s\n\n",
                                 "  that ends near line ", 
                                 pSym->lineOfFirstOccr,  
                                 pSym->fileOfFirstOccr,  
                                 "  but undefined for LHS in this rule.  ",
                                 pSym->lexeme,
                                 pSym->sortAAList[j].id
                               ); 
                        } 
                    } 
                 if (RHS && inh)  
                    {if (pSym->sortAAList[j].autoDef.autoInhLineno != -1)
                        genAutoDef(i,j,pSym->sortAAList[j].autoDef.autoWarn); 
                        else
                        {yerror("attribute is inherited in the rule\n"); 
                         fprintf(stderr,"%s%d of %s.\n%s%d%s     %s   %s\n\n",
                                 "  that ends near line ", 
                                 pSym->lineOfFirstOccr,  
                                 pSym->fileOfFirstOccr,  
                                 "  but undefined at position ",
                                 i, 
                                 " in this rule.", 
                                 pSym->lexeme,
                                 pSym->sortAAList[j].id
                                ); 
                        } 
                    } 
                } /* else */  
            } /* for j */ 
       } /* for i */  
  } 



/* put synthesized attributes of tokens in the ready set (queue) */ 
static void enqueueSynAttrbsOfTerms()  
  {int i,j; 
   struct gSym *pSym; 

   for (i=1; i<prodBufferPointer2; i++) 
       {pSym = &(gSymTable[prodBuffer2[i].gSymTabInd]);  
        for (j=0;j<pSym->nAttrbs;j++) 
            {if ((!(pSym->symAAList[j].InotS)) && (pSym->symNum > 0)) 
                {ldgTopSortQ[++ldgTopSortQrear].symPos = i;  
                 ldgTopSortQ[ldgTopSortQrear].attrbNum = j; 
                }  
            } /* for j */  
       } /* for i */ 
  } 
 


/* the static part of the topological sort. 
   outputs semantic actions into the yacc actions or the big nested 
   switch statement in yyySolveAndSignal().
 */
void ldgTopSort() 
  {int i,j,nA;
   long nextAN; 
   struct attrbOccr aoDum;
   struct ldgAdjListHeads *pHead; 
   static long entOccrSeqLoc; 
   long entOccrSeqLocHold; 
   struct gSym *pSym; 
/*
fprintf(stderr,"%d: \n",prodNumSeq-1);
 */
   enqueueSynAttrbsOfTerms(); 
   while (ldgTopSortQfront <= ldgTopSortQrear) 
     {aoDum=ldgTopSortQ[ldgTopSortQfront++]; 
      pHead = &(ldgALhead[ldgALheadInd[aoDum.symPos]+aoDum.attrbNum]); 
/*
fprintf(stderr,"\n    %s.%s\n",
        gSymTable[prodBuffer2[aoDum.symPos].gSymTabInd].lexeme,
        gSymTable[prodBuffer2[aoDum.symPos].gSymTabInd]
                 .sortAAList[aoDum.attrbNum].id
       );
 */ 
      if (pHead->refTextStart <= pHead->refTextEnd) 
         {translateAndOutputRefSeg(imm,&(pHead->refTextStart),pHead->refTextEnd,
                                   DONTCARE,DONTCARE, 
                                   yoxOutG 
                                  );
         } 
      nextAN = pHead->entList;  
      while (nextAN != 0) 
        {aoDum = ldgNodeStg[nextAN].node; 
         if (!(--(ldgALhead[ldgALheadInd[aoDum.symPos]+
                            aoDum.attrbNum
                           ].eeCount   
                 )
              ) 
            ) 
            ldgTopSortQ[++ldgTopSortQrear] = aoDum;  
         nextAN = ldgNodeStg[nextAN].next;  
        }
     }

/* separate the part above this comment and the part below into two separate
   routines.  The above is truly the sort. 
*/
 
   fprintf(temp1Out,
           "case %d:  /***yacc rule %d***/\n  switch (yyyws) {\n",
           prodNumSeq-1,prodNumSeq-1
          ); 
   for (i=0; i<prodBufferPointer2; i++) 
     {pSym = &(gSymTable[prodBuffer2[i].gSymTabInd]);   
      nA = pSym->nAttrbs; 
      if (nA) fprintf(temp1Out,"  case %d:  /**/\n",i); 
      if (nA) fprintf(temp1Out,"    switch (yyywa) {\n"); 
      for (j=0;j<nA;j++) 
        {pHead = &(ldgALhead[ldgALheadInd[i]+j]); 
         entOccrSeqLocHold = entOccrSeqLoc;  
         if (pHead->eeCount != 0)
            {  
             nextAN = pHead->entList; 
             while (nextAN != 0) 
               {entOccrSeqLoc++;  
                nextAN = ldgNodeStg[nextAN].next; 
               } 
            } 
         if (pHead->eeCount > 0) 
            {fprintf(temp1Out,"    case %d:\n",j ); 
             if (pHead->refTextStart <= pHead->refTextEnd) 
                {
                 translateAndOutputRefSeg(decor, &(pHead->refTextStart),
                                          pHead->refTextEnd,
                                          i,j,temp1Out  
                                         ); 
                }
             if (entOccrSeqLocHold < entOccrSeqLoc) 
                fprintf(temp1Out,
                        "    yyySignalEnts(yyyRefN,yyyEntL+%u,yyyEntL+%u);\n",
                        entOccrSeqLocHold*2, 
                        entOccrSeqLoc*2 
                       );  
             if (pHead->hasYaccPvarRef) 
                {yerror("decoration-time reference to\n     "); 
                 fprintf(stderr,"Yacc pseudo-variable\n");
                }
             if (pHead->inhFellowEnt && pHead->synFellowEnt) 
                {yerror("attribute reference segment with both\n     "); 
                 fprintf(stderr,"inherited and synthesized dependents\n"); 
                }
             fprintf(temp1Out,"    break;\n"); 
            } 
         pHead->synFellowEnt = 0;  
         pHead->inhFellowEnt = 0;  
         pHead->hasYaccPvarRef = 0; 
        } /* for j */  
      if (nA) fprintf(temp1Out,"    }"); 
      if (nA) fprintf(temp1Out,"\n  break;\n"); 
     } /* for i */ 
   fprintf(temp1Out,"  }\nbreak;\n"); 
  } 
 


void printProd()
  {gSymType pSym;
   int k;

   if (((prodNumSeq-1-1) % 10) == 0) fprintf(tempProdsIndFile,"\n");
   fprintf(tempProdsIndFile,"%4.1d,",gsOccurSeq);

   for (k=0;k<prodBufferPointer2;k++)
       {pSym = gSymTable + prodBuffer2[k].gSymTabInd;
        if (((gsOccurSeq+k) % 5) == 0) fprintf(tempProdsNumsFile,"\n");
        fprintf(tempProdsNumsFile,"{%4.1d,%4.1d},",
                stringIndexLookup(pSym->lexeme),
                pSym->typeNum
               );
       }
   gsOccurSeq += prodBufferPointer2;
  }



#if G_DEBUG 
void showDepGraph(fp)
  FILE *fp;  
  {int i,j; 
   long nextAN; 
   struct attrbOccr aoDum;
   int nA;  

   fprintf(fp,"***************  dependency graph for production %u:", 
              prodNumSeq-1 
          );  
   for (i=0; i<prodBufferPointer2; i++) 
       {nA = gSymTable[prodBuffer2[i].gSymTabInd].nAttrbs;   
        for (j=0;j<nA;j++) 
            {fprintf(fp,"\n\ndependees  of %u %u:  ",i,j);  
             nextAN = ldgALhead[ldgALheadInd[i]+j].eeList;  
             while (nextAN != 0) 
               {aoDum = ldgNodeStg[nextAN].node; 
                fprintf(fp,"    %u %u",aoDum.symPos,aoDum.attrbNum);  
                nextAN = ldgNodeStg[nextAN].next;  
               }
             fprintf(fp,"\ndependents of %u %u:  ",i,j);  
             nextAN = ldgALhead[ldgALheadInd[i]+j].entList;  
             while (nextAN != 0) 
               {aoDum = ldgNodeStg[nextAN].node; 
                fprintf(fp,"    %u %u",aoDum.symPos,aoDum.attrbNum);  
                nextAN = ldgNodeStg[nextAN].next;  
               }
             fprintf(fp,"\n");  
             fprintf(fp,"refTextStart == %d    refTextEnd == %d\n",
                        ldgALhead[ldgALheadInd[i]+j].refTextStart,  
                        ldgALhead[ldgALheadInd[i]+j].refTextEnd  
                    );  
            } /* for j */  
       } /* for i */ 
   fprintf(fp,"\n\n\n"); 
  } 



/* for debugging the grammar-symbol table */
void showGsymInfo(symPos) 
  int symPos; 
  {gSymType pSym;
   int j;  

   pSym = gSymTable + prodBuffer2[symPos].gSymTabInd;   
   fprintf(stderr,"     symbol Number: "); 
   fprintf(stderr,"%d\n",pSym->symNum); 
   fprintf(stderr,"     type :         "); 
   fprintf(stderr,"%d\n",pSym->typeNum); 
   fprintf(stderr,"     lexeme:        "); 
   fprintf(stderr,"%s\n",pSym->lexeme); 
   fprintf(stderr,"     number of attributes: ");
   fprintf(stderr,"%d\n",pSym->nAttrbs);  
   for (j=0;j<pSym->nAttrbs;j++) 
       {fprintf(stderr,"          attribute %2d: ",j); 
        fprintf(stderr,"%s",pSym->sortAAList[j].id);
        if (pSym->symAAList[j].IorSknown) 
           {fprintf(stderr,"  line of first definition: "); 
            fprintf(stderr,"%d ",pSym->lineOfFirstOccr); 
            if (pSym->symAAList[j].InotS) 
               fprintf(stderr,"  inherited\n");  
               else 
               fprintf(stderr,"  synthesized\n");
           } 
           else 
           fprintf(stderr," *neither syn nor inh \n");  
       } 
  } 



void showSymInfoForProd() 
  {int k; 

   fprintf(stderr,"\nSymbol information for production %d : \n",
           prodNumSeq - 1
          ); 
   for (k=0;k<prodBufferPointer2;k++) 
       {fprintf(stderr,"Position: %d\n",k); 
        showGsymInfo(k);
       } 
   fprintf(stderr,"\n\n\n");
  } 



void othershowGsymInfo(fp)
  FILE *fp;  
  {int i,j; 
   int nA;  
   struct gSym *pSym;

   fprintf(fp,"+++++++++++++++++symbol info for production %u:\n", 
              prodNumSeq-1 
          );  
   for (i=0; i<prodBufferPointer2; i++) 
       {pSym = &(gSymTable[prodBuffer2[i].gSymTabInd]);   
        nA = pSym->nAttrbs;
        for (j=0;j<nA;j++) 
            {fprintf(fp,"%s  %s  first defined at line %d. InotS == %d\n",
                        pSym->lexeme,
                        pSym->sortAAList[j].id,
                        pSym->lineOfFirstOccr,
                        pSym->symAAList[j].InotS
                    );
            } /* for j */  
       } /* for i */ 
   fprintf(fp,"\n\n\n\n"); 
  } 

#endif 



void flushAll() 
  {int i; 

   fflush(yoxOutG);  
   for (i=0;i<nLfiles;i++) fflush(Lfile[i].outPtr);  
   fflush(yoxOutH);  
   fflush(temp1Out);  
   fflush(temp2Out);  
   fflush(temp3Out);  
   fflush(temp4Out);  
   fflush(temp5Out);  
   fflush(temp6Out);  
   fflush(temp7Out);  
   fflush(tempTravOut);  
  } 
 
 

static int ldgCDcount; 



/* Returns false if pred is true for some attribute occurrence 
 * in the graph closure of AO.  graph is either dependEE or dependENT. 
 * Returns true  if pred is false for every attribute occurrence 
 * in the graph closure of AO.   
 *
 * In other words, returns true exactly when AO's graph closure 
 * is disjoint from the set of occurrences that satisfy pred. 
 *
 * Used for computing pruning conditions.
 */
static int ldgClosureDisjoint(AO,pred,graph)
  struct attrbOccr AO;
  int (*pred)();
  enum ENTorEE graph;
  {long nextAN;

   if (ldgCDcount++ > 200) 
      {ywarning("rule probably has cycle.\n");  
       return 0;
      }
   if ((*pred)(AO)) return 0; 
   nextAN = (graph == EE)?
            ldgALhead[ldgALheadInd[AO.symPos] + AO.attrbNum].eeList:
            ldgALhead[ldgALheadInd[AO.symPos] + AO.attrbNum].entList;
   while (nextAN != 0)  
     {if (!ldgClosureDisjoint(ldgNodeStg[nextAN].node,pred,graph)) 
         return 0;   
      nextAN = ldgNodeStg[nextAN].next;  
     } 
   return 1;
  }



static int isLHSinh(AO)
  struct attrbOccr AO;
  {return (!(AO.symPos)
           &&
           (gSymTable[prodBuffer2[AO.symPos].gSymTabInd].
               symAAList[AO.attrbNum].InotS
           )
          );
  }



static int areAllRHSoccrsSolvable()
  {int i,j,nA; 
   struct attrbOccr AO;
   
   ldgCDcount = 0; 
   for (i=1; i<prodBufferPointer2; i++) 
      {AO.symPos = i;
       nA = gSymTable[prodBuffer2[i].gSymTabInd].nAttrbs;   
       for (j=0;j<nA;j++) 
          {AO.attrbNum = j;
           if (!ldgClosureDisjoint(AO,isLHSinh,EE))
              return 0; 
          } /* for j */  
      } /* for i */ 
   return 1; 
  } 



static int onRHS(AO)
  struct attrbOccr AO;
  {return (AO.symPos > 0);
  }



static int oneSynEELevel() 
  {struct attrbOccr AO;
   struct gSym dumSym;
   int j,nA;

   ldgCDcount = 0; 
   dumSym = gSymTable[prodBuffer2[0].gSymTabInd];   
   nA = dumSym.nAttrbs;   
   AO.symPos = 0; 
   for (j=0;j<nA;j++) 
       {AO.attrbNum = j; 
        if (!(dumSym.symAAList[j].InotS))
           if (!ldgClosureDisjoint(AO,isLHSinh,EE)
               &&
               !ldgClosureDisjoint(AO,onRHS,EE)
              )
              return 0;
       } /* for j */  
   return 1;
  }



static int allRHSoccrsSolvable;
static int singleLevelSynEE;

void doPruneCondChecks()
  { 
   allRHSoccrsSolvable = areAllRHSoccrsSolvable();  
   singleLevelSynEE = oneSynEELevel(); 
  }



/* sticks node-generation code in yacc actions */
void printIntNodeGenInvocation() 
  {fprintf(yoxOutG,
           "\nyyyRSU(%d,%d,%d,%d);\n",
           prodNumSeq-1,prodBufferPointer2-1,
           gSymTable[prodBuffer2[0].gSymTabInd].nAttrbs,
           gSymTable[prodBuffer2[0].gSymTabInd].typeNum   
          );
   if (treeShow || xTreeShow)
      fprintf(yoxOutG,"yyyMakeINIOpreReduce(\"%s\");\n",
              gSymTable[prodBuffer2[0].gSymTabInd].lexeme
             );  
   fprintf(yoxOutG,"yyyGenIntNode();\n");
   if (treeShow)
      {fprintf(yoxOutG,"yyyMakeINIOpostReduce();");
       fprintf(yoxOutG,"yyyCheckBreakpoints(0);\n");
      }
   if (xTreeShow)
      {fprintf(yoxOutG,"yyyMakeINIOpostReduce();\n");
      }
  } 



/* output the dependee-count initialization lists and indices into 
   the space of those lists
 */
void conveyLocalDepGraphInfo() 
  {int i,j,nA,nextAN; 
   long eeCountInitCurrentProd;  
   struct ldgAdjListHeads *pHead;  
   static int k1; 
   static int k2; 
   static long GSoccrSeq;
   static long entOccrSeqHold;  

   eeCountInitCurrentProd = eeCountInitSeq; 
   indToEntsByProdNum[prodNumSeq-1] = GSoccrSeq; 
   pHead = ldgALhead; 
   for (i=0; i<prodBufferPointer2; i++) 
       {fprintf(temp5Out,"%u,",attrbOccrSeq); k1++;  
        if (!(k1%12)) fprintf(temp5Out,"\n");   
        GSoccrSeq++;   
        nA = ldgALheadInd[i+1] - ldgALheadInd[i];   
        for (j=0;j<nA;j++) 
            {if (pHead->eeCount > RCmax) RCmax = pHead->eeCount; 
             if (pHead->eeCount != -1)  
                {if (i == 0) 
                    {if (permitCtimeCircTest) 
                        {fprintf(temp2Out,"yyyR,"); 
                         fprintf(temp2Out,"%u,%u, ",j,pHead->eeCount);
                         eeCountInitSeq++; 
                        } 
                    } 
                    else     
                    {fprintf(temp2Out,"%u,",i-1); 
                     fprintf(temp2Out,"%u,%u, ",j,pHead->eeCount);
                     eeCountInitSeq++; 
                    } 
                 if (!(eeCountInitSeq%6)) fprintf(temp2Out,"\n");  
                 pHead->eeList = 0; 
                }
             entOccrSeqHold = entOccrSeq; 
             fprintf(temp4Out,"%u,",entOccrSeq*2); k2++;   
             if (!(k2%8)) fprintf(temp4Out,"\n");  
             attrbOccrSeq++; 
             if (pHead->eeCount != 0) 
                {nextAN = pHead->entList; 
                 while (nextAN != 0) 
                   {fprintf(temp3Out,"%u,%u,",ldgNodeStg[nextAN].node.symPos, 
                                              ldgNodeStg[nextAN].node.attrbNum 
                           );   
                    entOccrSeq++;  
                    if (!(entOccrSeq%8)) fprintf(temp3Out,"\n");  
                    nextAN = ldgNodeStg[nextAN].next; 
                   } 
                }  
             fprintf(temp6Out,"%u,",entOccrSeq-entOccrSeqHold);  
             if (!(k2%8)) fprintf(temp6Out,"\n");  
             pHead->eeCount = -1;  
             pHead->entList = 0; 
             pHead++; 
            } /* for j */  
       } /* for i */ 
   fprintf(yoxOutG,"yyyAdjustINRC(yyyRCIL+%u,yyyRCIL+%u);",
           eeCountInitCurrentProd*3,
           eeCountInitSeq*3 
          );
   {int prune = 0; 
    if ((prodBufferPointer2 > 1) 
        &&
        allRHSoccrsSolvable  
        &&
        singleLevelSynEE
       )  
       {if (!suppressPruning)
           {fprintf(yoxOutG,"yyyPrune(%d);",prodNumSeq-1);
            prune = 1;
           }
           else
           {if (pruneRequested)
               {fprintf(yoxOutG,"yyyPrune(%d);",prodNumSeq-1);
                prune = 1;
               }
               else
               fprintf(yoxOutG,"/*yyyPrune(%d);*/",prodNumSeq-1);
           }
       }
       else 
       {if (pruneRequested) 
           ywarning("warning: pruning requested but not permitted. ignored.\n");
       } 
    if (!prune && decorationRequested) 
       fprintf(yoxOutG,"yyyDecorate();");  
   }
  } 

 

/* writes the list of solved synthesized attributes of each token */
void installLeafRefCountInitList() 
  {struct gSym *pSym; 
   int i,leafRCIShold; 
   
   if (!permitCtimeCircTest) return;  
   leafRCIShold = leafRefCountInitSeq;  
   pSym = &(gSymTable[prodBuffer2[0].gSymTabInd]);  
   if (leafRefCountInitIndex[pSym->symNum] == -1)  
      {leafRefCountInitIndex[pSym->symNum] = leafRefCountInitSeq;    
       for (i=0; i<pSym->nAttrbs; i++)
           { 
            if (!pSym->symAAList[i].InotS) 
               {
                fprintf(temp7Out,"%u,",i); 
                leafRefCountInitSeq++; 
                if (!(leafRefCountInitSeq%20)) fprintf(temp7Out,"\n");  
               }  
           }   
       leafRefCountListLength[pSym->symNum] = 
                   leafRefCountInitSeq - leafRCIShold;    
      }
   fprintf(Lfile[currentLfile].outPtr,
           "yyyGenLeaf(%d,%d,yyyLRCIL+%u,yyyLRCIL+%u);", 
           gSymTable[prodBuffer2[0].gSymTabInd].nAttrbs,   
           gSymTable[prodBuffer2[0].gSymTabInd].typeNum, 
           leafRefCountInitIndex[pSym->symNum], 
           leafRefCountInitIndex[pSym->symNum] +  
              leafRefCountListLength[pSym->symNum]
          );   
   if (treeShow || xTreeShow)
/*      fprintf(Lfile[currentLfile].outPtr,
              "yyyMakeLNIOlookahead(\"%s\");",
              (gSymTable[prodBuffer2[0].gSymTabInd].lexeme == dumNodeSym)
              ?
              "?"
              :
              strTrans(gSymTable[prodBuffer2[0].gSymTabInd].lexeme)
             );
*/
      {if (gSymTable[prodBuffer2[0].gSymTabInd].lexeme == dumNodeSym)
          fprintf(Lfile[currentLfile].outPtr,
              "yyyMakeLNIOlookahead(strcpy((char *)malloc(yyleng+1),yytext));"
                 );
          else
          fprintf(Lfile[currentLfile].outPtr,
              "yyyMakeLNIOlookahead(\"%s\");",
              strTrans(gSymTable[prodBuffer2[0].gSymTabInd].lexeme)
                 );
      }
  } 



@EOF
set `sum $sumopt <oxDistG1.04/source/depGs.c`; if test $1 -ne 60709
then
	echo ERROR: oxDistG1.04/source/depGs.c checksum is $1 should be 60709
fi
set `wc -lwc <oxDistG1.04/source/depGs.c`
if test $1$2$3 != 1249332740635
then
	echo ERROR: wc results of oxDistG1.04/source/depGs.c are $* should be 1249 3327 40635
fi

chmod 755 oxDistG1.04/source/depGs.c

if test -f oxDistG1.04/source/depGs.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/depGs.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/depGs.h
	if test -f oxDistG1.04/source/depGs.h
	then
		echo Error: could not remove oxDistG1.04/source/depGs.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/depGs.h
cat >oxDistG1.04/source/depGs.h <<'@EOF'
/* $Header: depGs.h,v 5.10 94/04/16 20:24:15 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

extern long *indToEntsByProdNum; 
extern long maxNterms; 
extern long *leafRefCountInitIndex;  
extern long *leafRefCountListLength;  
extern long eeCountInitSeq;  
extern long attrbOccrSeq;  
extern long leafRefCountInitSeq; 
extern long entOccrSeq; 
extern long gsOccurSeq;

extern int permitCtimeCircTest; 
extern int maxNentsPerDepSpec; 
extern int maxNeesPerDepSpec;
 
extern int hasYaccPvarRefGlob; 

extern int maxNattrbOccrsPerProd;  
extern int ldgNodeStgSize;  

extern int pruneRequested; 
extern int decorationRequested; 
 
extern void prepareDataStructures2();


extern int memberDepend();

extern void initLDG(); 
extern void processAdepSpec();

extern void checkAttrbsSynOrInh();

extern void ldgTopSort();

/* debugging routines */
extern void showDepGraph();
extern void showGsymInfo();
extern void showSymInfoForProd();
extern void printProd();
extern void othershowGsymInfo();
extern void flushAll();

extern void doPruneCondChecks();
extern void printIntNodeGenInvocation();
extern void conveyLocalDepGraphInfo();
extern void installLeafRefCountInitList();

@EOF
set `sum $sumopt <oxDistG1.04/source/depGs.h`; if test $1 -ne 28116
then
	echo ERROR: oxDistG1.04/source/depGs.h checksum is $1 should be 28116
fi
set `wc -lwc <oxDistG1.04/source/depGs.h`
if test $1$2$3 != 1084853464
then
	echo ERROR: wc results of oxDistG1.04/source/depGs.h are $* should be 108 485 3464
fi

chmod 755 oxDistG1.04/source/depGs.h

if test -f oxDistG1.04/source/glob.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/glob.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/glob.h
	if test -f oxDistG1.04/source/glob.h
	then
		echo Error: could not remove oxDistG1.04/source/glob.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/glob.h
cat >oxDistG1.04/source/glob.h <<'@EOF'
/* $Header: glob.h,v 5.10 94/04/16 20:24:17 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <stdio.h>

#define DONTCARE          0 

#define augmentationNonterminal 0  
#define augNstr "yyyAugNonterm" 
#define augTstr "yyyAugTerm"  

#define tempTravFileID "@temp.~trav~" 

#define outG          1 
#define outL          2  
#define outT1         3  
#define outGandL      4 
#define LA1          11   
#define LA2          12   
#define rsB          21 
#define outMB        30
#define outTrv       40
#define SO           42
#define SE           43
#define nowhere      45


typedef unsigned short prodNumType; 

enum instRefType {imm,decor,trav};
enum ENTorEE {ENT,EE};  /* dependent or dependee */
enum SYNorINH {SYN,INH}; /* synthesized or inherited */

struct autoSynOrInh {int autoSynLineno;
                     int autoInhLineno;
                     char autoWarn;
                    };

struct sortAttrbAttrbs {char *id;  
                        struct autoSynOrInh autoDef;
                       };  
                       

struct symAttrbAttrbs {unsigned char IorSknown,InotS;
                      };  
                       

/* There is an array of struct symAttrbAttrbs for each symbol.  There is
 * an array of struct sortAttrbAttrbs for each sort, pointed to by each
 * struct gSym of that sort.  There are zero to many struct gSyms of each
 * sort.  typeNum is the serial number of the sort.
 */
typedef struct gSym  
        {int symNum; 
         char *lexeme; 
         short nAttrbs; 
         int typeNum;  
         int lineOfFirstOccr;  
         char *fileOfFirstOccr; 
         struct sortAttrbAttrbs *sortAAList;  
         struct symAttrbAttrbs *symAAList;  
        } 
        *gSymType; 

 
struct pb2 {char *lexeme; 
            int gSymTabInd; 
           };  

struct attrbOccr {short symPos,attrbNum;
                 }; 


/* error messages */  
#define dupStart "start symbol defined more than once" 
#define InvLitChar "unknown or forbidden literal character"  
#define tokOnLeft "token seen on left hand side of a rule" 


/* Each struct ldgAdjListHeads corresponds to an attribute occurrence in 
   the rule being parsed.  
   The following are predicates on the attribute occurrences of the rule: 
 
   defdThisProd:    is defined in this rule?  i.e., is an output occurrence? 
   hasYaccPvarRef:  definition has a reference to a Yacc pseudovariable? 
   inhFellowEnt:    has a fellow dependent that is inherited? 
   synFellowEnt:    has a fellow dependent that is synthesized? 
   (fellow dependents are possible using the explicit mode annunciator @e)
 */
struct ldgAdjListHeads {unsigned char defdThisProd  ;  
                        unsigned char hasYaccPvarRef;  
                        unsigned char inhFellowEnt  ;  
                        unsigned char synFellowEnt  ;  
                        long refTextStart,refTextEnd; 
                        long entList;  /* the occurrence's dependents */ 
                        long eeList;   /* the occurrence's dependees  */ 
                        short eeCount; /* the occurrence's dependee count */
                       }; 

struct ldgNodeStgType {struct attrbOccr node; 
                       long next; 
                      }; 

struct travSegBuf {long orderRevCondStartPtr;
                   long orderRevCondStopPtr;
                   long actionStartPtr;
                   long actionStopPtr;
                   struct travSegBuf *next;
                  };

struct trav {char *id;
             unsigned char RL;
             unsigned char LR;
             unsigned char PRE;
             unsigned char POST;
             unsigned char DA;
             long dirRevCondStartPtr;
             long dirRevCondStopPtr;
             int nActions;
             struct travSegBuf *TSBlist;
            };
@EOF
set `sum $sumopt <oxDistG1.04/source/glob.h`; if test $1 -ne 53780
then
	echo ERROR: oxDistG1.04/source/glob.h checksum is $1 should be 53780
fi
set `wc -lwc <oxDistG1.04/source/glob.h`
if test $1$2$3 != 1797636126
then
	echo ERROR: wc results of oxDistG1.04/source/glob.h are $* should be 179 763 6126
fi

chmod 755 oxDistG1.04/source/glob.h

if test -f oxDistG1.04/source/joinTabs.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/joinTabs.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/joinTabs.c
	if test -f oxDistG1.04/source/joinTabs.c
	then
		echo Error: could not remove oxDistG1.04/source/joinTabs.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/joinTabs.c
cat >oxDistG1.04/source/joinTabs.c <<'@EOF'
/* $Header: joinTabs.c,v 5.10 94/04/16 20:24:19 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <stdio.h> 
#include <string.h>

#include "glob.h" 
#include "opts.h" 
#include "depGs.h"
#include "symTrans.h"
#include "ctc.h"
#include "treeShow.h"
#include "xtreeshw.h"

#define temp1FileID "@temp1.~tab~.c" 
#define temp2FileID "@temp2.~tab~.c" 
#define temp3FileID "@temp3.~tab~.c" 
#define temp4FileID "@temp4.~tab~.c" 
#define temp5FileID "@temp5.~tab~.c" 
#define temp6FileID "@temp6.~tab~.c" 
#define temp7FileID "@temp7.~tab~.c" 
#define temp8FileID "@temp8.~tab~.c" 
#define tempTrashFileID "@temp.~trash~"

#define tempSortIndFileID "@temp9.~tab~.c"
#define tempSortNumsFileID "@temp10.~tab~.c"
#define tempProdsIndFileID "@temp11.~tab~.c"
#define tempProdsNumsFileID "@temp12.~tab~.c"
#define tempStringTabFileID "@temp13.~tab~.c"


FILE *temp1Out; 
FILE *temp2Out; 
FILE *temp3Out; 
FILE *temp4Out; 
FILE *temp5Out; 
FILE *temp6Out; 
FILE *temp7Out; 
FILE *temp8Out; 
FILE *tempTrashOut;
FILE *tempTravOut;
FILE *tempSortIndFile;
FILE *tempSortNumsFile;
FILE *tempProdsIndFile;
FILE *tempProdsNumsFile;
FILE *tempStringTabFile;


#define xferBufSize 1024 
static char xferBuf[xferBufSize];



void openTempFiles()
  {temp1Out=sfopen(temp1FileID,"w"); 
   temp2Out=sfopen(temp2FileID,"w"); 
   temp3Out=sfopen(temp3FileID,"w"); 
   temp4Out=sfopen(temp4FileID,"w"); 
   temp5Out=sfopen(temp5FileID,"w"); 
   temp6Out=sfopen(temp6FileID,"w"); 
   temp7Out=sfopen(temp7FileID,"w"); 
   temp8Out=sfopen(temp8FileID,"w"); 
   tempTrashOut=sfopen(tempTrashFileID,"w"); 
   tempTravOut=sfopen(tempTravFileID,"w"); 
   tempSortIndFile=sfopen(tempSortIndFileID,"w");
   tempSortNumsFile=sfopen(tempSortNumsFileID,"w");
   tempProdsIndFile=sfopen(tempProdsIndFileID,"w");
   tempProdsNumsFile=sfopen(tempProdsNumsFileID,"w");
   tempStringTabFile=sfopen(tempStringTabFileID,"w");
  }



void erasf(str) 
  char *str; 
  {char dummy[64];  

   strcpy(dummy,"rm "); 
   if (system(strcat(dummy,str))) 
      fprintf(stderr,"ox: system error removing %s",str); 
  } 

 

void rmTempFiles() 
  {fclose(temp1Out); 
   fclose(temp2Out); 
   fclose(temp3Out); 
   fclose(temp4Out); 
   fclose(temp5Out); 
   fclose(temp6Out); 
   fclose(temp7Out); 
   fclose(temp8Out); 
   fclose(tempTrashOut); 
   fclose(tempTravOut); 
   fclose(tempSortIndFile);
   fclose(tempSortNumsFile);
   fclose(tempProdsIndFile);
   fclose(tempProdsNumsFile);
   fclose(tempStringTabFile);
   erasf(temp1FileID);    
   erasf(temp2FileID);    
   erasf(temp3FileID);    
   erasf(temp4FileID);    
   erasf(temp5FileID);    
   erasf(temp6FileID);    
   erasf(temp7FileID);    
   erasf(temp8FileID);    
   erasf(tempTrashFileID);
   erasf(tempTravFileID);
   erasf(tempSortIndFileID);
   erasf(tempSortNumsFileID);
   erasf(tempProdsIndFileID);
   erasf(tempProdsNumsFileID);
   erasf(tempStringTabFileID);
  }



/* Closes an open file, reopens it for reading, copies it to a file 
 * that is already open for writing. 
 */ 
void appendToOutFile(tabFile,tabFileStr,dest) 
  FILE *tabFile,*dest; 
  char *tabFileStr; 
  {long count; 

   fclose(tabFile); 
   tabFile = fopen(tabFileStr,"r"); 
   while (count = fread(xferBuf,sizeof(char),xferBufSize,tabFile))    
      fwrite(xferBuf,sizeof(char),count,dest); 
  } 



void buildCycleFinder(outFile)
  FILE *outFile;
  {
   fprintf(outFile,"\n\n#define yyyLastProdNum %d\n",prodNumSeq-1);
   fprintf(outFile,"\n\n#define yyyNsorts %d\n",structTagNumSeq-1);

   fprintf(outFile,"\n\nint yyyProdsInd[] = {\n   0,");
   appendToOutFile(tempProdsIndFile,tempProdsIndFileID,outFile);
   fprintf(outFile,"\n%4.1d,\n};\n",gsOccurSeq);

   fprintf(outFile,"\n\nint yyyProds[][2] = {");
   appendToOutFile(tempProdsNumsFile,tempProdsNumsFileID,outFile);
   fprintf(outFile,"\n};\n");

   fprintf(outFile,"\n\nint yyySortsInd[] = {\n  0,");
   appendToOutFile(tempSortIndFile,tempSortIndFileID,outFile);
   fprintf(outFile,"\n%3.1d,",attrbDeclAttrbOccurSeq);
   fprintf(outFile,"\n};\n");

   fprintf(outFile,"\n\nint yyySorts[] = {");
   if (structTagNumSeq == 1) fprintf(outFile,"\n  0,");
   appendToOutFile(tempSortNumsFile,tempSortNumsFileID,outFile);
   fprintf(outFile,"\n};\n");

   printStringTab();

   fprintf(outFile,"\n\n\nchar *yyyStringTab[] = {");
   appendToOutFile(tempStringTabFile,tempStringTabFileID,outFile);
   fprintf(outFile,"\n};\n");

   compilerTextCopy7(outFile);
  }




void organizeTables() 
  {int i; 

   compilerTextCopy1(); 
   fprintf(yoxOutG,"\n\n\n\nyyyFT yyyRCIL["); 
   if (eeCountInitSeq) 
      {fprintf(yoxOutG,"] = {\n"); 
       appendToOutFile(temp2Out,temp2FileID,yoxOutG);  
       fprintf(yoxOutG,"\n}"); 
      }  
      else 
      fprintf(yoxOutG,"1]"); 
   fprintf(yoxOutG,";\n"); 

   fprintf(yoxOutG,"\nshort yyyIIIEL[] = {0,\n"); 
   for (i=1;i<prodNumSeq;i++) 
     {fprintf(yoxOutG,"%u,",indToEntsByProdNum[i]);   
      if (!(i%10)) fprintf(yoxOutG,"\n");
     }  
   fprintf(yoxOutG,"\n};\n"); 

   fprintf(yoxOutG,"\nlong yyyIIEL[] = {\n"); 
   appendToOutFile(temp5Out,temp5FileID,yoxOutG);  
   fprintf(yoxOutG,"\n};\n"); 

   fprintf(yoxOutG,"\nlong yyyIEL["); 
   if (attrbOccrSeq) 
      {fprintf(yoxOutG,"] = {\n"); 
       appendToOutFile(temp4Out,temp4FileID,yoxOutG);  
       fprintf(yoxOutG,"%d,",entOccrSeq*2); 
       fprintf(yoxOutG,"\n}"); 
      }
      else 
      fprintf(yoxOutG,"1]"); 
   fprintf(yoxOutG,";\n"); 

   fprintf(yoxOutG,"\nyyyFT yyyEntL["); 
   if (entOccrSeq) 
      {fprintf(yoxOutG,"] = {\n"); 
       appendToOutFile(temp3Out,temp3FileID,yoxOutG);  
       fprintf(yoxOutG,"\n}"); 
      }
      else  
      fprintf(yoxOutG,"1]"); 
   fprintf(yoxOutG,";\n"); 

   compilerTextCopy2(); 

   if (treeShow) outputTreeShowCode();
   if (xTreeShow) outputxTreeShowCode();

   fprintf(yoxOutG,"\n\n\n"); 
   appendToOutFile(temp1Out,temp1FileID,yoxOutG);  
   
   if (permitCtimeCircTest) 
      {
       fprintf(yoxOutG,"\n\n\nyyyWAT yyyLRCIL[%d]",
                       (leafRefCountInitSeq?leafRefCountInitSeq:1)  
              ); 
       if (leafRefCountInitSeq) 
          {fprintf(yoxOutG," = {",termSeq); 
           appendToOutFile(temp7Out,temp7FileID,yoxOutG);  
           fprintf(yoxOutG,"\n}"); 
          } 
       fprintf(yoxOutG,";\n"); 
      }  
   compilerTextCopy3(); 
   buildCycleFinder(yoxOutG);
  } 
  
 
@EOF
set `sum $sumopt <oxDistG1.04/source/joinTabs.c`; if test $1 -ne 8310
then
	echo ERROR: oxDistG1.04/source/joinTabs.c checksum is $1 should be 8310
fi
set `wc -lwc <oxDistG1.04/source/joinTabs.c`
if test $1$2$3 != 3007308642
then
	echo ERROR: wc results of oxDistG1.04/source/joinTabs.c are $* should be 300 730 8642
fi

chmod 755 oxDistG1.04/source/joinTabs.c

if test -f oxDistG1.04/source/joinTabs.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/joinTabs.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/joinTabs.h
	if test -f oxDistG1.04/source/joinTabs.h
	then
		echo Error: could not remove oxDistG1.04/source/joinTabs.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/joinTabs.h
cat >oxDistG1.04/source/joinTabs.h <<'@EOF'
/* $Header: joinTabs.h,v 5.10 94/04/16 20:24:22 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

extern FILE *temp1Out; 
extern FILE *temp2Out; 
extern FILE *temp3Out; 
extern FILE *temp4Out; 
extern FILE *temp5Out; 
extern FILE *temp6Out; 
extern FILE *temp7Out; 
extern FILE *temp8Out; 
extern FILE *tempTrashOut;
extern FILE *tempTravOut;
extern FILE *tempSortIndFile;
extern FILE *tempSortNumsFile;
extern FILE *tempProdsIndFile;
extern FILE *tempProdsNumsFile;
extern FILE *tempStringTabFile;

extern void openTempFiles();


extern void erasf();
extern void rmTempFiles();
extern void appendToOutFile();
void organizeTables();
  
 
@EOF
set `sum $sumopt <oxDistG1.04/source/joinTabs.h`; if test $1 -ne 46775
then
	echo ERROR: oxDistG1.04/source/joinTabs.h checksum is $1 should be 46775
fi
set `wc -lwc <oxDistG1.04/source/joinTabs.h`
if test $1$2$3 != 864412929
then
	echo ERROR: wc results of oxDistG1.04/source/joinTabs.h are $* should be 86 441 2929
fi

chmod 755 oxDistG1.04/source/joinTabs.h

if test -f oxDistG1.04/source/mDeps.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/mDeps.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/mDeps.h
	if test -f oxDistG1.04/source/mDeps.h
	then
		echo Error: could not remove oxDistG1.04/source/mDeps.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/mDeps.h
cat >oxDistG1.04/source/mDeps.h <<'@EOF'
/* $Header: mDeps.h,v 5.10 94/04/16 20:24:24 bischoff Exp $ */ 

/*
 *              copyright (c) 1992, 1993  Kurt M. Bischoff
 *
 * This file confines the hardware and software dependencies of Ox's 
 * source code.  Adapting Ox to your environment may require that this 
 * file be modified.  Users of 64-bit architectures such as DEC Alpha 
 * should read the comment near the definition of ALIGNsIZE.  Others
 * are unlikely to run into any trouble by ignoring this file and  
 * going ahead with `make'ing ox. 
 *
 */


/*  "target machine" as used in this comment means the machine on which the 
 *   generated evaluator is to run. 
 *
 *
 *  ALIGNsIZE should be assigned the smallest integer such that: 
 *
 *      if (n is an address on the target machine and 
 *          (n % ALIGNsIZE == 0)
 *         ) 
 *      then any C structure declared in a program that runs on the 
 *           target machine will satisfy the machines's alignment 
 *           requirements if it resides at n.     
 *  
 *  Users of 64-bit (in particular, DEC Alpha) machines probably need to 
 *  define ALIGNsIZE to be 8.  Just about everybody else can leave it 
 *  as 4 (the distribution default). 
 */ 
#define ALIGNsIZE 4



/* true if the character set of the compiler development machine is the 
 * same as the character set of the machine on which the developed 
 * compiler will run.  This is not currently a supported feature. 
 * so cscdmEQcscm should be left as 0.
 */
#define cscdmEQcscm 0 



/* The following constants control the sizes of data structures
 * in the generated evaluator.  Each is listed with its size in the
 * Ox distribution package.  The distribution default sizes assume 
 * that there is not a lot of memory available 
 * on the machine(s) on which the generated evaluators are to run.  They 
 * can be changed at evaluator-generation time by using Ox's -Y command 
 * line options, or now (at Ox-generation time) by editing this file. 
 * It is unlikely that the sizes other than the first three listed need 
 * to be changed at Ox-generation time.  Anyway, the generated evaluator 
 * fails gracefully and lets the user know in case it runs out of 
 * memory.  The Ox user also has the option of extending to the user 
 * of the generated evaluator the same memory-extension options (see
 * the reference manual).

 * Changing these constants is likely to cause some false alarms from 
 * the Ox test procedures.  If you aren't sure whether your installation 
 * is safe, send your question to: ox-project@cs.iastate.edu.   


 * * MAXnBYTESnODEsTG  400000L 
 * The number of bytes allocated for parse-tree node and attribute-
 * instance storage.

 * * MAXnREFcOUNTS     100000L 
 * The number of dependee counts (one byte each) allocated.  This is the
 * maximum number of attribute instances in the parse tree.
 * 
 * * MAXnCHILDREN       12000L 
 * The number of pointers allocated for child lists.  This is the maximum
 * number of non-root parse-tree nodes.  Each one consumes sizeof(void *)
 * bytes.



 * * MAXsTACKsIZE        1000L 
 * The maximum number of subtrees on the parse-tree stack.  This should
 * be increased if the attribute grammars are expected to use much right 
 * recursion and the generated evaluators are expected to process large 
 * inputs.

 * * ssalSPACEsIZE      10000L 
 * The maximum number of solved synthesized attributes of the roots of 
 * stacked subtrees.

 * * rsMAXsIZE            500L 
 * The maximum size of the ready set.   

 * * TRAVsTACKmAXsIZE    1000L
 * The maximum size of the postdecoration-traversal stack.  The size of
 * stack needed for a depth-first traversal of the parse tree. 
 */



/* Below are three models for memory allocation in the generated 
 * evaluators.  Choose one or design one of your own.
 */


/* small model 
 *    define MAXnBYTESnODEsTG  400000L 
 *    define MAXnREFcOUNTS     100000L 
 *    define MAXnCHILDREN       12000L 
 *    define MAXsTACKsIZE        1000L 
 *    define ssalSPACEsIZE      10000L 
 *    define rsMAXsIZE            500L 
 *    define TRAVsTACKmAXsIZE    1000L
*/



/* medium model 
 *    define MAXnBYTESnODEsTG  2000000L 
 *    define MAXnREFcOUNTS      500000L 
 *    define MAXnCHILDREN        60000L 
 *    define MAXsTACKsIZE        2000L 
 *    define ssalSPACEsIZE      20000L 
 *    define rsMAXsIZE           1000L 
 *    define TRAVsTACKmAXsIZE    2000L
 */



/* large model 
 *    define MAXnBYTESnODEsTG  4000000L 
 *    define MAXnREFcOUNTS     1000000L 
 *    define MAXnCHILDREN       120000L 
 *    define MAXsTACKsIZE        2000L 
 *    define ssalSPACEsIZE      20000L 
 *    define rsMAXsIZE           1000L 
 *    define TRAVsTACKmAXsIZE    2000L
 */



/* medium model */
#define MAXnBYTESnODEsTG  2000000L 
#define MAXnREFcOUNTS      500000L 
#define MAXnCHILDREN        60000L 
#define MAXsTACKsIZE        2000L 
#define ssalSPACEsIZE      20000L 
#define rsMAXsIZE           1000L 
#define TRAVsTACKmAXsIZE    2000L




@EOF
set `sum $sumopt <oxDistG1.04/source/mDeps.h`; if test $1 -ne 60601
then
	echo ERROR: oxDistG1.04/source/mDeps.h checksum is $1 should be 60601
fi
set `wc -lwc <oxDistG1.04/source/mDeps.h`
if test $1$2$3 != 1527494982
then
	echo ERROR: wc results of oxDistG1.04/source/mDeps.h are $* should be 152 749 4982
fi

chmod 755 oxDistG1.04/source/mDeps.h

if test -f oxDistG1.04/source/mac.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/mac.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/mac.c
	if test -f oxDistG1.04/source/mac.c
	then
		echo Error: could not remove oxDistG1.04/source/mac.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/mac.c
cat >oxDistG1.04/source/mac.c <<'@EOF'
/* $Header: mac.c,v 5.10 94/04/16 20:24:27 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

/* abbreviations in variable names: 
 * mac        macro  
 * tab        table
 * sp         space
 * sz         size
 * frm        formal
 * act        actual
 * prm        parameter
 * str        string
 * stg        storage
 * nx         next
 * fr         free
 * MD         macro define
 * MU         macro use
 * LLA        lexer lookahead 
 */ 

#include <stdio.h>
#include <string.h>

#include "opts.hh"



#define frmPrmIndFormat "#%4d#" 
#define fpifLen 6  
#define currBodyStart ((macTab[macStackTop->defNum]).bodyStart)
#define currAfterBody ((macTab[macStackTop->defNum]).afterBody)
#define inFromActPrm ((macStackTop->nextChar >= macActPrmStg) \
                      && \
                      (macStackTop->nextChar < afterMacActPrmStg) \
                     ) 



struct macroDef {char *name;
                 char **firstFrmPrm;
                 char **afterFrmPrms;
                 char *bodyStart;
                 char *afterBody;
                };


struct macroUse {int defNum;
                 char **firstActPrm;
                 char *nextChar;
                 char *bodyPtr;
                };


int inFromMac = 0; 

static unsigned char tempLLAbuf[BUFSIZ];
static unsigned char *LLAbufStart,*LLAbufNxFr; 



static void switchInputStreamToMacro(cp1,cp2)
  unsigned char cp1[],*cp2;
  {unsigned char *cpDumFrom,*cpDumTo; 

   inFromMac = 1; 
   cpDumFrom = LLAbufStart = (unsigned char *)cp1; 
               LLAbufNxFr  = (unsigned char *)cp2; 
   cpDumTo = tempLLAbuf; 
   while (cpDumFrom < LLAbufNxFr) *cpDumTo++ = *cpDumFrom++;  
  }



static void switchInputStreamFromMacro()
  {unsigned char *cpDumFrom,*cpDumTo; 

   inFromMac = 0; 
   cpDumTo = LLAbufStart;
   cpDumFrom = tempLLAbuf; 
   while (cpDumTo < LLAbufNxFr) *cpDumTo++ = *cpDumFrom++;  
  }



static int actPrmCount; 


long macTabSz = 32;
long macFrmPrmSpSz = 128; 
long macBodyStgSz = 16384;

static struct macroDef *macTab,*afterMacTab,*macTabNxFr;
static char **macFrmPrmSp,**afterMacFrmPrmSp,**macFrmPrmSpNxFr; 
static char *macBodyStg,*afterMacBodyStg,*macBodyStgNxFr; 

void prepareDataStructuresMD()
  {
   if ((macTab = (struct macroDef *)malloc(macTabSz * sizeof(struct macroDef)))
       == 
       (struct macroDef *)NULL
      )
      fatal("malloc error in macro definition table allocation\n");  
   afterMacTab = (macTabNxFr = macTab) + macTabSz; 
   
   if ((macFrmPrmSp = (char **)malloc(macFrmPrmSpSz * sizeof(char *)))
       == 
       (char **)NULL
      )
      fatal("malloc error in macro formal parameter space allocation\n");  
   afterMacFrmPrmSp = (macFrmPrmSpNxFr = macFrmPrmSp) + macFrmPrmSpSz; 
   
   if ((macBodyStg = (char *)malloc(macBodyStgSz))
       == 
       (char *)NULL
      )
      fatal("malloc error in macro body storage allocation\n");  
   afterMacBodyStg = (macBodyStgNxFr = macBodyStg) + macBodyStgSz; 
  }



long macStackSz = 16;
long macActPrmSpSz = 128; 
long macActPrmStgSz = 2048; 

static struct macroUse *macStack,*afterMacStack,*macStackTop; 
static char **macActPrmSp,**afterMacActPrmSp,**macActPrmSpNxFr; 
static char *macActPrmStg,*afterMacActPrmStg,*macActPrmStgNxFr; 

void prepareDataStructuresMU()
  {
   if ((macStackTop = 
          (struct macroUse *)malloc(macStackSz * sizeof(struct macroUse))
       )
       == 
       (struct macroUse *)NULL
      )
      fatal("malloc error in macro stack allocation\n");  
   macStack = macStackTop + 1; 
   afterMacStack = macStackTop + macStackSz; 
   
   if ((macActPrmSp = (char **)malloc(macActPrmSpSz * sizeof(char *)))
       == 
       (char **)NULL
      )
      fatal("malloc error in macro actual parameter space allocation\n");  
   afterMacActPrmSp = (macActPrmSpNxFr = macActPrmSp) + macActPrmSpSz; 
   
   if ((macActPrmStg = (char *)malloc(macActPrmStgSz))
       == 
       (char *)NULL
      )
      fatal("malloc error in macro actual parameter storage allocation\n");
   afterMacActPrmStg = (macActPrmStgNxFr = macActPrmStg) + macActPrmStgSz; 
  }



static int macroLookup(cp)
  char *cp; 
  {struct macroDef *mdDum; 

   for (mdDum = macTab; mdDum<macTabNxFr; mdDum++)
     if (mdDum->name == cp) 
         return(mdDum - macTab); 
   return -1;
  }



void initMacroDef(cp)
  char *cp; 
  {if (macroLookup(cp) != -1) 
      {yerror("macro multiply defined:  "); 
       fprintf(stderr,"%s\n",cp); 
      }
   if (macTabNxFr == afterMacTab) handleOverflow(NMCD);
   macTabNxFr->name = cp;
   macTabNxFr->firstFrmPrm = macTabNxFr->afterFrmPrms = macFrmPrmSpNxFr;
   macTabNxFr->bodyStart = macTabNxFr->afterBody = macBodyStgNxFr; 
  } 



static int macroFrmPrmLookup(cp) 
  char *cp;
  {char** fpDum;

   for (fpDum = macTabNxFr->firstFrmPrm; 
        fpDum < macTabNxFr->afterFrmPrms; 
        fpDum++ 
       )
     if (*fpDum == cp) 
        return(fpDum - macTabNxFr->firstFrmPrm); 
   return -1;
  } 



void installMacroFrmPrm(cp)
  char *cp;
  {if (macroFrmPrmLookup(cp) != -1) 
      ywarning("duplicate formal parameter in macro\n");  
   if (macFrmPrmSpNxFr == afterMacFrmPrmSp) handleOverflow(NMFP); 
   *macFrmPrmSpNxFr++ = cp;
   macTabNxFr->afterFrmPrms = macFrmPrmSpNxFr;
  } 



void putIDinMacroDefBody(cp) 
  char *cp; 
  {int index,len; 

   if ((index = macroFrmPrmLookup(cp)) == -1) 
      {if ((macBodyStgNxFr + (len = strlen(cp))) >= afterMacBodyStg)  
          handleOverflow(MBSS); 
          else 
          {strcpy(macBodyStgNxFr,cp); 
           macBodyStgNxFr += len; 
          }
      }
      else 
      {if ((macBodyStgNxFr + fpifLen) >= afterMacBodyStg)  
          handleOverflow(MBSS); 
          else 
          {sprintf(macBodyStgNxFr,frmPrmIndFormat,index); 
           macBodyStgNxFr += fpifLen;   
          }
      }
   macTabNxFr->afterBody = macBodyStgNxFr; 
  }



void putCharInMacroDefBody(c) 
  char c;
  {int i; 
   
   for (i=0; i <= (c == '#'); i++)
     {if (macBodyStgNxFr == afterMacBodyStg) handleOverflow(MBSS); 
      *macBodyStgNxFr++ = c; 
     } 
   macTabNxFr->afterBody = macBodyStgNxFr; 
  }



void terminateMacroDef()
  {macTabNxFr++; 
  } 



static void macroInterpSetup1(i) 
  int i; 
  {actPrmCount = 0; 
   if (++macStackTop == afterMacStack) handleOverflow(MSSZ);  
/* stopgap */
if (macStackTop > macStack)
   {yerror("nested macro feature disabled in this version.\n");
    fatal("exiting\n");
   }
   macStackTop->defNum = i; 
   macStackTop->firstActPrm = macActPrmSpNxFr;
   if (macActPrmSpNxFr == afterMacActPrmSp) handleOverflow(NMAP);   
   *macActPrmSpNxFr = macActPrmStgNxFr; 
  }



int macroInterpSetup1IfMacro(cp)
  char *cp; 
  {int i; 

   if ((i = macroLookup(cp)) == -1) 
      return 0; 
      else 
      {macroInterpSetup1(i);
       return 1;
      }
  }



void putCharInMacroActParam(c) 
  char c; 
  {if (macActPrmStgNxFr == afterMacActPrmStg) handleOverflow(MAPS); 
   *macActPrmStgNxFr++ = c; 
  }



void terminateActualParam()
  {putCharInMacroActParam('\0'); 
   if (++macActPrmSpNxFr == afterMacActPrmSp) handleOverflow(NMAP);   
   *macActPrmSpNxFr = macActPrmStgNxFr; 
   actPrmCount++; 
  } 



static void returnFromMacro()
  {macActPrmSpNxFr = macStackTop->firstActPrm;
   macActPrmStgNxFr = *(macStackTop->firstActPrm);
   macStackTop--;
  }



/* entered with macStackTop->nextChar pointing to the character after 
 * the one last gotten from the macro input stream, if one was just 
 * gotten, else points to the first character in the body of a 
 * macro use just placed on the macro stack.  Returns true if exiting
 * with macStackTop->nextChar pointing to a valid character, else 
 * returns false and the macro use stack is empty.  
 */ 
static int makeReadyInputFromMacro()
  {int index; 

   do 
     {if (inFromActPrm)
         {if (*(macStackTop->nextChar) == '\0') 
             {macStackTop->nextChar = macStackTop->bodyPtr;
              continue; 
             } 
         } 
         else
         {if (macStackTop->nextChar == currAfterBody) 
             {returnFromMacro(); 
              continue; 
             }
             else
             if (*(macStackTop->nextChar) == '#') 
                {if (*(macStackTop->nextChar + 1) == '#') 
                    (macStackTop->nextChar)++;
                    else 
                    {sscanf(macStackTop->nextChar,frmPrmIndFormat,&index);
                     macStackTop->bodyPtr = (macStackTop->nextChar) + fpifLen;
                     macStackTop->nextChar = 
                       *(macStackTop->firstActPrm + index);
                     continue;  
                    }
                }
         } 
      return 1; 
     } 
     while (macStackTop >= macStack); 
   return 0; 
  }



void macroInterpSetup2(cp1,cp2)
  unsigned char cp1[],*cp2;
  {int fpCount; 
   struct macroDef mdDum; 

   mdDum = macTab[macStackTop->defNum];
   fpCount = (mdDum.afterFrmPrms - mdDum.firstFrmPrm);
   if (actPrmCount > fpCount)  
      yerror("too many actual parameters in macro invocation.\n"); 
   if (actPrmCount < fpCount)  
      fatal("too few actual parameters or missing comma in macro invocation.\n"
           ); 
   macStackTop->nextChar = mdDum.bodyStart; 
   if (makeReadyInputFromMacro()) switchInputStreamToMacro(cp1,cp2);  
  }



/* This is called by input() exactly when inFromMac is set.  
 * macStackTop->nextChar always points to a valid character (in an 
 * actual parameter or in the body of the most recently invoked macro) when 
 * this is called.  So a valid character is always returned by this
 * routine.  Before returning, macStackTop->nextChar must be set to  
 * point to a valid character or the macro invocation stack must be 
 * emptied and inFromMac reset, which functions are performed by the 
 * call to makeReadyInputFromMacro().  
 */  
char inputFromMacro()
  {char c;

   c = *(macStackTop->nextChar)++; 
   if (!makeReadyInputFromMacro()) switchInputStreamFromMacro();  
   return c;
  }



@EOF
set `sum $sumopt <oxDistG1.04/source/mac.c`; if test $1 -ne 53034
then
	echo ERROR: oxDistG1.04/source/mac.c checksum is $1 should be 53034
fi
set `wc -lwc <oxDistG1.04/source/mac.c`
if test $1$2$3 != 448134312229
then
	echo ERROR: wc results of oxDistG1.04/source/mac.c are $* should be 448 1343 12229
fi

chmod 755 oxDistG1.04/source/mac.c

if test -f oxDistG1.04/source/mac.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/mac.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/mac.h
	if test -f oxDistG1.04/source/mac.h
	then
		echo Error: could not remove oxDistG1.04/source/mac.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/mac.h
cat >oxDistG1.04/source/mac.h <<'@EOF'
/* $Header: mac.h,v 5.10 94/04/16 20:24:31 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

extern long macTabSz        ;
extern long macFrmPrmSpSz   ; 
extern long macBodyStgSz    ;
extern long macStackSz      ;
extern long macActPrmSpSz   ; 
extern long macActPrmStgSz  ; 

extern int inFromMac;

extern int macroInterpSetup1IfMacro();
extern void macroInterpSetup2();
extern void terminateActualParam();
extern void prepareDataStructuresMD();
extern void prepareDataStructuresMU();
extern void initMacroDef();
extern void installMacroFrmPrm();
extern void putIDinMacroDefBody(); 
extern void putCharInMacroActParam();
extern void putCharInMacroDefBody();
extern void terminateMacroDef();
extern char inputFromMacro();

@EOF
set `sum $sumopt <oxDistG1.04/source/mac.h`; if test $1 -ne 47128
then
	echo ERROR: oxDistG1.04/source/mac.h checksum is $1 should be 47128
fi
set `wc -lwc <oxDistG1.04/source/mac.h`
if test $1$2$3 != 834453013
then
	echo ERROR: wc results of oxDistG1.04/source/mac.h are $* should be 83 445 3013
fi

chmod 755 oxDistG1.04/source/mac.h

if test -f oxDistG1.04/source/medi.l
then
	echo Ok to overwrite existing file oxDistG1.04/source/medi.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/medi.l
	if test -f oxDistG1.04/source/medi.l
	then
		echo Error: could not remove oxDistG1.04/source/medi.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/medi.l
cat >oxDistG1.04/source/medi.l <<'@EOF'
%{
/* $Header: medi.l,v 5.10 94/04/16 20:24:34 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

%}
%start LBS DEF IORU MDI MDU TT

%{
#include <string.h>

extern void substInputDef(); 
extern void substUnputDef(); 
%}

%%
<LBS>^#             {fputc(*yytext,yyout); BEGIN DEF;}
<LBS>.|\n           fputc(*yytext,yyout);
<DEF>define         {fprintf(yyout,yytext);
                     BEGIN IORU;
                    }
<DEF>[ \t\f]        fputc(*yytext,yyout);
<DEF>.|\n           {fputc(*yytext,yyout); BEGIN LBS;}
<IORU>input         {fprintf(yyout,yytext);
                     fprintf(yyout,"M");
                     BEGIN MDI;
                    }
<IORU>unput         {fprintf(yyout,yytext);
                     fprintf(yyout,"M");
                     BEGIN MDU;
                    }
<IORU>[ \t\f]       fputc(*yytext,yyout);
<IORU>.|\n          {fputc(*yytext,yyout); BEGIN LBS;}
<MDI>\\\n           fprintf(yyout,yytext);
<MDI>.              fputc(*yytext,yyout);
<MDI>\n             {fputc(*yytext,yyout);
                     substInputDef(yyout);
                     BEGIN LBS;
                    }
<MDU>\\\n           fprintf(yyout,yytext);
<MDU>.              fputc(*yytext,yyout);
<MDU>\n             {fputc(*yytext,yyout);
                     substUnputDef(yyout);
                     BEGIN LBS;
                    }
%%


#include <stdio.h>
FILE *inFile;
FILE *outFile;



void erasf(str)
  char *str;
  {char dummy[64];
   strcpy(dummy,"rm ");
   system(strcat(dummy,str));
  }



char *substIText[] = { 
"extern int inFromMac;\n", 
"extern char inputFromMacro();\n", 
"#define input() (inFromMac?((yysptr>yysbuf)?(*--yysptr):\\\n",
"                                              inputFromMacro()\\\n",
"                           ):\\\n",
"                           inputM()\\\n", 
"                )\n",
}; 



void substInputDef(fp) 
  FILE *fp;
  {int i; 
   for (i=0; i<(sizeof(substIText)/sizeof(char *)); i++) 
     fprintf(fp,"%s",substIText[i]);
  } 



char *substUText[] = { 
"extern int inFromMac;\n", 
"#define unput(c) {if (inFromMac) \\\n",
"                     {yytchar= (c);*yysptr++=yytchar;} \\\n",
"                     else \\\n",
"                     unputM(c) \\\n",
"                 }\n",
}; 



void substUnputDef(fp) 
  FILE *fp;
  {int i; 
   for (i=0; i<(sizeof(substUText)/sizeof(char *)); i++) 
     fprintf(fp,"%s",substUText[i]);
  } 



main(argc,argv)
int argc;
char *argv[];
{
BEGIN LBS;
if ((inFile = fopen(argv[1],"r")) == (FILE *)NULL)
   fprintf(stderr,"error when trying to open input file for med\n");
yyin = inFile;
if ((outFile = fopen(argv[2],"w")) == (FILE *)NULL)
   fprintf(stderr,"error when trying to open output file for med\n");
yyout = outFile;
yylex();
fclose(inFile);
fclose(outFile);
erasf(argv[1]);
exit(0);
}


@EOF
set `sum $sumopt <oxDistG1.04/source/medi.l`; if test $1 -ne 33013
then
	echo ERROR: oxDistG1.04/source/medi.l checksum is $1 should be 33013
fi
set `wc -lwc <oxDistG1.04/source/medi.l`
if test $1$2$3 != 1806015087
then
	echo ERROR: wc results of oxDistG1.04/source/medi.l are $* should be 180 601 5087
fi

chmod 755 oxDistG1.04/source/medi.l

if test -f oxDistG1.04/source/medyy.l
then
	echo Ok to overwrite existing file oxDistG1.04/source/medyy.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/medyy.l
	if test -f oxDistG1.04/source/medyy.l
	then
		echo Error: could not remove oxDistG1.04/source/medyy.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/medyy.l
sed 's/^@//' >oxDistG1.04/source/medyy.l <<'@EOF'
%{
/* $Header: medyy.l,v 5.10 94/04/16 20:24:36 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

%}

%{
#include <string.h>

char *modString;
%}

%%
yyyy                {fprintf(yyout,yytext);}
yyy                 {fprintf(yyout,yytext);}
yy                  {fprintf(yyout,yytext);
                     fprintf(yyout,modString);
                    }
@.                   fputc(*yytext,yyout);
%%


#include <stdio.h>
FILE *inFile;
FILE *outFile;



void erasf(str)
  char *str;
  {char dummy[64];
   strcpy(dummy,"rm ");
   system(strcat(dummy,str));
  }



main(argc,argv)
int argc;
char *argv[];
{
if ((inFile = fopen(argv[1],"r")) == (FILE *)NULL)
   fprintf(stderr,"error when trying to open input file for med\n");
yyin = inFile;
if ((outFile = fopen(argv[2],"w")) == (FILE *)NULL)
   fprintf(stderr,"error when trying to open output file for med\n");
yyout = outFile;
modString = argv[3];
yylex();
fclose(inFile);
fclose(outFile);
erasf(argv[1]);
exit(0);
}


@EOF
set `sum $sumopt <oxDistG1.04/source/medyy.l`; if test $1 -ne 23823
then
	echo ERROR: oxDistG1.04/source/medyy.l checksum is $1 should be 23823
fi
set `wc -lwc <oxDistG1.04/source/medyy.l`
if test $1$2$3 != 1144713258
then
	echo ERROR: wc results of oxDistG1.04/source/medyy.l are $* should be 114 471 3258
fi

chmod 755 oxDistG1.04/source/medyy.l

if test -f oxDistG1.04/source/opts.hh
then
	echo Ok to overwrite existing file oxDistG1.04/source/opts.hh\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/opts.hh
	if test -f oxDistG1.04/source/opts.hh
	then
		echo Error: could not remove oxDistG1.04/source/opts.hh, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/opts.hh
cat >oxDistG1.04/source/opts.hh <<'@EOF'
/* $Header: opts.hh,v 5.10 94/04/16 20:24:39 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#define LEXSCANNER 3
#define GENSCANNER 5
#define NOSCANNER  100

#define NPDS  'N'          /* maxNentsPerDepSpec      */  
#define EPDS  'E'          /* maxNeesPerDepSpec       */  
#define AOPP  'i'          /* maxNattrbOccrsPerProd   */  
#define LGNS  'n'          /* ldgNodeStgSize          */  
#define PRDL  'p'          /* maxProdLength           */  
#define NAPS  'a'          /* maxNattrbsPerSym        */  
#define RSBS  'r'          /* refSegBufferSize        */  
#define NTRM  't'          /* maxNterms               */  
#define NSTR  's'          /* maxNstrings             */  
#define MNGS  'g'          /* maxNgSyms               */  
#define MNST  'T'          /* maxNstructTags          */  
#define NPRD  'P'          /* maxNprods               */  

#define NMCD  'M'          /* macTabSz                */ 
#define NMFP  'F'          /* macFrmPrmSpSz           */
#define MBSS  'B'          /* macBodyStgSz            */ 
#define MSSZ  'm'          /* macStackSz              */ 
#define NMAP  'A'          /* macActPrmSpSz           */ 
#define MAPS  'S'          /* macActPrmStgSz          */ 
#define NTRV  'v'          /* maxNtravs               */ 
#define NTSB  'b'          /* maxNtravSegBufs         */ 

struct LfileRec {char *inName,*outName; 
                 FILE *inPtr,*outPtr; 
                 int scanner;
                };  

@EOF
set `sum $sumopt <oxDistG1.04/source/opts.hh`; if test $1 -ne 37266
then
	echo ERROR: oxDistG1.04/source/opts.hh checksum is $1 should be 37266
fi
set `wc -lwc <oxDistG1.04/source/opts.hh`
if test $1$2$3 != 925203757
then
	echo ERROR: wc results of oxDistG1.04/source/opts.hh are $* should be 92 520 3757
fi

chmod 755 oxDistG1.04/source/opts.hh

if test -f oxDistG1.04/source/opts.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/opts.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/opts.c
	if test -f oxDistG1.04/source/opts.c
	then
		echo Error: could not remove oxDistG1.04/source/opts.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/opts.c
cat >oxDistG1.04/source/opts.c <<'@EOF'
/* $Header: opts.c,v 5.10 94/04/16 20:24:42 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <stdio.h> 
#include <string.h>

#include "opts.hh"
#include "mDeps.h"
#include "trav.h"
#include "patchlvl.h"
#include "mac.h"
#include "depGs.h"
#include "symTrans.h"
#include "outMgr.h"


FILE *yoxInG; 
char *yoxInFileStrG; 
FILE *yoxOutG; 
char *yoxOutFileStrG = "oxout.y"; 
char *treeShowFileStr;

int nLfiles = 0; 
#define maxNLfiles 32  
struct LfileRec Lfile[maxNLfiles]; 
int currentLfile = -1; 

/*   extension must be ".l",  because an integer
     modifier will be shoved in between it and 
     the rest of the name if
     there are multiple L-files.  
*/ 
char *yoxOutFileStrL = "oxout.l"; 

FILE *yoxOutH; 
char *yoxOutFileStrH = "oxout.h"; 


int WAmax = 0; 
int RCmax = 0; 
int WSmax = 0; 


/* See mdeps.h */  
int alignSize = ALIGNsIZE;  

/* See mdeps.h */  
int CSCDMeqCSCM = cscdmEQcscm;    

/* See mdeps.h */ 
long maxNbytesNodeStg = MAXnBYTESnODEsTG;  
long maxNrefCounts    = MAXnREFcOUNTS; 
long maxNchildren     = MAXnCHILDREN; 
long maxStackSize     = MAXsTACKsIZE;  
long SSALspaceSize    = ssalSPACEsIZE;  
long RSmaxSize        = rsMAXsIZE; 
long travStackMaxSize = TRAVsTACKmAXsIZE;

/* when showStackOpts is set, ox produces an evaluator that displays 
   the sequence of operations on the stack of subtrees. 
 
   showPTsizeStats causes generation of an evaluator that reports 
   maximum sizes of some parse-tree-related data structures upon 
   termination. 
 */ 
int buildHeaderFile = 0; 
int suppressPruning = 0; 
int genEvUserCLoptsCode = 0;  
int neutralizeSemActions = 0; 
int stripOxConstructs = 0;
int showPTsizeStats = 0; 
int showStackOps = 0; 
int saveBadOutputs = 0; 
int suppressCycleReports = 0; 
int ansiNotKR = 0; 
int treeShow = 0;
int xTreeShow = 0;


char *ctSA[] =  
{
"/* read the command line for changes in sizes of \n", 
"                  the evaluator's data structures */\n",
"@@C@void yyyCheckForResizes(argc,argv) \n", 
"@@C@  int argc; \n", 
"@@C@  char *argv[]; \n", 
"@@A@void yyyCheckForResizes(int argc,char *argv[]) \n", 
"  {int i; \n", 
"   long dum; \n", 
" \n", 
"   if (!yyyPermitUserAlloc) return; \n", 
"   for (i=1;i<argc;i++) \n", 
"     { \n", 
"      if ((argv[i][0] != \'-\') || (argv[i][1] != \'Y\')) continue; \n", 
"      if (strlen(argv[i]) < 4) goto yyyErrO1; \n",
"      if (sscanf(argv[i]+3,\"%%d\",&dum) != 1) goto yyyErrO1;\n",
"      if (dum < 2) dum = 2;\n",
"      switch (argv[i][2]) \n",
"        {case yyyNSof:   yyyMaxNbytesNodeStg = dum; break; \n",
"         case yyyRCof:   yyyMaxNrefCounts    = dum; break; \n",
"         case yyyCLof:   yyyMaxNchildren     = dum; break; \n",
"         case yyySof:    yyyMaxStackSize     = dum; break; \n",
"         case yyySSALof: yyySSALspaceSize    = dum; break; \n",
"         case yyyRSof:   yyyRSmaxSize        = dum; break; \n",
"         case yyyTSof:   yyyTravStackMaxSize = dum; break; \n",
"         default : goto yyyErrO1; \n",
"        }\n",
"      continue;  \n",
"   yyyErrO1 : fprintf(stderr,\"invalid command line option: %%s\\n\",\n",
"                             argv[i] \n", 
"                     ); \n",
"     } \n",
"  } \n", 
"   \n", 
"   \n", 
"   \n", 
};



char *yoxOutGtopStuff[] =  
{
"%%{\n", 
"@@T@#include <curses.h>\n", 
"%%}\n", 
};



void printPatchlevelComment(fp)
  FILE *fp;
  {fprintf(fp,"/* output from %s */\n",PATCHLEVEL);
  }



void printPatchlevel(fp)
  FILE *fp;
  {fprintf(fp,"%s\n",PATCHLEVEL);
  }



void printVDATE(fp)
  FILE *fp;
  {fprintf(fp,"%s\n",VDATE);
  }



char *usageText[] = 
{
"usage: ox {option} Y-file [-G] L-file {[-G] L-file}\n",
};



void printUsageText(fp)
  FILE *fp;
  {printStringArray(usageText,sizeof(usageText),fp);
  }



char *copyrightText[] = 
{
"*******************************************************************\n",
"This is Ox.\n",
"Copyright (c) 1992, 1993  Kurt M. Bischoff.  All rights reserved.\n",
"Unauthorized use, distribution, and modification are prohibited.\n",
"\n",
"THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n",
"IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n",
"WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n",
"*******************************************************************\n",
};



void printCopyrightStatement(fp)
  FILE *fp;
  {printStringArray(copyrightText,sizeof(copyrightText),fp);
  }



void outputUserOptsCode() 
  {
   printStringArray(ctSA,sizeof(ctSA),yoxOutG);
  }   



/* Set the size of one of ox's internal data structures */ 
void setAnEGsize(len,str) 
  int len; 
  char *str; 
  {long dum;

   if (len < 4) goto errO3; 
   if (sscanf(str+3,"%d",&dum) != 1) goto errO3;
   if (dum < 2) dum = 2; 
   switch (str[2]) 
     {case NPDS:  maxNentsPerDepSpec    = dum; break; 
      case EPDS:  maxNeesPerDepSpec     = dum; break; 
      case AOPP:  maxNattrbOccrsPerProd = dum; break; 
      case LGNS:  ldgNodeStgSize        = dum; break; 
      case PRDL:  maxProdLength         = dum; break; 
      case NAPS:  maxNattrbsPerSym      = dum; break; 
      case RSBS:  refSegBufferSize      = dum; break; 
      case NTRM:  maxNterms             = dum; break; 
      case NSTR:  maxNstrings           = dum; break; 
      case MNGS:  maxNgSyms             = dum; break; 
      case MNST:  maxNstructTags        = dum; break; 
      case NPRD:  maxNprods             = dum; break; 
      case NMCD:  macTabSz              = dum; break; 
      case NMFP:  macFrmPrmSpSz         = dum; break; 
      case MBSS:  macBodyStgSz          = dum; break; 
      case MSSZ:  macStackSz            = dum; break; 
      case NMAP:  macActPrmSpSz         = dum; break; 
      case MAPS:  macActPrmStgSz        = dum; break; 
      case NTRV:  maxNtravs             = dum; break; 
      case NTSB:  maxNtravSegBufs       = dum; break; 
      default : goto errO3; 
     }
   return;  
errO3 : fprintf(stderr,"ox: invalid command line option: %s\n",str); 
  } 



/* set (at evaluator generation time) the size of one of the evaluator's
                 data structures */ 
void setaGEdefaultSize(len,str) 
  int len; 
  char *str; 
  {long dum;

   if (str[2] == 'Y') 
      {if (len > 3) goto errO1; 
       genEvUserCLoptsCode = 1;  
       return; 
      } 
   if (len < 4) goto errO1; 
   if (sscanf(str+3,"%d",&dum) != 1) goto errO1;
   if (dum < 2) dum = 2; 
   switch (str[2]) 
     {case 'n': maxNbytesNodeStg = dum; break; 
      case 'r': maxNrefCounts    = dum; break; 
      case 'c': maxNchildren     = dum; break; 
      case 's': maxStackSize     = dum; break; 
      case 'S': SSALspaceSize    = dum; break; 
      case 'q': RSmaxSize        = dum; break; 
      case 't': travStackMaxSize = dum; break;
      default : goto errO1; 
     }
   return;  
errO1 : fprintf(stderr,"ox: invalid command line option: %s\n",str); 
  } 



FILE *sfopen(name,mode) 
  char *name,*mode;  
  {FILE *dum; 

   if ((dum = fopen(name,mode)) 
       == 
       ((FILE *)NULL) 
      ) 
      {fprintf(stderr,"fatal error opening %s.\n",name); 
       exit(-1); 
      } 
      else 
      return dum; 
  } 



void openIOfilesAndSetOptions(argc,argv) 
  int argc; 
  char *argv[];  
  {int i; 
 
   if ((argc == 2) && (argv[1][0] == '-'))
      {int j,len;

       len = strlen(argv[1]); 
       for (j=1;j<len;j++) 
           {switch (argv[1][j])
              {case 'C' : printCopyrightStatement(stdout); 
                          break;
               case 'U' : printUsageText(stdout); 
                          break;
               case 'V' : printPatchlevel(stdout); 
                          printVDATE(stdout);
                          break;
               default  : fprintf(stderr,
                          "ox: bad command line option: %c\n",argv[1][j]
                                 ); 
                          break;
              }
           }
       exit(0);
      }

   i=0; 
  
   while ((++i < argc) && (argv[i][0] == '-'))     
      ; 
   if (i == argc) 
      {fprintf(stderr,"ox: command line lacks name for Y-file\n"); 
       printUsageText(stderr);
       exit(-1); 
      } 
      else   
      yoxInFileStrG = argv[i]; 

   yoxInG = sfopen(yoxInFileStrG,"r");  
   yoxOutG = sfopen(yoxOutFileStrG,"w");  
   printPatchlevelComment(yoxOutG);
 
   while (++i < argc)  
     {if (argv[i][0] != '-') 
        {if (nLfiles == maxNLfiles) fatal("too many L-files\n"); 
         Lfile[nLfiles].inName = argv[i]; 
         Lfile[nLfiles].scanner = LEXSCANNER; 
         if (!strcmp(argv[i-1],"-G"))
            Lfile[nLfiles].scanner = GENSCANNER; 
         if ((Lfile[nLfiles].outName = 
              (char *)malloc(strlen(yoxOutFileStrL) + 5)
             )
             == 
             ((char *)NULL) 
            ) 
            fatal("error mallocing outName\n"); 
         strcpy(Lfile[nLfiles].outName,yoxOutFileStrL); 
         nLfiles++; 
        }
     }

   if (!nLfiles) 
      {fprintf(stderr,"ox: command line lacks name for L-file\n");  
       printUsageText(stderr);
       exit(-1); 
      } 

   for (i=0;i<nLfiles;i++)  
     {Lfile[i].inPtr = sfopen(Lfile[i].inName,"r"); 
      if (nLfiles>1) 
         {sprintf(Lfile[i].outName +
                  strlen(yoxOutFileStrL) - strlen(".l"),
                  "%d",i
                 ); 
          strcat(Lfile[i].outName,".l"); 
         }
      Lfile[i].outPtr = sfopen(Lfile[i].outName,"w"); 
      printPatchlevelComment(Lfile[i].outPtr);
     } 

   yoxOutH = sfopen(yoxOutFileStrH,"w");  
   if (buildHeaderFile) printPatchlevelComment(yoxOutH);

   for (i=1;i<argc;i++) 
     {int j,len;
      long dum; 
      if (argv[i][0] != '-') continue;  
      len = strlen(argv[i]); 
      for (j=1;j<len;j++) 
        { 
         switch (argv[i][j]) 
           {case 'd' : suppressPruning = 1; break;  
            case 'h' : buildHeaderFile = 1; break;  
            case 'A' : CSCDMeqCSCM = 1; break;  
            case 'I' : ansiNotKR = 1;   break;
            case 'n' : neutralizeSemActions = 1; break;
            case 'S' : stripOxConstructs = 1; break;
            case 's' : showStackOps = 1; break;
            case 'j' : saveBadOutputs = 1; break;
            case 'u' : showPTsizeStats = 1; break;
            case 'c' : suppressCycleReports = 1; break;
            case 't' : xTreeShow = 1; break;
	    case 'U' : printCopyrightStatement(stdout); break;
            case 'V' : printPatchlevel(stdout); 
                       printVDATE(stdout);
                       break;
            case 'a' : 
                       if (j != 1) goto errO2; 
                       if (len < 3) goto errO2; 
                       if (sscanf(argv[i]+2,"%d",&dum) != 1) goto errO2;
                       switch (argv[i][j]) 
                         {case 'a' : if (dum < 1)  goto errO2; 
                                     alignSize = dum; 
                                     break; 
                          default:; 
                         } 
                       j = len; 
                       break; 
            case 'G' : if (strcmp(argv[i],"-G")) goto errO2;
                       break;
            case 'X' : if (j != 1) goto errO2; 
                       setAnEGsize(len,argv[i]); 
                       j = len; 
                       break; 
            case 'T' : if (j != 1) goto errO2; 
                       treeShow = 1; 
                       treeShowFileStr = argv[i]+2;
                       j = len; 
                       break; 
            case 'Y' : if (j != 1) goto errO2; 
                       setaGEdefaultSize(len,argv[i]); 
                       j = len; 
                       break; 
            default: ; 
           }  
        }
      continue; 
errO2 : fprintf(stderr,"ox: error in command line option: %s\n",argv[i]); 
     } 
   printStringArray(yoxOutGtopStuff,sizeof(yoxOutGtopStuff),yoxOutG);
   scanInit1();  
  } 



void closeIOfiles() 
  {int i;  

   fclose(yoxInG);   
   fclose(yoxOutG);   
   for (i=0;i<nLfiles;i++) 
     {fclose(Lfile[i].inPtr); 
      fclose(Lfile[i].outPtr); 
     } 
   fclose(yoxOutH);   
  } 



void rmOutputFiles() 
  {int i; 

   fclose(yoxOutG); 
   erasf(yoxOutFileStrG); 
   for (i=0;i<nLfiles;i++) 
       {fclose(Lfile[i].outPtr); 
        erasf(Lfile[i].outName); 
       }
   if (buildHeaderFile) 
      {fclose(yoxOutH); 
       erasf(yoxOutFileStrH); 
      }
   fprintf(stderr,"ox did not generate output.\n"); 
  } 



/* report overflow of one of the data structures of the evaluator generator.
   suggest a new size.  */
void handleOverflow(which) 
  char which; 
  {char *msg1,*msg2; 
   int  oldSize,newSize; 

   switch(which) 
     {
      case NPDS: 
           msg1 = "out of space for dependents: ";
           oldSize = maxNentsPerDepSpec; 
           break; 
      case EPDS: 
           msg1 = "out of space for dependees: ";
           oldSize = maxNeesPerDepSpec; 
           break; 
      case AOPP: 
           msg1 = "out of space for attribute occurrences: ";
           oldSize = maxNattrbOccrsPerProd; 
           break; 
      case LGNS: 
           msg1 = "out of space for dependency graph: ";
           oldSize = ldgNodeStgSize; 
           break; 
      case PRDL: 
           msg1 = "out of space for grammar rule: ";
           oldSize = maxProdLength; 
           break; 
      case NAPS: 
           msg1 = "too many attributes for one symbol: ";
           oldSize = maxNattrbsPerSym; 
           break; 
      case NTRM: 
           msg1 = "out of space for terminals: ";
           oldSize = maxNterms; 
           break; 
      case NSTR: 
           msg1 = "out of space for strings: ";
           oldSize = maxNstrings; 
           break; 
      case MNGS: 
           msg1 = "out of space for grammar symbols: ";
           oldSize = maxNgSyms; 
           break; 
      case MNST: 
           msg1 = "out of space for structure tags: ";
           oldSize = maxNstructTags; 
           break; 
      case NPRD: 
           msg1 = "out of space for productions: ";
           oldSize = maxNprods; 
           break; 
      case NMCD: 
           msg1 = "out of space for macro definitions: "; 
           oldSize = macTabSz; 
           break; 
      case NMFP: 
           msg1 = "out of space for macro formal parameters: "; 
           oldSize = macFrmPrmSpSz; 
           break; 
      case MBSS: 
           msg1 = "out of space for macro text: "; 
           oldSize = macBodyStgSz; 
           break; 
      case MSSZ: 
           msg1 = "out of space for macro use stack: "; 
           oldSize = macStackSz; 
           break; 
      case NMAP: 
           msg1 = "too many macro actual parameters: "; 
           oldSize = macActPrmSpSz; 
           break; 
      case MAPS: 
           msg1 = "macro actual parameters too long: "; 
           oldSize = macActPrmStgSz; 
           break; 
      case NTRV: 
           msg1 = "too many traversals: "; 
           oldSize = maxNtravs; 
           break; 
      case NTSB: 
           msg1 = "too many traversal actions: "; 
           oldSize = maxNtravSegBufs; 
           break; 
      default        :;  
     }
   newSize = (5*oldSize)/4; 
   if (newSize < 16) newSize = 16; 
   fprintf(stderr,msg1); 
   fprintf(stderr,"size was %d. \n",oldSize); 
   msg2 = "     Try -X%c%d option.\n"; 
   fprintf(stderr,msg2,which,newSize); 
   rmTempFiles();
   exit(-1); 
  }

@EOF
set `sum $sumopt <oxDistG1.04/source/opts.c`; if test $1 -ne 60203
then
	echo ERROR: oxDistG1.04/source/opts.c checksum is $1 should be 60203
fi
set `wc -lwc <oxDistG1.04/source/opts.c`
if test $1$2$3 != 612199817690
then
	echo ERROR: wc results of oxDistG1.04/source/opts.c are $* should be 612 1998 17690
fi

chmod 755 oxDistG1.04/source/opts.c

if test -f oxDistG1.04/source/opts.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/opts.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/opts.h
	if test -f oxDistG1.04/source/opts.h
	then
		echo Error: could not remove oxDistG1.04/source/opts.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/opts.h
cat >oxDistG1.04/source/opts.h <<'@EOF'
/* $Header: opts.h,v 5.10 94/04/16 20:24:45 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

extern char *yoxInFileStrL; 
extern char *yoxInFileStrG; 
extern char *yoxOutFileStrH; 
extern char *treeShowFileStr;

extern void handleOverflow();

extern FILE *yoxInG; 
extern FILE *yoxOutG; 
extern FILE *yoxOutH; 

extern int nLfiles; 
extern int currentLfile; 
extern struct LfileRec Lfile[]; 

extern int alignSize; 
extern int buildHeaderFile; 
extern int suppressPruning; 
extern int neutralizeSemActions; 
extern int stripOxConstructs; 
extern int showPTsizeStats; 
extern int showStackOps; 
extern int saveBadOutputs; 
extern int suppressCycleReports;
extern int genEvUserCLoptsCode; 
extern int CSCDMeqCSCM; 
extern int ansiNotKR; 
extern int treeShow; 
extern int xTreeShow;

extern long maxNbytesNodeStg; 
extern long maxNrefCounts   ; 
extern long maxNchildren    ; 
extern long maxStackSize    ;
extern long SSALspaceSize   ; 
extern long RSmaxSize       ; 
extern long travStackMaxSize;

extern FILE *sfopen(); 


extern int maxNentsPerDepSpec;        
extern int maxNeesPerDepSpec;         
extern int maxNattrbOccrsPerProd;     
extern long maxNterms;                 

extern int WAmax; 
extern int RCmax; 
extern int PNmax; 
extern int WSmax; 

extern void rmOutputFiles(); 

@EOF
set `sum $sumopt <oxDistG1.04/source/opts.h`; if test $1 -ne 24761
then
	echo ERROR: oxDistG1.04/source/opts.h checksum is $1 should be 24761
fi
set `wc -lwc <oxDistG1.04/source/opts.h`
if test $1$2$3 != 1145143581
then
	echo ERROR: wc results of oxDistG1.04/source/opts.h are $* should be 114 514 3581
fi

chmod 755 oxDistG1.04/source/opts.h

if test -f oxDistG1.04/source/outMgr.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/outMgr.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/outMgr.c
	if test -f oxDistG1.04/source/outMgr.c
	then
		echo Error: could not remove oxDistG1.04/source/outMgr.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/outMgr.c
cat >oxDistG1.04/source/outMgr.c <<'@EOF'
/* $Header: outMgr.c,v 5.10 94/04/16 20:24:48 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <stdio.h> 

#include "glob.h" 
#include "opts.hh" 
#include "opts.h" 
#include "symTrans.h"
#include "mac.h"
#include "joinTabs.h"
#include "scan.h"



#define LAbuffer1ArraySize 1024 
static int LAbuffer1Pointer = 0;  
static char LAbuffer1Array[LAbuffer1ArraySize]; 
static FILE *LAbuffer1File; 
static char *LAbuffer1FileStr = "LAbuf1.temp"; 

#define LAbuffer2ArraySize 1024 
static int LAbuffer2Pointer = 0;  
static char LAbuffer2Array[LAbuffer2ArraySize]; 
static FILE *LAbuffer2File; 
static char *LAbuffer2FileStr = "LAbuf2.temp"; 

long refSegBufferSize = 16384;   
long refSegBufferPointer;  
long nextRefSegBufferStart;  
char *refSegBuffer; 


#define S_DEBUG 0
#define DFAACCEPT 0 



static char lexinput() 
  {switch(whichScanner) 
     {case 1: return yy1input(); 
      case 2: return yy2input(); 
      case 3: return yy3input(); 
      case 4: return yy4input(); 
      case 5: return yy5input(); 
      default: fatal("lexinput: unknown scanner\n"); 
     } 
  } 



static void putCharInLAbuffer(c,whichBuf)
  char c; 
  int whichBuf;
  {switch(whichBuf)  
    {case LA1:   
     if (LAbuffer1Pointer < LAbuffer1ArraySize) 
        {LAbuffer1Array[LAbuffer1Pointer++] = c; 
         return; 
        } 
     if (LAbuffer1Pointer == LAbuffer1ArraySize) 
        LAbuffer1File = fopen(LAbuffer1FileStr,"w"); 
     putc(c,LAbuffer1File);  
     LAbuffer1Pointer++; 
     break;  
     case LA2: 
     if (LAbuffer2Pointer < LAbuffer2ArraySize) 
        {LAbuffer2Array[LAbuffer2Pointer++] = c; 
         return; 
        } 
     if (LAbuffer2Pointer == LAbuffer2ArraySize) 
        LAbuffer2File = fopen(LAbuffer2FileStr,"w"); 
     putc(c,LAbuffer2File);  
     LAbuffer2Pointer++; 
     break;  
    } 
  } 



static void putCharInRefSegBuffer(c)
  char c; 
  {if (refSegBufferPointer < refSegBufferSize) 
      refSegBuffer[refSegBufferPointer++] = c; 
      else 
      handleOverflow(RSBS); 
   if (c == '#') 
      {if (refSegBufferPointer < refSegBufferSize) 
          refSegBuffer[refSegBufferPointer++] = c; 
          else 
          handleOverflow(RSBS); 
      } 
   return;  
  } 



void putAttrbNumPairInRefSegBuffer(symPos,attrbNum)
  int symPos,attrbNum ;  
  {if (refSegBufferPointer+16 <= refSegBufferSize) 
      {sprintf(refSegBuffer+refSegBufferPointer,"#%7d",symPos); 
       sprintf(refSegBuffer+(refSegBufferPointer += 8),",%7d",attrbNum); 
       refSegBufferPointer += 8; 
      } 
      else 
      handleOverflow(RSBS); 
  } 



void genImmCrefForAttrbRef(symPos,attrbNum,GnotL,fp)
  int symPos,attrbNum,GnotL; 
  FILE *fp;  
  {struct gSym *pSym; 

   if ((symPos == -1) || (attrbNum == -1)) return; 
   pSym = &(gSymTable[prodBuffer2[symPos].gSymTabInd]);  
   if (!symPos) 
      fprintf(fp,"(((%s)%s)->%s)",structTDarr[pSym->typeNum], 
                                   (GnotL?"yyySTsn":
                                          "(yyyTermBuffer.snBufPtr)"),
                                   pSym->sortAAList[attrbNum].id
             ); 
      else 
      fprintf(fp,"(((%s)(((char *)((yyySTN->cL)[%u]))+yyyGNSz))->%s)", 
              structTDarr[pSym->typeNum], 
              symPos-1, 
              pSym->sortAAList[attrbNum].id
             );  
  }


 

static void genTravCrefForAttrbRef(symPos,attrbNum,outFile)
  int symPos,attrbNum; 
  FILE *outFile;
  {struct gSym *pSym; 

   if ((symPos == -1) || (attrbNum == -1)) return; 
   pSym = &(gSymTable[prodBuffer2[symPos].gSymTabInd]);  
   if (!symPos) 
      fprintf(outFile,"(((%s)(%s))->%s)",structTDarr[pSym->typeNum], 
                                  "((char *)yyyTSTn)+yyyGNSz",
                                  pSym->sortAAList[attrbNum].id
             ); 
      else 
      fprintf(outFile,"(((%s)(((char *)((yyyTSTn->cL)[%u]))+yyyGNSz))->%s)", 
              structTDarr[pSym->typeNum], 
              symPos-1, 
              pSym->sortAAList[attrbNum].id
             );  
  }



static void genDecorCrefForAttrbRef(symPos,attrbNum,targetSymPos,
                                    targetAttrbNum,fp
                                   )
  int symPos,attrbNum,targetSymPos,targetAttrbNum; 
  FILE *fp;  
  {struct gSym *pSym; 

   if ((symPos == -1) || (attrbNum == -1)) return;  
   pSym = &(gSymTable[prodBuffer2[symPos].gSymTabInd]);  
   if ((symPos == targetSymPos) && (attrbNum == targetAttrbNum)) 
      {fprintf(fp,"(((%s)(((char *)yyyRSTopN)+yyyGNSz))->%s)",
                  structTDarr[pSym->typeNum],
                  pSym->sortAAList[attrbNum].id
              ); 
       return; 
      } 
   if (!symPos) 
      fprintf(fp,"(((%s)(((char *)yyyRefN)+yyyGNSz))->%s)",
                 structTDarr[pSym->typeNum], 
                 pSym->sortAAList[attrbNum].id
             ); 
      else  
      fprintf(fp,"(((%s)(((char *)((yyyRefN->cL)[%u]))+yyyGNSz))->%s)", 
              structTDarr[pSym->typeNum], 
              symPos-1, 
              pSym->sortAAList[attrbNum].id
             );  
  }
 



void translateAndOutputRefSeg(refType,pFirst,last,
                              targetSymPos,targetAttrbNum,fp 
                             ) 
  enum instRefType refType; 
  long *pFirst,last; 
  int targetSymPos,targetAttrbNum;  
  FILE *fp; 
  {char c; 
   int symPos,attrbNum;  
   int state = 1; 
   FILE *temp;

   if (neutralizeSemActions) 
      {temp = fp; 
       fp = tempTrashOut;
      }  
   while (*pFirst <= last) 
     {c = refSegBuffer[(*pFirst)++];  
      switch (state)   
        {case 1: switch(c) 
                   {case '#' : state = 2; break;   
                    default :  putc(c,fp); 
                   } 
                 break;  
         case 2: switch(c) 
                   {case '#' : putc('#',fp); state = 1; break;  
                    default  : sscanf(refSegBuffer+(*pFirst)-2,"#%7d",&symPos);
                               (*pFirst) += 6;  
                               sscanf(refSegBuffer+(*pFirst),",%7d",&attrbNum); 
                               (*pFirst) += 8; 
                               switch (refType)
                                 {case imm:
                                    genImmCrefForAttrbRef(symPos,attrbNum,1,fp);
                                    break;
                                  case decor:
                                    genDecorCrefForAttrbRef(symPos,
                                                            attrbNum, 
                                                            targetSymPos, 
                                                            targetAttrbNum, 
                                                            fp 
                                                           ); 
                                    break;
                                  case trav:
                                    genTravCrefForAttrbRef(symPos,
                                                           attrbNum,
                                                           fp
                                                          );
                                    break;
                                 }
                               state = 1;  
                   }
                 break; 
         default : ;   
        } 
     }  /* while */ 
   if (neutralizeSemActions) 
      {fp = temp;
      } 
  }  



void charOut(c,whereTo) 
  char c; 
  int whereTo; 
  {switch (whereTo) 
     {case outG  : putc(c,yoxOutG); break; 
      case outL  : putc(c,Lfile[currentLfile].outPtr); break; 
      case outGandL  : putc(c,yoxOutH); break; 
      case outT1 : putc(c,temp1Out); break; 
      case rsB   : putCharInRefSegBuffer(c); break;  
      case outMB : putCharInMacroDefBody(c); break;  
      case outTrv: putc(c,tempTravOut); break; 
      case SO:     putc(c,stdout); break;
      case SE:     putc(c,stderr); break;
      case nowhere: break;
      default    : putCharInLAbuffer(c,whereTo); break;   
     }  
  } 



void stringOut(str,whereTo)
  char *str;
  int whereTo; 
  {while (*str != '\0') charOut(*str++,whereTo);
  }



void lexemeOut(whereTo) 
  int whereTo;  
  {int i; 

   for (i=0;i<*pleng;i++) charOut(ptext[i],whereTo);  
  } 



void flushLAbuffer(whichBuf,whereTo) 
  int whichBuf,whereTo;  
  {FILE *echoOut; 
   int i=0; 
   int count; 

   switch (whereTo) 
     {case outG: echoOut = yoxOutG; break; 
      case outL: echoOut = Lfile[currentLfile].outPtr; break; 
      case outT1: echoOut = temp1Out; break; 
     }  
   switch (whichBuf)  
     {case LA1: 
      count=(LAbuffer1ArraySize<LAbuffer1Pointer)?
            LAbuffer1ArraySize:LAbuffer1Pointer;
      while (i < count) charOut(LAbuffer1Array[i++],whereTo);    
      if (LAbuffer1Pointer > LAbuffer1ArraySize) 
         {fclose(LAbuffer1File); 
          LAbuffer1File = fopen(LAbuffer1FileStr,"r"); 
          do 
            {LAbuffer1Pointer -= LAbuffer1ArraySize;  
             count=(LAbuffer1ArraySize<LAbuffer1Pointer)?
                   LAbuffer1ArraySize:LAbuffer1Pointer;
             fread(LAbuffer1Array,sizeof(char),count,LAbuffer1File); 
             fwrite(LAbuffer1Array,sizeof(char),count,echoOut); 
            } 
          while (LAbuffer1Pointer > LAbuffer1ArraySize);   
         } 
      LAbuffer1Pointer = 0; 
      break; 
      case LA2: 
      count=(LAbuffer2ArraySize<LAbuffer2Pointer)?
             LAbuffer2ArraySize:LAbuffer2Pointer;
      while (i < count) charOut(LAbuffer2Array[i++],whereTo);    
      if (LAbuffer2Pointer > LAbuffer2ArraySize) 
         {fclose(LAbuffer2File); 
          LAbuffer2File = fopen(LAbuffer2FileStr,"r"); 
          do 
            {LAbuffer2Pointer -= LAbuffer2ArraySize;  
             count=(LAbuffer2ArraySize<LAbuffer2Pointer)?
                   LAbuffer2ArraySize:LAbuffer2Pointer;
             fread(LAbuffer2Array,sizeof(char),count,LAbuffer2File); 
             fwrite(LAbuffer2Array,sizeof(char),count,echoOut); 
            } 
          while (LAbuffer2Pointer > LAbuffer2ArraySize);   
         } 
      LAbuffer2Pointer = 0; 
      break;
     }  
  } 



void eatCommentAndEcho(whereTo,echoStart) 
  int whereTo,echoStart;  
  {char c; 
   int state = 1; 
   int ECline = *plineno; 

#if S_DEBUG 
   debCom(); 
#endif
   if (echoStart)
      {charOut('/',whereTo); 
       charOut('*',whereTo); 
      }
   while (state != DFAACCEPT)  
     {c = lexinput();  
      if (c == '\0')
         {yerror("error: unterminated comment.\n");
          fprintf(stderr, "  comment began at line %5d\n",ECline);
          rmTempFiles();
          exit(-1);
         }
      charOut(c,whereTo); 
      switch (state)   
        {case 1: switch(c) 
                   {case '*' : state = 2; break;  
                    default : ;
                   } 
                 break;  
         case 2: switch(c) 
                   {case '*' : break;  
                    case '/' : state = DFAACCEPT; 
                               continue; 
                    default  : state = 1;  
                   }
                 break; 
         default : ;   
        } 
     }  /* while */ 
  } 



void eatStringAndEcho(whereTo) 
  int whereTo;  
  {char c; 
   char cPrev = ' '; 
   int state = 1; 
   int ESline = *plineno; 

#if S_DEBUG 
   debString(); 
#endif
   charOut('\"',whereTo); 
   while (state != DFAACCEPT)  
     {c = lexinput();  
      if (c == '\0')
         {yerror("error: unterminated string.\n");
          fprintf(stderr, "  string began at line %5d\n",ESline);
          rmTempFiles();
          exit(-1);
         }
      if ((cPrev == '\n') && (c != '\\'))
         {yerror("error: string contains newline.\n");
          fprintf(stderr, "  string began at line %5d\n",ESline);
          rmTempFiles();
          exit(-1);
         }
      charOut(c,whereTo); 
      switch (state)   
        {case 1: switch(c) 
                   {case '\\' : state = 2; break;  
                    case '\"' : state = DFAACCEPT; break;  
                    default : ;  
                   }
                 break;  
         case 2: state = 1; 
                 break; 
         default : ;   
        } 
      cPrev = c;
     }  /* while */
  } 





/* S_DEBUG is for debugging the scanner and/or the parser.  The person 
 * doing the debugging sets S_DEBUG to 1 and places comments in his test 
 * file at places at which he wants to know the start condition of the 
 * scanner.  The scanner will print a message to stderr giving the line 
 * number and the current start condition while reading that comment.  
 * Comments can appear about anywhere, so this can give a good picture of 
 * what is happening. 
*/  


/* The lookahead buffer is a fixed size main memory array LAbufferArray 
 * (that is supposed to be fast and supposed to almost always be big enough 
 * to hold the lookahead text) and file buffer LAbufferFile (that is probably  
 * slow, but of unlimited size).  putCharInLAbuffer(), 
 * copyLexemeToLAbuffer(), and flushLAbuffer() act on these data structures. 
 * Flushing the lookahead buffer when empty has no effect.  The main 
 * memory array part of the buffer is used as a buffer for flushing 
 * the file part of the buffer. 
*/ 

@EOF
set `sum $sumopt <oxDistG1.04/source/outMgr.c`; if test $1 -ne 47535
then
	echo ERROR: oxDistG1.04/source/outMgr.c checksum is $1 should be 47535
fi
set `wc -lwc <oxDistG1.04/source/outMgr.c`
if test $1$2$3 != 505139915508
then
	echo ERROR: wc results of oxDistG1.04/source/outMgr.c are $* should be 505 1399 15508
fi

chmod 755 oxDistG1.04/source/outMgr.c

if test -f oxDistG1.04/source/outMgr.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/outMgr.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/outMgr.h
	if test -f oxDistG1.04/source/outMgr.h
	then
		echo Error: could not remove oxDistG1.04/source/outMgr.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/outMgr.h
cat >oxDistG1.04/source/outMgr.h <<'@EOF'
/* $Header: outMgr.h,v 5.10 94/04/16 20:24:51 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

extern long refSegBufferSize;   
extern long refSegBufferPointer;  
extern long nextRefSegBufferStart;  
extern char *refSegBuffer; 

extern void putAttrbNumPairInRefSegBuffer();
extern void genImmCrefForAttrbRef();
extern void genTravCrefForAttrbRef();
extern void translateAndOutputRefSeg();
extern void charOut();
extern void stringOut();
extern void lexemeOut();
extern void flushLAbuffer();
extern void eatCommentAndEcho();
extern void eatStringAndEcho();

@EOF
set `sum $sumopt <oxDistG1.04/source/outMgr.h`; if test $1 -ne 26855
then
	echo ERROR: oxDistG1.04/source/outMgr.h checksum is $1 should be 26855
fi
set `wc -lwc <oxDistG1.04/source/outMgr.h`
if test $1$2$3 != 774242848
then
	echo ERROR: wc results of oxDistG1.04/source/outMgr.h are $* should be 77 424 2848
fi

chmod 755 oxDistG1.04/source/outMgr.h

if test -f oxDistG1.04/source/patchlvl.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/patchlvl.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/patchlvl.h
	if test -f oxDistG1.04/source/patchlvl.h
	then
		echo Error: could not remove oxDistG1.04/source/patchlvl.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/patchlvl.h
cat >oxDistG1.04/source/patchlvl.h <<'@EOF'
/* $Header: patchlvl.h,v 5.10 94/04/16 20:24:54 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#define PATCHLEVEL "Ox version G1.04"
#define VDATE "April 16, 1994"
@EOF
set `sum $sumopt <oxDistG1.04/source/patchlvl.h`; if test $1 -ne 58409
then
	echo ERROR: oxDistG1.04/source/patchlvl.h checksum is $1 should be 58409
fi
set `wc -lwc <oxDistG1.04/source/patchlvl.h`
if test $1$2$3 != 633922457
then
	echo ERROR: wc results of oxDistG1.04/source/patchlvl.h are $* should be 63 392 2457
fi

chmod 755 oxDistG1.04/source/patchlvl.h

if test -f oxDistG1.04/source/scan.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/scan.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/scan.c
	if test -f oxDistG1.04/source/scan.c
	then
		echo Error: could not remove oxDistG1.04/source/scan.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/scan.c
cat >oxDistG1.04/source/scan.c <<'@EOF'
/* $Header: scan.c,v 5.10 94/04/16 20:24:57 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <ctype.h>

#include "glob.h"
#include "opts.hh"
#include "opts.h"
#include "symTrans.h"

int whichScanner; 
int *plineno; 
int *pleng; 
char *ptext; 
char *inFileStr; 
int removeOutput = 0; 

int line; 
int nLbraces; 
int nLparens; 

char *IDbuffer; 

char *gsBuffer; 
int suffixBuffer;  
char *atBuffer; 

void fatal();

int alreadyAugmented = 0; 
char *startSymLexeme = (char *)NULL; 
char *dumNodeSym; 



yylex() 
  {switch(whichScanner) 
     {case 1           : return yy1lex();
      case 2           : return yy2lex();
      case LEXSCANNER  : return yy3lex();
      case GENSCANNER  : return yy5lex();
      case NOSCANNER   : return '\0';
      default: fprintf(stderr,"yylex: request for unknown scanner\n"); 
     } 
  } 



void reportloc (msg) 
  char *msg; 
  { 
   fprintf(stderr,"ox is in %s: line %d: %s",inFileStr,*plineno,msg);  
   flushAll(); 
  }
 

/* very handy for when Ox crashes: change the name of this to yylex.
 *                                 change the name of yylex to something else.
 */ 
yylexx() 
  {
   int temp;  

              reportloc("");
              fprintf(stderr,"calling scanner--whichScanner == %d\n",
                             whichScanner
                     ); 
   switch(whichScanner) 
     {case 1           : temp = yy1lex();    break;
      case 2           : temp = yy2lex();    break;
      case LEXSCANNER  : temp = yy3lex();    break;
      case GENSCANNER  : temp = yy5lex();    break;
      case NOSCANNER   : temp = '\0';        break;
      default: fprintf(stderr,"yylex: request for unknown scanner\n"); break;
     } 
              reportloc("");
             
              fprintf (stderr,"returning %d --whichScanner == %d\n\n" ,
                              temp,whichScanner
                      ); 
              return temp; 
  } 

void scanScanInit()
  {
   if (++currentLfile == nLfiles) 
      {whichScanner = NOSCANNER; 
       return;
      }
   switch (whichScanner = Lfile[currentLfile].scanner)
     {case LEXSCANNER : scanInit3(); break;
      case GENSCANNER : scanInit5(); break;
      default         : fatal("scanScanInit: unknown scanner\n"); break;
     }
  }



printAugmentationProduction() 
  {if (startSymLexeme == (char *)NULL) startSymLexeme = IDbuffer; 
   fprintf(yoxOutG,"%s \n\t:\t{if (!yyyInitDone) \n", 
                    augNstr
          ); 
   fprintf(yoxOutG,"\t\t    {yyyYoxInit(); \n");  
   fprintf(yoxOutG,"\t\t     yyyInitDone = 1;\n"); 
   fprintf(yoxOutG,"\t\t    }\n"); 
   fprintf(yoxOutG,"\t\t yyyYoxReset();\n\t\t}\n\t\t%s\n",
                   startSymLexeme 
          ); 
   fprintf(yoxOutG,"\t\t{\n"); 
   if (treeShow) fprintf(yoxOutG,"\t\t yyyDebugAccept();\n"); 
   if (xTreeShow) fprintf(yoxOutG,"\t\t yyyXshowTree();\n");
   fprintf(yoxOutG,"\t\t yyyDecorate(); yyyExecuteRRsection();\n"); 
   fprintf(yoxOutG,"\t\t}\n\t;\n"); 
   alreadyAugmented = 1; 
  } 
 


/* Print the name of the current file and the number of the current line.
   Set a flag to remember to discard the output.
*/
void yerror (msg) 
  char *msg; 
  {fprintf(stderr,"ox: %s: near line %d: %s",inFileStr,*plineno,msg);  
   flushAll();
   removeOutput = 1; 
  }
 
/* void yerror(nMsgs, ...)  
  int nMsgs;   
  va_list ap; 
  {int i;
   char *msg;

   va_start(ap,nMsgs);   
   fprintf(stderr,"ox: %s: line %d:  ",inFileStr,*plineno);  
   for (i=0;i<nMsgs;i++) 
       {msg = va_arg(ap,char *); 
        fprintf(stderr,"%.80s",msg);
       }  
   flushAll(); 
   va_end(ap); 
  } 
*/ 



void scanAttrbName(ptext,leng) 
  char *ptext;
  int leng;
  {int charConstSym;  
   int i,k; 

   suffixBuffer = 0; 
   charConstSym = (ptext[0] == '\'');  
   i = leng - 1; 
   while ((i >= 0) && (ptext[i] != '.')) i--; 
   if (((i == -1) || (i == (leng - 1))) ||  
       ((atBuffer = stringLookup(ptext+i+1,leng-i-1,0)) == (char *)NULL) 
      ) 
      goto err; 
      else 
      ptext[i--] = ' ';  
   if (!charConstSym) 
      {if ((gsBuffer = stringLookup(ptext,i+1,0)) != (char *)NULL) return;}
      else
      {if (ptext[i] == '\'') 
          {if ((gsBuffer = getFirstTextOfCC(stringLookup(ptext,i+1,1)))
               == 
               (char *)NULL
              )
              goto err;
              else
              return;  
          }
      }
   k = i;
   while ((i >= 0) && (isdigit(ptext[i]))) i--;  
   if ((i == -1) || (i == k) || (ptext[i] != '.')) goto err; 
   i--;   
   sscanf(ptext+i+2,"%d",&suffixBuffer);  
   if (!charConstSym)
      {if ((gsBuffer = stringLookup(ptext,i+1,0)) != (char *)NULL) return; 
          else goto err;
      }
      else  
      {if ((gsBuffer = getFirstTextOfCC(stringLookup(ptext,i+1,1)))  
           != 
           (char *)NULL 
          )
          return;
          else
          goto err; 
      } 
err:
   {yerror("syntax error or unknown identifier in attribute name:\n"); 
    fprintf(stderr,"     %s \n",ptext); 
    suffixBuffer = -1; 
    return;  
   } 
  } 



char stringHasChar(cp,c)
  char *cp,c;
  {int i = 0;
 
   while ((cp[i] != c) && (cp[i] != '\0')) i++; 
   return(cp[i]);  
  }


 
void ywarning (msg) 
  char *msg; 
  { 
   fprintf(stderr,"ox: %s: warning: line %d: %s",inFileStr,*plineno,msg);  
   flushAll(); 
  }
 


/* Print a string, remove temporary files and output files, and exit */ 
void fatal(msg)    
  char *msg; 
  {yerror(msg); 
   fprintf(stderr,"  fatal error\n");
   rmTempFiles();
   rmOutputFiles();
   exit(-1);    
  } 



yyerror(msg)  char *msg; 
  {if (strcmp(msg,"syntax error")) yerror(msg);
       else
       yerror("syntax error\n"); 
  } 



int getScnState() 
  {switch(whichScanner) 
     {case 1: return yy1ScnState(); 
      case 2: return yy2ScnState(); 
      case 3: return yy3ScnState(); 
      case 5: return yy5ScnState(); 
      default: fprintf(stderr,"getScnState: unknown scanner\n"); 
     } 
  } 



int debCom() 
  {fprintf(stderr,"eating comment at line %5d in scanner %d in sc %5d\n", 
	   *plineno,whichScanner,getScnState());   
  } 


 
int debString() 
  {fprintf(stderr,"eating string at line %5d in scanner %d in sc %5d\n", 
	   *plineno,whichScanner,getScnState());   
  } 


 
int debReportSC(str) 
  char *str;
  {ywarning(str);
   fprintf(stderr," in scanner %5d in sc %5d\n", 
	          whichScanner,getScnState()
          );  
  } 



/* EOGFRET becomes the start condition upon the first execution of yywrap(). 
 * Its only purpose is to cause the scanner to return a token to signify 
 * to the parser that the end of the file containing the syntactic 
 * specification has been encountered.  
*/ 
 

@EOF
set `sum $sumopt <oxDistG1.04/source/scan.c`; if test $1 -ne 14884
then
	echo ERROR: oxDistG1.04/source/scan.c checksum is $1 should be 14884
fi
set `wc -lwc <oxDistG1.04/source/scan.c`
if test $1$2$3 != 34510688956
then
	echo ERROR: wc results of oxDistG1.04/source/scan.c are $* should be 345 1068 8956
fi

chmod 755 oxDistG1.04/source/scan.c

if test -f oxDistG1.04/source/scan.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/scan.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/scan.h
	if test -f oxDistG1.04/source/scan.h
	then
		echo Error: could not remove oxDistG1.04/source/scan.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/scan.h
cat >oxDistG1.04/source/scan.h <<'@EOF'
/* $Header: scan.h,v 5.10 94/04/16 20:24:59 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include "ytab.h"

extern void scanInit1(); 
extern void scanInit2(); 
extern void scanInit3(); 
extern void scanInit4(); 
extern void scanInit5(); 
extern void scanScanInit();


extern char *IDbuffer; 
extern char *gsBuffer; 
extern char *dumNodeSym; 
extern char *atBuffer;
extern char *startSymLexeme;
extern int suffixBuffer;
extern int alreadyAugmented; 
extern int nLbraces; 
extern int nLparens; 
extern int whichScanner; 
extern int line; 
extern int removeOutput;

extern int *plineno; 
extern int *pleng; 
extern char *ptext; 

extern char stringHasChar();
extern char *getFirstTextOfCC(); 
extern void yerror(); 
extern void fatal(); 
extern void ywarning(); 
extern void reportloc(); 
extern void rmTempFiles();

extern char *inFileStr; 
extern char *yoxInFileStrL; 
extern char *yoxOutFileStrH; 

extern void afterAllAttrbDecls(); 
extern void scanAttrbName(); 

@EOF
set `sum $sumopt <oxDistG1.04/source/scan.h`; if test $1 -ne 40011
then
	echo ERROR: oxDistG1.04/source/scan.h checksum is $1 should be 40011
fi
set `wc -lwc <oxDistG1.04/source/scan.h`
if test $1$2$3 != 1034833261
then
	echo ERROR: wc results of oxDistG1.04/source/scan.h are $* should be 103 483 3261
fi

chmod 755 oxDistG1.04/source/scan.h

if test -f oxDistG1.04/source/symTrans.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/symTrans.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/symTrans.c
	if test -f oxDistG1.04/source/symTrans.c
	then
		echo Error: could not remove oxDistG1.04/source/symTrans.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/symTrans.c
cat >oxDistG1.04/source/symTrans.c <<'@EOF'
/* $Header: symTrans.c,v 5.10 94/04/16 20:25:02 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <stdio.h> 
#include <limits.h> 
#include <ctype.h>
#include <string.h>

#include "glob.h" 
#include "opts.hh"
#include "opts.h"
#include "scan.h"
#include "joinTabs.h"



/* Here follow some data structures for giving serial numbers to objects 
 * encountered in ox's input.  These sequences most of the time hold the 
 * value of the *next* serial number to be used, rather than the one that 
 * was *just* used. 
 */ 
/************************************************************************/ 
/* an increasing sequence of numbers to represent terminals of the grammar 
 */
#define firstTermNum 1 
int termSeq = firstTermNum; 



/* a decreasing sequence of numbers to represent nonterminals of the grammar 
 */
static int nontermSeq = -1; 



/* an increasing sequence of numbers to represent productions of the grammar 
*/
#define firstProdNum 1 
int prodNumSeq = firstProdNum; 



int attrbDeclAttrbOccurSeq = 0;



/* an increasing sequence of numbers to represent kinds of nodes of the 
   parse trees of the language 
 */  
#define NOTYPE 0 
#define firstStructTagNum (NOTYPE+1) 
int structTagNumSeq = firstStructTagNum; 
/************************************************************************/


/* holds the identifier for the structure that Ox creates for each given 
   type of node  */ 
static char **structTagArr;  



/* true if at least one grammar symbol appears in some attribute
   declaration  
 */
int atLeastOneSymHasAttrbs = 0;



/* holds the identifier for the typedef for the above structure  */ 
char **structTDarr;  



/* Here follow some parameters to be set at evaluator generation time. 
 * Generally they may be changed from ox's command line. 
 */ 
/*******************************************************************/ 

/* The size of the array of pointers to "canonical" copies 
 * of lexemes (other than 
 * those for ox reserved words) found in ox's input.  
 * These strings will mostly be:
 * 1) identifiers and 2) strings that represent character constants.  
 */  
int maxNstrings = 1231;  


/* The biggest permitted numbers of: grammar symbols, productions, 
 * attributes of one symbol, 
 * symbols in one production, kinds of parse tree nodes.  
 */  
int maxNgSyms = 509; 
int maxNprods = 1024; 
int maxNattrbsPerSym =  256;  
int maxProdLength = 256;  
int maxNstructTags = 256;
/*******************************************************************/ 


/* `sort' is used in the sense of `kind'.
 * sortAAListBuffer[i] is a structure that holds attributes of 
 * of the ith attribute of the @attributes declaration being processed. 
 * Each sort corresponds to exactly one use of @attributes.  The buffer
 * holds the list of attributes of attributes for the sort 
 * declaration being processed.
 */  
static struct sortAttrbAttrbs *sortAAListBuffer;  

/* points into sortAAListBuffer */   
static int sortAAListBufPtr; 


/* stringTable[i] is either (char *)NULL or a canonical string 
 */ 
static char **stringTable; 


/* stringAttrbsTable[i] contains attributes of stringTable[i]  
 */ 
struct autoSynOrInh *stringAttrbsTable; 


/* holds information about the current symbol in the current production
   until ready to install the symbol in the symbol table */  
static struct gSym gSymBuffer; 


/* the table of grammar symbols */  
struct gSym *gSymTable;  



int bufPosInProd;  /* The position of an attribute occurrence in a rule */
int bufAttrbNum;   /* The serial number of the attribute in an occurrence */



/* points into prodBuffer2 */ 
int prodBufferPointer2 = 0; 

/* holds pointers to information about the symbols of the rule being 
   parsed
 */ 
struct pb2 *prodBuffer2; 

int errorProd; 

/*  generates and returns a pointer to a permanent null-terminated copy 
 *  of the first len characters of the string cp 
 */  
static char *allocString(cp,len) 
  char *cp; 
  int len; 
  {char *ncp, *str_save; 

   if ((ncp = ((char *) malloc(len+1))) 
       == 
       ((char *) NULL) 
      )  
      fatal("internal malloc error in allocString"); 
   str_save = ncp; 
   while (len--) 
         *ncp++ = *cp++; 
   *ncp = '\0';  
   return(str_save); 
  } 



/*  compute a hash value for a string */  
static stringHash(cp,len) 
  char *cp; 
  int len; 
  {int hashval; 

   switch (hashval = len) 
     {default: hashval += cp[len - 2] * 512; 
      case 3:  hashval += cp[len - 1] * 64; 
      case 2:  hashval += cp[1] * 8; 
      case 1:  hashval += *cp; break;  
      case 0:  fatal("internal error: can't seek the empty string.\n"); 
     }
   return(hashval); 
  } 



/* Search the string table for a string matching the first len characters of
 * cp.  If it is absent and insertion is requested, insert it, returning
 * a pointer to a permanent null-terminated copy.  
 * If absent and insertion not requested, return null pointer.  
 * If already present, return pointer to the null-terminated copy. 
 * Fatal error upon attempt to insert into full table.
 */  
char *stringLookup(cp,len,insertIfAbsent) 
  char *cp; 
  int len; 
  int insertIfAbsent; 
  {int i,try;  
   char **dum; 

   try = stringHash(cp,len) % maxNstrings; 
   for (i=0; i<maxNstrings; i++) 
       {dum = stringTable + try;  
        try = (try + 1) % maxNstrings;     
        if (*dum == (char *)NULL) 
           {if (insertIfAbsent) *dum = allocString(cp,len); 
            return(*dum); 
           } 
        if (strlen(*dum) != len) continue; /* don't match proper prefixes */ 
        if (!strncmp(*dum,cp,len)) return(*dum); 
       } 
   fatal("out of room in string table");  
  } 



void printStringTab()
  {int i;

   for (i=0; i<maxNstrings; i++)
     {if ((i % 5) == 0) fprintf(tempStringTabFile,"\n",i);
      if (stringTable[i] != ((char *)NULL))
        fprintf(tempStringTabFile,"\"%s\",",stringTable[i]);
      else
        fprintf(tempStringTabFile,"0,");
     }
  }



/* for debugging */
void *showStringTab() 
  {int i;  

   for (i=0; i<maxNstrings; i++) 
       if (stringTable[i] != ((char *)NULL))
          printf("%.5d   %s\n",i,stringTable[i]);
  } 



/* Search the string table for a string matching the null-terminated string 
 * cp.  When found, return the string's position in the string table. 
 * Never call unless the string has already been inserted into the table.
 */  
int stringIndexLookup(cp) 
  char *cp; 
  {int i,try;  
   char **dum; 

   try = stringHash(cp,(int)strlen(cp)) % maxNstrings; 
   for (i=0; i<maxNstrings; i++) 
       {dum = stringTable + try;  
        if (*dum == (char *)NULL) 
           fatal("stringIndexLookup: string not found");  
        if (!strcmp(*dum,cp)) return(try); 
        try = (try + 1) % maxNstrings;     
       } 
   fatal("stringIndexLookup: string not found");  
  } 



/* translate a representation of a character constant (read from ox's input) 
 * into the value of that constant on the machine on which ox is executing. 
 * This is useful when the target machine has the same character set as the 
 * machine on which ox is run.  For instance, if the C compilers on both 
 * machines use ASCII (for instance, when the ox-running machine
 * is the same machine as the target machine), then ox knows that 'A' 
 * means the same as '\201'.   
 *
 * This is related to an undocumented feature that should probably 
 * be eliminated.
 */ 
static unsigned char cctouc(cp) 
  char *cp; 
  {int temp; 

   if (strlen(cp) == 3) return((unsigned char) cp[1]); 
   switch (cp[2]) 
      {case 'n':  return((unsigned char) '\n'); 
       case 't':  return((unsigned char) '\t'); 
       case 'v':  return((unsigned char) '\v'); 
       case 'b':  return((unsigned char) '\b'); 
       case 'r':  return((unsigned char) '\r'); 
       case 'f':  return((unsigned char) '\f'); 
       case 'a':  yerror("unsupported escape sequence");
                  return((unsigned char) 'a'); 
       case '\\': return((unsigned char) '\\'); 
       case '?':  return((unsigned char) '?' ); 
       case '\'': return((unsigned char) '\''); 
       case '\"': return((unsigned char) '\"'); 
       default :  sscanf(cp,"\'\\%o\'",&temp);  
                  return((unsigned char) temp);  
      }   
  } 



/* stores the canonical textual representations of string representations
 * of character constants. Used exactly when CSCDMeqCSCM.  
 */ 
static char *firstTextOfCC[UCHAR_MAX+1]; 
  


/* returns the first-encountered string representation of a character constant, 
   one of whose string representations has just been encountered. 
 */ 
char *getFirstTextOfCC(cp) 
  char *cp; 
  {unsigned char ind; 

   if (!CSCDMeqCSCM) return(cp);  
   ind = cctouc(cp); 
   if (firstTextOfCC[ind] == (char *)NULL) firstTextOfCC[ind] = cp; 
   return(firstTextOfCC[ind]);  
  } 



/* get the index into the grammar symbol table for a symbol, given 
 * its canonical string 
 */  
int gSymLookup(cp) 
  char *cp;  
  {int i,try; 

   if (*cp == '\'') cp = getFirstTextOfCC(cp);  
   try = (stringHash(cp,(int)strlen(cp)) % maxNgSyms); 
   for (i=0; i<maxNgSyms; i++) 
       {if (gSymTable[try].lexeme == cp) 
           return(try); 
        if (gSymTable[try].lexeme == (char *)NULL) return(-1); 
        try = ((try + 1) % maxNgSyms);  
       } 
   return(-1);   
  } 



/* This runs soon after each encounter of the @attributes reserved word. 
 * 
 *   {
 *    characterize this sort by the current value of 
 *        structTagNumSeq after checking for overflow;
 *    get a block of characters to store the tag of this type of node, 
 *        such tag to be generated later in this routine, and such 
 *        tag to become part of a struct-specifier in the 
 *        generated C program.    
 *    get a block of characters to store a C identifier that will be 
 *        used in a typedef in the generated C program.  
 *    write the struct tag into the alotted space. 
 *    write the identifier for the typedef into its alotted space.  
 *    write the structure declaration to the Y-file.  
 *    write the structure declaration to the L-file.  
 *    get the node-type numbering sequence ready for next time.  
 *   } 
 */  
void initForAttrbDeclList() 
  {sortAAListBufPtr = 0; 
   if ((gSymBuffer.typeNum = structTagNumSeq) == maxNstructTags) 
      handleOverflow(MNST);   
   if ((structTagArr[structTagNumSeq] = (char *) malloc(10)) 
        == 
        ((char *) NULL) 
       )   
       fatal("malloc error in struct tag name allocation\n"); 
   if ((structTDarr[structTagNumSeq] = (char *) malloc(10)) 
        == 
        ((char *) NULL) 
       )   
       fatal("malloc error in struct tag name allocation\n"); 
   sprintf(structTagArr[structTagNumSeq],"yyyT%d\0",structTagNumSeq); 
   sprintf(structTDarr[structTagNumSeq],"yyyP%d\0",structTagNumSeq); 
   fprintf(yoxOutH,"\n\nstruct %s ",structTagArr[structTagNumSeq]);  
   structTagNumSeq++; 
  } 



void stringAutoDef(cp,syn,inh,warn)
  char *cp,syn,inh,warn;
  {int ind;
   int asln, ailn;

   if (stringHasChar(cp,'.')) yerror("period in attribute name\n"); 

   ind = stringIndexLookup(cp);
   asln = stringAttrbsTable[ind].autoSynLineno; 
   ailn = stringAttrbsTable[ind].autoInhLineno; 

   if (((asln != -1) && inh)
       ||
       ((ailn != -1) && syn)
      )
      {yerror("global @autosyn and global @autoinh\n"); 
       fprintf(stderr,"   declarations for ");
       fprintf(stderr,"%s: near lines %d and %d\n\n",
               cp,
               (asln == -1)? *plineno : asln,
               (ailn == -1)? *plineno : ailn
              );
       return;
      }
   if ((asln != -1) && syn)
      {ywarning("duplicate global @autosyn \n"); 
       fprintf(stderr,"   declarations for ");
       fprintf(stderr,"%s: near lines %d and %d\n\n",cp,asln,*plineno);
      }
   if ((ailn != -1) && inh)
      {ywarning("duplicate global @autoinh \n"); 
       fprintf(stderr,"   declarations for ");
       fprintf(stderr,"%s: near lines %d and %d\n\n",cp,ailn,*plineno);
      }
   if ((syn) && (asln == -1)) stringAttrbsTable[ind].autoSynLineno = *plineno;
   if ((inh) && (ailn == -1)) stringAttrbsTable[ind].autoInhLineno = *plineno;
   stringAttrbsTable[ind].autoWarn |= warn;
  }



/* inside ox, attributes declared for each symbol have attributes. 
 * These are called attribute attributes. This gets an array of structures,
 * one for each attribute of the current symbol.  It then initializes, 
 * for each attribute of the current node, its attribute IorSknown and 
 * possibly InotS. 
 * There is an array of struct symAttrbAttrbs for each symbol.  There is
 * an array of struct sortAttrbAttrbs for each sort, pointed to by each
 * struct gSym of that sort. 
 * 
 */  
static struct symAttrbAttrbs *allocSymAAList(len) 
  int len;  
  {int i; 
   struct symAttrbAttrbs *dum; 

   if ((dum = (struct symAttrbAttrbs *) 
              malloc((size_t)(len * sizeof(struct symAttrbAttrbs)))
       ) 
       != 
       ((struct symAttrbAttrbs *) NULL) 
      )   
      {for (i=0;i<len;i++) 
           {
            dum[i].IorSknown = 0; 
            if (sortAAListBuffer[i].autoDef.autoSynLineno != -1)
               {dum[i].IorSknown = 1; 
                dum[i].InotS = 0; 
               }
            if (sortAAListBuffer[i].autoDef.autoInhLineno != -1)
               {dum[i].IorSknown = 1; 
                dum[i].InotS = 1; 
               }
           }
       return (dum); 
      } 
      else  
      fatal("malloc error in attribute attributes list allocation\n");  
  } 



/* Things are complicated by permitting attribute declarations to 
   appear anywhere before the first %% mark.  There are different
   occasions for installing grammar symbols.  To simplify things,
   probably Ox should be changed such that attribute declarations 
   not appear before %token and %start.  
 */ 
int installGsymAfterAttrbDeclList(cp) 
  char *cp;  
  {int i,try;

   atLeastOneSymHasAttrbs = 1;
   gSymBuffer.lexeme = (cp[0] == '\'') ? getFirstTextOfCC(cp) : cp;  
   try = stringHash(gSymBuffer.lexeme,
                    (int)strlen(gSymBuffer.lexeme)
                   ) 
         % 
         maxNgSyms
         ;
   for (i=0; i<maxNgSyms; i++) 
       {if ((gSymTable[try].lexeme == gSymBuffer.lexeme) &&  
            (gSymTable[try].typeNum != NOTYPE)
           )  
           {yerror("attributes redeclared for grammar symbol: "); 
            fprintf(stderr,"%s  %s.\n",gSymBuffer.lexeme,cp); 
            return(-1);  
           }  
        if ((gSymTable[try].lexeme == gSymBuffer.lexeme) || 
            (gSymTable[try].lexeme == (char *)NULL)
           )   
           {gSymTable[try].lexeme = gSymBuffer.lexeme; 
            gSymTable[try].sortAAList = gSymBuffer.sortAAList; 
            gSymTable[try].nAttrbs = gSymBuffer.nAttrbs; 
            gSymTable[try].typeNum = gSymBuffer.typeNum; 
            gSymTable[try].symAAList = 
               allocSymAAList(sortAAListBufPtr); 
            return(try); 
           }  
        try = ((try + 1) % maxNgSyms);  
       } 
   fatal("full grammar symbol table\n"); 
  } 



int installGsymAsTokenIfNew(cp) 
  char *cp; 
  {int i,try;

   cp = (cp[0] == '\'') ? getFirstTextOfCC(cp) : cp;  
   try = (stringHash(cp,(int)strlen(cp)) % maxNgSyms);  
   for (i=0; i<maxNgSyms; i++) 
       {if (gSymTable[try].lexeme == cp)   
           {if (gSymTable[try].symNum == -1) 
               yerror("start symbol redeclared as token\n"); 
            if (gSymTable[try].symNum == 0) 
               {if (termSeq == maxNterms) 
                   handleOverflow(NTRM);  
                gSymTable[try].symNum = termSeq++; 
               }
            return(try); 
           }  
           else 
           if (gSymTable[try].lexeme == (char *)NULL) 
              {gSymTable[try].lexeme = cp; 
               if (termSeq == maxNterms) 
                  handleOverflow(NTRM);  
               gSymTable[try].symNum = termSeq++; 
               return(try);  
              }  
        try = ((try + 1) % maxNgSyms);  
       } 
   fatal("full grammar symbol table\n"); 
  } 



int installStartSym(cp) 
  char *cp; 
  {int i,try;

   try = (stringHash(cp,(int)strlen(cp)) % maxNgSyms);
   for (i=0; i<maxNgSyms; i++) 
       {if (gSymTable[try].lexeme == cp)   
           {if (gSymTable[try].symNum > 0) 
               yerror("token redeclared as start symbol\n"); 
               else 
               gSymTable[try].symNum = nontermSeq--;  
            return(try); 
           }  
        if (gSymTable[try].lexeme == (char *)NULL) 
           {gSymTable[try].lexeme = cp; 
            gSymTable[try].symNum = nontermSeq--; 
            return(try);  
           }  
        try = ((try + 1) % maxNgSyms);  
       } 
   fatal("full grammar symbol table\n"); 
  } 
 


int installGsymAsNontermIfNew(cp) 
  char *cp; 
  {int i,try;

   try = (stringHash(cp,(int)strlen(cp)) % maxNgSyms);
   for (i=0; i<maxNgSyms; i++) 
       {if (gSymTable[try].lexeme == cp)   
           {if (gSymTable[try].symNum != 0) 
               return(try); 
               else  
               {gSymTable[try].symNum = nontermSeq--; 
                return(try);  
               }
           }  
        if (gSymTable[try].lexeme == (char *)NULL) 
           {gSymTable[try].lexeme = cp; 
            gSymTable[try].symNum = nontermSeq--; 
            return(try);  
           }  
        try = ((try + 1) % maxNgSyms);  
       } 
   fatal("full grammar symbol table\n"); 
  } 


 
char autoSyn;
char autoInh;
char autoWarning;

void bufferAnAttrbID(cp,syn,inh,warn) 
  char *cp,syn,inh,warn; 
  {int ind;
   int asln,ailn;
   char aw;

   if (sortAAListBufPtr == maxNattrbsPerSym) 
      fatal("too many attributes declared for a grammar symbol\n"); 
   if ((cp[0] == '\'') || isdigit(cp[0]) || (stringHasChar(cp,'.')))
      yerror("syntax error in attribute identifier\n"); 
   if (syn && inh)
      {yerror("declaration of local @autosyn and local @autoinh\n");
       fprintf(stderr,"   for %s near line %d. \n",cp,*plineno);
       inh = 0;
      }

   ind = stringIndexLookup(cp);
   asln = stringAttrbsTable[ind].autoSynLineno; 
   ailn = stringAttrbsTable[ind].autoInhLineno; 
   aw = stringAttrbsTable[ind].autoWarn; 

   if ((asln != -1) && inh) 
      {yerror("declaration of global @autosyn and local @autoinh\n");
       fprintf(stderr,"   for %s near lines %d and %d.\n\n",cp,asln,*plineno); 
       inh = 0;
      }
   if ((ailn != -1) && syn) 
      {yerror("declaration of global @autoinh and local @autosyn\n");
       fprintf(stderr,"   for %s near lines %d and %d.\n\n",cp,ailn,*plineno); 
       syn = 0;
      }
   sortAAListBuffer[sortAAListBufPtr].autoDef.autoSynLineno =   
             (asln != -1) ? asln : (syn ? *plineno : -1);
   sortAAListBuffer[sortAAListBufPtr].autoDef.autoInhLineno =   
             (ailn != -1) ? ailn : (inh ? *plineno : -1);
   sortAAListBuffer[sortAAListBufPtr].id = cp;  
   sortAAListBuffer[sortAAListBufPtr].autoDef.autoWarn = aw || warn;  
   sortAAListBufPtr++;  
  } 
 

/* Output the typedef for the node type just read. 
   Allocate a permanent list of attribute attributes 
   to be pointed to by the grammar symbol table entry of each symbol
   of this sort.  Check
   whether, upon this sort, a new maximum number of attributes
   per sort has been reached. Copy the buffer for the list of declared 
   attribute ids into the permanent list, deleting duplicates.  
   Except in case of duplicates, original order of appearance in the 
   declaration list is preserved.
*/
void afterAttrbDeclList()  
  {struct sortAttrbAttrbs *dum; 
   int i,j; 

   if (((structTagNumSeq-firstStructTagNum-1) % 10) == 0) 
     fprintf(tempSortIndFile,"\n");
   fprintf(tempSortIndFile,"%3.1d,",attrbDeclAttrbOccurSeq); 

   fprintf(yoxOutH,"; \ntypedef struct %s *%s; \n",
                   structTagArr[gSymBuffer.typeNum], 
                   structTDarr[gSymBuffer.typeNum] 
          ); 
   if ((dum = (struct sortAttrbAttrbs *) 
              malloc((sortAAListBufPtr * sizeof(struct sortAttrbAttrbs)))
       ) 
       == 
       ((struct sortAttrbAttrbs *) NULL) 
      )   
      fatal("malloc error in sort attribute attribute list allocation\n"); 
      if (sortAAListBufPtr > WAmax) WAmax = sortAAListBufPtr - 1; 
      for (i=0; i<sortAAListBufPtr; i++) 
        {for (j=0; j<i; j++)  
           if (dum[j].id == sortAAListBuffer[i].id) 
              {yerror(
                 "\n  attribute name used twice for same grammar symbol: "
                     );
               fprintf(stderr,"%s \n",dum[j].id); 
               break;
              }  
         dum[i] = sortAAListBuffer[i]; 
         if (j != i) dum[i].id = (char *)NULL; 
         if ((attrbDeclAttrbOccurSeq % 10) == 0)
           fprintf(tempSortNumsFile,"\n"); 
         fprintf(tempSortNumsFile,"%5.1d,",stringIndexLookup(dum[j].id)); 
         attrbDeclAttrbOccurSeq++;
        } 
      gSymBuffer.sortAAList = dum; 
      gSymBuffer.nAttrbs = sortAAListBufPtr; 
  }  



#define maxNwyes 256 

void setupDumNodeSym() 
  {char wyes[maxNwyes]; 
   int i; 

   wyes[0] = 'y'; 
   for (i=1; i<maxNwyes; i++) 
       {wyes[i] = 'y'; 
        if (stringLookup(wyes,i,0) == (char *)NULL) break;  
       }
   if (i == maxNwyes) fatal("out of room for wyes\n");   
   dumNodeSym = stringLookup(wyes,i,1);  
   installGsymAsTokenIfNew(dumNodeSym);  
  }  



static char *nsText1[] = 
{  
"       {yyyNdSz[i] = yyyCeiling(yyyNdSz[i],yyyAlignSize); \n",
"        yyyNdPrSz[i] = yyyNdSz[i] + yyyGNSz;\n",
/*
"        fprintf(stderr,\"yyyNdPrSz[%d] == %d\\n\",i,yyyNdPrSz[i]);\n",   
*/ 
"        if (yyyBiggestNodeSize < yyyNdSz[i])\n",
"           yyyBiggestNodeSize = yyyNdSz[i];\n",
"        yyyNdCopySz[i] = yyyCeiling(yyyNdSz[i],sizeof(yyyCopyType)) / \n",
"                         sizeof(yyyCopyType); \n",
"       }\n",
"  }\n\n",
};

 

static void printNodeSizeCalcTail() 
  {int i; 

   for (i=0;i < (sizeof(nsText1)/sizeof(char *));i++) 
     fprintf(temp1Out,"%s",nsText1[i]);
  } 



void afterAllAttrbDecls() 
  {int i;

   fprintf(temp1Out,"\n#define yyyCeiling(num,inc) ");   
   fprintf(temp1Out,"(((inc) * ((num)/(inc))) + (((num)%%(inc))?(inc):0)) \n"); 
   fprintf(temp1Out,"\n\n\nint yyyAlignSize = %d;",alignSize);   
   fprintf(temp1Out,"\nint yyyNdSz[%d];\n",structTagNumSeq);   
   fprintf(temp1Out,"\nint yyyNdPrSz[%d];\n",structTagNumSeq);   
   fprintf(temp1Out,"\ntypedef int yyyCopyType;\n",structTagNumSeq);   
   fprintf(temp1Out,"\nint yyyNdCopySz[%d];\n",structTagNumSeq);   
   fprintf(temp1Out,"long yyyBiggestNodeSize = 0;\n");  
   fprintf(temp1Out,"\nvoid yyyNodeSizeCalc()\n"); 
   fprintf(temp1Out,"  {int i;\n");  
   fprintf(temp1Out,"   yyyGNSz = yyyCeiling(yyyGNSz,yyyAlignSize); \n");   
   fprintf(temp1Out,"   yyyNdSz[0] = 0;\n");  
   for (i=1;i<structTagNumSeq;i++) 
       fprintf(temp1Out,"   yyyNdSz[%d] = sizeof(struct %s);\n",
                        i,structTagArr[i] 
              );  
   fprintf(temp1Out,"   for (i=0;i<%d;i++) \n",structTagNumSeq);   
   printNodeSizeCalcTail(); 
}



void incProdNumSeq() 
  {if ((++prodNumSeq) == maxNprods) 
      handleOverflow(NPRD);  
  } 

 

void putSymbolInProdBuffer2(tabInd)             
  int tabInd;  
  {if (prodBufferPointer2 > WSmax) WSmax = prodBufferPointer2;            
   if (prodBufferPointer2 < maxProdLength)            
      {prodBuffer2[prodBufferPointer2].lexeme = gSymTable[tabInd].lexeme; 
       prodBuffer2[prodBufferPointer2].gSymTabInd = tabInd; 
       if (!strcmp(gSymTable[tabInd].lexeme,"error")) errorProd = 1; 
       prodBufferPointer2++;
      } 
      else                                            
      handleOverflow(PRDL);   
  } 




/* translates (gsBuffer,suffixBuffer,atBuffer) into 
              (bufPosInProd,bufAttrbNum) 
*/
void transAttrbNameToNumPair() 
  {struct gSym dum; 
   int nTimesSymSeen = 0; 

   bufPosInProd = 0; 
   bufAttrbNum = 0; 
   if (suffixBuffer == -1) goto err2;  
   while (bufPosInProd<prodBufferPointer2) 
     {if (prodBuffer2[bufPosInProd].lexeme == gsBuffer) 
         {if (suffixBuffer == nTimesSymSeen) 
             break; 
             else 
             nTimesSymSeen++;
         }  
      bufPosInProd++; 
     }    
   if (bufPosInProd == prodBufferPointer2) goto err; 
   dum = gSymTable[prodBuffer2[bufPosInProd].gSymTabInd];  
   while (bufAttrbNum < dum.nAttrbs) 
     {if (dum.sortAAList[bufAttrbNum].id == atBuffer) 
         return;
         else
         bufAttrbNum++;
     }
err:
   yerror("attribute name not valid for this production: \n    "); 
   fprintf(stderr,"%s.%d.%s\n",gsBuffer,suffixBuffer,atBuffer);  
err2: 
   bufPosInProd = -1; 
   bufAttrbNum = -1; 
   return;  
  } 



void prepareDataStructures1() 
  {int i;

   if ((stringTable = (char **) malloc(maxNstrings * sizeof(char *)))
       != 
       ((char **) NULL) 
      )   
      for (i=0; i<maxNstrings; i++) stringTable[i] = (char *)NULL; 
      else 
      fatal("malloc error in string table allocation\n");  

   if ((stringAttrbsTable = 
          (struct autoSynOrInh *) malloc(maxNstrings * 
                                         sizeof(struct autoSynOrInh)
                                        )
       )  
       != 
       ((struct autoSynOrInh *) NULL) 
      )   
      for (i=0; i<maxNstrings; i++) 
          {stringAttrbsTable[i].autoSynLineno = -1; 
           stringAttrbsTable[i].autoInhLineno = -1; 
          }
      else 
      fatal("malloc error in string-attributes-table allocation\n");  

   if ((gSymTable = 
        ((struct gSym *) malloc(sizeof(struct gSym) * maxNgSyms )) 
       )  
       != 
       ((struct gSym *) NULL) 
      )   
      for (i=0; i<maxNgSyms; i++) 
          {gSymTable[i].symNum = 0; 
           gSymTable[i].lexeme = (char *)NULL; 
           gSymTable[i].nAttrbs = 0; 
           gSymTable[i].typeNum = NOTYPE; 
           gSymTable[i].lineOfFirstOccr = -1; 
          } 
      else 
      fatal("out of memory for grammar symbol table \n"); 

   for (i=0;i<=UCHAR_MAX;i++) firstTextOfCC[i] = (char *)NULL;  
  
   if ((structTagArr = (char **) malloc(maxNstructTags * sizeof(char *)))  
       == 
       ((char **) NULL) 
      )   
      fatal("malloc error in struct tag string array allocation\n");  

   if ((structTDarr = (char **) malloc(maxNstructTags * sizeof(char *)))  
       == 
       ((char **) NULL) 
      )   
      fatal("malloc error in struct typedef string array allocation\n");  

   if ((sortAAListBuffer = 
        (struct sortAttrbAttrbs *) malloc(maxNattrbsPerSym * 
                                          sizeof(struct sortAttrbAttrbs)
                                         )
       )  
       == 
       ((struct sortAttrbAttrbs *) NULL) 
      )   
      fatal("malloc error: sort attribute attribute list buffer allocation\n");  
   if ((prodBuffer2 = 
        (struct pb2 *) malloc(maxProdLength * sizeof(struct pb2))
       )  
       == 
       ((struct pb2 *) NULL) 
      )   
      fatal("malloc error in production buffer allocation\n");  
   
  }


@EOF
set `sum $sumopt <oxDistG1.04/source/symTrans.c`; if test $1 -ne 26690
then
	echo ERROR: oxDistG1.04/source/symTrans.c checksum is $1 should be 26690
fi
set `wc -lwc <oxDistG1.04/source/symTrans.c`
if test $1$2$3 != 952325629336
then
	echo ERROR: wc results of oxDistG1.04/source/symTrans.c are $* should be 952 3256 29336
fi

chmod 755 oxDistG1.04/source/symTrans.c

if test -f oxDistG1.04/source/symTrans.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/symTrans.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/symTrans.h
	if test -f oxDistG1.04/source/symTrans.h
	then
		echo Error: could not remove oxDistG1.04/source/symTrans.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/symTrans.h
cat >oxDistG1.04/source/symTrans.h <<'@EOF'
/* $Header: symTrans.h,v 5.10 94/04/16 20:25:05 bischoff Exp $ */ 

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

extern int maxProdLength;
extern int maxNattrbsPerSym;
extern int maxNstrings;
extern int maxNgSyms;
extern int maxNstructTags;
extern int maxNprods;

extern int termSeq; 
extern int prodNumSeq; 
extern int structTagNumSeq;
extern int attrbDeclAttrbOccurSeq;
extern char **structTDarr;  
extern struct gSym *gSymTable;  
extern int bufPosInProd; 
extern int bufAttrbNum; 
extern int atLeastOneSymHasAttrbs;

extern char autoSyn;
extern char autoInh;
extern char autoWarning;

extern int prodBufferPointer2; 
extern long gsOccurSeq;
extern struct pb2 *prodBuffer2; 
extern int errorProd; 

extern char *stringLookup(); 
extern int stringIndexLookup();
extern void *showStringTab();
extern void printStringTab();
extern char *getFirstTextOfCC();
extern int gSymLookup();

extern void initForAttrbDeclList();

extern int installGsymAfterAttrbDeclList();
extern int installGsymAsTokenIfNew();
extern int installStartSym();
extern int installGsymAsNontermIfNew();
 
extern void bufferAnAttrbID(); 
extern void afterAttrbDeclList();  
extern void setupDumNodeSym(); 
extern void afterAllAttrbDecls(); 
extern void incProdNumSeq();
extern void putSymbolInProdBuffer2();
extern void transAttrbNameToNumPair();
extern void prepareDataStructures1();
extern void stringAutoDef();

@EOF
set `sum $sumopt <oxDistG1.04/source/symTrans.h`; if test $1 -ne 6970
then
	echo ERROR: oxDistG1.04/source/symTrans.h checksum is $1 should be 6970
fi
set `wc -lwc <oxDistG1.04/source/symTrans.h`
if test $1$2$3 != 1115103659
then
	echo ERROR: wc results of oxDistG1.04/source/symTrans.h are $* should be 111 510 3659
fi

chmod 755 oxDistG1.04/source/symTrans.h

if test -f oxDistG1.04/source/trav.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/trav.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/trav.c
	if test -f oxDistG1.04/source/trav.c
	then
		echo Error: could not remove oxDistG1.04/source/trav.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/trav.c
cat >oxDistG1.04/source/trav.c <<'@EOF'
/* $Header: trav.c,v 5.10 94/04/16 20:25:08 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <stdio.h>

#include "glob.h"
#include "opts.hh"
#include "opts.h"
#include "symTrans.h"
#include "joinTabs.h"
#include "outMgr.h"

int travNumSeq = -1;
int maxNtravs = 64;
struct trav *travArr; 
struct trav travBuf;

int maxNtravSegBufs = 64;
struct travSegBuf *travSegBufArr,*lambdaTSB,travSegBufBuf;
int travSegBufAvail;
static int maxNactions = 0;

int currentTrav;



void newTrav(id)
  char *id;
  {if ((travBuf.RL && travBuf.LR) 
       ||
       (travBuf.PRE && travBuf.POST)
      )
      yerror("contradictory traversal declaration\n");
   if (!travBuf.RL  && !travBuf.LR)   travBuf.LR   = 1;
   if (!travBuf.PRE && !travBuf.POST) travBuf.POST = 1;
   if (travNumSeq == maxNtravs) handleOverflow(NTRV);
   travArr[travNumSeq] = travBuf; 
   travArr[travNumSeq].id = id; 
   travArr[travNumSeq].dirRevCondStartPtr = 
              travArr[travNumSeq].dirRevCondStopPtr = 0; 
   travArr[travNumSeq].nActions = 0;
   travArr[travNumSeq].TSBlist = lambdaTSB;
   travNumSeq++; 
  }



void clearTravBuf()
  {travBuf.RL = 0; 
   travBuf.LR = 0; 
   travBuf.PRE = 0; 
   travBuf.POST = 0; 
   travBuf.DA = 0;
  }



int travLookup(id)
  char *id;
  {int i;

   for (i=0; i<travNumSeq; i++) 
     if (id == travArr[i].id) return i;
   yerror("unknown traversal:\n");
   fprintf(stderr,"  %s\n",id);
   fatal("unknown traversal or syntax error.\n");
  } 



void clearErrorTrav()
  {travArr[-1].dirRevCondStartPtr = travArr[-1].dirRevCondStopPtr = 0; 
   travArr[-1].nActions = 0; 
   travArr[-1].TSBlist = lambdaTSB;
  }



void outputTravCodePerProd()
  {int i,j;
   struct travSegBuf *TSBdum;

   if (!travNumSeq) return;
   fprintf(tempTravOut,"case %d:\n",prodNumSeq-1);
   if (travNumSeq > 1) fprintf(tempTravOut,"\tswitch(yyyi)\t{ \n"); 
   for (i=0; i<travNumSeq; i++) 
     {if (travNumSeq > 1) fprintf(tempTravOut,"\t\tcase %d:\n",i);
      fprintf(tempTravOut,"\t\t\tswitch(yyyPass)\t{\n");
      fprintf(tempTravOut,"\t\t\t\tcase 0:\n");
      fprintf(tempTravOut,"yyyRL = "); 
      if (travArr[i].dirRevCondStartPtr != travArr[i].dirRevCondStopPtr)
         {if (!travArr[i].LR) fprintf(tempTravOut,"!");
          if (neutralizeSemActions) fprintf(tempTravOut,"1");
          translateAndOutputRefSeg(trav,
                                   &(travArr[i].dirRevCondStartPtr),
                                   travArr[i].dirRevCondStopPtr,
                                   DONTCARE,DONTCARE,tempTravOut
                                  ); 
         }
         else
         fprintf(tempTravOut,"%d",!travArr[i].LR);
      fprintf(tempTravOut,";");
      TSBdum = travArr[i].TSBlist;
      j = 0; 
      while (TSBdum != lambdaTSB)
        {if (TSBdum->orderRevCondStartPtr != TSBdum->orderRevCondStopPtr)
            {fprintf(tempTravOut,"\nif (");
             if (!travArr[i].POST) fprintf(tempTravOut,"!");
             translateAndOutputRefSeg(trav,
                                      &(TSBdum->orderRevCondStartPtr),
                                      TSBdum->orderRevCondStopPtr,
                                      DONTCARE,DONTCARE,tempTravOut
                                     );
             fprintf(tempTravOut,") yyySetCond(%d)\n",j);
            }
            else
            {if (!travArr[i].POST) fprintf(tempTravOut,"yyySetCond(%d)\n",j);
            }
         TSBdum = TSBdum->next;
         j++;
        }
      fprintf(tempTravOut,"\n\t\t\t\tcase 1:\n");  
      TSBdum = travArr[i].TSBlist;
      j = 0; 
      while (TSBdum != lambdaTSB)
        {fprintf(tempTravOut,"\nif (yyyCond(%d) != yyyPass) {",j); 
         translateAndOutputRefSeg(trav,
                                  &(TSBdum->actionStartPtr),
                                  TSBdum->actionStopPtr,
                                  DONTCARE,DONTCARE,tempTravOut
                                 );
         fprintf(tempTravOut,"}"); 
         TSBdum = TSBdum->next;
         j++;
        }
      fprintf(tempTravOut,"\n\t\t\t\tbreak;\n");
      fprintf(tempTravOut,"\t\t\t\t\t}\n"); 
      if (travNumSeq > 1) fprintf(tempTravOut,"\t\tbreak;\n"); 
      if (maxNactions < travArr[i].nActions) 
         maxNactions = travArr[i].nActions;
      travArr[i].nActions = 0; 
      travArr[i].TSBlist = lambdaTSB; 
     } /* for */
   if (travNumSeq > 1) fprintf(tempTravOut,"\t\t\t}\n"); 
   fprintf(tempTravOut,"\nbreak;\n");
   travSegBufAvail = 0;  
   clearErrorTrav();
  }



static void printTravDefines(fp)
  FILE *fp;
  {fprintf(fp,"\n\n\n"); 
   if      (maxNactions <= 16) 
      {fprintf(fp,"#define condStg unsigned int conds;\n");
       fprintf(fp,"#define yyyClearConds {yyyTST->conds = 0;}\n");
       fprintf(fp,"#define yyySetCond(n) {yyyTST->conds += (1<<(n));}\n");
       fprintf(fp,"#define yyyCond(n) ((yyyTST->conds & (1<<(n)))?1:0)\n");
      }
   else if (maxNactions <= 32)
      {fprintf(fp,"#define condStg unsigned long conds;\n");
       fprintf(fp,"#define yyyClearConds {yyyTST->conds = 0;}\n");
       fprintf(fp,"#define yyySetCond(n) {yyyTST->conds += (1<<(n));}\n");
       fprintf(fp,"#define yyyCond(n) ((yyyTST->conds & (1<<(n)))?1:0)\n");
      }
   else 
      {fprintf(fp,
           "#define yyyNCW ceiling(%d,sizeof(unsigned int))];\n",maxNactions
              );
       fprintf(fp,"#define condStg unsigned int conds[yyyNCW];\n");
       fprintf(fp,
   "#define yyyClearConds {int i; for (i=0;i<yyyNCW;i++)yyyTST->conds[i]=0;}\n"
              );
       fprintf(fp, 
         "#define yyySetCond(n) {yyyTST->conds[(n)/sizeof(unsigned int)] "
              );
       fprintf(fp,"+= (1<<(n%%sizeof(unsigned int)));}\n");
       fprintf(fp,
        "#define yyyCond(n) ((yyyTST->conds[(n)/sizeof(unsigned int)] "
              );
       fprintf(fp,"& (1<<(n%%sizeof(unsigned int))))?1:0)\n");
      }
  }



void startTravDirCond()
  {if (travArr[currentTrav].dirRevCondStartPtr 
       !=
       travArr[currentTrav].dirRevCondStopPtr 
      )
      {yerror("multiple @revdirection\n");
       fprintf(stderr,"  traversal name: %s\n",travArr[currentTrav].id);
      }
   travArr[currentTrav].dirRevCondStartPtr = travSegBufBuf.actionStartPtr;
  }



void startTravOrderCond()
  {if (travSegBufBuf.orderRevCondStartPtr 
       != 
       travSegBufBuf.orderRevCondStopPtr
      )
      {yerror("multiple @revorder\n");
       fprintf(stderr,"  traversal name: %s\n",travArr[currentTrav].id);
      }
   travSegBufBuf.orderRevCondStartPtr = travSegBufBuf.actionStartPtr;
  }



void startTravAction()
  {travSegBufBuf.actionStartPtr = refSegBufferPointer;}



void wrapUpTravDirCond()
  {travArr[currentTrav].dirRevCondStopPtr = refSegBufferPointer - 1;}



void wrapUpTravOrderCond()
  {travSegBufBuf.orderRevCondStopPtr = refSegBufferPointer - 1;}



static void clearTSBbuf()
  {travSegBufBuf.orderRevCondStartPtr = travSegBufBuf.orderRevCondStopPtr = 0;
   travSegBufBuf.actionStartPtr = travSegBufBuf.actionStopPtr;
  }



void wrapUpTravAction()
  {struct travSegBuf **pTSBdum;

   travSegBufBuf.actionStopPtr = refSegBufferPointer - 1;
   travSegBufBuf.next = lambdaTSB;
   travSegBufArr[travSegBufAvail] = travSegBufBuf;
   clearTSBbuf();
   travArr[currentTrav].nActions++; 
   pTSBdum = &(travArr[currentTrav].TSBlist);
   while (*pTSBdum != lambdaTSB) pTSBdum = &((*pTSBdum)->next);
   *pTSBdum =  travSegBufArr + travSegBufAvail;
   travSegBufAvail++; 
   nextRefSegBufferStart = refSegBufferPointer;
  }



char *ct45[] = 
{
"\n",
"\n",
"\n",
"struct yyyTravStackItem {yyyGNT *node; \n",
"                         char isReady;\n",
"                         condStg\n",
"                        };\n",
"\n",
"\n",
"\n",
"void yyyDoTraversals()\n",
"{struct yyyTravStackItem *yyyTravStack,*yyyTST,*yyyAfterTravStack;\n",
" register yyyGNT *yyyTSTn,**yyyCLptr1,**yyyCLptr2; \n",
" register int yyyi,yyyRL,yyyPass;\n",
"\n",
" if (!yyyYok) return;\n",
" if ((yyyTravStack = \n",
"                 ((struct yyyTravStackItem *) \n",
"                  malloc((yyyTravStackMaxSize * \n",
"                                  sizeof(struct yyyTravStackItem)\n",
"                                 )\n",
"                        )\n",
"                 )\n",
"     )\n",
"     == \n",
"     (struct yyyTravStackItem *)NULL\n",
"    ) \n",
"    {fprintf(stderr,\"malloc error in traversal stack allocation\\n\"); \n",
"     exit(-1); \n",
"    } \n",
"\n",
"yyyAfterTravStack = yyyTravStack + yyyTravStackMaxSize; \n",
"yyyTravStack++; \n",
"\n",
"\n",
};



char *ct45_5[] = 
{
"yyyTST = yyyTravStack; \n",
"yyyTST->node = yyyStack->node;\n",
"yyyTST->isReady = 0;\n",
"yyyClearConds\n",
"\n",
"while(yyyTST >= yyyTravStack)\n",
"  {yyyTSTn = yyyTST->node;\n",
"   if (yyyTST->isReady)  \n",
"      {yyyPass = 1;\n",
"       goto yyyTravSwitch;\n",
"yyyTpop:\n",
"       yyyTST--;\n",
"      } \n",
"      else \n",
"      {yyyPass = 0;\n",
"       goto yyyTravSwitch;\n",
"yyyTpush:\n",
"       yyyTST->isReady = 1;  \n",
"       if (yyyTSTn->prodNum)\n",
"          if (yyyRL)\n",
"             {yyyCLptr2 = yyyTSTn->cL; \n",
"              while \n",
"                ((yyyCLptr2 != yyyNextCLspace)\n",
"                 &&\n",
"                 ((*yyyCLptr2)->parent == yyyTSTn) \n",
"                )  \n",
"                {if (++yyyTST == yyyAfterTravStack)\n",
"                    yyyHandleOverflow(yyyTSof);\n",
"                    else\n",
"                    {yyyTST->node = *yyyCLptr2; \n",
"                     yyyTST->isReady = 0; \n",
"                     yyyClearConds\n",
"                    }\n",
"                 yyyCLptr2++; \n",
"                } \n",
"             } /* right to left */\n",
"             else  /* left to right */\n",
"             {yyyCLptr1 = yyyCLptr2 = yyyTSTn->cL; \n",
"              while \n",
"                ((yyyCLptr2 != yyyNextCLspace)\n",
"                 &&\n",
"                 ((*yyyCLptr2)->parent == yyyTSTn) \n",
"                )  \n",
"                yyyCLptr2++; \n",
"              while (yyyCLptr2-- > yyyCLptr1)\n",
"                if (++yyyTST == yyyAfterTravStack)\n",
"                   yyyHandleOverflow(yyyTSof);\n",
"                   else\n",
"                   {yyyTST->node = *yyyCLptr2; \n",
"                    yyyTST->isReady = 0; \n",
"                    yyyClearConds\n",
"                   }\n",
"             } /* left to right */\n",
"      } /* else */\n",
"   continue;\n",
"yyyTravSwitch:\n",
"\t\t\t\tswitch(yyyTSTn->prodNum)\t{\n",
};



char *ct48[] = 
{
"\t\t\t\t\t\t\t\t} /* switch */ \n",
"   if (yyyPass) goto yyyTpop; else goto yyyTpush; \n",
"  } /* while */ \n",
" } /* for */ \n",
"} /* yyyDoTraversals */ \n",
"\n",
}; 



int someTravEnabled()
  {int i;

   for (i=0;i<travNumSeq;i++) if (! travArr[i].DA) return 1;
   return 0;
  }



void printTravCode()
  {int i;
  
   if (!travNumSeq) 
      {fprintf(temp1Out,"void yyyDoTraversals(){}\n");
       return;
      }
   printTravDefines(temp1Out);
   printStringArray(ct45,sizeof(ct45),temp1Out);
   fprintf(temp1Out,"for (yyyi=0; yyyi<%d; yyyi++) {\n",travNumSeq);
   for (i=0;i<travNumSeq;i++) 
       if (travArr[i].DA)  fprintf(temp1Out,"if (yyyi == %d) continue;\n",i);
   printStringArray(ct45_5,sizeof(ct45_5),temp1Out);
   appendToOutFile(tempTravOut,tempTravFileID,temp1Out); 
   printStringArray(ct48,sizeof(ct48),temp1Out);
  } 



@EOF
set `sum $sumopt <oxDistG1.04/source/trav.c`; if test $1 -ne 24568
then
	echo ERROR: oxDistG1.04/source/trav.c checksum is $1 should be 24568
fi
set `wc -lwc <oxDistG1.04/source/trav.c`
if test $1$2$3 != 454127713665
then
	echo ERROR: wc results of oxDistG1.04/source/trav.c are $* should be 454 1277 13665
fi

chmod 755 oxDistG1.04/source/trav.c

if test -f oxDistG1.04/source/trav.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/trav.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/trav.h
	if test -f oxDistG1.04/source/trav.h
	then
		echo Error: could not remove oxDistG1.04/source/trav.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/trav.h
cat >oxDistG1.04/source/trav.h <<'@EOF'
/* $Header: trav.h,v 5.10 94/04/16 20:25:11 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

extern void newTrav();
extern void clearTravBuf();
extern void printTravCode();
extern void outputTravCodePerProd();
extern void startTravDirCond();
extern void startTravOrderCond();
extern void startTravAction();
extern void wrapUpTravAction();
extern void wrapUpTravDirCond();
extern void wrapUpTravOrderCond();
extern void printTravCode();
extern int travLookup();
extern int someTravEnabled();

extern struct trav *travArr;
extern struct trav travBuf;
extern struct travSegBuf *travSegBufArr,*lambdaTSB;

extern int maxNtravs;
extern int maxNtravSegBufs;
extern int travSegBufAvail;
extern int currentTrav;

@EOF
set `sum $sumopt <oxDistG1.04/source/trav.h`; if test $1 -ne 60470
then
	echo ERROR: oxDistG1.04/source/trav.h checksum is $1 should be 60470
fi
set `wc -lwc <oxDistG1.04/source/trav.h`
if test $1$2$3 != 844452996
then
	echo ERROR: wc results of oxDistG1.04/source/trav.h are $* should be 84 445 2996
fi

chmod 755 oxDistG1.04/source/trav.h

if test -f oxDistG1.04/source/treeShow.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/treeShow.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/treeShow.c
	if test -f oxDistG1.04/source/treeShow.c
	then
		echo Error: could not remove oxDistG1.04/source/treeShow.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/treeShow.c
cat >oxDistG1.04/source/treeShow.c <<'@EOF'
/* $Header: treeShow.c,v 5.10 94/04/16 20:25:13 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <stdio.h>
#include "ctc.h"
#include "opts.h" 


char *ptt[] = {
"/* NIO == Node-image Object */\n",
"/* STI == Subtree Image  */\n",
"\n",
"#define yyySTpad 1\n",
"\n",
"long yyyNIOspaceSize;\n",
"long yyySTIrowNumMax;\n",
"long yyySTInextColumn;\n",
"\n",
"int yyyAccept;\n",
"\n",
"struct yyyStackItem yyySTIstTemp;\n",
"\n",
/* "void yyySTIstUpdate()\n", */
/* "  {\n", */
/* "   yyyStackTop->STIwidth = yyySTIstTemp.STIwidth;\n", */
/* "   yyyStackTop->rootNIOx = yyySTIstTemp.rootNIOx;\n", */
/* "   yyyStackTop->STIleftEdge = yyySTIstTemp.STIleftEdge;\n", */
/* "   yyyStackTop->oldestNIO = yyySTIstTemp.oldestNIO;\n", */
/* "  }\n", */
/* "\n", */
/* "\n", */
/* "\n", */
"FILE *yyyTreeShowFile;\n",
"\n",
"@@C@FILE *yyysfopen(name,mode) \n",
"@@C@  char *name,*mode;  \n",
"@@A@FILE *yyysfopen(char *name, char *mode) \n",
"  {FILE *dum; \n",
"\n",
"   if ((dum = fopen(name,mode)) \n",
"       == \n",
"       ((FILE *)NULL) \n",
"      ) \n",
"      {fprintf(stderr,\"fatal error opening %%s.\\n\",name); \n",
"       exit(-1); \n",
"      } \n",
"      else \n",
"      return dum; \n",
"  } \n",
"\n",
"\n",
"\n",
"struct yyyNIO {long x;\n",
"               long y;\n",
"               char *str;\n",
"               short isLeaf;\n",
"              };\n",
"\n",
"static struct yyyNIO *yyyNIOspace;\n",
"static struct yyyNIO *yyyAfterNIOspace;\n",
"static struct yyyNIO *yyyNextNIO;\n",
"\n",
"static long yyynShifts;\n",
"static long yyynReductions;\n",
"static long yyynStackOps;\n",
"\n",
"static long yyyNextShiftsBreak;\n",
"static long yyyNextReductionsBreak;\n",
"static long yyyNextStackOpsBreak;\n",
"\n",
"static long yyyPTSwinUpperEdge;\n",
"static long yyyPTSwinLeftEdge;\n",
"\n",
"#define yyyTERMIO 0\n",
"\n",
"#if yyyTERMIO \n",
"\n",
"#include <termio.h> \n",
"struct termio yyyTtyS;\n",
"struct termio yyyTtyH;\n",
"\n",
"#else\n",
"\n",
"struct sgttyb yyyTtyS;\n",
"struct sgttyb yyyTtyH;\n",
"\n",
"#endif\n",
"\n",
"int yyyttyin;\n",
"WINDOW *yyyStatusLine;\n",
"\n",
"\n",
"\n",
"void yyyDebugInit()\n",
"  {\n",
"   yyyNIOspaceSize = 100000;\n",
"   if ((yyyNIOspace = (struct yyyNIO *) \n",
"         malloc((yyyNIOspaceSize * sizeof(struct yyyNIO)))\n",
"       )  \n",
"       == \n",
"       ((struct yyyNIO *) NULL) \n",
"      )   \n",
"      yyyfatal(\"malloc error in ox node image object allocation\\n\");\n",
"   yyyAfterNIOspace = yyyNIOspace + yyyNIOspaceSize; \n",
"   yyyTreeShowFile = stdout;\n",
"   if (strcmp(\"\",yyyTreeShowFileStr))\n",
"      yyyTreeShowFile = yyysfopen(yyyTreeShowFileStr,\"w\");\n",
"   initscr();\n",
"   yyyStatusLine = newwin(1,COLS-1,LINES-1,0);\n",
"   wstandout(yyyStatusLine);\n",
"   yyyttyin = 2;\n",
"#if yyyTERMIO \n",
"   ioctl(yyyttyin,TCGETA,&yyyTtyS); \n",
"   yyyTtyH = yyyTtyS; \n",
"   yyyTtyS.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL); \n",
"   yyyTtyS.c_cc[VMIN] = 1; \n",
"   yyyTtyS.c_cc[VTIME] = 0; \n",
"\n",
"#else\n",
"   ioctl(yyyttyin,TIOCGETP,&yyyTtyS); \n",
"   yyyTtyH = yyyTtyS; \n",
"   yyyTtyS.sg_flags |= CBREAK; \n",
"   yyyTtyS.sg_flags &= ~(ECHO|XTABS); \n",
"\n",
"#endif\n",
"  }\n",
"\n",
"\n",
"\n",
"@@C@void yyyMakeLNIOlookahead(label)\n",
"@@C@  char *label;\n",
"@@A@void yyyMakeLNIOlookahead(char *label)\n",
"  {\n",
"   yyyTermBuffer.NIOstr = label;\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyMakeLNIOshift()\n",
"  {int len;\n",
"\n",
"   if (yyyNextNIO == yyyAfterNIOspace)\n",
"      {fprintf(stderr,\"yyyNIOspace overflow\\n\");\n",
"       /* yyyHandleOverflow */\n",
"       exit(-1);\n",
"      }\n",
"   yyyNextNIO->y = 0;\n",
"   len = strlen(yyyNextNIO->str = yyyTermBuffer.NIOstr);\n",
"   yyyStackTop->rootNIOx = \n",
"     yyyNextNIO->x =\n",
"       (yyyStackTop->STIleftEdge = yyySTInextColumn) +\n",
"       yyySTpad + len/2;\n",
"   yyySTInextColumn += (yyyStackTop->STIwidth = 2*yyySTpad + len);\n",
"   yyyNextNIO->isLeaf = 1;\n",
"   yyyStackTop->oldestNIO = yyyNextNIO++;\n",
"  }\n",
"\n",
"\n",
"\n",
"@@C@long yyyRoundFloatToLong(f)\n",
"@@C@  float f;\n",
"@@A@long yyyRoundFloatToLong(float f)\n",
"  {\n",
"   return (((long)(f * 10.0)) >= 5 + (10 * ((long)f)))?\n",
"          ((long)(f) + 1):\n",
"          (long)(f);\n",
"  }\n",
"\n",
"\n",
"\n",
"@@C@void yyyMakeINIOpreReduce(label)\n",
"@@C@  char *label;\n",
"@@A@void yyyMakeINIOpreReduce(char *label)\n",
"  {\n",
"   int i,j,rightShift;\n",
"   long oldWidth = 0;\n",
"   struct yyyNIO *NIOdum;\n",
"   float slope;\n",
"   char *stickStr;\n",
"   long newPos, minNewPos, maxNewPos;\n",
"   long posSum = 0;\n",
"   \n",
"   for (i=0; i<yyyRHSlength; i++)\n",
"      {\n",
"       oldWidth += yyyStackTop[-i].STIwidth;\n",
"       posSum +=   yyyStackTop[-i].rootNIOx;\n",
"      }\n",
"   yyySTIstTemp.STIwidth = (2 * yyySTpad) + strlen(label);\n",
"   if (yyySTIstTemp.STIwidth < oldWidth) yyySTIstTemp.STIwidth = oldWidth;\n",
"   rightShift = (yyySTIstTemp.STIwidth - oldWidth)/2;\n",
"   if (yyyRHSlength)\n",
"      {\n",
"       for (NIOdum = yyyStackTop[1-yyyRHSlength].oldestNIO;\n",
"            NIOdum < yyyNextNIO;\n",
"            NIOdum++\n",
"           )\n",
"           {\n",
"            NIOdum->x += rightShift;\n",
"            NIOdum->y += 2;\n",
"            if (NIOdum->y > yyySTIrowNumMax) yyySTIrowNumMax = NIOdum->y;\n",
"           }\n",
"      }\n",
"   if (yyyNextNIO + yyyRHSlength + 1 >= yyyAfterNIOspace)\n",
"      {fprintf(stderr,\"yyyNIOspace overflow\\n\");\n",
"       /* yyyHandleOverflow */\n",
"       exit(-1);\n",
"      }\n",
"\n",
"   if (yyyRHSlength)\n",
"      yyyNextNIO->x = rightShift +\n",
"         yyyRoundFloatToLong((float)posSum / (float)yyyRHSlength);\n",
"      else\n",
"      {yyyNextNIO->x = yyySTInextColumn + yyySTIstTemp.STIwidth/2;\n",
"       yyyNextNIO->y = 1;\n",
"       yyyNextNIO->str = \"|\";\n",
"       yyySTIstTemp.STIleftEdge = yyySTInextColumn;\n",
"       yyySTIstTemp.oldestNIO = yyyNextNIO;\n",
"       yyyNextNIO->isLeaf = 0;\n",
"       yyyNextNIO++;\n",
"       yyyNextNIO->x = (yyyNextNIO - 1)->x;\n",
"      }\n",
"   yyySTInextColumn += (yyySTIstTemp.STIwidth - oldWidth);\n",
"   yyySTIstTemp.rootNIOx = yyyNextNIO->x;\n",
"   yyyNextNIO->y = 0;\n",
"   yyyNextNIO->str = label;\n",
"   yyyNextNIO->isLeaf = 0;\n",
"   yyyNextNIO++;\n",
"\n",
"   if (yyyRHSlength == 1)\n",
"      {\n",
"       stickStr = \"|\";\n",
"       newPos =  yyyStackTop[0].rootNIOx + rightShift;\n",
"       yyyNextNIO->x = (yyySTIstTemp.rootNIOx + newPos)/2;\n",
"       yyyNextNIO->y = 1;\n",
"       yyyNextNIO->str = stickStr;\n",
"       yyyNextNIO->isLeaf = 0;\n",
"       yyyNextNIO++;\n",
"      }\n",
"   if (yyyRHSlength > 1)\n",
"      {\n",
"       minNewPos = maxNewPos = yyySTIstTemp.rootNIOx; \n",
"       for (i=0; i<yyyRHSlength; i++)\n",
"          {\n",
"           newPos =  yyyStackTop[-i].rootNIOx + rightShift;\n",
"           if (newPos < minNewPos) minNewPos = newPos;\n",
"           if (newPos > maxNewPos) maxNewPos = newPos;\n",
"          }\n",
"       yyyNextNIO->x = minNewPos + ((maxNewPos - minNewPos)/2);\n",
"       yyyNextNIO->y = 1;\n",
"       yyyNextNIO->str = (char *)malloc(sizeof(char) * \n",
"                                        ((maxNewPos - minNewPos) + 1)\n",
"                                       );\n",
"       for (j=minNewPos; j<yyySTIstTemp.rootNIOx; j++)\n",
"           yyyNextNIO->str[j-minNewPos] = \'\\'\'; \n",
"       for (; j<maxNewPos; j++)\n",
"           yyyNextNIO->str[j-minNewPos] = \'`\'; \n",
"       yyyNextNIO->str[j-minNewPos] = \'\\0\'; \n",
"       yyyNextNIO->isLeaf = 0;\n",
"       yyyNextNIO++;\n",
"      }\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyMakeINIOpostReduce()\n",
"  {\n",
"   yyyStackTop->STIwidth = yyySTIstTemp.STIwidth;\n",
"   yyyStackTop->rootNIOx = yyySTIstTemp.rootNIOx;\n",
"   if (!yyyRHSlength)\n",
"      {\n",
"       yyyStackTop->STIleftEdge = yyySTIstTemp.STIleftEdge;\n",
"       yyyStackTop->oldestNIO = yyySTIstTemp.oldestNIO;\n",
"      }\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyPTSshowToFile()\n",
"  {char *screen, *cp;\n",
"   long nextColTemp;\n",
"   long i,len,screenSize;\n",
"   struct yyyNIO *NIOdum;\n",
"\n",
"   nextColTemp = yyySTInextColumn + 1;\n",
"   screenSize = (yyySTIrowNumMax + 1) * nextColTemp;\n",
"   screen = (char *)malloc( (screenSize * sizeof(char)));\n",
"   if (screen == (char *)NULL)\n",
"      yyyfatal(\"malloc error in ox node image screen allocation\\n\");\n",
"   for (i=0; i<nextColTemp; i++)\n", 
"      screen[i] = \' \';\n", 
"   for (i=nextColTemp; i<screenSize; i++)\n",
"      screen[i] = \' \';\n",
"   for (i=1; i<=(yyySTIrowNumMax + 1); i++)\n",
"      screen[(i * nextColTemp) - 1] = \'\\n\';\n",
"   for (NIOdum = yyyNIOspace; NIOdum < yyyNextNIO; NIOdum++)\n",
"     {\n",
"      len = strlen(NIOdum->str);\n",
"      cp = screen + ((NIOdum->y * nextColTemp) + NIOdum->x)\n",
"                  - yyySTpad - len/2 ;\n",
"      for (i=0; i < yyySTpad; i++) *cp++ = \' \';\n",
"      strcpy(cp,NIOdum->str); cp += len;\n",
"      for (i=0; i < yyySTpad; i++) *cp++ = \' \';\n",
"     }\n",
"   for (i=0; i<screenSize; i++)\n",
"      fputc(screen[i],yyyTreeShowFile);\n",
"   free((void *)screen);\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyPTSshowToFileAux()\n",
"  {int i;\n",
"\n",
"   fputc(\'\\n\',yyyTreeShowFile);\n",
"   fputc(\'\\n\',yyyTreeShowFile);\n",
"   fputc(\'\\n\',yyyTreeShowFile);\n",
"   for (i=0; i< yyySTInextColumn; i++)\n", 
"      fputc(\'#\',yyyTreeShowFile);\n",
"   fputc(\'\\n\',yyyTreeShowFile);\n",
"   yyyPTSshowToFile();\n",
"   fputc(\'\\n\',yyyTreeShowFile);\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyWriteStatusLine()\n",
"  {\n",
"   int i;\n",
"\n",
"   for (i=0;i<COLS;i++) mvwaddch(yyyStatusLine,0,i,\' \');\n",
"\n",
"   if (yyyAccept)\n",
"      mvwaddstr(yyyStatusLine,0,COLS-1 - strlen(\"accepted\") - 2,\n",
"               \"accepted\"\n",
"               );\n",
"\n",
"   wmove(yyyStatusLine,0,0);\n",
"   wprintw(yyyStatusLine,\"%%d,%%d\",yyyPTSwinLeftEdge,yyyPTSwinUpperEdge);\n",
"\n",
"   wmove(yyyStatusLine,0,10);\n",
"   wprintw(yyyStatusLine,\"%%dS + %%dR = %%d\",\n",
"           yyynShifts,yyynReductions,yyynStackOps\n",
"          );\n",
"\n",
"   wmove(yyyStatusLine,0,40);\n",
"   wprintw(yyyStatusLine,\"H:%%d\",yyyStackTop-yyyStack+1);\n",
"\n",
"   wmove(yyyStatusLine,0,50);\n",
"   wprintw(yyyStatusLine,\"L:%%s\",\n",
"           (yychar == -1)?\"\":((yychar == 0)?\"$\":yyyTermBuffer.NIOstr)\n",
"          );\n",
"\n",
"   overwrite(yyyStatusLine,stdscr);\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyPTSshowToScreen()\n",
"  {\n",
"   long i,len,relX,relY,first,last;\n",
"   struct yyyNIO *NIOdum;\n",
"   char *cp;\n",
"\n",
"   erase();\n",
"   for (NIOdum = yyyNIOspace; NIOdum < yyyNextNIO; NIOdum++)\n",
"     {\n",
"      relY = NIOdum->y - yyyPTSwinUpperEdge;\n",
"      if ((relY < 0) || (relY > LINES-2)) continue;\n",
"      relX = NIOdum->x - yyyPTSwinLeftEdge;\n",
"      len = strlen(NIOdum->str);\n",
"      first = relX - len/2;\n",
"      last  = first + len - 1;\n",
"      cp = NIOdum->str;\n",
"      if (NIOdum->isLeaf) standout();\n",
"      for (i=first; i <= last; i++)\n",
"         {if ((i>=0) && (i<= COLS-1))\n",
"             mvaddch(relY,i,*cp);\n",
"          cp++;\n",
"         }\n",
"      if (NIOdum->isLeaf) standend();\n",
"     }\n",
"   yyyWriteStatusLine();\n",
"   move(LINES-1,COLS-2);\n",
"   refresh();\n",
"   wrefresh(curscr);\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyDebugCleanup()\n",
"  {\n",
"   move(0,0);\n",
"   deleteln();\n",
"   move(LINES-1,0);\n",
"   refresh();\n",
"   endwin();\n",
"   putchar(\'\\n\');\n",
"  }\n",
"\n",
"\n",
"\n",
"@@C@void yyyInterpDebugCommand(repeat)\n",
"@@C@  int repeat;\n",
"@@A@void yyyInterpDebugCommand(int repeat)\n",
"  {\n",
"   char c;\n",
"   int jumpSize = 8;\n",
"   int bigJumpSize = 64;\n",
"\n",
"   while(1)\n",
"     {\n",
"      yyyPTSshowToScreen();\n",
"#if yyyTERMIO\n",
"      ioctl(yyyttyin,TCSETAW,&yyyTtyS);\n",
"      read(yyyttyin,&c,1);\n",
"      ioctl(yyyttyin,TCSETAW,&yyyTtyH);\n",
"#else\n",
"      ioctl(yyyttyin,TIOCSETN,&yyyTtyS);\n",
"      read(yyyttyin,&c,1);\n",
"      ioctl(yyyttyin,TIOCSETN,&yyyTtyH);\n",
"#endif\n",
"      if (('0' <= c) && (c <= '9'))\n",
"         {yyyNextStackOpsBreak = yyynStackOps + (c - \'0\');\n",
"          if (!repeat) return;\n",
"         }\n",
"      switch(c)\n",
"        {\n",
"         case \'h\': yyyPTSwinLeftEdge -= jumpSize;\n",
"                   if (yyyPTSwinLeftEdge < 0) yyyPTSwinLeftEdge = 0;\n",
"                   break;\n",
"         case \'j\': yyyPTSwinUpperEdge += jumpSize;\n",
"                   break;\n",
"         case \'k\': yyyPTSwinUpperEdge -= jumpSize;\n",
"                   if (yyyPTSwinUpperEdge < 0) yyyPTSwinUpperEdge = 0;\n",
"                   break;\n",
"         case \'l\': yyyPTSwinLeftEdge += jumpSize;\n",
"                   break;\n",
"         case \'H\': yyyPTSwinLeftEdge -= bigJumpSize;\n",
"                   if (yyyPTSwinLeftEdge < 0) yyyPTSwinLeftEdge = 0;\n",
"                   break;\n",
"         case \'J\': yyyPTSwinUpperEdge += bigJumpSize;\n",
"                   break;\n",
"         case \'K\': yyyPTSwinUpperEdge -= bigJumpSize;\n",
"                   if (yyyPTSwinUpperEdge < 0) yyyPTSwinUpperEdge = 0;\n",
"                   break;\n",
"         case \'L\': yyyPTSwinLeftEdge += bigJumpSize;\n",
"                   break;\n",
"         case \'\\f\': wrefresh(curscr);\n",
"                   break;\n",
"         case \'q\': if (repeat) return;\n",
"                   break;\n",
"         case \'Q\':\n",
"                   yyyDebugCleanup();\n",
"                   exit(0);\n",
"                   break;\n",
"        }\n",
"     }\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyDebugReset()\n",
"  {\n",
"   yyyNextNIO = yyyNIOspace;\n",
"   yyySTIrowNumMax = 1;\n",
"   yyySTInextColumn = 0;\n",
"\n",
"   yyynShifts = 0;\n",
"   yyynReductions = 0;\n",
"   yyynStackOps = 0;\n",
"\n",
"   yyyNextShiftsBreak = -1;\n",
"   yyyNextReductionsBreak = -1;\n",
"   yyyNextStackOpsBreak = -1;\n",
"   yyyPTSwinUpperEdge = 0;\n",
"   yyyPTSwinLeftEdge = 0;\n",
"   yyyInterpDebugCommand(0);\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyDebugAccept()\n",
"  {\n",
"   yyyAccept = 1;\n",
"   yyyInterpDebugCommand(1);\n",
"   yyyDebugCleanup();\n",
"  }\n",
"\n",
"\n",
"\n",
"@@C@void yyyCheckBreakpoints(isShift)\n",
"@@C@  int isShift;\n",
"@@A@void yyyCheckBreakpoints(int isShift)\n",
"  {\n",
"   yyynStackOps++;\n",
"   if (isShift) yyynShifts++; else yyynReductions++;\n",
"   if ((yyynStackOps   == yyyNextStackOpsBreak)   || \n",
"       (yyynShifts     == yyyNextShiftsBreak)     ||\n",
"       (yyynReductions == yyyNextReductionsBreak)\n",
"      )\n",
"      {\n",
"       yyyInterpDebugCommand(0);\n",
"      }\n",
"  }\n",
"\n",
"\n",
"\n",
};



char strTransBuffer[128];


char *strTrans(cp)
  char *cp;
  {char *cp2,c;

   cp2 = strTransBuffer;
   while ((c = *cp2++ = *cp++) != '\0') 
     if ((c == '\\') || 
         (c == '\"')  
        )
        {cp2[-1] = '\\';
         cp2++[0]  = c;
        } 
   return strTransBuffer;
  }



void outputTreeShowCode()
  {fprintf(yoxOutG,"\n#define yyyTreeShowFileStr \"%s\"\n\n",treeShowFileStr);
   printStringArray(ptt,sizeof(ptt),yoxOutG);
  }


@EOF
set `sum $sumopt <oxDistG1.04/source/treeShow.c`; if test $1 -ne 32449
then
	echo ERROR: oxDistG1.04/source/treeShow.c checksum is $1 should be 32449
fi
set `wc -lwc <oxDistG1.04/source/treeShow.c`
if test $1$2$3 != 595203517629
then
	echo ERROR: wc results of oxDistG1.04/source/treeShow.c are $* should be 595 2035 17629
fi

chmod 755 oxDistG1.04/source/treeShow.c

if test -f oxDistG1.04/source/treeShow.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/treeShow.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/treeShow.h
	if test -f oxDistG1.04/source/treeShow.h
	then
		echo Error: could not remove oxDistG1.04/source/treeShow.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/treeShow.h
cat >oxDistG1.04/source/treeShow.h <<'@EOF'
/* $Header: treeShow.h,v 5.10 94/04/16 20:25:16 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

extern char *strTrans();
extern void outputTreeShowCode();
@EOF
set `sum $sumopt <oxDistG1.04/source/treeShow.h`; if test $1 -ne 16923
then
	echo ERROR: oxDistG1.04/source/treeShow.h checksum is $1 should be 16923
fi
set `wc -lwc <oxDistG1.04/source/treeShow.h`
if test $1$2$3 != 633882447
then
	echo ERROR: wc results of oxDistG1.04/source/treeShow.h are $* should be 63 388 2447
fi

chmod 755 oxDistG1.04/source/treeShow.h

if test -f oxDistG1.04/source/xtreeshw.c
then
	echo Ok to overwrite existing file oxDistG1.04/source/xtreeshw.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/xtreeshw.c
	if test -f oxDistG1.04/source/xtreeshw.c
	then
		echo Error: could not remove oxDistG1.04/source/xtreeshw.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/xtreeshw.c
cat >oxDistG1.04/source/xtreeshw.c <<'@EOF'
/* $Header: xtreeshw.c,v 5.10 94/04/16 20:25:23 bischoff Exp $ */
/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

#include <stdio.h>
#include "ctc.h"
#include "opts.h" 


char *pttX[] = {
"/* NIO == Node-image Object */\n",
"/* STI == Subtree Image  */\n",
"\n",
"int yyyAccept;\n",
"\n",
"struct yyyStackItem yyySTIstTemp;\n",
"\n",
"\n",
"\n",
"Widget yyyTreeWidget;\n",
"Widget yyyTempINIO;\n",
"Widget yyyToplevel;\n",
"XtAppContext yyyApp_con;\n",
"Cardinal yyyargcdum = 1;\n",
"String yyyDumString = \"parse tree browser\";\n",
"String *yyyargvdum = &yyyDumString;\n",
"\n",
"\n",
"\n",
"void yyyDebugInit()\n",
"  {\n",
"   Widget scroller;\n",
"\n",
"   yyyToplevel = XtVaAppInitialize\n",
"       (&yyyApp_con, \"tree browser\", NULL, 0, &yyyargcdum, yyyargvdum,\n",
"        NULL, NULL\n",
"       );\n",
"   scroller = XtVaCreateManagedWidget\n",
"                (\"viewport\", viewportWidgetClass, yyyToplevel,\n",
"                 XtNwidth, 1000, XtNheight, 800,\n",
"                 /* XtNforceBars, True, */\n",
"                 XtNuseBottom, True, XtNuseRight, True,\n",
"                 XtNallowVert, True, XtNallowHoriz,True,\n",
"                 NULL\n",
"                );\n",
"   yyyTreeWidget = XtVaCreateManagedWidget\n",
"                  (\"tree\", treeWidgetClass, scroller,\n",
"                   XtNgravity, EastGravity,\n",
"                   XtNautoReconfigure, TRUE,\n",
"                   NULL\n",
"                  );\n",
"  }\n",
"\n",
"\n",
"\n",
"@@C@void yyyMakeLNIOlookahead(label)\n",
"@@C@  char *label;\n",
"@@A@void yyyMakeLNIOlookahead(char *label)\n",
"  {\n",
"   yyyTermBuffer.NIOstr = label;\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyMakeLNIOshift()\n",
"  {\n",
"   yyyStackTop->NIO = \n",
"     XtVaCreateManagedWidget\n",
"       (\"node\",labelWidgetClass,yyyTreeWidget,XtNlabel,\n",
"        yyyTermBuffer.NIOstr,NULL\n",
"       );\n",
"  }\n",
"\n",
"\n",
"\n",
"@@C@void yyyMakeINIOpreReduce(label)\n",
"@@C@  char *label;\n",
"@@A@void yyyMakeINIOpreReduce(char *label)\n",
"  {int i;\n",
"\n",
"   yyyTempINIO =\n",
"     XtVaCreateManagedWidget\n",
"           (\"node\", labelWidgetClass, yyyTreeWidget, XtNlabel,\n",
"            label, NULL\n",
"           );\n",
"   for (i=yyyRHSlength-1; i>=0; i--)\n",
"      {\n",
"       XtVaSetValues(yyyStackTop[-i].NIO,XtNtreeParent,yyyTempINIO,NULL);\n",
"      }\n",
"   if (yyyRHSlength == 0)\n",
"      {\n",
"       XtVaSetValues(\n",
"         XtVaCreateManagedWidget\n",
"           (\"node\", labelWidgetClass, yyyTreeWidget, XtNlabel,\n",
"            \"\", NULL\n",
"           ),\n",
"         XtNtreeParent,yyyTempINIO,NULL\n",
"                    );\n",
"      }\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyMakeINIOpostReduce()\n",
"  {\n",
"   yyyStackTop->NIO = yyyTempINIO;\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyXshowTree()\n",
"  {\n",
"   XtRealizeWidget(yyyToplevel);\n",
"   XtAppMainLoop(yyyApp_con);\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyDebugCleanup()\n",
"  {\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyDebugReset()\n",
"  {\n",
"  }\n",
"\n",
"\n",
"\n",
"void yyyDebugAccept()\n",
"  {\n",
"   yyyAccept = 1;\n",
"   yyyDebugCleanup();\n",
"  }\n",
"\n",
"\n",
"\n",
};


void outputxTreeShowCode()
  {
   printStringArray(pttX,sizeof(pttX),yoxOutG);
  }



@EOF
set `sum $sumopt <oxDistG1.04/source/xtreeshw.c`; if test $1 -ne 57655
then
	echo ERROR: oxDistG1.04/source/xtreeshw.c checksum is $1 should be 57655
fi
set `wc -lwc <oxDistG1.04/source/xtreeshw.c`
if test $1$2$3 != 2046935568
then
	echo ERROR: wc results of oxDistG1.04/source/xtreeshw.c are $* should be 204 693 5568
fi

chmod 755 oxDistG1.04/source/xtreeshw.c

if test -f oxDistG1.04/source/xtreeshw.h
then
	echo Ok to overwrite existing file oxDistG1.04/source/xtreeshw.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/xtreeshw.h
	if test -f oxDistG1.04/source/xtreeshw.h
	then
		echo Error: could not remove oxDistG1.04/source/xtreeshw.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/xtreeshw.h
cat >oxDistG1.04/source/xtreeshw.h <<'@EOF'
/* $Header: xtreeshw.h,v 5.10 94/04/16 20:25:25 bischoff Exp $ */

/* 
 *                          Ox version G1.04
 * 
 *        Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
 *                        All rights reserved
 * 
 * The author of Ox is Kurt M. Bischoff.
 * 
 * The following policies are intended to contribute to the sane
 * evolution of Ox.  Your views and ideas about that evolution are
 * welcome.
 * 
 * The author intends that Ox become about as widely available as
 * Yacc and Lex, and at about the same price.
 * 
 * Code generated by Ox is the property of the individual or
 * organization using Ox: the author of Ox makes no claim on code
 * generated by Ox.
 * 
 * You may modify the files `Makefile' and `mDeps.h' as necessary to
 * adapt this version to your hardware configuration.
 * 
 * The existing syntax and semantics of Ox are stable.  Certain
 * *extensions* of these are under consideration.  Your ideas for
 * extending Ox are welcome.  You may not add new functionality to
 * this version of Ox without explicit permission from the author.
 * 
 * If you believe you have found a bug in this version of Ox, please
 * report it to the author at one of the addresses below.  If you
 * make reasonable attempts, and are unable to contact the author
 * (which at this point seems unlikely), and are sure that there
 * really is a bug, you may attempt to repair the bug yourself.
 * 
 * You may not distribute modifications of this version of Ox
 * outside of your organization, except when all modifications are
 * confined to `Makefile' and `mDeps.h' as mentioned above, or the
 * author gives explicit permission for such distribution.
 * 
 * You may not sell this version or any modification of this version
 * of Ox.
 * 
 * The author may be contacted at the following addresses (listed in
 * order of preference):
 * 
 *       bischoff@cs.iastate.edu
 * 
 *       bischoff@oracorp.com
 * 
 *       Kurt Bischoff
 *       3059 12th Avenue North
 *       Fort Dodge IA  50501
 * 
 ***********************************************************************
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR        *
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      *
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *
 ***********************************************************************
 */

extern void outputxTreeShowCode();

@EOF
set `sum $sumopt <oxDistG1.04/source/xtreeshw.h`; if test $1 -ne 62476
then
	echo ERROR: oxDistG1.04/source/xtreeshw.h checksum is $1 should be 62476
fi
set `wc -lwc <oxDistG1.04/source/xtreeshw.h`
if test $1$2$3 != 633852424
then
	echo ERROR: wc results of oxDistG1.04/source/xtreeshw.h are $* should be 63 385 2424
fi

chmod 755 oxDistG1.04/source/xtreeshw.h

if test -f oxDistG1.04/source/mDepsh.bak
then
	echo Ok to overwrite existing file oxDistG1.04/source/mDepsh.bak\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/mDepsh.bak
	if test -f oxDistG1.04/source/mDepsh.bak
	then
		echo Error: could not remove oxDistG1.04/source/mDepsh.bak, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/mDepsh.bak
cat >oxDistG1.04/source/mDepsh.bak <<'@EOF'
/* $Header: mDeps.h,v 5.10 94/04/16 20:24:24 bischoff Exp $ */ 

/*
 *              copyright (c) 1992, 1993  Kurt M. Bischoff
 *
 * This file confines the hardware and software dependencies of Ox's 
 * source code.  Adapting Ox to your environment may require that this 
 * file be modified.  Users of 64-bit architectures such as DEC Alpha 
 * should read the comment near the definition of ALIGNsIZE.  Others
 * are unlikely to run into any trouble by ignoring this file and  
 * going ahead with `make'ing ox. 
 *
 */


/*  "target machine" as used in this comment means the machine on which the 
 *   generated evaluator is to run. 
 *
 *
 *  ALIGNsIZE should be assigned the smallest integer such that: 
 *
 *      if (n is an address on the target machine and 
 *          (n % ALIGNsIZE == 0)
 *         ) 
 *      then any C structure declared in a program that runs on the 
 *           target machine will satisfy the machines's alignment 
 *           requirements if it resides at n.     
 *  
 *  Users of 64-bit (in particular, DEC Alpha) machines probably need to 
 *  define ALIGNsIZE to be 8.  Just about everybody else can leave it 
 *  as 4 (the distribution default). 
 */ 
#define ALIGNsIZE 4



/* true if the character set of the compiler development machine is the 
 * same as the character set of the machine on which the developed 
 * compiler will run.  This is not currently a supported feature. 
 * so cscdmEQcscm should be left as 0.
 */
#define cscdmEQcscm 0 



/* The following constants control the sizes of data structures
 * in the generated evaluator.  Each is listed with its size in the
 * Ox distribution package.  The distribution default sizes assume 
 * that there is not a lot of memory available 
 * on the machine(s) on which the generated evaluators are to run.  They 
 * can be changed at evaluator-generation time by using Ox's -Y command 
 * line options, or now (at Ox-generation time) by editing this file. 
 * It is unlikely that the sizes other than the first three listed need 
 * to be changed at Ox-generation time.  Anyway, the generated evaluator 
 * fails gracefully and lets the user know in case it runs out of 
 * memory.  The Ox user also has the option of extending to the user 
 * of the generated evaluator the same memory-extension options (see
 * the reference manual).

 * Changing these constants is likely to cause some false alarms from 
 * the Ox test procedures.  If you aren't sure whether your installation 
 * is safe, send your question to: ox-project@cs.iastate.edu.   


 * * MAXnBYTESnODEsTG  400000L 
 * The number of bytes allocated for parse-tree node and attribute-
 * instance storage.

 * * MAXnREFcOUNTS     100000L 
 * The number of dependee counts (one byte each) allocated.  This is the
 * maximum number of attribute instances in the parse tree.
 * 
 * * MAXnCHILDREN       12000L 
 * The number of pointers allocated for child lists.  This is the maximum
 * number of non-root parse-tree nodes.  Each one consumes sizeof(void *)
 * bytes.



 * * MAXsTACKsIZE        1000L 
 * The maximum number of subtrees on the parse-tree stack.  This should
 * be increased if the attribute grammars are expected to use much right 
 * recursion and the generated evaluators are expected to process large 
 * inputs.

 * * ssalSPACEsIZE      10000L 
 * The maximum number of solved synthesized attributes of the roots of 
 * stacked subtrees.

 * * rsMAXsIZE            500L 
 * The maximum size of the ready set.   

 * * TRAVsTACKmAXsIZE    1000L
 * The maximum size of the postdecoration-traversal stack.  The size of
 * stack needed for a depth-first traversal of the parse tree. 
 */



/* Below are three models for memory allocation in the generated 
 * evaluators.  Choose one or design one of your own.
 */


/* small model 
 *    define MAXnBYTESnODEsTG  400000L 
 *    define MAXnREFcOUNTS     100000L 
 *    define MAXnCHILDREN       12000L 
 *    define MAXsTACKsIZE        1000L 
 *    define ssalSPACEsIZE      10000L 
 *    define rsMAXsIZE            500L 
 *    define TRAVsTACKmAXsIZE    1000L
*/



/* medium model 
 *    define MAXnBYTESnODEsTG  2000000L 
 *    define MAXnREFcOUNTS      500000L 
 *    define MAXnCHILDREN        60000L 
 *    define MAXsTACKsIZE        2000L 
 *    define ssalSPACEsIZE      20000L 
 *    define rsMAXsIZE           1000L 
 *    define TRAVsTACKmAXsIZE    2000L
 */



/* large model 
 *    define MAXnBYTESnODEsTG  4000000L 
 *    define MAXnREFcOUNTS     1000000L 
 *    define MAXnCHILDREN       120000L 
 *    define MAXsTACKsIZE        2000L 
 *    define ssalSPACEsIZE      20000L 
 *    define rsMAXsIZE           1000L 
 *    define TRAVsTACKmAXsIZE    2000L
 */



/* medium model */
#define MAXnBYTESnODEsTG  2000000L 
#define MAXnREFcOUNTS      500000L 
#define MAXnCHILDREN        60000L 
#define MAXsTACKsIZE        2000L 
#define ssalSPACEsIZE      20000L 
#define rsMAXsIZE           1000L 
#define TRAVsTACKmAXsIZE    2000L




@EOF
set `sum $sumopt <oxDistG1.04/source/mDepsh.bak`; if test $1 -ne 60601
then
	echo ERROR: oxDistG1.04/source/mDepsh.bak checksum is $1 should be 60601
fi
set `wc -lwc <oxDistG1.04/source/mDepsh.bak`
if test $1$2$3 != 1527494982
then
	echo ERROR: wc results of oxDistG1.04/source/mDepsh.bak are $* should be 152 749 4982
fi

chmod 755 oxDistG1.04/source/mDepsh.bak

if test -f oxDistG1.04/source/ytab.h.bak
then
	echo Ok to overwrite existing file oxDistG1.04/source/ytab.h.bak\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/source/ytab.h.bak
	if test -f oxDistG1.04/source/ytab.h.bak
	then
		echo Error: could not remove oxDistG1.04/source/ytab.h.bak, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/source/ytab.h.bak
>oxDistG1.04/source/ytab.h.bak
set `sum $sumopt <oxDistG1.04/source/ytab.h.bak`; if test $1 -ne 0
then
	echo ERROR: oxDistG1.04/source/ytab.h.bak checksum is $1 should be 0
fi
set `wc -lwc <oxDistG1.04/source/ytab.h.bak`
if test $1$2$3 != 000
then
	echo ERROR: wc results of oxDistG1.04/source/ytab.h.bak are $* should be 0 0 0
fi

chmod 755 oxDistG1.04/source/ytab.h.bak

chmod 755 oxDistG1.04/source

echo mkdir - oxDistG1.04/demo
mkdir oxDistG1.04/demo

if test -f oxDistG1.04/demo/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/README
	if test -f oxDistG1.04/demo/README
	then
		echo Error: could not remove oxDistG1.04/demo/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/README
cat >oxDistG1.04/demo/README <<'@EOF'
The present directory has subdirectories containing example Ox
programs for toy evaluators:

oxTutEGs is a directory containing the examples from the Ox
Tutorial Introduction.

The following directories contain examples from the Ox User
Reference Manual:

     * calc:  an integer calculator.

     * bintrans:  Knuth's binary number translator.

     * traverse:  translator of expressions from infix to postfix
     and prefix.

     * convHand: an example showing how to convert to Ox a
     translator that uses a hand-built (rather than Lex-
     generated) scanner.  The directories `convHand/before' and
     `convHand/after' show the Yacc-only and Yacc/Ox
     implementations respectively.

The executable evaluator is named gc in each case.  Examine the
Makefiles to discover the names of the Y-files and L-files, and
examine these to understand the behaviors of the evaluators.

Check that ox is on your path by typing `which ox' or `type ox'.
To build a given evaluator, enter the subdirectory and type
`make'.

Each evaluator has a subdirectory gct that contains test inputs.
Each evaluator reads stdin and writes stdout, so each can be run
interactively or by redirection.
@EOF
set `sum $sumopt <oxDistG1.04/demo/README`; if test $1 -ne 35114
then
	echo ERROR: oxDistG1.04/demo/README checksum is $1 should be 35114
fi
set `wc -lwc <oxDistG1.04/demo/README`
if test $1$2$3 != 331721187
then
	echo ERROR: wc results of oxDistG1.04/demo/README are $* should be 33 172 1187
fi

chmod 755 oxDistG1.04/demo/README

if test -f oxDistG1.04/demo/.expand
then
	echo Ok to overwrite existing file oxDistG1.04/demo/.expand\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/.expand
	if test -f oxDistG1.04/demo/.expand
	then
		echo Error: could not remove oxDistG1.04/demo/.expand, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/.expand
cat >oxDistG1.04/demo/.expand <<'@EOF'
#
foreach i (bintrans calc traverse)
  echo ""
  echo ""
  echo $i
  cd $i
  chmod 700 .
  make 
  if ($status) then
    echo "error making $i"
  endif
  cd ..
end

cd convHand 
foreach i (before after)
  echo ""
  echo ""
  echo $i
  cd $i 
  chmod 700 .
  make 
  if ($status) then
    echo "error making $i"
  endif
  cd ..
end
cd ..

cd oxTutEGs
foreach i (eg*)
  echo ""
  echo ""
  echo $i
  cd $i 
  chmod 700 .
  make 
  if ($status) then
    echo "error making $i"
  endif
  cd ..
end
cd ..
@EOF
set `sum $sumopt <oxDistG1.04/demo/.expand`; if test $1 -ne 33001
then
	echo ERROR: oxDistG1.04/demo/.expand checksum is $1 should be 33001
fi
set `wc -lwc <oxDistG1.04/demo/.expand`
if test $1$2$3 != 4390500
then
	echo ERROR: wc results of oxDistG1.04/demo/.expand are $* should be 43 90 500
fi

chmod 755 oxDistG1.04/demo/.expand

echo mkdir - oxDistG1.04/demo/convHand
mkdir oxDistG1.04/demo/convHand

echo mkdir - oxDistG1.04/demo/convHand/before
mkdir oxDistG1.04/demo/convHand/before

if test -f oxDistG1.04/demo/convHand/before/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/before/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/before/Makefile
	if test -f oxDistG1.04/demo/convHand/before/Makefile
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/before/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/before/Makefile
cat >oxDistG1.04/demo/convHand/before/Makefile <<'@EOF'
gc: y.tab.o scan.o 
	cc -o gc y.tab.o scan.o -ly   

y.tab.c y.tab.h: gram.y  
	yacc -d gram.y  

y.tab.o: y.tab.c 
	cc -c y.tab.c  

scan.o: scan.c
	cc -c scan.c   


clean: 
	rm *.o y.tab.c y.tab.h gc     
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/before/Makefile`; if test $1 -ne 40845
then
	echo ERROR: oxDistG1.04/demo/convHand/before/Makefile checksum is $1 should be 40845
fi
set `wc -lwc <oxDistG1.04/demo/convHand/before/Makefile`
if test $1$2$3 != 1531208
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/before/Makefile are $* should be 15 31 208
fi

chmod 755 oxDistG1.04/demo/convHand/before/Makefile

if test -f oxDistG1.04/demo/convHand/before/gram.y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/before/gram.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/before/gram.y
	if test -f oxDistG1.04/demo/convHand/before/gram.y
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/before/gram.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/before/gram.y
cat >oxDistG1.04/demo/convHand/before/gram.y <<'@EOF'
%token ICONST IDENT
%%
seq	:	
	|	seq	ICONST
	|	seq	IDENT
	;
%%
main()
  {yyparse();}	
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/before/gram.y`; if test $1 -ne 24222
then
	echo ERROR: oxDistG1.04/demo/convHand/before/gram.y checksum is $1 should be 24222
fi
set `wc -lwc <oxDistG1.04/demo/convHand/before/gram.y`
if test $1$2$3 != 91686
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/before/gram.y are $* should be 9 16 86
fi

chmod 755 oxDistG1.04/demo/convHand/before/gram.y

echo mkdir - oxDistG1.04/demo/convHand/before/gct
mkdir oxDistG1.04/demo/convHand/before/gct

if test -f oxDistG1.04/demo/convHand/before/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/before/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/before/gct/t1
	if test -f oxDistG1.04/demo/convHand/before/gct/t1
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/before/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/before/gct/t1
cat >oxDistG1.04/demo/convHand/before/gct/t1 <<'@EOF'
457 thing word 897
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/before/gct/t1`; if test $1 -ne 49409
then
	echo ERROR: oxDistG1.04/demo/convHand/before/gct/t1 checksum is $1 should be 49409
fi
set `wc -lwc <oxDistG1.04/demo/convHand/before/gct/t1`
if test $1$2$3 != 1419
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/before/gct/t1 are $* should be 1 4 19
fi

chmod 755 oxDistG1.04/demo/convHand/before/gct/t1

if test -f oxDistG1.04/demo/convHand/before/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/before/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/before/gct/t2
	if test -f oxDistG1.04/demo/convHand/before/gct/t2
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/before/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/before/gct/t2
cat >oxDistG1.04/demo/convHand/before/gct/t2 <<'@EOF'
1919 Wino Way
Walla Walla  WA
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/before/gct/t2`; if test $1 -ne 41000
then
	echo ERROR: oxDistG1.04/demo/convHand/before/gct/t2 checksum is $1 should be 41000
fi
set `wc -lwc <oxDistG1.04/demo/convHand/before/gct/t2`
if test $1$2$3 != 2630
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/before/gct/t2 are $* should be 2 6 30
fi

chmod 755 oxDistG1.04/demo/convHand/before/gct/t2

if test -f oxDistG1.04/demo/convHand/before/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/before/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/before/gct/t3
	if test -f oxDistG1.04/demo/convHand/before/gct/t3
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/before/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/before/gct/t3
cat >oxDistG1.04/demo/convHand/before/gct/t3 <<'@EOF'
this is a test
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/before/gct/t3`; if test $1 -ne 11768
then
	echo ERROR: oxDistG1.04/demo/convHand/before/gct/t3 checksum is $1 should be 11768
fi
set `wc -lwc <oxDistG1.04/demo/convHand/before/gct/t3`
if test $1$2$3 != 1415
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/before/gct/t3 are $* should be 1 4 15
fi

chmod 755 oxDistG1.04/demo/convHand/before/gct/t3

chmod 755 oxDistG1.04/demo/convHand/before/gct

if test -f oxDistG1.04/demo/convHand/before/scan.c
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/before/scan.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/before/scan.c
	if test -f oxDistG1.04/demo/convHand/before/scan.c
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/before/scan.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/before/scan.c
cat >oxDistG1.04/demo/convHand/before/scan.c <<'@EOF'
#include <stdio.h>
#include <string.h>
#include "y.tab.h"

#define bufsize 80
char buf[bufsize];
char *lexBuf;

char *lexeme(inString)
  char inString[];
  {return strcpy((char *)malloc(1+strlen(inString)),inString);}

int yylex()
  {char *bufp = buf;

   while ((*bufp = getchar()) != EOF) 
     {if (bufp == (buf + bufsize - 1))
         {fprintf(stderr,"exceeded buffer\n"); exit(-1);}
      if ((*bufp == ' ')  || (*bufp == '\n') || 
          (*bufp == '\t') || (*bufp == '\f')
         )
         {if (bufp == buf) continue; else break;}
      if (!isalnum(*bufp)) {fprintf(stderr,"illegal character\n"); exit(-1);}
      bufp++; 
     } 
   if (bufp != buf) 
      {*++bufp = '\0'; 
       lexBuf = lexeme(buf);
       bufp = lexBuf;
       if (isalpha(lexBuf[0]))
          {while (*bufp != '\0') 
             if (isdigit(*bufp++))
                {fprintf(stderr,"illegal string\n"); exit(-1);}
           return (IDENT);
          }
       if (isdigit(lexBuf[0]))
          {while (*bufp != '\0') 
             if (isalpha(*bufp++))
                {fprintf(stderr,"illegal string\n"); exit(-1);}
           return (ICONST);
          }
      }
   return 0;
  }
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/before/scan.c`; if test $1 -ne 13758
then
	echo ERROR: oxDistG1.04/demo/convHand/before/scan.c checksum is $1 should be 13758
fi
set `wc -lwc <oxDistG1.04/demo/convHand/before/scan.c`
if test $1$2$3 != 441201173
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/before/scan.c are $* should be 44 120 1173
fi

chmod 755 oxDistG1.04/demo/convHand/before/scan.c

if test -f oxDistG1.04/demo/convHand/before/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/before/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/before/README
	if test -f oxDistG1.04/demo/convHand/before/README
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/before/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/before/README
cat >oxDistG1.04/demo/convHand/before/README <<'@EOF'
An example from the Ox User Reference Manual.  The gct directory
contains sample inputs.
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/before/README`; if test $1 -ne 48410
then
	echo ERROR: oxDistG1.04/demo/convHand/before/README checksum is $1 should be 48410
fi
set `wc -lwc <oxDistG1.04/demo/convHand/before/README`
if test $1$2$3 != 21489
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/before/README are $* should be 2 14 89
fi

chmod 755 oxDistG1.04/demo/convHand/before/README

chmod 755 oxDistG1.04/demo/convHand/before

echo mkdir - oxDistG1.04/demo/convHand/after
mkdir oxDistG1.04/demo/convHand/after

if test -f oxDistG1.04/demo/convHand/after/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/after/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/after/Makefile
	if test -f oxDistG1.04/demo/convHand/after/Makefile
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/after/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/after/Makefile
cat >oxDistG1.04/demo/convHand/after/Makefile <<'@EOF'
gc: y.tab.o scan.o 
	cc -o gc y.tab.o scan.o -ly   

oxout.y oxout.l: gram.y scan2.l
	ox -h gram.y -G scan2.l

y.tab.c y.tab.h: oxout.y  
	yacc -d oxout.y  

y.tab.o: y.tab.c 
	cc -c y.tab.c  

scan.o: oxout.l y.tab.h scan.c
	cc -c scan.c   



clean: 
	rm *.o oxout.* y.tab.c y.tab.h gc     
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/after/Makefile`; if test $1 -ne 60163
then
	echo ERROR: oxDistG1.04/demo/convHand/after/Makefile checksum is $1 should be 60163
fi
set `wc -lwc <oxDistG1.04/demo/convHand/after/Makefile`
if test $1$2$3 != 1943293
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/after/Makefile are $* should be 19 43 293
fi

chmod 755 oxDistG1.04/demo/convHand/after/Makefile

if test -f oxDistG1.04/demo/convHand/after/gram.y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/after/gram.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/after/gram.y
	if test -f oxDistG1.04/demo/convHand/after/gram.y
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/after/gram.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/after/gram.y
sed 's/^@//' >oxDistG1.04/demo/convHand/after/gram.y <<'@EOF'
%{
#include "oxout.h"
%}

%token ICONST IDENT

@@attributes {char *string;} IDENT ICONST

%%
seq	:	
	|	seq	ICONST
	|	seq	IDENT
	;
%%
main()
  {yyparse();}	
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/after/gram.y`; if test $1 -ne 4745
then
	echo ERROR: oxDistG1.04/demo/convHand/after/gram.y checksum is $1 should be 4745
fi
set `wc -lwc <oxDistG1.04/demo/convHand/after/gram.y`
if test $1$2$3 != 1625155
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/after/gram.y are $* should be 16 25 155
fi

chmod 755 oxDistG1.04/demo/convHand/after/gram.y

echo mkdir - oxDistG1.04/demo/convHand/after/gct
mkdir oxDistG1.04/demo/convHand/after/gct

if test -f oxDistG1.04/demo/convHand/after/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/after/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/after/gct/t1
	if test -f oxDistG1.04/demo/convHand/after/gct/t1
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/after/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/after/gct/t1
cat >oxDistG1.04/demo/convHand/after/gct/t1 <<'@EOF'
457 thing word 897
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/after/gct/t1`; if test $1 -ne 49409
then
	echo ERROR: oxDistG1.04/demo/convHand/after/gct/t1 checksum is $1 should be 49409
fi
set `wc -lwc <oxDistG1.04/demo/convHand/after/gct/t1`
if test $1$2$3 != 1419
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/after/gct/t1 are $* should be 1 4 19
fi

chmod 755 oxDistG1.04/demo/convHand/after/gct/t1

if test -f oxDistG1.04/demo/convHand/after/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/after/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/after/gct/t2
	if test -f oxDistG1.04/demo/convHand/after/gct/t2
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/after/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/after/gct/t2
cat >oxDistG1.04/demo/convHand/after/gct/t2 <<'@EOF'
1919 Wino Way
Walla Walla  WA
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/after/gct/t2`; if test $1 -ne 41000
then
	echo ERROR: oxDistG1.04/demo/convHand/after/gct/t2 checksum is $1 should be 41000
fi
set `wc -lwc <oxDistG1.04/demo/convHand/after/gct/t2`
if test $1$2$3 != 2630
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/after/gct/t2 are $* should be 2 6 30
fi

chmod 755 oxDistG1.04/demo/convHand/after/gct/t2

if test -f oxDistG1.04/demo/convHand/after/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/after/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/after/gct/t3
	if test -f oxDistG1.04/demo/convHand/after/gct/t3
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/after/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/after/gct/t3
cat >oxDistG1.04/demo/convHand/after/gct/t3 <<'@EOF'
this is a test
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/after/gct/t3`; if test $1 -ne 11768
then
	echo ERROR: oxDistG1.04/demo/convHand/after/gct/t3 checksum is $1 should be 11768
fi
set `wc -lwc <oxDistG1.04/demo/convHand/after/gct/t3`
if test $1$2$3 != 1415
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/after/gct/t3 are $* should be 1 4 15
fi

chmod 755 oxDistG1.04/demo/convHand/after/gct/t3

chmod 755 oxDistG1.04/demo/convHand/after/gct

if test -f oxDistG1.04/demo/convHand/after/scan2.l
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/after/scan2.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/after/scan2.l
	if test -f oxDistG1.04/demo/convHand/after/scan2.l
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/after/scan2.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/after/scan2.l
cat >oxDistG1.04/demo/convHand/after/scan2.l <<'@EOF'
       if (isalpha(lexBuf[0]))
          {while (*bufp != '\0') 
             if (isdigit(*bufp++))
                {fprintf(stderr,"illegal string\n"); exit(-1);}
           return (IDENT);  @{ @IDENT.string@ = lexBuf; @}
          }
       if (isdigit(lexBuf[0]))
          {while (*bufp != '\0') 
             if (isalpha(*bufp++))
                {fprintf(stderr,"illegal string\n"); exit(-1);}
           return (ICONST); @{ @ICONST.string@ = lexBuf; @}
          }
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/after/scan2.l`; if test $1 -ne 12606
then
	echo ERROR: oxDistG1.04/demo/convHand/after/scan2.l checksum is $1 should be 12606
fi
set `wc -lwc <oxDistG1.04/demo/convHand/after/scan2.l`
if test $1$2$3 != 1238471
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/after/scan2.l are $* should be 12 38 471
fi

chmod 755 oxDistG1.04/demo/convHand/after/scan2.l

if test -f oxDistG1.04/demo/convHand/after/scan.c
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/after/scan.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/after/scan.c
	if test -f oxDistG1.04/demo/convHand/after/scan.c
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/after/scan.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/after/scan.c
cat >oxDistG1.04/demo/convHand/after/scan.c <<'@EOF'
#include <stdio.h>
#include <string.h>
#include "y.tab.h"
#include "oxout.h"

#define bufsize 80
char buf[bufsize];
char *lexBuf;

char *lexeme(inString)
  char inString[];
  {return strcpy((char *)malloc(1+strlen(inString)),inString);}

int yylex()
  {char *bufp = buf;

   while ((*bufp = getchar()) != EOF) 
     {if (bufp == (buf + bufsize - 1))
         {fprintf(stderr,"exceeded buffer\n"); exit(-1);}
      if ((*bufp == ' ')  || (*bufp == '\n') || 
          (*bufp == '\t') || (*bufp == '\f')
         )
         {if (bufp == buf) continue; else break;}
      if (!isalnum(*bufp)) {fprintf(stderr,"illegal character\n"); exit(-1);}
      bufp++; 
     } 
   if (bufp != buf) 
      {*++bufp = '\0'; 
       lexBuf = lexeme(buf);
       bufp = lexBuf;

#include "oxout.l"

      }
   return 0;
  }
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/after/scan.c`; if test $1 -ne 28205
then
	echo ERROR: oxDistG1.04/demo/convHand/after/scan.c checksum is $1 should be 28205
fi
set `wc -lwc <oxDistG1.04/demo/convHand/after/scan.c`
if test $1$2$3 != 3696806
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/after/scan.c are $* should be 36 96 806
fi

chmod 755 oxDistG1.04/demo/convHand/after/scan.c

if test -f oxDistG1.04/demo/convHand/after/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/after/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/after/README
	if test -f oxDistG1.04/demo/convHand/after/README
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/after/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/after/README
cat >oxDistG1.04/demo/convHand/after/README <<'@EOF'
An example from the Ox User Reference Manual.  The gct directory
contains sample inputs.
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/after/README`; if test $1 -ne 48410
then
	echo ERROR: oxDistG1.04/demo/convHand/after/README checksum is $1 should be 48410
fi
set `wc -lwc <oxDistG1.04/demo/convHand/after/README`
if test $1$2$3 != 21489
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/after/README are $* should be 2 14 89
fi

chmod 755 oxDistG1.04/demo/convHand/after/README

chmod 755 oxDistG1.04/demo/convHand/after

if test -f oxDistG1.04/demo/convHand/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/convHand/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/convHand/README
	if test -f oxDistG1.04/demo/convHand/README
	then
		echo Error: could not remove oxDistG1.04/demo/convHand/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/convHand/README
cat >oxDistG1.04/demo/convHand/README <<'@EOF'
An example from the user reference manual, showing how to
convert to Ox a translator that uses a hand-built
(rather than Lex-generated) scanner.  The before directory
and the after directory show the Yacc-only and Yacc/Ox   
implementations respectively.
@EOF
set `sum $sumopt <oxDistG1.04/demo/convHand/README`; if test $1 -ne 57162
then
	echo ERROR: oxDistG1.04/demo/convHand/README checksum is $1 should be 57162
fi
set `wc -lwc <oxDistG1.04/demo/convHand/README`
if test $1$2$3 != 537255
then
	echo ERROR: wc results of oxDistG1.04/demo/convHand/README are $* should be 5 37 255
fi

chmod 755 oxDistG1.04/demo/convHand/README

chmod 755 oxDistG1.04/demo/convHand

echo mkdir - oxDistG1.04/demo/calc
mkdir oxDistG1.04/demo/calc

if test -f oxDistG1.04/demo/calc/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/calc/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/calc/Makefile
	if test -f oxDistG1.04/demo/calc/Makefile
	then
		echo Error: could not remove oxDistG1.04/demo/calc/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/calc/Makefile
cat >oxDistG1.04/demo/calc/Makefile <<'@EOF'
gc: build expr.L expr.Y 
	sh -v <build
	mv calc gc




clean:
	rm *.o lex.yy.c y.tab.c y.tab.h oxout.? gc
@EOF
set `sum $sumopt <oxDistG1.04/demo/calc/Makefile`; if test $1 -ne 25764
then
	echo ERROR: oxDistG1.04/demo/calc/Makefile checksum is $1 should be 25764
fi
set `wc -lwc <oxDistG1.04/demo/calc/Makefile`
if test $1$2$3 != 918106
then
	echo ERROR: wc results of oxDistG1.04/demo/calc/Makefile are $* should be 9 18 106
fi

chmod 755 oxDistG1.04/demo/calc/Makefile

if test -f oxDistG1.04/demo/calc/build
then
	echo Ok to overwrite existing file oxDistG1.04/demo/calc/build\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/calc/build
	if test -f oxDistG1.04/demo/calc/build
	then
		echo Error: could not remove oxDistG1.04/demo/calc/build, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/calc/build
cat >oxDistG1.04/demo/calc/build <<'@EOF'
        ox -h expr.Y expr.L
        yacc -d oxout.y
        lex oxout.l
        cc -c y.tab.c
        cc -c lex.yy.c
        cc -o calc y.tab.o lex.yy.o -ly -ll
@EOF
set `sum $sumopt <oxDistG1.04/demo/calc/build`; if test $1 -ne 10294
then
	echo ERROR: oxDistG1.04/demo/calc/build checksum is $1 should be 10294
fi
set `wc -lwc <oxDistG1.04/demo/calc/build`
if test $1$2$3 != 622161
then
	echo ERROR: wc results of oxDistG1.04/demo/calc/build are $* should be 6 22 161
fi

chmod 755 oxDistG1.04/demo/calc/build

if test -f oxDistG1.04/demo/calc/expr.L
then
	echo Ok to overwrite existing file oxDistG1.04/demo/calc/expr.L\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/calc/expr.L
	if test -f oxDistG1.04/demo/calc/expr.L
	then
		echo Error: could not remove oxDistG1.04/demo/calc/expr.L, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/calc/expr.L
cat >oxDistG1.04/demo/calc/expr.L <<'@EOF'
%{
/* expr.L:  L-file for a simple expression language */
#include "y.tab.h" 
#include "oxout.h"
%}

%% 
[ \n\t\f]*     ;  
[0-9]+         return(CONST); @{ 
                  sscanf(yytext,"%d",&(@CONST.val@)); @}   
\(             return('('); 
\)             return(')'); 
\+             return('+'); 
\*             return('*'); 
%%
@EOF
set `sum $sumopt <oxDistG1.04/demo/calc/expr.L`; if test $1 -ne 44186
then
	echo ERROR: oxDistG1.04/demo/calc/expr.L checksum is $1 should be 44186
fi
set `wc -lwc <oxDistG1.04/demo/calc/expr.L`
if test $1$2$3 != 1533337
then
	echo ERROR: wc results of oxDistG1.04/demo/calc/expr.L are $* should be 15 33 337
fi

chmod 755 oxDistG1.04/demo/calc/expr.L

if test -f oxDistG1.04/demo/calc/expr.Y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/calc/expr.Y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/calc/expr.Y
	if test -f oxDistG1.04/demo/calc/expr.Y
	then
		echo Error: could not remove oxDistG1.04/demo/calc/expr.Y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/calc/expr.Y
sed 's/^@//' >oxDistG1.04/demo/calc/expr.Y <<'@EOF'
/* expr.Y:  Y-file for a simple expression language */
%left '+'
%left '*'
%token CONST  

@@attributes {long val;} s e CONST 

%{ 
#include "oxout.h"
long sVal; 
%} 

%%
s       :       e
        @{ @i sVal = @s.val@ = @e.val@;            @}
        ;
e       :       e       '+'     e       
        @{ @i @e.0.val@ = @e.1.val@ + @e.2.val@;   @}
        ;
e       :       e       '*'     e       
        @{ @i @e.0.val@ = @e.1.val@ * @e.2.val@;   @}
        ;
e       :       '('     e       ')'     
        @{ @i @e.val@ = @e.1.val@;                 @}
        ;
e       :       CONST           
        @{ @i @e.val@ = @CONST.val@;               @}   
        ;
%% 

main() 
{yyparse(); 
 printf("%d\n",sVal);     
} 
@EOF
set `sum $sumopt <oxDistG1.04/demo/calc/expr.Y`; if test $1 -ne 16288
then
	echo ERROR: oxDistG1.04/demo/calc/expr.Y checksum is $1 should be 16288
fi
set `wc -lwc <oxDistG1.04/demo/calc/expr.Y`
if test $1$2$3 != 3495723
then
	echo ERROR: wc results of oxDistG1.04/demo/calc/expr.Y are $* should be 34 95 723
fi

chmod 755 oxDistG1.04/demo/calc/expr.Y

if test -f oxDistG1.04/demo/calc/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/calc/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/calc/README
	if test -f oxDistG1.04/demo/calc/README
	then
		echo Error: could not remove oxDistG1.04/demo/calc/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/calc/README
cat >oxDistG1.04/demo/calc/README <<'@EOF'
An example from the Ox User Reference Manual.  The gct directory
contains sample inputs.
@EOF
set `sum $sumopt <oxDistG1.04/demo/calc/README`; if test $1 -ne 48410
then
	echo ERROR: oxDistG1.04/demo/calc/README checksum is $1 should be 48410
fi
set `wc -lwc <oxDistG1.04/demo/calc/README`
if test $1$2$3 != 21489
then
	echo ERROR: wc results of oxDistG1.04/demo/calc/README are $* should be 2 14 89
fi

chmod 755 oxDistG1.04/demo/calc/README

echo mkdir - oxDistG1.04/demo/calc/gct
mkdir oxDistG1.04/demo/calc/gct

if test -f oxDistG1.04/demo/calc/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/demo/calc/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/calc/gct/t1
	if test -f oxDistG1.04/demo/calc/gct/t1
	then
		echo Error: could not remove oxDistG1.04/demo/calc/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/calc/gct/t1
cat >oxDistG1.04/demo/calc/gct/t1 <<'@EOF'
4*9+(8+0)*8+2
@EOF
set `sum $sumopt <oxDistG1.04/demo/calc/gct/t1`; if test $1 -ne 8282
then
	echo ERROR: oxDistG1.04/demo/calc/gct/t1 checksum is $1 should be 8282
fi
set `wc -lwc <oxDistG1.04/demo/calc/gct/t1`
if test $1$2$3 != 1114
then
	echo ERROR: wc results of oxDistG1.04/demo/calc/gct/t1 are $* should be 1 1 14
fi

chmod 755 oxDistG1.04/demo/calc/gct/t1

if test -f oxDistG1.04/demo/calc/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/demo/calc/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/calc/gct/t2
	if test -f oxDistG1.04/demo/calc/gct/t2
	then
		echo Error: could not remove oxDistG1.04/demo/calc/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/calc/gct/t2
cat >oxDistG1.04/demo/calc/gct/t2 <<'@EOF'
3*2+9+8*6+0*4*2+6
@EOF
set `sum $sumopt <oxDistG1.04/demo/calc/gct/t2`; if test $1 -ne 9607
then
	echo ERROR: oxDistG1.04/demo/calc/gct/t2 checksum is $1 should be 9607
fi
set `wc -lwc <oxDistG1.04/demo/calc/gct/t2`
if test $1$2$3 != 1118
then
	echo ERROR: wc results of oxDistG1.04/demo/calc/gct/t2 are $* should be 1 1 18
fi

chmod 755 oxDistG1.04/demo/calc/gct/t2

if test -f oxDistG1.04/demo/calc/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/demo/calc/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/calc/gct/t3
	if test -f oxDistG1.04/demo/calc/gct/t3
	then
		echo Error: could not remove oxDistG1.04/demo/calc/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/calc/gct/t3
cat >oxDistG1.04/demo/calc/gct/t3 <<'@EOF'
5*8+(((4+9)+(3*4)*34)+9*7)+4
@EOF
set `sum $sumopt <oxDistG1.04/demo/calc/gct/t3`; if test $1 -ne 43228
then
	echo ERROR: oxDistG1.04/demo/calc/gct/t3 checksum is $1 should be 43228
fi
set `wc -lwc <oxDistG1.04/demo/calc/gct/t3`
if test $1$2$3 != 1129
then
	echo ERROR: wc results of oxDistG1.04/demo/calc/gct/t3 are $* should be 1 1 29
fi

chmod 755 oxDistG1.04/demo/calc/gct/t3

chmod 755 oxDistG1.04/demo/calc/gct

chmod 755 oxDistG1.04/demo/calc

echo mkdir - oxDistG1.04/demo/bintrans
mkdir oxDistG1.04/demo/bintrans

if test -f oxDistG1.04/demo/bintrans/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/bintrans/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/bintrans/Makefile
	if test -f oxDistG1.04/demo/bintrans/Makefile
	then
		echo Error: could not remove oxDistG1.04/demo/bintrans/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/bintrans/Makefile
cat >oxDistG1.04/demo/bintrans/Makefile <<'@EOF'
gc: y.tab.o lex.yy.o 
	cc -o gc y.tab.o lex.yy.o -ll -ly



y.tab.c y.tab.h: oxout.y
	yacc -d oxout.y

lex.yy.c: oxout.l
	lex oxout.l

lex.yy.o: lex.yy.c y.tab.h
	cc -c lex.yy.c

y.tab.o: y.tab.c
	cc -c y.tab.c

oxout.y oxout.l: scan.l gram.y
	ox gram.y scan.l

clean:
	rm *.o y.tab.c y.tab.h lex.yy.c oxout.? gc
@EOF
set `sum $sumopt <oxDistG1.04/demo/bintrans/Makefile`; if test $1 -ne 15501
then
	echo ERROR: oxDistG1.04/demo/bintrans/Makefile checksum is $1 should be 15501
fi
set `wc -lwc <oxDistG1.04/demo/bintrans/Makefile`
if test $1$2$3 != 2246313
then
	echo ERROR: wc results of oxDistG1.04/demo/bintrans/Makefile are $* should be 22 46 313
fi

chmod 755 oxDistG1.04/demo/bintrans/Makefile

if test -f oxDistG1.04/demo/bintrans/scan.l
then
	echo Ok to overwrite existing file oxDistG1.04/demo/bintrans/scan.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/bintrans/scan.l
	if test -f oxDistG1.04/demo/bintrans/scan.l
	then
		echo Error: could not remove oxDistG1.04/demo/bintrans/scan.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/bintrans/scan.l
sed 's/^@//' >oxDistG1.04/demo/bintrans/scan.l <<'@EOF'
%{
#include "y.tab.h" 
%}

%% 
[0]            return ZERO;
[1]            return ONE; 
\.             return DOT;  
[\n\t\v ]      ;       
@.              {fprintf(stderr,"illegal character\n"); 
                exit(-1); 
               }

@EOF
set `sum $sumopt <oxDistG1.04/demo/bintrans/scan.l`; if test $1 -ne 59888
then
	echo ERROR: oxDistG1.04/demo/bintrans/scan.l checksum is $1 should be 59888
fi
set `wc -lwc <oxDistG1.04/demo/bintrans/scan.l`
if test $1$2$3 != 1322241
then
	echo ERROR: wc results of oxDistG1.04/demo/bintrans/scan.l are $* should be 13 22 241
fi

chmod 755 oxDistG1.04/demo/bintrans/scan.l

if test -f oxDistG1.04/demo/bintrans/gram.y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/bintrans/gram.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/bintrans/gram.y
	if test -f oxDistG1.04/demo/bintrans/gram.y
	then
		echo Error: could not remove oxDistG1.04/demo/bintrans/gram.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/bintrans/gram.y
sed 's/^@//' >oxDistG1.04/demo/bintrans/gram.y <<'@EOF'
%token ZERO ONE DOT   
 
@@attributes {float value; int scale;}                   bit 
@@attributes {float value; int scale,length;}            bitlist 
@@attributes {float value;}                              num 

%start num   

%{
#include <stdio.h>
float numValue;
%}
%%
bit     :       ZERO
                @{ @i @bit.value@ = 0; 
                   /* value is synthesized for bit.  */
                   /* scale is inherited for bit.    */
                @}
        ;

bit     :       ONE
                @{ @i @bit.value@ = twoToThe(@bit.scale@); 
                @}
        ;

bitlist :       bit 
                @{ @i @bitlist.value@ = @bit.value@; 
                   @i @bit.scale@ = @bitlist.scale@;
                   @i @bitlist.length@ = 1; 
                   /* value and length are synthesized for bitlist.  */
                   /* scale is inherited for bitlist.                */
                @}

        |       bitlist bit              
                @{ @i @bitlist.0.value@ = @bitlist.1.value@ + @bit.value@; 
                   @i @bit.scale@ = @bitlist.0.scale@;
                   @i @bitlist.1.scale@ = @bitlist.0.scale@ + 1; 
                   @i @bitlist.0.length@ = @bitlist.1.length@ + 1; 
                @}
        ;

num     :       bitlist              
                @{ @i numValue = @num.value@ = @bitlist.0.value@;
                   @i @bitlist.scale@ = 0; 
                   /* value is synthesized for num. */
                @}

        |       bitlist DOT     bitlist  
                @{ @i numValue = @num.value@ = 
                         @bitlist.0.value@ + @bitlist.1.value@; 
                   @i @bitlist.0.scale@ = 0;
                   @i @bitlist.1.scale@ = - @bitlist.1.length@;
                @}        
        ;
%% 
main() 
  {if (!(yyparse())) 
      printf("%30.15f\n",numValue); 
  } 



float twoToThe(in)             /* returns 2 raised to the power in */  
  int in; 
  {if (in < 0) return (1.0 / twoToThe(-in)); 
   if (in == 0) return 1.0; 
      else return (2.0 * twoToThe(in - 1));
  } 



@EOF
set `sum $sumopt <oxDistG1.04/demo/bintrans/gram.y`; if test $1 -ne 52050
then
	echo ERROR: oxDistG1.04/demo/bintrans/gram.y checksum is $1 should be 52050
fi
set `wc -lwc <oxDistG1.04/demo/bintrans/gram.y`
if test $1$2$3 != 712112072
then
	echo ERROR: wc results of oxDistG1.04/demo/bintrans/gram.y are $* should be 71 211 2072
fi

chmod 755 oxDistG1.04/demo/bintrans/gram.y

if test -f oxDistG1.04/demo/bintrans/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/bintrans/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/bintrans/README
	if test -f oxDistG1.04/demo/bintrans/README
	then
		echo Error: could not remove oxDistG1.04/demo/bintrans/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/bintrans/README
cat >oxDistG1.04/demo/bintrans/README <<'@EOF'
An example from the Ox User Reference Manual.  The gct directory
contains sample inputs.
@EOF
set `sum $sumopt <oxDistG1.04/demo/bintrans/README`; if test $1 -ne 48410
then
	echo ERROR: oxDistG1.04/demo/bintrans/README checksum is $1 should be 48410
fi
set `wc -lwc <oxDistG1.04/demo/bintrans/README`
if test $1$2$3 != 21489
then
	echo ERROR: wc results of oxDistG1.04/demo/bintrans/README are $* should be 2 14 89
fi

chmod 755 oxDistG1.04/demo/bintrans/README

echo mkdir - oxDistG1.04/demo/bintrans/gct
mkdir oxDistG1.04/demo/bintrans/gct

if test -f oxDistG1.04/demo/bintrans/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/demo/bintrans/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/bintrans/gct/t1
	if test -f oxDistG1.04/demo/bintrans/gct/t1
	then
		echo Error: could not remove oxDistG1.04/demo/bintrans/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/bintrans/gct/t1
cat >oxDistG1.04/demo/bintrans/gct/t1 <<'@EOF'
1101.01
@EOF
set `sum $sumopt <oxDistG1.04/demo/bintrans/gct/t1`; if test $1 -ne 63033
then
	echo ERROR: oxDistG1.04/demo/bintrans/gct/t1 checksum is $1 should be 63033
fi
set `wc -lwc <oxDistG1.04/demo/bintrans/gct/t1`
if test $1$2$3 != 118
then
	echo ERROR: wc results of oxDistG1.04/demo/bintrans/gct/t1 are $* should be 1 1 8
fi

chmod 755 oxDistG1.04/demo/bintrans/gct/t1

if test -f oxDistG1.04/demo/bintrans/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/demo/bintrans/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/bintrans/gct/t2
	if test -f oxDistG1.04/demo/bintrans/gct/t2
	then
		echo Error: could not remove oxDistG1.04/demo/bintrans/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/bintrans/gct/t2
cat >oxDistG1.04/demo/bintrans/gct/t2 <<'@EOF'
1010011111010101.011010
@EOF
set `sum $sumopt <oxDistG1.04/demo/bintrans/gct/t2`; if test $1 -ne 49041
then
	echo ERROR: oxDistG1.04/demo/bintrans/gct/t2 checksum is $1 should be 49041
fi
set `wc -lwc <oxDistG1.04/demo/bintrans/gct/t2`
if test $1$2$3 != 1124
then
	echo ERROR: wc results of oxDistG1.04/demo/bintrans/gct/t2 are $* should be 1 1 24
fi

chmod 755 oxDistG1.04/demo/bintrans/gct/t2

if test -f oxDistG1.04/demo/bintrans/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/demo/bintrans/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/bintrans/gct/t3
	if test -f oxDistG1.04/demo/bintrans/gct/t3
	then
		echo Error: could not remove oxDistG1.04/demo/bintrans/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/bintrans/gct/t3
cat >oxDistG1.04/demo/bintrans/gct/t3 <<'@EOF'
101001111
@EOF
set `sum $sumopt <oxDistG1.04/demo/bintrans/gct/t3`; if test $1 -ne 55994
then
	echo ERROR: oxDistG1.04/demo/bintrans/gct/t3 checksum is $1 should be 55994
fi
set `wc -lwc <oxDistG1.04/demo/bintrans/gct/t3`
if test $1$2$3 != 1110
then
	echo ERROR: wc results of oxDistG1.04/demo/bintrans/gct/t3 are $* should be 1 1 10
fi

chmod 755 oxDistG1.04/demo/bintrans/gct/t3

if test -f oxDistG1.04/demo/bintrans/gct/t4
then
	echo Ok to overwrite existing file oxDistG1.04/demo/bintrans/gct/t4\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/bintrans/gct/t4
	if test -f oxDistG1.04/demo/bintrans/gct/t4
	then
		echo Error: could not remove oxDistG1.04/demo/bintrans/gct/t4, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/bintrans/gct/t4
cat >oxDistG1.04/demo/bintrans/gct/t4 <<'@EOF'
0.11010101011
@EOF
set `sum $sumopt <oxDistG1.04/demo/bintrans/gct/t4`; if test $1 -ne 54266
then
	echo ERROR: oxDistG1.04/demo/bintrans/gct/t4 checksum is $1 should be 54266
fi
set `wc -lwc <oxDistG1.04/demo/bintrans/gct/t4`
if test $1$2$3 != 1114
then
	echo ERROR: wc results of oxDistG1.04/demo/bintrans/gct/t4 are $* should be 1 1 14
fi

chmod 755 oxDistG1.04/demo/bintrans/gct/t4

chmod 755 oxDistG1.04/demo/bintrans/gct

chmod 755 oxDistG1.04/demo/bintrans

echo mkdir - oxDistG1.04/demo/traverse
mkdir oxDistG1.04/demo/traverse

if test -f oxDistG1.04/demo/traverse/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/traverse/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/traverse/Makefile
	if test -f oxDistG1.04/demo/traverse/Makefile
	then
		echo Error: could not remove oxDistG1.04/demo/traverse/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/traverse/Makefile
cat >oxDistG1.04/demo/traverse/Makefile <<'@EOF'
gc: y.tab.o lex.yy.o 
	cc -o gc y.tab.o lex.yy.o -ll -ly



y.tab.c y.tab.h: oxout.y
	yacc -d oxout.y

lex.yy.c: oxout.l
	lex oxout.l

lex.yy.o: lex.yy.c y.tab.h oxout.h
	cc -c lex.yy.c

y.tab.o: y.tab.c oxout.h
	cc -c y.tab.c

oxout.y oxout.l: expr.L expr.Y
	ox -h expr.Y expr.L

clean:
	rm *.o y.tab.c y.tab.h lex.yy.c oxout.? gc
@EOF
set `sum $sumopt <oxDistG1.04/demo/traverse/Makefile`; if test $1 -ne 59595
then
	echo ERROR: oxDistG1.04/demo/traverse/Makefile checksum is $1 should be 59595
fi
set `wc -lwc <oxDistG1.04/demo/traverse/Makefile`
if test $1$2$3 != 2249332
then
	echo ERROR: wc results of oxDistG1.04/demo/traverse/Makefile are $* should be 22 49 332
fi

chmod 755 oxDistG1.04/demo/traverse/Makefile

if test -f oxDistG1.04/demo/traverse/expr.L
then
	echo Ok to overwrite existing file oxDistG1.04/demo/traverse/expr.L\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/traverse/expr.L
	if test -f oxDistG1.04/demo/traverse/expr.L
	then
		echo Error: could not remove oxDistG1.04/demo/traverse/expr.L, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/traverse/expr.L
cat >oxDistG1.04/demo/traverse/expr.L <<'@EOF'
%{
/* L-file for translation of infix expressions */
#include "y.tab.h" 
#include "oxout.h"

char *lexeme()
  {char *dum;
   dum = (char *)malloc(yyleng+1);
   strcpy(dum,yytext);
   return dum;
  }

%}

%% 
[ \n\t\f]*              ;  
[0-9]+\.?[0-9]*         return(CONST); @{ @CONST.lexeme@ = lexeme(); @}   
[A-Za-z_][A-Za-z_0-9]*  return(ID);    @{ @ID.lexeme@ = lexeme();    @}
\(                      return('('); 
\)                      return(')'); 
\+                      return('+'); 
\*                      return('*'); 
\/                      return('/'); 
\-                      return('-'); 
%%

@EOF
set `sum $sumopt <oxDistG1.04/demo/traverse/expr.L`; if test $1 -ne 37184
then
	echo ERROR: oxDistG1.04/demo/traverse/expr.L checksum is $1 should be 37184
fi
set `wc -lwc <oxDistG1.04/demo/traverse/expr.L`
if test $1$2$3 != 2657615
then
	echo ERROR: wc results of oxDistG1.04/demo/traverse/expr.L are $* should be 26 57 615
fi

chmod 755 oxDistG1.04/demo/traverse/expr.L

if test -f oxDistG1.04/demo/traverse/expr.Y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/traverse/expr.Y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/traverse/expr.Y
	if test -f oxDistG1.04/demo/traverse/expr.Y
	then
		echo Error: could not remove oxDistG1.04/demo/traverse/expr.Y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/traverse/expr.Y
sed 's/^@//' >oxDistG1.04/demo/traverse/expr.Y <<'@EOF'

/* Y-file for translation of infix expressions to prefix and postfix */
%token ID CONST  
%start s    
%left '+' '-'
%left '*' '/'

@@attributes {char *lexeme;} ID CONST 
@@traversal @preorder LRpre
@@traversal LRpost

%{ 
#include "oxout.h" 
#include <stdio.h>
%} 

%%
s       :       expr
                @{ @LRpost printf("\n"); 
                   @LRpost @revorder (1) printf("postfix:  ");
                   @LRpre  @revorder (1) printf("\n"); 
                   @LRpre  printf("prefix:   ");
                @}
expr    :       expr    '*'     expr
                @{ @LRpost printf(" * "); 
                   @LRpre  printf(" * "); 
                @}
        |       expr    '+'     expr
                @{ @LRpre  printf(" + "); 
                   @LRpost printf(" + "); 
                @}
        |       expr    '/'     expr
                @{ @LRpost printf(" / "); 
                   @LRpre  printf(" / "); 
                @}
        |       expr    '-'     expr
                @{ @LRpost printf(" - "); 
                   @LRpre  printf(" - "); 
                @}
        |       '('     expr    ')'
        |       ID
                @{ @LRpost printf(" %s ",@ID.lexeme@); 
                   @LRpre  printf(" %s ",@ID.lexeme@); 
                @}
        |       CONST
                @{ @LRpost printf(" %s ",@CONST.lexeme@); 
                   @LRpre  printf(" %s ",@CONST.lexeme@); 
                @}
        ;
%% 


main() 
  {yyparse(); 
  } 

@EOF
set `sum $sumopt <oxDistG1.04/demo/traverse/expr.Y`; if test $1 -ne 28989
then
	echo ERROR: oxDistG1.04/demo/traverse/expr.Y checksum is $1 should be 28989
fi
set `wc -lwc <oxDistG1.04/demo/traverse/expr.Y`
if test $1$2$3 != 561491476
then
	echo ERROR: wc results of oxDistG1.04/demo/traverse/expr.Y are $* should be 56 149 1476
fi

chmod 755 oxDistG1.04/demo/traverse/expr.Y

if test -f oxDistG1.04/demo/traverse/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/traverse/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/traverse/README
	if test -f oxDistG1.04/demo/traverse/README
	then
		echo Error: could not remove oxDistG1.04/demo/traverse/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/traverse/README
cat >oxDistG1.04/demo/traverse/README <<'@EOF'
An example from the Ox User Reference Manual.  The gct directory
contains sample inputs.
@EOF
set `sum $sumopt <oxDistG1.04/demo/traverse/README`; if test $1 -ne 48410
then
	echo ERROR: oxDistG1.04/demo/traverse/README checksum is $1 should be 48410
fi
set `wc -lwc <oxDistG1.04/demo/traverse/README`
if test $1$2$3 != 21489
then
	echo ERROR: wc results of oxDistG1.04/demo/traverse/README are $* should be 2 14 89
fi

chmod 755 oxDistG1.04/demo/traverse/README

echo mkdir - oxDistG1.04/demo/traverse/gct
mkdir oxDistG1.04/demo/traverse/gct

if test -f oxDistG1.04/demo/traverse/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/demo/traverse/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/traverse/gct/t1
	if test -f oxDistG1.04/demo/traverse/gct/t1
	then
		echo Error: could not remove oxDistG1.04/demo/traverse/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/traverse/gct/t1
cat >oxDistG1.04/demo/traverse/gct/t1 <<'@EOF'
4*9+(8+0)*8+2
@EOF
set `sum $sumopt <oxDistG1.04/demo/traverse/gct/t1`; if test $1 -ne 8282
then
	echo ERROR: oxDistG1.04/demo/traverse/gct/t1 checksum is $1 should be 8282
fi
set `wc -lwc <oxDistG1.04/demo/traverse/gct/t1`
if test $1$2$3 != 1114
then
	echo ERROR: wc results of oxDistG1.04/demo/traverse/gct/t1 are $* should be 1 1 14
fi

chmod 755 oxDistG1.04/demo/traverse/gct/t1

if test -f oxDistG1.04/demo/traverse/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/demo/traverse/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/traverse/gct/t2
	if test -f oxDistG1.04/demo/traverse/gct/t2
	then
		echo Error: could not remove oxDistG1.04/demo/traverse/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/traverse/gct/t2
cat >oxDistG1.04/demo/traverse/gct/t2 <<'@EOF'
3*2+9+8*6+0/4*2-6
@EOF
set `sum $sumopt <oxDistG1.04/demo/traverse/gct/t2`; if test $1 -ne 47495
then
	echo ERROR: oxDistG1.04/demo/traverse/gct/t2 checksum is $1 should be 47495
fi
set `wc -lwc <oxDistG1.04/demo/traverse/gct/t2`
if test $1$2$3 != 1118
then
	echo ERROR: wc results of oxDistG1.04/demo/traverse/gct/t2 are $* should be 1 1 18
fi

chmod 755 oxDistG1.04/demo/traverse/gct/t2

if test -f oxDistG1.04/demo/traverse/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/demo/traverse/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/traverse/gct/t3
	if test -f oxDistG1.04/demo/traverse/gct/t3
	then
		echo Error: could not remove oxDistG1.04/demo/traverse/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/traverse/gct/t3
cat >oxDistG1.04/demo/traverse/gct/t3 <<'@EOF'
5*8+(((4+9)-(3/4)*34)+9*7)+4
@EOF
set `sum $sumopt <oxDistG1.04/demo/traverse/gct/t3`; if test $1 -ne 43249
then
	echo ERROR: oxDistG1.04/demo/traverse/gct/t3 checksum is $1 should be 43249
fi
set `wc -lwc <oxDistG1.04/demo/traverse/gct/t3`
if test $1$2$3 != 1129
then
	echo ERROR: wc results of oxDistG1.04/demo/traverse/gct/t3 are $* should be 1 1 29
fi

chmod 755 oxDistG1.04/demo/traverse/gct/t3

chmod 755 oxDistG1.04/demo/traverse/gct

chmod 755 oxDistG1.04/demo/traverse

echo mkdir - oxDistG1.04/demo/oxTutEGs
mkdir oxDistG1.04/demo/oxTutEGs

echo mkdir - oxDistG1.04/demo/oxTutEGs/eg1
mkdir oxDistG1.04/demo/oxTutEGs/eg1

if test -f oxDistG1.04/demo/oxTutEGs/eg1/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg1/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg1/Makefile
	if test -f oxDistG1.04/demo/oxTutEGs/eg1/Makefile
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg1/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg1/Makefile
cat >oxDistG1.04/demo/oxTutEGs/eg1/Makefile <<'@EOF'
gc: y.tab.o lex.yy.o 
	cc -o gc y.tab.o lex.yy.o -ly -ll  

y.tab.c y.tab.h: gram.y  
	yacc -d gram.y  

lex.yy.c: scan.l 
	lex scan.l 

y.tab.o: y.tab.c y.tab.h
	cc -c y.tab.c  

lex.yy.o: lex.yy.c y.tab.h 
	cc -c lex.yy.c   



clean: 
	rm *.o lex.yy.c y.tab.c y.tab.h gc     
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg1/Makefile`; if test $1 -ne 16902
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg1/Makefile checksum is $1 should be 16902
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg1/Makefile`
if test $1$2$3 != 1939279
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg1/Makefile are $* should be 19 39 279
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/Makefile

if test -f oxDistG1.04/demo/oxTutEGs/eg1/gram.y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg1/gram.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg1/gram.y
	if test -f oxDistG1.04/demo/oxTutEGs/eg1/gram.y
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg1/gram.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg1/gram.y
cat >oxDistG1.04/demo/oxTutEGs/eg1/gram.y <<'@EOF'
%token ICONST 
%left '+' '-'
%left '*' '/'

%%
expr    :       expr    '*'     expr
        |       expr    '/'     expr
        |       expr    '+'     expr
        |       expr    '-'     expr
        |       '('     expr    ')'
        |       ICONST
        ;
%% 
main() 
  {return(yyparse()); 
  } 
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg1/gram.y`; if test $1 -ne 17842
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg1/gram.y checksum is $1 should be 17842
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg1/gram.y`
if test $1$2$3 != 1637304
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg1/gram.y are $* should be 16 37 304
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/gram.y

if test -f oxDistG1.04/demo/oxTutEGs/eg1/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg1/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg1/README
	if test -f oxDistG1.04/demo/oxTutEGs/eg1/README
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg1/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg1/README
cat >oxDistG1.04/demo/oxTutEGs/eg1/README <<'@EOF'
An example from the Ox Tutorial Introduction.  The gct directory
contains sample inputs.
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg1/README`; if test $1 -ne 47352
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg1/README checksum is $1 should be 47352
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg1/README`
if test $1$2$3 != 21389
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg1/README are $* should be 2 13 89
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/README

echo mkdir - oxDistG1.04/demo/oxTutEGs/eg1/gct
mkdir oxDistG1.04/demo/oxTutEGs/eg1/gct

if test -f oxDistG1.04/demo/oxTutEGs/eg1/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg1/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg1/gct/t1
	if test -f oxDistG1.04/demo/oxTutEGs/eg1/gct/t1
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg1/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg1/gct/t1
cat >oxDistG1.04/demo/oxTutEGs/eg1/gct/t1 <<'@EOF'
3*7+9
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg1/gct/t1`; if test $1 -ne 22588
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg1/gct/t1 checksum is $1 should be 22588
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg1/gct/t1`
if test $1$2$3 != 116
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg1/gct/t1 are $* should be 1 1 6
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/gct/t1

if test -f oxDistG1.04/demo/oxTutEGs/eg1/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg1/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg1/gct/t2
	if test -f oxDistG1.04/demo/oxTutEGs/eg1/gct/t2
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg1/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg1/gct/t2
cat >oxDistG1.04/demo/oxTutEGs/eg1/gct/t2 <<'@EOF'
8*8*8*8*9+9+4*7
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg1/gct/t2`; if test $1 -ne 29492
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg1/gct/t2 checksum is $1 should be 29492
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg1/gct/t2`
if test $1$2$3 != 1116
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg1/gct/t2 are $* should be 1 1 16
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/gct/t2

if test -f oxDistG1.04/demo/oxTutEGs/eg1/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg1/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg1/gct/t3
	if test -f oxDistG1.04/demo/oxTutEGs/eg1/gct/t3
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg1/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg1/gct/t3
cat >oxDistG1.04/demo/oxTutEGs/eg1/gct/t3 <<'@EOF'
4*7+3*((4+9)*16)
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg1/gct/t3`; if test $1 -ne 40803
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg1/gct/t3 checksum is $1 should be 40803
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg1/gct/t3`
if test $1$2$3 != 1117
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg1/gct/t3 are $* should be 1 1 17
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/gct/t3

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/gct

if test -f oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile
	if test -f oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile
cat >oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile <<'@EOF'
gc: y.tab.o lex.yy.o 
	cc -o gc y.tab.o lex.yy.o -ly -ll  

oxout.y oxout.l: gram.y scan.l
	ox gram.y scan.l

y.tab.c y.tab.h: oxout.y  
	yacc -d oxout.y  

lex.yy.c: oxout.l 
	lex oxout.l 

y.tab.o: y.tab.c y.tab.h
	cc -c y.tab.c  

lex.yy.o: lex.yy.c y.tab.h 
	cc -c lex.yy.c   



clean: 
	rm *.o lex.yy.c y.tab.c y.tab.h oxout.? gc     
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile`; if test $1 -ne 60826
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile checksum is $1 should be 60826
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile`
if test $1$2$3 != 2247341
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile are $* should be 22 47 341
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/oxMakefile

if test -f oxDistG1.04/demo/oxTutEGs/eg1/scan.l
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg1/scan.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg1/scan.l
	if test -f oxDistG1.04/demo/oxTutEGs/eg1/scan.l
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg1/scan.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg1/scan.l
cat >oxDistG1.04/demo/oxTutEGs/eg1/scan.l <<'@EOF'
%{
#include "y.tab.h" 
%}

%% 
[ \n\t\f]+        ;  
[0-9]+            return(ICONST); 
[()*/+\-]         return(yytext[0]); 
%%
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg1/scan.l`; if test $1 -ne 9607
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg1/scan.l checksum is $1 should be 9607
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg1/scan.l`
if test $1$2$3 != 913129
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg1/scan.l are $* should be 9 13 129
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/scan.l

if test -f oxDistG1.04/demo/oxTutEGs/eg1/oxout.y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg1/oxout.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg1/oxout.y
	if test -f oxDistG1.04/demo/oxTutEGs/eg1/oxout.y
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg1/oxout.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg1/oxout.y
cat >oxDistG1.04/demo/oxTutEGs/eg1/oxout.y <<'@EOF'
/* output from Ox version 4.1 */
%{
%}
%token ICONST 
%left '+' '-'
%left '*' '/'


%{
                                                      /*custom*/  
typedef unsigned char yyyWAT; 
typedef unsigned char yyyRCT; 
typedef unsigned char yyyPNT; 
typedef unsigned char yyyWST; 

#include <limits.h>
#define yyyR UCHAR_MAX  

 /* funny type; as wide as the widest of yyyWAT,yyyWST,yyyRCT  */ 
typedef unsigned char yyyFT;

                                                      /*stock*/  

struct yyyGenNode {void *parent;  
                   struct yyyGenNode **cL; 
                   yyyRCT *refCountList; 
                   yyyPNT prodNum;                      
                   yyyWST whichSym; 
                  }; 

typedef struct yyyGenNode yyyGNT; 



struct yyyTB {int isEmpty; 
              int typeNum; 
              int nAttrbs; 
              char *snBufPtr; 
              yyyWAT *startP,*stopP; 
             };  




extern struct yyyTB yyyTermBuffer; 
extern yyyWAT yyyLRCIL[]; 
extern void yyyGenLeaf(); 


%}

%{
#include <stdio.h>

int yyyYok = 1;
int yyyInitDone = 0;
char *yyySTsn;
yyyGNT *yyySTN;
int yyyGNSz = sizeof(yyyGNT);
int yyyProdNum,yyyRHSlength,yyyNattrbs,yyyTypeNum; 

extern yyyFT yyyRCIL[];

void yyyExecuteRRsection();
void yyyYoxInit();
void yyyYoxReset();
void yyyDecorate();
void yyyGenIntNode();
void yyyAdjustINRC();
void yyyPrune();
void yyyerror();

#define yyyRSU(NUM1,NUM2,NUM3,NUM4) \
   yyyProdNum=NUM1;yyyRHSlength=NUM2;yyyNattrbs=NUM3;yyyTypeNum=NUM4;\
   if ((yychar <= 0) && (!yyyTermBuffer.isEmpty)) yyyShift(); 
%}


%%
yyyAugNonterm 
	:	{if (!yyyInitDone) 
		    {yyyYoxInit(); 
		     yyyInitDone = 1;
		    }
		 yyyYoxReset();
		}
		expr
		{
		 yyyDecorate(); yyyExecuteRRsection();
		}
	;
expr    :       expr    '*'     expr
        {if(yyyYok){
yyyRSU(1,3,0,0);
yyyGenIntNode();yyyAdjustINRC(yyyRCIL+0,yyyRCIL+0);yyyPrune();}}|       expr    '/'     expr
        {if(yyyYok){
yyyRSU(2,3,0,0);
yyyGenIntNode();yyyAdjustINRC(yyyRCIL+0,yyyRCIL+0);yyyPrune();}}|       expr    '+'     expr
        {if(yyyYok){
yyyRSU(3,3,0,0);
yyyGenIntNode();yyyAdjustINRC(yyyRCIL+0,yyyRCIL+0);yyyPrune();}}|       expr    '-'     expr
        {if(yyyYok){
yyyRSU(4,3,0,0);
yyyGenIntNode();yyyAdjustINRC(yyyRCIL+0,yyyRCIL+0);yyyPrune();}}|       '('     expr    ')'
        {if(yyyYok){
yyyRSU(5,3,0,0);
yyyGenIntNode();yyyAdjustINRC(yyyRCIL+0,yyyRCIL+0);yyyPrune();}}|       ICONST
        {if(yyyYok){
yyyRSU(6,1,0,0);
yyyGenIntNode();yyyAdjustINRC(yyyRCIL+0,yyyRCIL+0);yyyPrune();}};

%% 
main() 
  {return(yyparse()); 
  } 
                                                      /*custom*/  
long yyyMaxNbytesNodeStg = 400000; 
long yyyMaxNrefCounts =    100000; 
long yyyMaxNchildren =     12000; 
long yyyMaxStackSize =     1000; 
long yyySSALspaceSize =    10000; 
long yyyRSmaxSize =        500; 
long yyyTravStackMaxSize = 1000; 


struct yyyTB yyyTermBuffer; 

char *yyyNodeAndStackSpace; 

char *yyyNodeSpace;
char *yyyNextNodeSpace; 
char *yyyAfterNodeSpace; 


 
struct yyyGenNode **yyyChildListSpace;  
struct yyyGenNode **yyyNextCLspace; 
struct yyyGenNode **yyyAfterChildListSpace; 



yyyRCT *yyyRefCountListSpace;
yyyRCT *yyyNextRCLspace;  
yyyRCT *yyyAfterRefCountListSpace;   



struct yyySolvedSAlistCell {yyyWAT attrbNum; 
                            long next; 
                           }; 
#define yyyLambdaSSAL 0 
long yyySSALCfreeList = yyyLambdaSSAL; 
long yyyNewSSALC = 1; 
 
struct yyySolvedSAlistCell *yyySSALspace; 


 
struct yyyStackItem {struct yyyGenNode *node; 
                     long solvedSAlist; 
                     struct yyyGenNode *oldestNode; 
                    };  

long yyyNbytesStackStg; 
struct yyyStackItem *yyyStack; 
struct yyyStackItem *yyyAfterStack; 
struct yyyStackItem *yyyStackTop; 



struct yyyRSitem {yyyGNT *node; 
                  yyyWST whichSym; 
                  yyyWAT wa;  
                 };  

struct yyyRSitem *yyyRS;  
struct yyyRSitem *yyyRSTop;  
struct yyyRSitem *yyyAfterRS;  
 





yyyFT yyyRCIL[1];

short yyyIIIEL[] = {0,
0,4,8,12,16,20,
};

long yyyIIEL[] = {
0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,
};

long yyyIEL[1];

yyyFT yyyEntL[1];

#define yyyPermitUserAlloc  0 


void yyyfatal(msg)
  char *msg; 
{fprintf(stderr,msg);exit(-1);} 



#define yyyNSof   'n' 
#define yyyRCof   'r' 
#define yyyCLof   'c' 
#define yyySof    's' 
#define yyySSALof 'S' 
#define yyyRSof   'q' 
#define yyyTSof   't' 



void yyyHandleOverflow(which) 
  char which; 
  {char *msg1,*msg2; 
   long  oldSize,newSize; 
   switch(which) 
     {
      case yyyNSof   : 
           msg1 = "node storage overflow: ";
           oldSize = yyyMaxNbytesNodeStg; 
           break; 
      case yyyRCof   : 
           msg1 = "dependee count overflow: ";
           oldSize = yyyMaxNrefCounts; 
           break; 
      case yyyCLof   : 
           msg1 = "child list overflow: ";
           oldSize = yyyMaxNchildren; 
           break; 
      case yyySof    : 
           msg1 = "parse-tree stack overflow: ";
           oldSize = yyyMaxStackSize; 
           break; 
      case yyySSALof : 
           msg1 = "SSAL overflow: ";
           oldSize = yyySSALspaceSize; 
           break; 
      case yyyRSof   : 
           msg1 = "ready set overflow: ";
           oldSize = yyyRSmaxSize; 
           break; 
      case yyyTSof   : 
           msg1 = "traversal stack overflow: ";
           oldSize = yyyTravStackMaxSize; 
           break; 
      default        :;  
     }
   newSize = (5*oldSize)/4; 
   if (newSize < 100) newSize = 100; 
   fprintf(stderr,msg1); 
   fprintf(stderr,"size was %d.\n",oldSize); 
   if (yyyPermitUserAlloc) 
      msg2 = "     Try -Y%c%d option.\n"; 
      else 
      msg2 = "     Have to modify evaluator:  -Y%c%d.\n"; 
   fprintf(stderr,msg2,which,newSize); 
   exit(-1); 
  }



void yyySignalEnts(node,startP,stopP) 
  register yyyGNT *node; 
  register yyyFT *startP,*stopP;  
  {register yyyGNT *dumNode; 

   while (startP < stopP)  
     {
      if (!(*startP)) dumNode = node;  
         else dumNode = (node->cL)[(*startP)-1];   
      if (!(--((dumNode->refCountList)[*(startP+1)]
              ) 
           )
         ) 
         { 
          if (++yyyRSTop == yyyAfterRS) 
             {yyyHandleOverflow(yyyRSof); 
              break; 
             }
          yyyRSTop->node = dumNode; 
          yyyRSTop->whichSym = *startP;  
          yyyRSTop->wa = *(startP+1);  
         }  
      startP += 2;  
     }  
  } 




#define yyyCeiling(num,inc) (((inc) * ((num)/(inc))) + (((num)%(inc))?(inc):0)) 



int yyyAlignSize = 4;
int yyyNdSz[1];

int yyyNdPrSz[1];

typedef int yyyCopyType;

int yyyNdCopySz[1];
long yyyBiggestNodeSize = 0;

void yyyNodeSizeCalc()
  {int i;
   yyyGNSz = yyyCeiling(yyyGNSz,yyyAlignSize); 
   yyyNdSz[0] = 0;
   for (i=0;i<1;i++) 
       {yyyNdSz[i] = yyyCeiling(yyyNdSz[i],yyyAlignSize); 
        yyyNdPrSz[i] = yyyNdSz[i] + yyyGNSz;
        if (yyyBiggestNodeSize < yyyNdSz[i])
           yyyBiggestNodeSize = yyyNdSz[i];
        yyyNdCopySz[i] = yyyCeiling(yyyNdSz[i],sizeof(yyyCopyType)) / 
                         sizeof(yyyCopyType); 
       }
  }




void yyySolveAndSignal() {
register long yyyiDum,*yyypL;
register int yyyws,yyywa;
register yyyGNT *yyyRSTopN,*yyyRefN; 
register void *yyyRSTopNp; 


yyyRSTopNp = (yyyRSTopN = yyyRSTop->node)->parent;
yyyRefN= (yyyws = (yyyRSTop->whichSym))?((yyyGNT *)yyyRSTopNp):yyyRSTopN;
yyywa = yyyRSTop->wa; 
yyyRSTop--;
switch(yyyRefN->prodNum) {
case 1:  /***1***/
  switch (yyyws) {
  }
break;
case 2:  /***2***/
  switch (yyyws) {
  }
break;
case 3:  /***3***/
  switch (yyyws) {
  }
break;
case 4:  /***4***/
  switch (yyyws) {
  }
break;
case 5:  /***5***/
  switch (yyyws) {
  }
break;
case 6:  /***6***/
  switch (yyyws) {
  }
break;
} /* switch */ 

if (yyyws)  /* the just-solved instance was inherited. */ 
   {if (yyyRSTopN->prodNum) 
       {yyyiDum = yyyIIEL[yyyIIIEL[yyyRSTopN->prodNum]] + yyywa;
        yyySignalEnts(yyyRSTopN,yyyEntL + yyyIEL[yyyiDum],
                                yyyEntL + yyyIEL[yyyiDum+1]
                     );
       }
   } 
   else     /* the just-solved instance was synthesized. */ 
   {if ((char *)yyyRSTopNp >= yyyNodeSpace) /* node has a parent. */ 
       {yyyiDum = yyyIIEL[yyyIIIEL[((yyyGNT *)yyyRSTopNp)->prodNum] + 
                          yyyRSTopN->whichSym 
                         ] + 
                  yyywa;
        yyySignalEnts((yyyGNT *)yyyRSTopNp,
                      yyyEntL + yyyIEL[yyyiDum],
                      yyyEntL + yyyIEL[yyyiDum+1] 
                     );
       } 
       else   /* node is still on the stack--it has no parent yet. */ 
       {yyypL = &(((struct yyyStackItem *)yyyRSTopNp)->solvedSAlist); 
        if (yyySSALCfreeList == yyyLambdaSSAL) 
           {yyySSALspace[yyyNewSSALC].next = *yyypL; 
            if ((*yyypL = yyyNewSSALC++) == yyySSALspaceSize) 
               yyyHandleOverflow(yyySSALof); 
           }  
           else
           {yyyiDum = yyySSALCfreeList; 
            yyySSALCfreeList = yyySSALspace[yyySSALCfreeList].next; 
            yyySSALspace[yyyiDum].next = *yyypL; 
            *yyypL = yyyiDum;  
           } 
        yyySSALspace[*yyypL].attrbNum = yyywa; 
       } 
   }

} /* yyySolveAndSignal */ 



void yyyDoTraversals(){}
void yyyExecuteRRsection()  {
   int yyyi; 
   long yyynRefCounts; 
   long cycleSum = 0;
   long nNZrc = 0;

   if (!yyyYok) return; 
   yyynRefCounts = yyyNextRCLspace - yyyRefCountListSpace; 
   for (yyyi=0;yyyi<yyynRefCounts;yyyi++) 
     if (yyyRefCountListSpace[yyyi])
        {cycleSum += yyyRefCountListSpace[yyyi]; nNZrc++;} 
   if (cycleSum) 
      {
       fprintf(stderr,
               "postdecoration cycle: average ref count == %f.\n", 
               (float)(cycleSum/nNZrc) 
              ); 
      }
   yyyDoTraversals();
} /* yyyExecuteRRsection */ 



yyyWAT yyyLRCIL[1];



void yyyYoxInit()                                  /*stock*/  
  { 

   yyyNodeSizeCalc(); 

   if ((yyyTermBuffer.snBufPtr = 
        (char *) malloc((yyyBiggestNodeSize + sizeof(yyyCopyType)))
       )  
       == 
       ((char *) NULL) 
      )   
      yyyfatal("malloc error in yyyTermBuffer allocation\n");  
  
  
   yyyNbytesStackStg = yyyMaxStackSize*sizeof(struct yyyStackItem); 
   yyyNbytesStackStg = ((yyyNbytesStackStg/yyyAlignSize)+1)*yyyAlignSize;  
   if ((yyyNodeAndStackSpace = 
        (char *) malloc((yyyNbytesStackStg + 
                                 yyyMaxNbytesNodeStg + 
                                 yyyGNSz + 
                                 yyyBiggestNodeSize + 
                                 sizeof(yyyCopyType) 
                                )
                       )
       )  
       == 
       ((char *) NULL) 
      )   
      yyyfatal("malloc error in ox node and stack space allocation\n");
   yyyStack = (struct yyyStackItem *) yyyNodeAndStackSpace; 
   yyyAfterStack = yyyStack + yyyMaxStackSize;  
   yyyNodeSpace = yyyNodeAndStackSpace + yyyNbytesStackStg;
   yyyAfterNodeSpace = yyyNodeSpace + yyyMaxNbytesNodeStg;
 
 
   if ((yyyRS = (struct yyyRSitem *) 
         malloc(((yyyRSmaxSize+1)*sizeof(struct yyyRSitem)))
       )  
       == 
       ((struct yyyRSitem *) NULL) 
      )   
      yyyfatal("malloc error in ox ready set space allocation\n");  
   yyyRS++; 
   yyyAfterRS = yyyRS + yyyRSmaxSize; 

 
   if ((yyyChildListSpace = 
        (yyyGNT **) malloc((yyyMaxNchildren*sizeof(yyyGNT *)))
       )  
       == 
       ((yyyGNT **) NULL) 
      )   
      yyyfatal("malloc error in ox child list space allocation\n");  
   yyyAfterChildListSpace = yyyChildListSpace + yyyMaxNchildren; 

 
   if ((yyyRefCountListSpace = 
        (yyyRCT *) malloc((yyyMaxNrefCounts * sizeof(yyyRCT)))
       )  
       == 
       ((yyyRCT *) NULL) 
      )   
      yyyfatal("malloc error in ox reference count list space allocation\n");  
   yyyAfterRefCountListSpace = yyyRefCountListSpace + yyyMaxNrefCounts;  
  
 
   if ((yyySSALspace = (struct yyySolvedSAlistCell *) 
          malloc(((yyySSALspaceSize+1) * 
                          sizeof(struct yyySolvedSAlistCell))
                         ) 
       ) 
       == 
       ((struct yyySolvedSAlistCell *) NULL) 
      ) 
      yyyfatal("malloc error in stack solved list space allocation\n"); 
  } /* yyyYoxInit */ 



void yyyYoxReset() 
  { 
   yyyTermBuffer.isEmpty = 1; 
   yyyStackTop = yyyStack; 
   while (yyyStackTop != yyyAfterStack) 
     (yyyStackTop++)->solvedSAlist = yyyLambdaSSAL; 
   yyyStackTop = yyyStack - 1; 
   yyyNextNodeSpace = yyyNodeSpace; 
   yyyRSTop = yyyRS - 1; 
   yyyNextCLspace = yyyChildListSpace;
   yyyNextRCLspace = yyyRefCountListSpace; 
  }  



void yyyDecorate() 
  { 
   while (yyyRSTop >= yyyRS) 
      yyySolveAndSignal();  
  } 



void yyyShift() 
  {yyyRCT *rcPdum; 
   register yyyCopyType *CTp1,*CTp2,*CTp3; 
   register yyyWAT *startP,*stopP;  

   if ((++yyyStackTop) == yyyAfterStack) 
      yyyHandleOverflow(yyySof);
   CTp2 = (yyyCopyType *)(yyyStackTop->oldestNode = 
                          yyyStackTop->node = 
                          (yyyGNT *)yyyNextNodeSpace 
                         ); 
   yyyTermBuffer.isEmpty = 1;
   ((yyyGNT *)CTp2)->parent = (void *)yyyStackTop; 
   ((yyyGNT *)CTp2)->cL = yyyNextCLspace;  
   rcPdum = ((yyyGNT *)CTp2)->refCountList = yyyNextRCLspace;  
   ((yyyGNT *)CTp2)->prodNum = 0; 
   if ((yyyNextRCLspace += yyyTermBuffer.nAttrbs) 
       > 
       yyyAfterRefCountListSpace 
      ) 
      yyyHandleOverflow(yyyRCof); 
   startP = yyyTermBuffer.startP;  
   stopP = yyyTermBuffer.stopP;  
   while (startP < stopP) rcPdum[*(startP++)] = 0; 
   if ((yyyNextNodeSpace += yyyNdPrSz[yyyTermBuffer.typeNum]) 
       > 
       yyyAfterNodeSpace 
      ) 
      yyyHandleOverflow(yyyNSof);  
   CTp1 = (yyyCopyType *)(yyyTermBuffer.snBufPtr); 
   CTp2 = (yyyCopyType *)(((char *)CTp2) + yyyGNSz); 
   CTp3 = CTp2 + yyyNdCopySz[yyyTermBuffer.typeNum]; 
   while (CTp2 < CTp3) *CTp2++ = *CTp1++; 
  } 



void yyyGenIntNode() 
  {register yyyWST i;
   register struct yyyStackItem *stDum;  
   register yyyGNT *gnpDum; 

   if ((stDum = (yyyStackTop -= (yyyRHSlength-1))) >= yyyAfterStack) 
      yyyHandleOverflow(yyySof);
   yyySTsn = ((char *)(yyySTN = (yyyGNT *)yyyNextNodeSpace)) + yyyGNSz; 
   yyySTN->parent       =  (void *)yyyStackTop;  
   yyySTN->cL           =  yyyNextCLspace; 
   yyySTN->refCountList =  yyyNextRCLspace; 
   yyySTN->prodNum      =  yyyProdNum; 
   if ((yyyNextCLspace+yyyRHSlength) > yyyAfterChildListSpace) 
      yyyHandleOverflow(yyyCLof); 
   for (i=1;i<=yyyRHSlength;i++) 
     {gnpDum = *(yyyNextCLspace++) = (stDum++)->node;  
      gnpDum->whichSym = i;  
      gnpDum->parent = (void *)yyyNextNodeSpace; 
     } 
   if ((yyyNextRCLspace += yyyNattrbs) > yyyAfterRefCountListSpace) 
      yyyHandleOverflow(yyyRCof); 
   if ((yyyNextNodeSpace += yyyNdPrSz[yyyTypeNum]) > yyyAfterNodeSpace) 
      yyyHandleOverflow(yyyNSof);  
  } 



#define DECORfREQ 50 



void yyyAdjustINRC(startP,stopP) 
  register yyyFT *startP,*stopP;
  {yyyWST i;
   long SSALptr,SSALptrHead,*cPtrPtr; 
   long *pL; 
   struct yyyStackItem *stDum;  
   yyyGNT *gnpDum; 
   long iTemp;
   register yyyFT *nextP;
   static unsigned short intNodeCount = DECORfREQ;

   nextP = startP;
   while (nextP < stopP) 
     {if ((*nextP) == yyyR)  
         {(yyySTN->refCountList)[*(nextP+1)] = *(nextP+2);
         } 
         else 
         {(((yyySTN->cL)[*nextP])->refCountList)[*(nextP+1)] = *(nextP+2);
         } 
      nextP += 3;  
     }
   pL = yyyIIEL + yyyIIIEL[yyyProdNum]; 
   stDum = yyyStackTop;  
   for (i=1;i<=yyyRHSlength;i++) 
     {pL++; 
      SSALptrHead = SSALptr = *(cPtrPtr = &((stDum++)->solvedSAlist)); 
      if (SSALptr != yyyLambdaSSAL) 
         {*cPtrPtr = yyyLambdaSSAL; 
          do 
            {
             iTemp = (*pL+yyySSALspace[SSALptr].attrbNum);
             yyySignalEnts(yyySTN,
                           yyyEntL + yyyIEL[iTemp],
                           yyyEntL + yyyIEL[iTemp+1]
                          );  
             SSALptr = *(cPtrPtr = &(yyySSALspace[SSALptr].next)); 
            } 
            while (SSALptr != yyyLambdaSSAL);  
          *cPtrPtr = yyySSALCfreeList;  
          yyySSALCfreeList = SSALptrHead;  
         } 
     } 
   nextP = startP + 2;
   while (nextP < stopP) 
     {if (!(*nextP))
         {if ((*(nextP-2)) == yyyR)  
             {pL = &(yyyStackTop->solvedSAlist); 
              if (yyySSALCfreeList == yyyLambdaSSAL) 
                 {yyySSALspace[yyyNewSSALC].next = *pL; 
                  if ((*pL = yyyNewSSALC++) == yyySSALspaceSize) 
                     yyyHandleOverflow(yyySSALof); 
                 }  
                 else
                 {iTemp = yyySSALCfreeList; 
                  yyySSALCfreeList = yyySSALspace[yyySSALCfreeList].next; 
                  yyySSALspace[iTemp].next = *pL; 
                  *pL = iTemp;  
                 } 
              yyySSALspace[*pL].attrbNum = *(nextP-1); 
             } 
             else 
             {if ((gnpDum = (yyySTN->cL)[*(nextP-2)])->prodNum != 0)
                 {
                  iTemp = yyyIIEL[yyyIIIEL[gnpDum->prodNum]] + *(nextP-1);
                  yyySignalEnts(gnpDum, 
                                yyyEntL + yyyIEL[iTemp],  
                                yyyEntL + yyyIEL[iTemp+1] 
                               );    
                 }  
             } 
         } 
      nextP += 3; 
     } 
   yyyStackTop->node = yyySTN;
   if (!yyyRHSlength) yyyStackTop->oldestNode = yyySTN; 
   if (!--intNodeCount) 
      {intNodeCount = DECORfREQ; 
       yyyDecorate(); 
      } 
  } 



void yyyPrune() 
  {  
   int i,n; 
   register char *cp1,*cp2;  
   register yyyRCT *rcp1,*rcp2,*rcp3;  
   long cycleSum = 0;
   long nNZrc = 0;
   
   yyyDecorate();
   yyyNextRCLspace = 
     (rcp1 = rcp2 = (yyyStackTop->oldestNode)->refCountList) + yyyNattrbs;
   rcp3 = (yyyStackTop->node)->refCountList; 
   while (rcp2 < rcp3) 
     if (*rcp2++) {cycleSum += *(rcp2 -1); nNZrc++;} 
   if (cycleSum) 
      {
       fprintf(stderr,"pruning cycle: average ref count == %f.\n", 
               (float)(cycleSum/nNZrc) 
              ); 
       return; 
      }
   for (i=0;i<yyyNattrbs;i++) rcp1[i] = rcp3[i]; 
   yyyNextCLspace = (yyyStackTop->oldestNode)->cL; 
   yyyNextNodeSpace = (char *)(yyyStackTop->oldestNode) + 
                      (n = yyyNdPrSz[yyyTypeNum]);
   cp1 = (char *)yyyStackTop->oldestNode; 
   cp2 = (char *)yyyStackTop->node; 
   for (i=0;i<n;i++) *cp1++ = *cp2++; 
   yyyStackTop->node = yyyStackTop->oldestNode; 
   (yyyStackTop->node)->refCountList = rcp1; 
   (yyyStackTop->node)->cL = yyyNextCLspace; 
  } 



void yyyGenLeaf(nAttrbs,typeNum,startP,stopP) 
  int nAttrbs,typeNum; 
  yyyWAT *startP,*stopP; 
  {
   if  (!(yyyTermBuffer.isEmpty)) yyyShift(); 
   yyyTermBuffer.isEmpty = 0;
   yyyTermBuffer.typeNum = typeNum; 
   yyyTermBuffer.nAttrbs = nAttrbs; 
   yyyTermBuffer.startP = startP; 
   yyyTermBuffer.stopP = stopP; 
   
  } 



void yyyerror()
  {yyyYok = 0; 
  } 



/* read the command line for changes in sizes of 
                  the evaluator's data structures */
void yyyCheckForResizes(argc,argv) 
  int argc; 
  char *argv[]; 
  {int i; 
   long dum; 
 
   if (!yyyPermitUserAlloc) return; 
   for (i=1;i<argc;i++) 
     { 
      if ((argv[i][0] != '-') || (argv[i][1] != 'Y')) continue; 
      if (strlen(argv[i]) < 4) goto yyyErrO1; 
      if (sscanf(argv[i]+3,"%d",&dum) != 1) goto yyyErrO1;
      if (dum < 2) dum = 2;
      switch (argv[i][2]) 
        {case yyyNSof:   yyyMaxNbytesNodeStg = dum; break; 
         case yyyRCof:   yyyMaxNrefCounts    = dum; break; 
         case yyyCLof:   yyyMaxNchildren     = dum; break; 
         case yyySof:    yyyMaxStackSize     = dum; break; 
         case yyySSALof: yyySSALspaceSize    = dum; break; 
         case yyyRSof:   yyyRSmaxSize        = dum; break; 
         case yyyTSof:   yyyTravStackMaxSize = dum; break; 
         default : goto yyyErrO1; 
        }
      continue;  
   yyyErrO1 : fprintf(stderr,"invalid command line option: %s\n",
                             argv[i] 
                     ); 
     } 
  } 
   
   
   
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg1/oxout.y`; if test $1 -ne 4334
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg1/oxout.y checksum is $1 should be 4334
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg1/oxout.y`
if test $1$2$3 != 777174820233
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg1/oxout.y are $* should be 777 1748 20233
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/oxout.y

if test -f oxDistG1.04/demo/oxTutEGs/eg1/oxout.l
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg1/oxout.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg1/oxout.l
	if test -f oxDistG1.04/demo/oxTutEGs/eg1/oxout.l
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg1/oxout.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg1/oxout.l
cat >oxDistG1.04/demo/oxTutEGs/eg1/oxout.l <<'@EOF'
/* output from Ox version 4.1 */
%{
#include "y.tab.h" 
%}


%{
                                                      /*custom*/  
typedef unsigned char yyyWAT; 
typedef unsigned char yyyRCT; 
typedef unsigned char yyyPNT; 
typedef unsigned char yyyWST; 

#include <limits.h>
#define yyyR UCHAR_MAX  

 /* funny type; as wide as the widest of yyyWAT,yyyWST,yyyRCT  */ 
typedef unsigned char yyyFT;

                                                      /*stock*/  

struct yyyGenNode {void *parent;  
                   struct yyyGenNode **cL; 
                   yyyRCT *refCountList; 
                   yyyPNT prodNum;                      
                   yyyWST whichSym; 
                  }; 

typedef struct yyyGenNode yyyGNT; 



struct yyyTB {int isEmpty; 
              int typeNum; 
              int nAttrbs; 
              char *snBufPtr; 
              yyyWAT *startP,*stopP; 
             };  




extern struct yyyTB yyyTermBuffer; 
extern yyyWAT yyyLRCIL[]; 
extern void yyyGenLeaf(); 


%}
%% 
[ \n\t\f]+        ;  
[0-9]+            {yyyGenLeaf(0,0,yyyLRCIL+0,yyyLRCIL+0);return(ICONST);} 
[()*/+\-]         {yyyGenLeaf(0,0,yyyLRCIL+0,yyyLRCIL+0);return(yytext[0]);} 
%%
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg1/oxout.l`; if test $1 -ne 9531
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg1/oxout.l checksum is $1 should be 9531
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg1/oxout.l`
if test $1$2$3 != 531011194
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg1/oxout.l are $* should be 53 101 1194
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1/oxout.l

chmod 755 oxDistG1.04/demo/oxTutEGs/eg1

echo mkdir - oxDistG1.04/demo/oxTutEGs/eg2
mkdir oxDistG1.04/demo/oxTutEGs/eg2

if test -f oxDistG1.04/demo/oxTutEGs/eg2/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg2/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg2/Makefile
	if test -f oxDistG1.04/demo/oxTutEGs/eg2/Makefile
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg2/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg2/Makefile
cat >oxDistG1.04/demo/oxTutEGs/eg2/Makefile <<'@EOF'
gc: y.tab.o lex.yy.o 
	cc -o gc y.tab.o lex.yy.o -ly -ll  

oxout.y oxout.l: gram.y scan.l
	ox gram.y scan.l

y.tab.c y.tab.h: oxout.y  
	yacc -d oxout.y  

lex.yy.c: oxout.l 
	lex oxout.l 

y.tab.o: y.tab.c 
	cc -c y.tab.c  

lex.yy.o: lex.yy.c y.tab.h 
	cc -c lex.yy.c   



clean: 
	rm *.o oxout.* lex.yy.c y.tab.c y.tab.h gc     
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg2/Makefile`; if test $1 -ne 31760
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg2/Makefile checksum is $1 should be 31760
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg2/Makefile`
if test $1$2$3 != 2246334
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg2/Makefile are $* should be 22 46 334
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg2/Makefile

if test -f oxDistG1.04/demo/oxTutEGs/eg2/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg2/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg2/README
	if test -f oxDistG1.04/demo/oxTutEGs/eg2/README
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg2/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg2/README
cat >oxDistG1.04/demo/oxTutEGs/eg2/README <<'@EOF'
An example from the Ox Tutorial Introduction.  The gct directory
contains sample inputs.
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg2/README`; if test $1 -ne 47352
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg2/README checksum is $1 should be 47352
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg2/README`
if test $1$2$3 != 21389
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg2/README are $* should be 2 13 89
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg2/README

if test -f oxDistG1.04/demo/oxTutEGs/eg2/gram.y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg2/gram.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg2/gram.y
	if test -f oxDistG1.04/demo/oxTutEGs/eg2/gram.y
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg2/gram.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg2/gram.y
sed 's/^@//' >oxDistG1.04/demo/oxTutEGs/eg2/gram.y <<'@EOF'
%token ICONST 
%left '+' '-'
%left '*' '/'

@@attributes {char *string; } ICONST
@@attributes {long val;}      expr 

%%
expr    :       expr    '*'     expr 
                @{ @i @expr.0.val@ = @expr.1.val@ * @expr.2.val@;  @} 

        |       expr    '/'     expr
                @{ @i @expr.0.val@ = @expr.1.val@ / @expr.2.val@;  @} 

        |       expr    '+'     expr
                @{ @i @expr.val@ = @expr.1.val@ + @expr.2.val@;    @} 

        |       expr    '-'     expr
                @{ @i @expr.0.val@ = @expr.1.val@ - @expr.2.val@;  @} 

        |       '('     expr    ')'
                @{ @i @expr.0.val@ = @expr.1.val@;                 @} 

        |       ICONST
                @{ @i @expr.val@ = atoi(@ICONST.string@);          @} 
        ;
%% 
main() 
  {return(yyparse()); 
  } 
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg2/gram.y`; if test $1 -ne 19049
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg2/gram.y checksum is $1 should be 19049
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg2/gram.y`
if test $1$2$3 != 3090808
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg2/gram.y are $* should be 30 90 808
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg2/gram.y

if test -f oxDistG1.04/demo/oxTutEGs/eg2/scan.l
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg2/scan.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg2/scan.l
	if test -f oxDistG1.04/demo/oxTutEGs/eg2/scan.l
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg2/scan.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg2/scan.l
cat >oxDistG1.04/demo/oxTutEGs/eg2/scan.l <<'@EOF'
%{
#include "y.tab.h" 
#include <string.h>

#define lexeme strcpy((char *)malloc(yyleng+1),yytext)
%}

%% 
[ \n\t\f]+        ;  
[0-9]+            return(ICONST); @{ @ICONST.string@ = lexeme; @} 
"("               return('('); 
")"               return(')'); 
"*"               return('*'); 
"/"               return('/'); 
"+"               return('+'); 
"-"               return('-'); 
%%
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg2/scan.l`; if test $1 -ne 12270
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg2/scan.l checksum is $1 should be 12270
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg2/scan.l`
if test $1$2$3 != 1734391
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg2/scan.l are $* should be 17 34 391
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg2/scan.l

echo mkdir - oxDistG1.04/demo/oxTutEGs/eg2/gct
mkdir oxDistG1.04/demo/oxTutEGs/eg2/gct

if test -f oxDistG1.04/demo/oxTutEGs/eg2/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg2/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg2/gct/t1
	if test -f oxDistG1.04/demo/oxTutEGs/eg2/gct/t1
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg2/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg2/gct/t1
cat >oxDistG1.04/demo/oxTutEGs/eg2/gct/t1 <<'@EOF'
3*7+9
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg2/gct/t1`; if test $1 -ne 22588
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg2/gct/t1 checksum is $1 should be 22588
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg2/gct/t1`
if test $1$2$3 != 116
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg2/gct/t1 are $* should be 1 1 6
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg2/gct/t1

if test -f oxDistG1.04/demo/oxTutEGs/eg2/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg2/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg2/gct/t2
	if test -f oxDistG1.04/demo/oxTutEGs/eg2/gct/t2
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg2/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg2/gct/t2
cat >oxDistG1.04/demo/oxTutEGs/eg2/gct/t2 <<'@EOF'
8*8*8*8*9+9+4*7
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg2/gct/t2`; if test $1 -ne 29492
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg2/gct/t2 checksum is $1 should be 29492
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg2/gct/t2`
if test $1$2$3 != 1116
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg2/gct/t2 are $* should be 1 1 16
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg2/gct/t2

if test -f oxDistG1.04/demo/oxTutEGs/eg2/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg2/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg2/gct/t3
	if test -f oxDistG1.04/demo/oxTutEGs/eg2/gct/t3
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg2/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg2/gct/t3
cat >oxDistG1.04/demo/oxTutEGs/eg2/gct/t3 <<'@EOF'
4*7+3*((4+9)*16)
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg2/gct/t3`; if test $1 -ne 40803
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg2/gct/t3 checksum is $1 should be 40803
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg2/gct/t3`
if test $1$2$3 != 1117
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg2/gct/t3 are $* should be 1 1 17
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg2/gct/t3

chmod 755 oxDistG1.04/demo/oxTutEGs/eg2/gct

chmod 755 oxDistG1.04/demo/oxTutEGs/eg2

echo mkdir - oxDistG1.04/demo/oxTutEGs/eg3
mkdir oxDistG1.04/demo/oxTutEGs/eg3

if test -f oxDistG1.04/demo/oxTutEGs/eg3/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg3/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg3/Makefile
	if test -f oxDistG1.04/demo/oxTutEGs/eg3/Makefile
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg3/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg3/Makefile
cat >oxDistG1.04/demo/oxTutEGs/eg3/Makefile <<'@EOF'
gc: y.tab.o lex.yy.o 
	cc -o gc y.tab.o lex.yy.o -ly -ll  

oxout.y oxout.l : gram.y scan.l; 
	ox gram.y scan.l

y.tab.c y.tab.h: oxout.y  
	yacc -d oxout.y  

lex.yy.c: oxout.l 
	lex oxout.l 

y.tab.o: y.tab.c 
	cc -c y.tab.c  

lex.yy.o: lex.yy.c y.tab.h 
	cc -c lex.yy.c   



clean: 
	rm *.o oxout.* lex.yy.c y.tab.c y.tab.h gc     
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg3/Makefile`; if test $1 -ne 57521
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg3/Makefile checksum is $1 should be 57521
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg3/Makefile`
if test $1$2$3 != 2247337
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg3/Makefile are $* should be 22 47 337
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg3/Makefile

if test -f oxDistG1.04/demo/oxTutEGs/eg3/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg3/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg3/README
	if test -f oxDistG1.04/demo/oxTutEGs/eg3/README
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg3/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg3/README
cat >oxDistG1.04/demo/oxTutEGs/eg3/README <<'@EOF'
An example from the Ox Tutorial Introduction.  The gct directory
contains sample inputs.
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg3/README`; if test $1 -ne 47352
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg3/README checksum is $1 should be 47352
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg3/README`
if test $1$2$3 != 21389
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg3/README are $* should be 2 13 89
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg3/README

if test -f oxDistG1.04/demo/oxTutEGs/eg3/gram.y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg3/gram.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg3/gram.y
	if test -f oxDistG1.04/demo/oxTutEGs/eg3/gram.y
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg3/gram.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg3/gram.y
sed 's/^@//' >oxDistG1.04/demo/oxTutEGs/eg3/gram.y <<'@EOF'
%token ICONST 
%left '+' '-'
%left '*' '/'

%{                                                              /* */
long globVal;                                                   /* */
%}                                                              /* */

@@attributes {char *string;} ICONST
@@attributes {long val;}     s expr                              /* */
%%
s       :       expr                                            /* */
                @{ @i globVal = @s.val@ = @expr.val@;      @}   /* */
        ;                                                       /* */

expr    :       expr    '*'     expr 
                @{ @i @expr.0.val@ = @expr.1.val@ * @expr.2.val@;  @} 

        |       expr    '/'     expr
                @{ @i @expr.0.val@ = @expr.1.val@ / @expr.2.val@;  @} 

        |       expr    '+'     expr
                @{ @i @expr.val@ = @expr.1.val@ + @expr.2.val@;    @} 

        |       expr    '-'     expr
                @{ @i @expr.0.val@ = @expr.1.val@ - @expr.2.val@;  @} 

        |       '('     expr    ')'
                @{ @i @expr.0.val@ = @expr.1.val@;                 @} 

        |       ICONST
                @{ @i @expr.val@ = atoi(@ICONST.string@);          @} 
        ;
%% 
main() 
  {yyparse();                                                   /* */ 
   printf("%d\n",globVal);                                      /* */
  } 
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg3/gram.y`; if test $1 -ne 13788
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg3/gram.y checksum is $1 should be 13788
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg3/gram.y`
if test $1$2$3 != 381251381
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg3/gram.y are $* should be 38 125 1381
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg3/gram.y

if test -f oxDistG1.04/demo/oxTutEGs/eg3/scan.l
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg3/scan.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg3/scan.l
	if test -f oxDistG1.04/demo/oxTutEGs/eg3/scan.l
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg3/scan.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg3/scan.l
cat >oxDistG1.04/demo/oxTutEGs/eg3/scan.l <<'@EOF'
%{
#include "y.tab.h" 
#include <string.h>

#define lexeme strcpy((char *)malloc(yyleng+1),yytext)
%}

%% 
[ \n\t\f]+        ;  
[0-9]+            return(ICONST); @{ @ICONST.string@ = lexeme; @} 
"("               return('('); 
")"               return(')'); 
"*"               return('*'); 
"/"               return('/'); 
"+"               return('+'); 
"-"               return('-'); 
%%
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg3/scan.l`; if test $1 -ne 12270
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg3/scan.l checksum is $1 should be 12270
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg3/scan.l`
if test $1$2$3 != 1734391
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg3/scan.l are $* should be 17 34 391
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg3/scan.l

echo mkdir - oxDistG1.04/demo/oxTutEGs/eg3/gct
mkdir oxDistG1.04/demo/oxTutEGs/eg3/gct

if test -f oxDistG1.04/demo/oxTutEGs/eg3/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg3/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg3/gct/t1
	if test -f oxDistG1.04/demo/oxTutEGs/eg3/gct/t1
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg3/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg3/gct/t1
cat >oxDistG1.04/demo/oxTutEGs/eg3/gct/t1 <<'@EOF'
3*7+9
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg3/gct/t1`; if test $1 -ne 22588
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg3/gct/t1 checksum is $1 should be 22588
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg3/gct/t1`
if test $1$2$3 != 116
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg3/gct/t1 are $* should be 1 1 6
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg3/gct/t1

if test -f oxDistG1.04/demo/oxTutEGs/eg3/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg3/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg3/gct/t2
	if test -f oxDistG1.04/demo/oxTutEGs/eg3/gct/t2
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg3/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg3/gct/t2
cat >oxDistG1.04/demo/oxTutEGs/eg3/gct/t2 <<'@EOF'
8*8*8*8*9+9+4*7
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg3/gct/t2`; if test $1 -ne 29492
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg3/gct/t2 checksum is $1 should be 29492
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg3/gct/t2`
if test $1$2$3 != 1116
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg3/gct/t2 are $* should be 1 1 16
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg3/gct/t2

if test -f oxDistG1.04/demo/oxTutEGs/eg3/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg3/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg3/gct/t3
	if test -f oxDistG1.04/demo/oxTutEGs/eg3/gct/t3
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg3/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg3/gct/t3
cat >oxDistG1.04/demo/oxTutEGs/eg3/gct/t3 <<'@EOF'
4*7+3*((4+9)*16)
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg3/gct/t3`; if test $1 -ne 40803
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg3/gct/t3 checksum is $1 should be 40803
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg3/gct/t3`
if test $1$2$3 != 1117
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg3/gct/t3 are $* should be 1 1 17
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg3/gct/t3

chmod 755 oxDistG1.04/demo/oxTutEGs/eg3/gct

chmod 755 oxDistG1.04/demo/oxTutEGs/eg3

echo mkdir - oxDistG1.04/demo/oxTutEGs/eg4
mkdir oxDistG1.04/demo/oxTutEGs/eg4

if test -f oxDistG1.04/demo/oxTutEGs/eg4/gram.y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg4/gram.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg4/gram.y
	if test -f oxDistG1.04/demo/oxTutEGs/eg4/gram.y
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg4/gram.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg4/gram.y
sed 's/^@//' >oxDistG1.04/demo/oxTutEGs/eg4/gram.y <<'@EOF'
%token ICONST 
%left '+' '-'
%left '*' '/'

@@traversal @preorder yourTrav
@@traversal @preorder yoursToo

@@attributes {char *string;} ICONST
@@attributes {long val;}     s expr 
%%
s       :       expr
                @{ @i @s.val@ = @expr.val@; 
                   @yoursToo printf("\n%d\n",@s.val@);
                @}
        ;
expr    :       expr    '*'     expr 
                @{ @i @expr.0.val@ = @expr.1.val@ * @expr.2.val@; 
                   @yourTrav printf(" * "); 
                @} 
        |       expr    '/'     expr
                @{ @i @expr.0.val@ = @expr.1.val@ / @expr.2.val@; 
                   @yourTrav printf(" / "); 
                @} 
        |       expr    '+'     expr
                @{ @i @expr.val@ = @expr.1.val@ + @expr.2.val@; 
                   @yourTrav printf(" + "); 
                @} 
        |       expr    '-'     expr
                @{ @i @expr.0.val@ = @expr.1.val@ - @expr.2.val@; 
                   @yourTrav printf(" - "); 
                @} 
        |       '('     expr    ')'
                @{ @i @expr.0.val@ = @expr.1.val@; 
                @} 
        |       ICONST
                @{ @i @expr.val@ = atoi(@ICONST.string@); 
                   @yourTrav printf(" %s ",@ICONST.string@); 
                @} 
        ;
%% 
main() 
  {return(yyparse()); 
  } 
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg4/gram.y`; if test $1 -ne 59771
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg4/gram.y checksum is $1 should be 59771
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg4/gram.y`
if test $1$2$3 != 431281326
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg4/gram.y are $* should be 43 128 1326
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg4/gram.y

if test -f oxDistG1.04/demo/oxTutEGs/eg4/scan.l
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg4/scan.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg4/scan.l
	if test -f oxDistG1.04/demo/oxTutEGs/eg4/scan.l
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg4/scan.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg4/scan.l
cat >oxDistG1.04/demo/oxTutEGs/eg4/scan.l <<'@EOF'
%{
#include "y.tab.h" 
#include <string.h>

#define lexeme strcpy((char *)malloc(yyleng+1),yytext)
%}

%% 
[ \n\t\f]+        ;  
[0-9]+            return(ICONST); @{ @ICONST.string@ = lexeme; @} 
"("               return('('); 
")"               return(')'); 
"*"               return('*'); 
"/"               return('/'); 
"+"               return('+'); 
"-"               return('-'); 
%%
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg4/scan.l`; if test $1 -ne 12270
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg4/scan.l checksum is $1 should be 12270
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg4/scan.l`
if test $1$2$3 != 1734391
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg4/scan.l are $* should be 17 34 391
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg4/scan.l

if test -f oxDistG1.04/demo/oxTutEGs/eg4/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg4/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg4/Makefile
	if test -f oxDistG1.04/demo/oxTutEGs/eg4/Makefile
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg4/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg4/Makefile
cat >oxDistG1.04/demo/oxTutEGs/eg4/Makefile <<'@EOF'
gc: y.tab.o lex.yy.o 
	cc -o gc y.tab.o lex.yy.o -ly -ll  

oxout.y oxout.l: gram.y scan.l
	ox gram.y scan.l

y.tab.c y.tab.h: oxout.y  
	yacc -d oxout.y  

lex.yy.c: oxout.l 
	lex oxout.l 

y.tab.o: y.tab.c 
	cc -c y.tab.c  

lex.yy.o: lex.yy.c y.tab.h 
	cc -c lex.yy.c   



clean: 
	rm *.o oxout.* lex.yy.c y.tab.c y.tab.h gc     
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg4/Makefile`; if test $1 -ne 31760
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg4/Makefile checksum is $1 should be 31760
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg4/Makefile`
if test $1$2$3 != 2246334
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg4/Makefile are $* should be 22 46 334
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg4/Makefile

if test -f oxDistG1.04/demo/oxTutEGs/eg4/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg4/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg4/README
	if test -f oxDistG1.04/demo/oxTutEGs/eg4/README
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg4/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg4/README
cat >oxDistG1.04/demo/oxTutEGs/eg4/README <<'@EOF'
An example from the Ox Tutorial Introduction.  The gct directory
contains sample inputs.
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg4/README`; if test $1 -ne 47352
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg4/README checksum is $1 should be 47352
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg4/README`
if test $1$2$3 != 21389
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg4/README are $* should be 2 13 89
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg4/README

echo mkdir - oxDistG1.04/demo/oxTutEGs/eg4/gct
mkdir oxDistG1.04/demo/oxTutEGs/eg4/gct

if test -f oxDistG1.04/demo/oxTutEGs/eg4/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg4/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg4/gct/t1
	if test -f oxDistG1.04/demo/oxTutEGs/eg4/gct/t1
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg4/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg4/gct/t1
cat >oxDistG1.04/demo/oxTutEGs/eg4/gct/t1 <<'@EOF'
3*7+9
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg4/gct/t1`; if test $1 -ne 22588
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg4/gct/t1 checksum is $1 should be 22588
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg4/gct/t1`
if test $1$2$3 != 116
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg4/gct/t1 are $* should be 1 1 6
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg4/gct/t1

if test -f oxDistG1.04/demo/oxTutEGs/eg4/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg4/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg4/gct/t2
	if test -f oxDistG1.04/demo/oxTutEGs/eg4/gct/t2
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg4/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg4/gct/t2
cat >oxDistG1.04/demo/oxTutEGs/eg4/gct/t2 <<'@EOF'
8*8*8*8*9+9+4*7
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg4/gct/t2`; if test $1 -ne 29492
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg4/gct/t2 checksum is $1 should be 29492
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg4/gct/t2`
if test $1$2$3 != 1116
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg4/gct/t2 are $* should be 1 1 16
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg4/gct/t2

if test -f oxDistG1.04/demo/oxTutEGs/eg4/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg4/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg4/gct/t3
	if test -f oxDistG1.04/demo/oxTutEGs/eg4/gct/t3
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg4/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg4/gct/t3
cat >oxDistG1.04/demo/oxTutEGs/eg4/gct/t3 <<'@EOF'
4*7+3*((4+9)*16)
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg4/gct/t3`; if test $1 -ne 40803
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg4/gct/t3 checksum is $1 should be 40803
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg4/gct/t3`
if test $1$2$3 != 1117
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg4/gct/t3 are $* should be 1 1 17
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg4/gct/t3

chmod 755 oxDistG1.04/demo/oxTutEGs/eg4/gct

chmod 755 oxDistG1.04/demo/oxTutEGs/eg4

echo mkdir - oxDistG1.04/demo/oxTutEGs/eg5
mkdir oxDistG1.04/demo/oxTutEGs/eg5

if test -f oxDistG1.04/demo/oxTutEGs/eg5/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg5/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg5/Makefile
	if test -f oxDistG1.04/demo/oxTutEGs/eg5/Makefile
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg5/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg5/Makefile
cat >oxDistG1.04/demo/oxTutEGs/eg5/Makefile <<'@EOF'
gc: y.tab.o lex.yy.o 
	cc -o gc y.tab.o lex.yy.o -ly -ll  

oxout.y oxout.l: gram.y scan.l
	ox gram.y scan.l

y.tab.c y.tab.h: oxout.y  
	yacc -d oxout.y  

lex.yy.c: oxout.l 
	lex oxout.l 

y.tab.o: y.tab.c 
	cc -c y.tab.c  

lex.yy.o: lex.yy.c y.tab.h 
	cc -c lex.yy.c   



clean: 
	rm *.o oxout.* lex.yy.c y.tab.c y.tab.h gc     
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg5/Makefile`; if test $1 -ne 31760
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg5/Makefile checksum is $1 should be 31760
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg5/Makefile`
if test $1$2$3 != 2246334
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg5/Makefile are $* should be 22 46 334
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5/Makefile

if test -f oxDistG1.04/demo/oxTutEGs/eg5/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg5/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg5/README
	if test -f oxDistG1.04/demo/oxTutEGs/eg5/README
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg5/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg5/README
cat >oxDistG1.04/demo/oxTutEGs/eg5/README <<'@EOF'
An example from the Ox Tutorial Introduction.  The gct directory
contains sample inputs.
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg5/README`; if test $1 -ne 47352
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg5/README checksum is $1 should be 47352
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg5/README`
if test $1$2$3 != 21389
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg5/README are $* should be 2 13 89
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5/README

if test -f oxDistG1.04/demo/oxTutEGs/eg5/gram.y
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg5/gram.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg5/gram.y
	if test -f oxDistG1.04/demo/oxTutEGs/eg5/gram.y
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg5/gram.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg5/gram.y
sed 's/^@//' >oxDistG1.04/demo/oxTutEGs/eg5/gram.y <<'@EOF'
%token REAL INT BOOL IDENT

%{
#include <stdlib.h>
struct sym {char *str,*typeMark;};

struct sym *allocSym(cp,t)
  char *cp,*t;
  {struct sym *pSym;
   pSym = (struct sym *) malloc(sizeof (struct sym));
   pSym->str = cp; pSym->typeMark = t; 
   return pSym;
  }
%}

@@attributes {char *string; struct sym *sym; } IDENT
@@attributes {char *tMark;                   } varList
@@traversal @postorder myT /* my Traversal */

%%
varDecl    :        varList ':' REAL ';'
                    @{ @i @varList.tMark@ = "real";    @}

           |        varList ':' INT ';'
                    @{ @i @varList.tMark@ = "integer"; @}

           |        varList ':' BOOL ';'
                    @{ @i @varList.tMark@ = "boolean"; @}
           ;

varList    :        IDENT
                    @{ @i @IDENT.sym@ = 
                            allocSym(@IDENT.string@,@varList.tMark@);
                       @myT printf("%s: %s;\n",@IDENT.sym@->typeMark,
                                               @IDENT.sym@->str);
                    @}
           |        varList ',' IDENT
                    @{ @i @varList.1.tMark@ = @varList.tMark@;
                       @i @IDENT.sym@ = 
                            allocSym(@IDENT.string@,@varList.tMark@);
                       @myT printf("%s: %s;\n",@IDENT.sym@->typeMark,
                                               @IDENT.sym@->str);
                    @}
           ; 
%% 
main() 
  {return(yyparse()); } 
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg5/gram.y`; if test $1 -ne 35900
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg5/gram.y checksum is $1 should be 35900
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg5/gram.y`
if test $1$2$3 != 471301453
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg5/gram.y are $* should be 47 130 1453
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5/gram.y

if test -f oxDistG1.04/demo/oxTutEGs/eg5/scan.l
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg5/scan.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg5/scan.l
	if test -f oxDistG1.04/demo/oxTutEGs/eg5/scan.l
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg5/scan.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg5/scan.l
sed 's/^@//' >oxDistG1.04/demo/oxTutEGs/eg5/scan.l <<'@EOF'
%{
#include "y.tab.h" 
#include <string.h>

#define lexeme strcpy((char *)malloc(yyleng+1),yytext)
%}

%% 
[ \n\t\f]+        ;  
real              return(REAL);
integer           return(INT);
boolean           return(BOOL);
[a-zA-Z]+         return(IDENT);  @{ @IDENT.string@ = lexeme; @} 
","               return(',');
";"               return(';');
":"               return(':');
@.                 {fprintf(stderr,"illegal character\n"); exit(-1);} 
%%
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg5/scan.l`; if test $1 -ne 17758
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg5/scan.l checksum is $1 should be 17758
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg5/scan.l`
if test $1$2$3 != 1838456
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg5/scan.l are $* should be 18 38 456
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5/scan.l

echo mkdir - oxDistG1.04/demo/oxTutEGs/eg5/gct
mkdir oxDistG1.04/demo/oxTutEGs/eg5/gct

if test -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg5/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t1
	if test -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t1
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg5/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg5/gct/t1
cat >oxDistG1.04/demo/oxTutEGs/eg5/gct/t1 <<'@EOF'
i: integer;
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg5/gct/t1`; if test $1 -ne 30973
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg5/gct/t1 checksum is $1 should be 30973
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg5/gct/t1`
if test $1$2$3 != 1212
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg5/gct/t1 are $* should be 1 2 12
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5/gct/t1

if test -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg5/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t2
	if test -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t2
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg5/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg5/gct/t2
cat >oxDistG1.04/demo/oxTutEGs/eg5/gct/t2 <<'@EOF'
i,j,k: integer;
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg5/gct/t2`; if test $1 -ne 32975
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg5/gct/t2 checksum is $1 should be 32975
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg5/gct/t2`
if test $1$2$3 != 1216
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg5/gct/t2 are $* should be 1 2 16
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5/gct/t2

if test -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg5/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t3
	if test -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t3
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg5/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg5/gct/t3
cat >oxDistG1.04/demo/oxTutEGs/eg5/gct/t3 <<'@EOF'
p,q: boolean;
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg5/gct/t3`; if test $1 -ne 65339
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg5/gct/t3 checksum is $1 should be 65339
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg5/gct/t3`
if test $1$2$3 != 1214
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg5/gct/t3 are $* should be 1 2 14
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5/gct/t3

if test -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t4
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg5/gct/t4\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t4
	if test -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t4
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg5/gct/t4, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg5/gct/t4
cat >oxDistG1.04/demo/oxTutEGs/eg5/gct/t4 <<'@EOF'
x,y,z: integer;
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg5/gct/t4`; if test $1 -ne 33605
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg5/gct/t4 checksum is $1 should be 33605
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg5/gct/t4`
if test $1$2$3 != 1216
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg5/gct/t4 are $* should be 1 2 16
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5/gct/t4

if test -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t5
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/eg5/gct/t5\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t5
	if test -f oxDistG1.04/demo/oxTutEGs/eg5/gct/t5
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/eg5/gct/t5, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/eg5/gct/t5
cat >oxDistG1.04/demo/oxTutEGs/eg5/gct/t5 <<'@EOF'
x,y,z,x,y,z: integer;
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/eg5/gct/t5`; if test $1 -ne 9167
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/eg5/gct/t5 checksum is $1 should be 9167
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/eg5/gct/t5`
if test $1$2$3 != 1222
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/eg5/gct/t5 are $* should be 1 2 22
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5/gct/t5

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5/gct

chmod 755 oxDistG1.04/demo/oxTutEGs/eg5

if test -f oxDistG1.04/demo/oxTutEGs/README
then
	echo Ok to overwrite existing file oxDistG1.04/demo/oxTutEGs/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/demo/oxTutEGs/README
	if test -f oxDistG1.04/demo/oxTutEGs/README
	then
		echo Error: could not remove oxDistG1.04/demo/oxTutEGs/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/demo/oxTutEGs/README
cat >oxDistG1.04/demo/oxTutEGs/README <<'@EOF'
Each subdirectory contains an example from the Ox Tutorial Introduction.
@EOF
set `sum $sumopt <oxDistG1.04/demo/oxTutEGs/README`; if test $1 -ne 14576
then
	echo ERROR: oxDistG1.04/demo/oxTutEGs/README checksum is $1 should be 14576
fi
set `wc -lwc <oxDistG1.04/demo/oxTutEGs/README`
if test $1$2$3 != 11073
then
	echo ERROR: wc results of oxDistG1.04/demo/oxTutEGs/README are $* should be 1 10 73
fi

chmod 755 oxDistG1.04/demo/oxTutEGs/README

chmod 755 oxDistG1.04/demo/oxTutEGs

chmod 755 oxDistG1.04/demo

echo mkdir - oxDistG1.04/gppl
mkdir oxDistG1.04/gppl

if test -f oxDistG1.04/gppl/README
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/README
	if test -f oxDistG1.04/gppl/README
	then
		echo Error: could not remove oxDistG1.04/gppl/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/README
cat >oxDistG1.04/gppl/README <<'@EOF'
The present directory has source code for `gc', a compiler for
GPPL, a small C-like (but block-structured) imperative
programming language.  The language and the compiler are
described in `gppl.ps', a 66-page Postscript document in the
present directory.

To build `gc', you need an executable `ox' on your path.  In this
case, typing `make' in the present directory builds `gc'.

gppl.Y.A is a Y-file equivalent to gppl.Y.  It uses the @autosyn
and @autoinh constructs for automatic generation of copy rules.
It may be substituted for gppl.Y.

The directory `gct' in the present directory contains test
programs for `gc'.  See the README file in that directory for
descriptions of those test programs.

The following abstract describes the document in `gppl.ps':



                 GPPL: A Small Block-Structured
                Imperative Programming Language
                      Implemented Using Ox

                      by Kurt M. Bischoff
                      Iowa State University
                            TR#92-32
                         December, 1992

GPPL is a small, block-structured, imperative programming
language, for which a compiler, gc, has been built using the
Yacc/Lex-based attribute-grammar compiler Ox (see TR#92-30).
This paper describes GPPL and gc, and is directed mainly to those
who would like to study and modify them.  The implementation of
GPPL may be considered as an example of the use of attribute
grammars in general and as a nontrivial example application of
Ox.

The syntax of GPPL bears some resemblance to that of C but, being
described in only about eighty grammar rules, lacks many C
constructs.  GPPL's semantics are similar to those of Pascal,
with block structure and relatively strict error checking.

gc's target language is a very small subset of C, comparable to
assembly languages.  The source code for gc occupies about
seventy kilobytes and constitutes about a dozen files.

This paper describes GPPL syntax and semantics, gives some
example programs, and explains the implementation with reference
to the source code, which is included.
@EOF
set `sum $sumopt <oxDistG1.04/gppl/README`; if test $1 -ne 47870
then
	echo ERROR: oxDistG1.04/gppl/README checksum is $1 should be 47870
fi
set `wc -lwc <oxDistG1.04/gppl/README`
if test $1$2$3 != 513012099
then
	echo ERROR: wc results of oxDistG1.04/gppl/README are $* should be 51 301 2099
fi

chmod 755 oxDistG1.04/gppl/README

if test -f oxDistG1.04/gppl/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/Makefile
	if test -f oxDistG1.04/gppl/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/Makefile
sed 's/^@//' >oxDistG1.04/gppl/Makefile <<'@EOF'
# $Header: Makefile,v 1.7 93/11/09 19:15:00 bischoff Exp $  

SHELL= /bin/sh
CFLAGS = 
CC=cc
YACC=yacc
LEX=lex
CLIBS=-ly -ll -lcurses

@.IGNORE:

gc: y.tab.o lex.yy.o scan.o sem.o code.o util.o
	$(CC) $(CFLAGS) -o gc y.tab.o lex.yy.o scan.o \
	                      sem.o code.o util.o $(CLIBS)  

oxout.y oxout.l: gppl.Y gppl.L 
	ox -YY -Yn500000 -Yc60000 -Yr30000 gppl.Y gppl.L 

strip: gppl.Y gppl.L 
	ox -S gppl.Y gppl.L 

lex.yy.c : oxout.l  
	$(LEX) oxout.l 

y.tab.c y.tab.h: oxout.y  
	$(YACC) -dv oxout.y
	diff y.tab.h y.tab.h.bak > y.tab.h.diff 2>&1 
	if test -s y.tab.h.diff; then cp y.tab.h y.tab.h.bak; fi
	rm y.tab.h.diff

scan.o: glob.h util.h scan.c 
	$(CC) $(CFLAGS) -c scan.c 

sem.o: glob.h y.tab.h.bak util.h sem.c 
	$(CC) $(CFLAGS) -c sem.c 

code.o: code.c y.tab.h.bak glob.h util.h   
	$(CC) $(CFLAGS) -c code.c

util.o: util.c 
	$(CC) $(CFLAGS) -c util.c

y.tab.o: y.tab.c y.tab.h.bak glob.h util.h scan.h sem.h code.h  
	$(CC) $(CFLAGS) -c y.tab.c  

lex.yy.o: lex.yy.c y.tab.h.bak glob.h util.h scan.h  
	$(CC) $(CFLAGS) -c lex.yy.c 

clean: 
	rm *.o oxout.? lex.yy.c y.tab.c y.tab.h y.output gc  

LC:
	lint lex.yy.c y.tab.c sem.c scan.c code.c util.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/Makefile`; if test $1 -ne 59623
then
	echo ERROR: oxDistG1.04/gppl/Makefile checksum is $1 should be 59623
fi
set `wc -lwc <oxDistG1.04/gppl/Makefile`
if test $1$2$3 != 531561178
then
	echo ERROR: wc results of oxDistG1.04/gppl/Makefile are $* should be 53 156 1178
fi

chmod 755 oxDistG1.04/gppl/Makefile

if test -f oxDistG1.04/gppl/glob.h
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/glob.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/glob.h
	if test -f oxDistG1.04/gppl/glob.h
	then
		echo Error: could not remove oxDistG1.04/gppl/glob.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/glob.h
cat >oxDistG1.04/gppl/glob.h <<'@EOF'
/* $Header: glob.h,v 1.7 93/11/09 19:15:21 bischoff Exp $ */ 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define DONTCARE 0 

#define ceiling(num,inc) (((inc) * ((num)/(inc))) + (((num)%(inc))?(inc):0)) 

#define max(t1,t2) (((t1)>(t2))?(t1):(t2))

#define spaceSetup(string,type,name,size,minSize,after,stock) \
if ((size) < (minSize)) {fprintf(stderr,\
"allocation request for %s space too small.\n",string);\
exit(-1);}\
if (((name) = (type *) malloc((size) * sizeof(type)))  \
    == \
    ((type *) NULL) \
   )   \
{fprintf(stderr,"malloc error in %s space allocation.\n",string);exit(-1);}\
(stock) = (name) + 1; \
(after) = ((name) + (size)); 

typedef unsigned short lineNumType;
typedef unsigned short labelType;
typedef unsigned short levelType;
typedef short regNumType;

enum stgClass {VARIABLEC,VALPARAMC,REFPARAMC};
enum symType  {INTT,FLOATT,BOOLT,VOIDT,ERRT};  
enum mapType  {ARITHM,LOGM}; 
enum pred     {False,True};

extern enum pred doCodeGen;

extern long stgSize(); 
extern void handleSemError(); 
extern void yyyerror(); 

union num {int i; 
           float f; 
           int b; 
          };

struct dim {long size;
            long scale;
            struct dim *next;
           };

struct sym {
            /* members used for all kinds of symbols */
            char *id; 	
            lineNumType line; 
            enum symType type; 
            levelType level;
            struct sym *next; 

            /* members used only for storage symbols */
            enum stgClass Class; 
            long addr;
            long size;
            struct dim *dimList;

            /* members used only for function symbols */
            long paramsSize;
            labelType label; 
            struct sym *paramLoc;
           }; 

struct env {struct sym *funcSym;
            struct sym *varLoc;
            struct sym *funcLoc; 
            levelType level; 
            short nRegs;
            labelType exitLabel;
            long varsSize;
            struct env *outerEnv; 
           }; 

extern struct dim *dimListSpace; 
#define lambdaDim dimListSpace 

extern struct sym *symSpace; 
#define lambdaSym symSpace 

extern struct env *envSpace; 
#define lambdaEnv envSpace 
@EOF
set `sum $sumopt <oxDistG1.04/gppl/glob.h`; if test $1 -ne 27074
then
	echo ERROR: oxDistG1.04/gppl/glob.h checksum is $1 should be 27074
fi
set `wc -lwc <oxDistG1.04/gppl/glob.h`
if test $1$2$3 != 882402234
then
	echo ERROR: wc results of oxDistG1.04/gppl/glob.h are $* should be 88 240 2234
fi

chmod 755 oxDistG1.04/gppl/glob.h

if test -f oxDistG1.04/gppl/scan.h
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/scan.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/scan.h
	if test -f oxDistG1.04/gppl/scan.h
	then
		echo Error: could not remove oxDistG1.04/gppl/scan.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/scan.h
cat >oxDistG1.04/gppl/scan.h <<'@EOF'
/* $Header: scan.h,v 1.7 93/11/09 19:16:17 bischoff Exp $ */ 

extern void scanSetup();
extern char *stringLookup(); 
extern char *copyLexemeOfSTRING();
extern void eatComment();

@EOF
set `sum $sumopt <oxDistG1.04/gppl/scan.h`; if test $1 -ne 48241
then
	echo ERROR: oxDistG1.04/gppl/scan.h checksum is $1 should be 48241
fi
set `wc -lwc <oxDistG1.04/gppl/scan.h`
if test $1$2$3 != 722180
then
	echo ERROR: wc results of oxDistG1.04/gppl/scan.h are $* should be 7 22 180
fi

chmod 755 oxDistG1.04/gppl/scan.h

if test -f oxDistG1.04/gppl/sem.h
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/sem.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/sem.h
	if test -f oxDistG1.04/gppl/sem.h
	then
		echo Error: could not remove oxDistG1.04/gppl/sem.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/sem.h
cat >oxDistG1.04/gppl/sem.h <<'@EOF'
/* $Header: sem.h,v 1.7 93/11/09 19:16:21 bischoff Exp $ */ 

#define FIRSTREGNUM 0

extern struct sym *newStgSym();
extern struct sym *newFuncSym();
extern struct sym *concatLocs(); 
extern struct sym *cdrParamList();
extern struct sym *stgRefLookup();
extern struct sym *funcInvocLookup();
extern struct env *newEnv(); 
extern struct dim *adjustDimList(); 
extern struct dim *cdrDimList(); 
extern struct dim *consDimList(); 
extern enum symType unrOpTypeCheck(); 
extern enum symType binOpTypeCheck(); 
extern enum symType assignmentTypeCheck(); 
extern void semSetup();
extern void paramMatchCheck();

@EOF
set `sum $sumopt <oxDistG1.04/gppl/sem.h`; if test $1 -ne 4849
then
	echo ERROR: oxDistG1.04/gppl/sem.h checksum is $1 should be 4849
fi
set `wc -lwc <oxDistG1.04/gppl/sem.h`
if test $1$2$3 != 2071606
then
	echo ERROR: wc results of oxDistG1.04/gppl/sem.h are $* should be 20 71 606
fi

chmod 755 oxDistG1.04/gppl/sem.h

if test -f oxDistG1.04/gppl/code.h
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/code.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/code.h
	if test -f oxDistG1.04/gppl/code.h
	then
		echo Error: could not remove oxDistG1.04/gppl/code.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/code.h
cat >oxDistG1.04/gppl/code.h <<'@EOF'
/* $Header: code.h,v 1.7 93/11/09 19:16:23 bischoff Exp $ */ 

#include <stdio.h>
#include "y.tab.h"

extern FILE *tempOut; 
#define tempOutID "g.c" 

extern labelType newLabelNum(); 
extern labelType newReturnLabelNum(); 
extern long stgSize(); 
extern void cgHeader(); 
extern void cgTrailer(); 
extern void cgFuncAddress(); 
extern void cgFuncCall(); 
extern void cgFuncTrailer(); 
extern void cgBlockEnter(); 
extern void cgBlockExit(); 
extern void cgBinArithExpr();
extern void cgRelExpr();
extern void cgBinLogExpr();
extern void cgLogNegExpr();
extern void cgUnrArithExpr();
extern void cgEmptyIndexSeq();
extern void cgConstSimpleExpr();
extern void cgIndexSeq();
extern void cgAssign(); 
extern void cgPush(); 
extern void cgCondDeref(); 
extern void cgOutputNoArg();
extern void cgOutputOneArg();
extern void cgCast();
extern void cgInput(); 
extern void cgIfThen(); 
extern void cgIfThenElse(); 
extern void cgThen(); 
extern void cgElse(); 
extern void cgWhileStatement(); 
extern void cgWdecision(); 
extern void cgWhile(); 
extern void cgReturnStmt();
extern void cgExitStmt();
extern void cgEOF();
@EOF
set `sum $sumopt <oxDistG1.04/gppl/code.h`; if test $1 -ne 15643
then
	echo ERROR: oxDistG1.04/gppl/code.h checksum is $1 should be 15643
fi
set `wc -lwc <oxDistG1.04/gppl/code.h`
if test $1$2$3 != 431251114
then
	echo ERROR: wc results of oxDistG1.04/gppl/code.h are $* should be 43 125 1114
fi

chmod 755 oxDistG1.04/gppl/code.h

if test -f oxDistG1.04/gppl/util.h
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/util.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/util.h
	if test -f oxDistG1.04/gppl/util.h
	then
		echo Error: could not remove oxDistG1.04/gppl/util.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/util.h
cat >oxDistG1.04/gppl/util.h <<'@EOF'
/* $Header: util.h,v 1.7 93/11/09 19:16:26 bischoff Exp $ */ 

extern void yyerror();
extern void fatal();
extern void internal(); 
extern void handleOverflow();
extern FILE *safeOpen();
extern void printStringArray(); 

@EOF
set `sum $sumopt <oxDistG1.04/gppl/util.h`; if test $1 -ne 16219
then
	echo ERROR: oxDistG1.04/gppl/util.h checksum is $1 should be 16219
fi
set `wc -lwc <oxDistG1.04/gppl/util.h`
if test $1$2$3 != 928221
then
	echo ERROR: wc results of oxDistG1.04/gppl/util.h are $* should be 9 28 221
fi

chmod 755 oxDistG1.04/gppl/util.h

if test -f oxDistG1.04/gppl/gppl.L
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gppl.L\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gppl.L
	if test -f oxDistG1.04/gppl/gppl.L
	then
		echo Error: could not remove oxDistG1.04/gppl/gppl.L, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gppl.L
sed 's/^@//' >oxDistG1.04/gppl/gppl.L <<'@EOF'
%{
/* $Header: gppl.L,v 1.7 93/11/09 19:16:29 bischoff Exp $ */ 

#include "glob.h" 
#include "scan.h"
#include "y.tab.h" 

%}

IDENT ([a-zA-Z_][a-zA-Z0-9_]*) 

%% 
int            return(INT);        @{ @INT.line@     = yylineno; @}  
float          return(TKFLOAT);    @{ @TKFLOAT.line@ = yylineno; @} 
bool           return(BOOL);       @{ @BOOL.line@    = yylineno; @} 
void           return(VOID);       @{ @VOID.line@    = yylineno; @} 
var            return(VAR); 
if             return(IF);         @{ @IF.line@      = yylineno; @} 
then           return(THEN); 
else           return(ELSE); 
while          return(WHILE);      @{ @WHILE.line@   = yylineno; @} 
return         return(RETURN);     @{ @RETURN.line@  = yylineno; @} 
exit           return(EXIT);       @{ @EXIT.line@    = yylineno; @} 
input          return(INPUT); 
output         return(OUTPUT); 
\"             {char *strDum;
                strDum = copyLexemeOfSTRING(); 
                return (STRING);  
                                   @{ @STRING.str@   = strDum;   @}
               }
\/\*           eatComment(); 
[ \n\t\f]*     ;  
[0-9]+\.[0-9]+ return(FCONST);     @{ sscanf((char *)yytext,"%f",
                                             &(@FCONST.val@.f)
                                            ); 
                                   @}
[0-9]+         return(ICONST);     @{ sscanf((char *)yytext,"%d",
                                             &(@ICONST.val@.i)
                                            ); 
                                   @}
EOF            return(EOFCONST);  
TRUE           return(BCONST);     @{ @BCONST.val@.b = 1;        @} 
FALSE          return(BCONST);     @{ @BCONST.val@.b = 0;        @} 
\(             return('(');        @{ @'('.line@     = yylineno; @}
\[             return('[');        @{ @'['.line@     = yylineno; @}
[,]            return(',');        @{ @','.line@     = yylineno; @}
[{]            return('{');
[}]            return('}');
[)]            return(')');
[;]            return(';');
[\]]           return(']');
&&             return(AND);        @{ @AND.line@     = yylineno; @} 
\|\|           return(OR);         @{ @OR.line@      = yylineno; @} 
!              return(NOT);        @{ @NOT.line@     = yylineno; @} 
[*]            return('*');        @{ @'*'.line@     = yylineno; @} 
[+]            return('+');        @{ @'+'.line@     = yylineno; @} 
[/]            return('/');        @{ @'/'.line@     = yylineno; @} 
[\-]           return('-');        @{ @'-'.line@     = yylineno; @} 
=              return(GETS);       @{ @GETS.line@    = yylineno; @} 
==             return(EQ);         @{ @EQ.line@      = yylineno; @} 
!=             return(NEQ);        @{ @NEQ.line@     = yylineno; @} 
\<             return(LT);         @{ @LT.line@      = yylineno; @} 
\>             return(GT);         @{ @GT.line@      = yylineno; @} 
\<=            return(LEQ);        @{ @LEQ.line@     = yylineno; @} 
\>=            return(GEQ);        @{ @GEQ.line@     = yylineno; @} 
{IDENT}        {
                return(ID);   
                @{ @ID.str@ = stringLookup((char *)yytext,yyleng,1); 
                   @ID.line@ = yylineno; 
                @} 
               } 
@.              {fprintf(stderr,"line %d: illegal character\n",yylineno); 
                handleSemError();
               }
%%

@EOF
set `sum $sumopt <oxDistG1.04/gppl/gppl.L`; if test $1 -ne 55491
then
	echo ERROR: oxDistG1.04/gppl/gppl.L checksum is $1 should be 55491
fi
set `wc -lwc <oxDistG1.04/gppl/gppl.L`
if test $1$2$3 != 762883357
then
	echo ERROR: wc results of oxDistG1.04/gppl/gppl.L are $* should be 76 288 3357
fi

chmod 755 oxDistG1.04/gppl/gppl.L

if test -f oxDistG1.04/gppl/gppl.Y
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gppl.Y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gppl.Y
	if test -f oxDistG1.04/gppl/gppl.Y
	then
		echo Error: could not remove oxDistG1.04/gppl/gppl.Y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gppl.Y
sed 's/^@//' >oxDistG1.04/gppl/gppl.Y <<'@EOF'
/* $Header: gppl.Y,v 1.7 93/11/09 19:16:41 bischoff Exp $ */ 

/* a compiler for a general purpose programming language */ 

%{
#include "glob.h"
#include "y.tab.h"
#include "scan.h"
#include "sem.h"
#include "code.h"
#include "util.h"
%}


%start prog    

%token ID ICONST FCONST BCONST EOFCONST
%token INT TKFLOAT BOOL VOID 
%token VAR  
%token IF THEN ELSE WHILE   
%token EQ LT GT GEQ LEQ NEQ  
%token AND OR NOT  
%token INPUT OUTPUT STRING 
%token RETURN EXIT  

%right GETS
%left OR 
%left AND 
%nonassoc EQ NEQ  
%nonassoc LT LEQ GT GEQ   
%left '+' '-'
%left '*' '/' 
%right NOT

@traversal t 

@@attributes {struct env *env; 
             regNumType maxRegNum;
            } 
            execElem statement 
            returnStatement exitStatement
            ifStatement whileStatement  

@@attributes {struct env *env; 
             regNumType regNum;
             regNumType maxRegNum;
             struct sym *formParamList;
             struct sym *func;
             lineNumType line;
            } 
            actParamList    

@@attributes {struct env *env; 
             struct sym *varLoc,*funcLoc; 
             regNumType maxRegNum;
            } 
            block blockElemList 

@@attributes {struct sym *loc; 
             enum stgClass Class;
            } 
            stgDecl   

@@attributes {struct sym *loc; 
             struct sym *funcSym; 
            } 
            paramDeclList   

@@attributes {struct sym *loc; 
            } 
            paramDecl  

@@attributes {struct env *env; 
             struct sym *loc; 
            } 
            funcDecl 

@@attributes {enum symType type; 
             lineNumType line; 
            } 
            typeSpec  

@@attributes {enum symType type; 
             struct sym *loc;
             enum stgClass Class; 
            } 
            stgDecl2 stgDecl2List 

@attributes {struct dim *dimList;
            }
            dimSeq

@@attributes {struct env *env; 
             enum symType type; 
             regNumType regNum;
             regNumType maxRegNum;
            } 
            funcInvoc assignExpr 

@@attributes {struct env *env; 
             enum symType type; 
             regNumType regNum;
             regNumType maxRegNum;
             struct sym *formalMatch; 
             enum pred isStgRef;
            } 
            expr simpleExpr  

@@attributes {struct env *env; 
             regNumType regNum;
             regNumType maxRegNum;
             struct dim *dimList;  
             struct sym *sym;
             lineNumType line; 
            } 
            indexSeq

@@attributes {struct env *env; 
             enum symType type; 
             regNumType regNum;
             regNumType maxRegNum;
             struct sym *formalMatch;
            } 
            stgRef 

@@attributes {char *str; 
             lineNumType line; 
             struct sym *sym; 
            } 
            ID  

@@attributes {char *str;
            }
            STRING

@@attributes {lineNumType line; 
            } 
            AND OR NOT 
            GETS 
            GT LT EQ NEQ GEQ LEQ 
            '*' '+' '/' '-' '(' ',' '['
            FOR IF WHILE DO 
            INT TKFLOAT BOOL VOID
            RETURN EXIT

@@attributes {labelType label;
             regNumType decisionRegNum;
            }
            then wDecision 

@@attributes {labelType label;
            }
            else while

@@attributes {union num val; 
            } 
            ICONST FCONST BCONST 

@@attributes {long val; 
            } 
            iConstExpr

@macro constSimpleExpr(SYM,TYPE,)
   @i @simpleExpr.type@ = TYPE;   
   @i @simpleExpr.maxRegNum@ = @simpleExpr.regNum@;
   @i @simpleExpr.isStgRef@ = False;
   @t cgConstSimpleExpr(@simpleExpr.regNum@,TYPE,@SYM.val@); 
@@end


@@macro unrOpExprdefs(op,)
  @i @expr.type@ = unrOpTypeCheck(@expr.1.type@,op,@op.line@);
  @i @expr.1.env@ = @expr.env@;
  @i @expr.1.regNum@ = @expr.regNum@;
  @i @expr.maxRegNum@ = @expr.1.maxRegNum@;
  @i @expr.1.formalMatch@ = lambdaSym;
  @i @expr.isStgRef@ = False;
@@end


@@macro binOpExprdefs(op,) 
  @i @expr.type@ = binOpTypeCheck(@expr.1.type@,@expr.2.type@,op,@op.line@);
  @i @expr.1.env@ = @expr.env@;
  @i @expr.2.env@ = @expr.env@;
  @i @expr.1.regNum@ = @expr.regNum@;
  @i @expr.2.regNum@ = @expr.regNum@ + 1;
  @i @expr.maxRegNum@ = max(@expr.1.maxRegNum@,@expr.2.maxRegNum@);
  @i @expr.1.formalMatch@ = lambdaSym;
  @i @expr.2.formalMatch@ = lambdaSym;
  @i @expr.isStgRef@ = False;
@@end

@@macro binArithExpr(op,) 
  @t cgBinArithExpr(@expr.1.regNum@,op,@expr.type@); 
@@end

@@macro relExpr(op,)
  @t cgRelExpr(@expr.1.regNum@,op,@expr.1.type@);
@@end  

@@macro binLogExpr(op,)
  @t cgBinLogExpr(@expr.1.regNum@,op);
@@end  


%%
prog	
	:	block	
		@{ @i @block.env@ = newEnv(lambdaEnv,
		                           lambdaSym, 
		                           @block.varLoc@,
		                           @block.funcLoc@,
		                           @block.maxRegNum@
		                          ); 
		@}  
	; 

block	
	:	'{'	blockElemList	'}' 
		@{ @i @blockElemList.env@ = @block.env@; 
		   @i @block.maxRegNum@ = @blockElemList.maxRegNum@;
		   @i @block.varLoc@ = @blockElemList.varLoc@; 
		   @i @block.funcLoc@ = @blockElemList.funcLoc@; 
		   @t cgBlockExit(@block.env@); 
		@} 
	; 

blockElemList 
	:
		@{ @i @blockElemList.varLoc@ = lambdaSym;
		   @i @blockElemList.funcLoc@ = lambdaSym; 
		   @i @blockElemList.maxRegNum@ = FIRSTREGNUM - 1;
		   @t cgBlockEnter(@blockElemList.env@); 
		@}
	|	blockElemList	execElem	
		@{ @i @blockElemList.1.env@ = @blockElemList.env@; 
		   @i @blockElemList.maxRegNum@ = 
		         max(@blockElemList.1.maxRegNum@,
		             @execElem.maxRegNum@ 
		            ); 
		   @i @blockElemList.varLoc@ = @blockElemList.1.varLoc@; 
		   @i @blockElemList.funcLoc@ = @blockElemList.1.funcLoc@; 
		   @i @execElem.env@ = @blockElemList.env@; 
		@} 
	|	blockElemList	stgDecl	
		@{ @i @blockElemList.1.env@ = @blockElemList.env@; 
		   @i @blockElemList.maxRegNum@ = @blockElemList.1.maxRegNum@;
		   @i @blockElemList.varLoc@ =  
		        concatLocs(@blockElemList.1.varLoc@,@stgDecl.loc@); 
		   @i @blockElemList.funcLoc@ = @blockElemList.1.funcLoc@; 
		   @i @stgDecl.Class@ = VARIABLEC;
		@}
	|	blockElemList	funcDecl	
		@{ @i @blockElemList.1.env@ = @blockElemList.env@; 
		   @i @blockElemList.maxRegNum@ = @blockElemList.1.maxRegNum@;
		   @i @blockElemList.varLoc@ = @blockElemList.1.varLoc@; 
		   @i @blockElemList.funcLoc@ = 
		        concatLocs(@blockElemList.1.funcLoc@,@funcDecl.loc@); 
		   @i @funcDecl.env@ = @blockElemList.env@; 
		@}
	; 
 
execElem	
	:	statement
		@{ @i @statement.env@ = @execElem.env@; 
		   @i @execElem.maxRegNum@ = @statement.maxRegNum@;
		@}
	|	block	
		@{ @i @block.env@ = newEnv(@execElem.env@,
		                           lambdaSym,
		                           @block.varLoc@,
		                           @block.funcLoc@,
		                           @block.maxRegNum@
		                          ); 
		   @i @execElem.maxRegNum@ = FIRSTREGNUM - 1;
		@} 
	;

statement 
	:	';'	
		@{ @i @statement.maxRegNum@ = FIRSTREGNUM - 1;
		@}
	|	expr	';'	
		@{ @i @expr.env@ = @statement.env@; 
		   @i @expr.regNum@ = FIRSTREGNUM; 
		   @i @statement.maxRegNum@ = @expr.maxRegNum@;
		   @i @expr.formalMatch@ = lambdaSym; 
		@}
	|	ifStatement
		@{ @i @ifStatement.env@ = @statement.env@; 
		   @i @statement.maxRegNum@ = @ifStatement.maxRegNum@; 
		@}
	|	whileStatement
		@{ @i @whileStatement.env@ = @statement.env@; 
		   @i @statement.maxRegNum@ = @whileStatement.maxRegNum@; 
		@}
	|	returnStatement
		@{ @i @returnStatement.env@ = @statement.env@; 
		   @i @statement.maxRegNum@ = @returnStatement.maxRegNum@; 
		@}
	|	exitStatement
		@{ @i @exitStatement.env@ = @statement.env@; 
		   @i @statement.maxRegNum@ = @exitStatement.maxRegNum@; 
		@}
	; 

expr	
	:	assignExpr
		@{ @i @expr.type@ = @assignExpr.type@;
		   @i @assignExpr.env@ = @expr.env@;
		   @i @assignExpr.regNum@ = @expr.regNum@;
		   @i @expr.maxRegNum@ = @assignExpr.maxRegNum@;
		   @i @expr.isStgRef@ = False;
		@}
	|	simpleExpr
		@{ @i @expr.type@ = @simpleExpr.type@;
		   @i @simpleExpr.env@ = @expr.env@;
		   @i @simpleExpr.regNum@ = @expr.regNum@; 
		   @i @expr.maxRegNum@ = @simpleExpr.maxRegNum@;
		   @i @simpleExpr.formalMatch@ = @expr.formalMatch@;
		   @i @expr.isStgRef@ = @simpleExpr.isStgRef@;
		@}
	|	'('	expr	')'
		@{ @i @expr.type@ = @expr.1.type@;
		   @i @expr.1.env@ = @expr.env@;
		   @i @expr.1.regNum@ = @expr.regNum@; 
		   @i @expr.maxRegNum@ = @expr.1.maxRegNum@;
		   @i @expr.1.formalMatch@ = @expr.formalMatch@;  
		   @i @expr.isStgRef@ = @expr.1.isStgRef@;
		@}
	|	'-'	expr		
		@{ unrOpExprdefs('-',) 
		   @t cgUnrArithExpr(@expr.regNum@,'-',@expr.type@); 
		@}
	|	'+'	expr	
		@{ unrOpExprdefs('+',) 
		   @t cgUnrArithExpr(@expr.regNum@,'+',@expr.type@); 
		@}
	|	NOT	expr		
		@{ unrOpExprdefs(NOT,) 
		   @t cgLogNegExpr(@expr.regNum@);
		@}
	|	expr	'*'	expr
		@{ binOpExprdefs('*',) 
		   binArithExpr('*',) 
		@}
	|	expr	'/'	expr
		@{ binOpExprdefs('/',) 
		   binArithExpr('/',) 
		@}
	|	expr	'+'	expr
		@{ binOpExprdefs('+',) 
		   binArithExpr('+',) 
		@}
	|	expr	'-'	expr
		@{ binOpExprdefs('-',) 
		   binArithExpr('-',) 
		@}
	|	expr	EQ	expr
		@{ binOpExprdefs(EQ,) 
		   relExpr(EQ,)
		@}
	|	expr	NEQ	expr
		@{ binOpExprdefs(NEQ,) 
		   relExpr(NEQ,)
		@}
	|	expr	LT	expr
		@{ binOpExprdefs(LT,) 
		   relExpr(LT,)
		@}
	|	expr	GT	expr
		@{ binOpExprdefs(GT,) 
		   relExpr(GT,)
		@}
	|	expr	LEQ	expr
		@{ binOpExprdefs(LEQ,) 
		   relExpr(LEQ,)
		@}
	|	expr	GEQ	expr
		@{ binOpExprdefs(GEQ,) 
		   relExpr(GEQ,)
		@}
	|	expr	AND	expr
		@{ binOpExprdefs(AND,) 
		   binLogExpr(AND,)
		@}
	|	expr	OR	expr
		@{ binOpExprdefs(OR,) 
		   binLogExpr(OR,)
		@}
	;

assignExpr	
	:	stgRef 	GETS	expr 
		@{ @i @assignExpr.type@ = assignmentTypeCheck(@stgRef.type@,
		                                              @expr.type@,
		                                              @GETS.line@
		                                             );
		   @i @stgRef.env@ = @assignExpr.env@;
		   @i @expr.env@ = @assignExpr.env@;
		   @i @expr.regNum@ = @assignExpr.regNum@ + 1; 
		   @i @stgRef.regNum@ = @assignExpr.regNum@; 
		   @i @assignExpr.maxRegNum@ = 
		         max(@stgRef.maxRegNum@,@expr.maxRegNum@);
		   @i @stgRef.formalMatch@ = lambdaSym; 
		   @i @expr.formalMatch@ = lambdaSym; 
		   @t cgAssign(@stgRef.regNum@,@assignExpr.type@); 
		@}
	;

simpleExpr	
	:	stgRef 
		@{ @i @simpleExpr.type@ = @stgRef.type@; 
		   @i @stgRef.env@ = @simpleExpr.env@;
		   @i @stgRef.regNum@ = @simpleExpr.regNum@;
		   @i @simpleExpr.maxRegNum@ = @stgRef.maxRegNum@;
		   @i @stgRef.formalMatch@ = @simpleExpr.formalMatch@; 
		   @i @simpleExpr.isStgRef@ = True;
		   @t cgCondDeref(@simpleExpr.formalMatch@,@simpleExpr.regNum@,
		                  @simpleExpr.type@
		                 ); 
		@}
	|	funcInvoc
		@{ @i @simpleExpr.type@ = @funcInvoc.type@; 
		   @i @funcInvoc.env@ = @simpleExpr.env@;
		   @i @funcInvoc.regNum@ = @simpleExpr.regNum@;
		   @i @simpleExpr.maxRegNum@ = @funcInvoc.maxRegNum@;
		   @i @simpleExpr.isStgRef@ = False;
		@}
 	|	ICONST
		@{ constSimpleExpr(ICONST,INTT,)   @}
 	|	FCONST
		@{ constSimpleExpr(FCONST,FLOATT,) @}
 	|	BCONST
		@{ constSimpleExpr(BCONST,BOOLT,)  @}
 	|	EOFCONST
		@{ @i @simpleExpr.type@ = INTT;   
   		   @i @simpleExpr.maxRegNum@ = @simpleExpr.regNum@;
   		   @i @simpleExpr.isStgRef@ = False;
   		   @t cgEOF(@simpleExpr.regNum@); 
		@}
	;

iConstExpr	
 	:	ICONST
		@{ @i @iConstExpr.val@ = @ICONST.val@.i;  
		@}
	|	'-'	iConstExpr
		@{ @i @iConstExpr.val@ = - @iConstExpr.1.val@ ; 
		@}
	|	'+'	iConstExpr
		@{ @i @iConstExpr.val@ =   @iConstExpr.1.val@ ; 
		@}
	|	'('	iConstExpr	')'
		@{ @i @iConstExpr.val@ =   @iConstExpr.1.val@ ; 
		@}
	|	iConstExpr	'*'	iConstExpr
		@{ @i @iConstExpr.val@ = @iConstExpr.1.val@ * 
                                           @iConstExpr.2.val@ ;  
		@}
	|	iConstExpr	'+'	iConstExpr
		@{ @i @iConstExpr.val@ = @iConstExpr.1.val@ + 
                                           @iConstExpr.2.val@ ;  
		@}
	|	iConstExpr	'/'	iConstExpr
		@{ @i @iConstExpr.val@ = @iConstExpr.1.val@ / 
                                           @iConstExpr.2.val@ ;  
		@}
	|	iConstExpr	'-'	iConstExpr
		@{ @i @iConstExpr.val@ = @iConstExpr.1.val@ - 
                                           @iConstExpr.2.val@ ;  
		@}
	;

stgRef	
	:	ID	indexSeq
		@{ @i @ID.sym@ = 
                        stgRefLookup(@stgRef.env@,@ID.str@,@ID.line@);
		   @i @indexSeq.env@ = @stgRef.env@;
		   @i @indexSeq.regNum@ = @stgRef.regNum@;
		   @i @stgRef.type@ = @ID.sym@->type;
		   @i @indexSeq.dimList@ = 
		         adjustDimList(@stgRef.formalMatch@,@ID.sym@,@ID.line@);
		   @i @stgRef.maxRegNum@ = @indexSeq.maxRegNum@;
		   @i @indexSeq.sym@ = @ID.sym@;
		   @i @indexSeq.line@ = @ID.line@;
		@}
	;

indexSeq
	:	
		@{ @i @indexSeq.maxRegNum@ = @indexSeq.regNum@; 
		   @t cgEmptyIndexSeq(@indexSeq.env@,@indexSeq.sym@,
		         @indexSeq.line@,@indexSeq.regNum@,@indexSeq.dimList@
		                     );
		@}
	|	indexSeq	'['	expr	']'
		@{ @i @indexSeq.1.env@ = @indexSeq.env@;
		   @i @expr.env@ = @indexSeq.env@;
		   @i @indexSeq.1.regNum@ = @indexSeq.regNum@; 
		   @i @expr.regNum@ = @indexSeq.regNum@ + 1; 
		   @i @indexSeq.maxRegNum@ = max(@indexSeq.1.maxRegNum@,
		                               @expr.maxRegNum@
		                              );
		   @i @indexSeq.1.dimList@ = cdrDimList(@indexSeq.dimList@,
		                                        @indexSeq.sym@,
		                                        @indexSeq.line@
		                                       ); 
		   @i @indexSeq.1.sym@ = @indexSeq.sym@;
		   @i @indexSeq.1.line@ = @indexSeq.line@;
		   @i @expr.formalMatch@ = lambdaSym;
		   @t cgIndexSeq(@indexSeq.sym@,@indexSeq.regNum@,
		                 @indexSeq.dimList@
		                );
		@}
	;

funcInvoc
	:	ID	'('	')'
		@{ @i @funcInvoc.type@ = @ID.sym@->type; 
		   @i @ID.sym@ = 
		        funcInvocLookup(@funcInvoc.env@,@ID.str@,@ID.line@);
		   @i @funcInvoc.maxRegNum@ = @funcInvoc.regNum@;
		   @t cgFuncCall(@funcInvoc.env@,@ID.sym@,
				 @funcInvoc.regNum@,True,@ID.line@
		                ); 
		@}
	|	ID	'('	actParamList	')'
		@{ @i @actParamList.env@ = @funcInvoc.env@;
		   @i @funcInvoc.type@ = @ID.sym@->type; 
		   @i @ID.sym@ = 
		        funcInvocLookup(@funcInvoc.env@,@ID.str@,@ID.line@);
		   @i @actParamList.regNum@ = @funcInvoc.regNum@;
		   @i @funcInvoc.maxRegNum@ = @actParamList.maxRegNum@;
		   @i @actParamList.formParamList@ = @ID.sym@->paramLoc;
		   @i @actParamList.func@ = @ID.sym@;
		   @i @actParamList.line@ = @ID.line@;
		   @t cgFuncCall(@funcInvoc.env@,@ID.sym@,
		                 @funcInvoc.regNum@,False,@ID.line@
                                ); 
		@}
	|	typeSpec	'('	expr	')'
		@{ @i @expr.env@ = @funcInvoc.env@;
		   @i @funcInvoc.type@ = @typeSpec.type@; 
		   @i @expr.regNum@ = @funcInvoc.regNum@;
		   @i @funcInvoc.maxRegNum@ = @expr.maxRegNum@;
		   @i @expr.formalMatch@ = lambdaSym;
		   @t cgCast(@expr.regNum@,@typeSpec.type@,@expr.type@);
		@}
	|	INPUT	'('	STRING	','	stgRef	')' 
		@{ @i @stgRef.env@ = @funcInvoc.env@;
		   @i @funcInvoc.type@ = INTT; 
		   @i @stgRef.regNum@ = @funcInvoc.regNum@;
		   @i @funcInvoc.maxRegNum@ = @stgRef.maxRegNum@;
		   @i @stgRef.formalMatch@ = lambdaSym;
		   @t cgInput(@STRING.str@,@stgRef.regNum@,
		              @stgRef.type@,@'('.line@
		             ); 
		@}
	|	OUTPUT	'('	STRING	')' 
		@{ @i @funcInvoc.type@ = INTT; 
		   @i @funcInvoc.maxRegNum@ = @funcInvoc.regNum@;
		   @t cgOutputNoArg(@STRING.str@,@funcInvoc.regNum@); 
		@}
	|	OUTPUT	'('	STRING	','	expr	')' 
		@{ @i @expr.env@ = @funcInvoc.env@;
		   @i @funcInvoc.type@ = INTT; 
		   @i @expr.regNum@ = @funcInvoc.regNum@;
		   @i @funcInvoc.maxRegNum@ = @expr.maxRegNum@;
		   @i @expr.formalMatch@ = lambdaSym;
		   @t cgOutputOneArg(@STRING.str@,@expr.regNum@,@expr.type@); 
		@}
	;

actParamList
	:	expr
		@{ @i @expr.regNum@ = @actParamList.regNum@;
		   @i @actParamList.maxRegNum@ = @expr.maxRegNum@;
		   @i @expr.env@ = @actParamList.env@;
		   @i @expr.formalMatch@ = @actParamList.formParamList@; 
		   @t paramMatchCheck(@actParamList.formParamList@,
		                      @expr.type@,
		                      @expr.isStgRef@,True,
		                      @actParamList.func@,@actParamList.line@
		                     ); 
		      cgPush(@actParamList.regNum@);
		@}
	|	actParamList	','	expr	
		@{ @i @actParamList.1.env@ = @actParamList.env@;
		   @i @expr.env@ = @actParamList.env@;
		   @i @actParamList.1.regNum@ = @actParamList.regNum@;
		   @i @expr.regNum@ = @actParamList.regNum@;
		   @i @actParamList.maxRegNum@ = max(@actParamList.1.maxRegNum@,
		                                     @expr.maxRegNum@
		                                    );
		   @i @actParamList.1.formParamList@ = 
		        cdrParamList(@actParamList.formParamList@,
		                     @actParamList.func@,
		                     @actParamList.line@
		                    ); 
		   @i @actParamList.1.func@ = @actParamList.func@;
		   @i @actParamList.1.line@ = @actParamList.line@;
		   @i @expr.formalMatch@ = @actParamList.formParamList@; 
		   @t paramMatchCheck(@actParamList.formParamList@,
		                      @expr.type@,
		                      @expr.isStgRef@,False,
		                      @actParamList.func@,@actParamList.line@
		                     ); 
		      cgPush(@actParamList.regNum@);
		@}
	;

funcDecl
	:	typeSpec	ID	'('	paramDeclList	')'	block
		@{ @i @block.env@ = newEnv(@funcDecl.env@,
		                           @ID.sym@,
		                           @block.varLoc@,
		                           @block.funcLoc@,
		                           @block.maxRegNum@
		                          ); 
		   @i @funcDecl.loc@ = @ID.sym@; 
		   @i @ID.sym@ = newFuncSym(@ID.str@,@ID.line@,
		                            @typeSpec.type@,
		                            newLabelNum(),
		                            @paramDeclList.loc@ 
		                           );
		   @i @paramDeclList.funcSym@ = @ID.sym@; 
		   @t cgFuncTrailer(@ID.sym@); 
		@} 
	;

paramDeclList
	:
		@{ @i @paramDeclList.loc@ = lambdaSym; 
		   @t cgFuncAddress(@paramDeclList.funcSym@); 
		@}
	|	paramDeclList	paramDecl
		@{ @i @paramDeclList.loc@ = 
                        concatLocs(@paramDecl.loc@,@paramDeclList.1.loc@); 
		   @i @paramDeclList.1.funcSym@ = @paramDeclList.funcSym@; 
		@}
	;	

paramDecl	
	:		stgDecl		
		@{ @i @paramDecl.loc@ = @stgDecl.loc@; 
		   @i @stgDecl.Class@ = VALPARAMC;
		@}
	|	VAR	stgDecl	
		@{ @i @paramDecl.loc@ = @stgDecl.loc@; 
		   @i @stgDecl.Class@ = REFPARAMC;
		@}
	; 

stgDecl	
	:		typeSpec	stgDecl2List	';'
		@{ @i @stgDecl.loc@ = @stgDecl2List.loc@; 
		   @i @stgDecl2List.type@ = @typeSpec.type@;
		   @i @stgDecl2List.Class@ = @stgDecl.Class@;
		@}
	;

typeSpec
	:	INT
		@{ @i @typeSpec.type@ = INTT;
		   @i @typeSpec.line@ = @INT.line@;
		@}
	|	TKFLOAT
		@{ @i @typeSpec.type@ = FLOATT;
		   @i @typeSpec.line@ = @TKFLOAT.line@;
		@}
	|	BOOL
		@{ @i @typeSpec.type@ = BOOLT;
		   @i @typeSpec.line@ = @BOOL.line@;
		@}
	|	VOID
		@{ @i @typeSpec.type@ = VOIDT;
		   @i @typeSpec.line@ = @VOID.line@;
		@}
	;

stgDecl2List
	:	stgDecl2	
		@{ @i @stgDecl2List.loc@ = @stgDecl2.loc@;
		   @i @stgDecl2.type@ = @stgDecl2List.type@;
		   @i @stgDecl2.Class@ = @stgDecl2List.Class@;
		@}
	|	stgDecl2List	','	stgDecl2
		@{ @i @stgDecl2List.loc@ = concatLocs(@stgDecl2.loc@,
		                                      @stgDecl2List.1.loc@
		                                     ); 
		   @i @stgDecl2List.1.type@ = @stgDecl2List.type@;
		   @i @stgDecl2List.1.Class@ = @stgDecl2List.Class@;
		   @i @stgDecl2.type@ = @stgDecl2List.type@;
		   @i @stgDecl2.Class@ = @stgDecl2List.Class@;
		@}
	;

stgDecl2	
	:	ID	dimSeq
		@{ @i @stgDecl2.loc@ = @ID.sym@; 
		   @i @ID.sym@ = newStgSym(@ID.str@,@ID.line@,
		                           @stgDecl2.type@,
		                           @stgDecl2.Class@,
		                           @dimSeq.dimList@
		                          );
		@}
	;

dimSeq	:	
		@{ @i @dimSeq.dimList@ = lambdaDim; 
		@}
	|	dimSeq	'['	iConstExpr	']'
		@{ @i @dimSeq.dimList@ = 
		         consDimList(@iConstExpr.val@,@dimSeq.1.dimList@,
		                     @'['.line@  
		                    ); 
		@}
	;

ifStatement
	:	IF	expr	then	execElem	
		@{ @i @execElem.env@ = @ifStatement.env@; 
		   @i @expr.env@ = @ifStatement.env@;
		   @i @expr.regNum@ = FIRSTREGNUM;
		   @i @ifStatement.maxRegNum@ = max(@expr.maxRegNum@,
		                                    @execElem.maxRegNum@
		                                   );
		   @i @expr.formalMatch@ = lambdaSym;
		   @i @then.label@ = newLabelNum(); 
		   @i @then.decisionRegNum@ = @expr.regNum@;
		   @t cgIfThen(@expr.type@,@IF.line@,@then.label@); 
		@} 

	|	IF	expr	then	execElem	else	execElem
		@{ @i @expr.env@ = @ifStatement.env@; 
                   @i @execElem.env@ = @ifStatement.env@;  
		   @i @execElem.1.env@ = @ifStatement.env@; 
		   @i @expr.regNum@ = FIRSTREGNUM;
		   @i @ifStatement.maxRegNum@ = 
                         max(@expr.maxRegNum@,
		             max(@execElem.maxRegNum@,
		                 @execElem.1.maxRegNum@
		                )
		            );
		   @i @expr.formalMatch@ = lambdaSym;
		   @i @then.label@ = newLabelNum(); 
		   @i @then.decisionRegNum@ = @expr.regNum@;
		   @i @else.label@ = @then.label@; 
		   @t cgIfThenElse(@expr.type@,@IF.line@,@then.label@); 
		@} 
	;

then 	
	:	THEN
		@{ @t cgThen(@then.decisionRegNum@,@then.label@); 
		@}
	;

else	
	:	ELSE
		@{ @t cgElse(@else.label@); 
		@}
	;

whileStatement
	:	while	'(' 	expr	')'	wDecision	execElem
		@{ @i @expr.env@ = @whileStatement.env@; 
		   @i @execElem.env@ = @whileStatement.env@; 
		   @i @expr.regNum@ = FIRSTREGNUM;
		   @i @whileStatement.maxRegNum@ = max(@expr.maxRegNum@,
		                                       @execElem.maxRegNum@
		                                      );
		   @i @expr.formalMatch@ = lambdaSym;
		   @i @while.label@ = newLabelNum(); 
		   @i @wDecision.label@ = @while.label@;
		   @i @wDecision.decisionRegNum@ = @expr.regNum@;
		   @t cgWhileStatement(@expr.type@,@'('.line@,@while.label@); 
		@} 
	;

while	
	:	WHILE
		@{ @t cgWhile(@while.label@); 
		@}
	;

wDecision
	:
		@{ @t cgWdecision(@wDecision.decisionRegNum@,@wDecision.label@);
		@}
	;

returnStatement
	:	RETURN	expr	';'
		@{ @i @expr.env@ = @returnStatement.env@; 
		   @i @expr.regNum@ = FIRSTREGNUM;
		   @i @returnStatement.maxRegNum@ = @expr.maxRegNum@;
		   @i @expr.formalMatch@ = lambdaSym;
		   @t cgReturnStmt(@returnStatement.env@,@expr.regNum@,
		                   @expr.type@,@RETURN.line@
		                  ); 
		@} 
	|	RETURN	';'
		@{ @i @returnStatement.maxRegNum@ = FIRSTREGNUM - 1;
		   @t cgReturnStmt(@returnStatement.env@,DONTCARE,
		                   VOIDT,@RETURN.line@
		                  ); 
		@} 
exitStatement
	:	EXIT	expr	';'
		@{ @i @expr.env@ = @exitStatement.env@; 
		   @i @expr.regNum@ = FIRSTREGNUM;
		   @i @exitStatement.maxRegNum@ = @expr.maxRegNum@;
		   @i @expr.formalMatch@ = lambdaSym;
		   @t cgExitStmt(@expr.regNum@,@expr.type@,@EXIT.line@); 
		@} 
	;

%% 
#include <stdio.h>

void yyyCheckForResizes();



main(argc,argv) 
  int argc;
  char *argv[];
  {int parseStatus;

   yyyCheckForResizes(argc,argv);
   scanSetup(); 
   semSetup(); 
   tempOut = safeOpen(tempOutID,"w"); 
   cgHeader();  
   parseStatus = yyparse();
   cgTrailer();  
   fclose(tempOut); 
   return(parseStatus || (doCodeGen == False)); 
  } 



@EOF
set `sum $sumopt <oxDistG1.04/gppl/gppl.Y`; if test $1 -ne 8820
then
	echo ERROR: oxDistG1.04/gppl/gppl.Y checksum is $1 should be 8820
fi
set `wc -lwc <oxDistG1.04/gppl/gppl.Y`
if test $1$2$3 != 844201023525
then
	echo ERROR: wc results of oxDistG1.04/gppl/gppl.Y are $* should be 844 2010 23525
fi

chmod 755 oxDistG1.04/gppl/gppl.Y

if test -f oxDistG1.04/gppl/gppl.Y.A
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gppl.Y.A\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gppl.Y.A
	if test -f oxDistG1.04/gppl/gppl.Y.A
	then
		echo Error: could not remove oxDistG1.04/gppl/gppl.Y.A, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gppl.Y.A
sed 's/^@//' >oxDistG1.04/gppl/gppl.Y.A <<'@EOF'
/* $Header: gppl.Y.A,v 1.3 93/11/09 19:16:54 bischoff Exp $ */ 

/* a compiler for a general purpose programming language */ 

%{
#include "glob.h"
#include "y.tab.h"
#include "scan.h"
#include "sem.h"
#include "code.h"
#include "util.h"
%}


%start prog    

%token ID ICONST FCONST BCONST EOFCONST
%token INT TKFLOAT BOOL VOID 
%token VAR  
%token IF THEN ELSE WHILE   
%token EQ LT GT GEQ LEQ NEQ  
%token AND OR NOT  
%token INPUT OUTPUT STRING 
%token RETURN EXIT  

%right GETS
%left OR 
%left AND 
%nonassoc EQ NEQ  
%nonassoc LT LEQ GT GEQ   
%left '+' '-'
%left '*' '/' 
%right NOT

@traversal t 

@@autoinh env 
@@autosyn maxRegNum 

@@attributes {struct env *env; 
             regNumType maxRegNum;
            } 
            execElem statement 
            returnStatement exitStatement
            ifStatement whileStatement  

@@attributes {struct env *env; 
             regNumType regNum;
             regNumType maxRegNum;
             struct sym *formParamList;
             struct sym *func;
             lineNumType line;
            } 
            actParamList    

@@attributes {struct env *env; 
             struct sym *varLoc,*funcLoc; 
             regNumType maxRegNum;
            } 
            block blockElemList 

@@attributes {struct sym *loc; 
             enum stgClass Class;
            } 
            stgDecl   

@@attributes {struct sym *loc; 
             struct sym *funcSym; 
            } 
            paramDeclList   

@@attributes {struct sym *loc; 
            } 
            paramDecl  

@@attributes {struct env *env; 
             struct sym *loc; 
            } 
            funcDecl 

@@attributes {enum symType type; 
             lineNumType line; 
            } 
            typeSpec  

@@attributes {enum symType type; 
             struct sym *loc;
             enum stgClass Class; 
            } 
            stgDecl2 stgDecl2List 

@attributes {struct dim *dimList;
            }
            dimSeq

@@attributes {struct env *env; 
             enum symType type; 
             regNumType regNum;
             regNumType maxRegNum;
            } 
            funcInvoc assignExpr 

@@attributes {struct env *env; 
             enum symType type; 
             regNumType regNum;
             regNumType maxRegNum;
             struct sym *formalMatch; 
             enum pred isStgRef;
            } 
            expr simpleExpr  

@@attributes {struct env *env; 
             regNumType regNum;
             regNumType maxRegNum;
             struct dim *dimList;  
             struct sym *sym;
             lineNumType line; 
            } 
            indexSeq

@@attributes {struct env *env; 
             enum symType type; 
             regNumType regNum;
             regNumType maxRegNum;
             struct sym *formalMatch;
            } 
            stgRef 

@@attributes {char *str; 
             lineNumType line; 
             struct sym *sym; 
            } 
            ID  

@@attributes {char *str;
            }
            STRING

@@attributes {lineNumType line; 
            } 
            AND OR NOT 
            GETS 
            GT LT EQ NEQ GEQ LEQ 
            '*' '+' '/' '-' '(' ',' '['
            FOR IF WHILE DO 
            INT TKFLOAT BOOL VOID
            RETURN EXIT

@@attributes {labelType label;
             regNumType decisionRegNum;
            }
            then wDecision 

@@attributes {labelType label;
            }
            else while

@@attributes {union num val; 
            } 
            ICONST FCONST BCONST 

@@attributes {long val; 
            } 
            iConstExpr

@macro constSimpleExpr(SYM,TYPE,)
   @i @simpleExpr.type@ = TYPE;   
   @i @simpleExpr.maxRegNum@ = @simpleExpr.regNum@;
   @i @simpleExpr.isStgRef@ = False;
   @t cgConstSimpleExpr(@simpleExpr.regNum@,TYPE,@SYM.val@); 
@@end


@@macro unrOpExprdefs(op,)
  @i @expr.type@ = unrOpTypeCheck(@expr.1.type@,op,@op.line@);
  @i @expr.1.regNum@ = @expr.regNum@;
  @i @expr.1.formalMatch@ = lambdaSym;
  @i @expr.isStgRef@ = False;
@@end


@@macro binOpExprdefs(op,) 
  @i @expr.type@ = binOpTypeCheck(@expr.1.type@,@expr.2.type@,op,@op.line@);
  @i @expr.1.regNum@ = @expr.regNum@;
  @i @expr.2.regNum@ = @expr.regNum@ + 1;
  @i @expr.maxRegNum@ = max(@expr.1.maxRegNum@,@expr.2.maxRegNum@);
  @i @expr.1.formalMatch@ = lambdaSym;
  @i @expr.2.formalMatch@ = lambdaSym;
  @i @expr.isStgRef@ = False;
@@end

@@macro binArithExpr(op,) 
  @t cgBinArithExpr(@expr.1.regNum@,op,@expr.type@); 
@@end

@@macro relExpr(op,)
  @t cgRelExpr(@expr.1.regNum@,op,@expr.1.type@);
@@end  

@@macro binLogExpr(op,)
  @t cgBinLogExpr(@expr.1.regNum@,op);
@@end  


%%
prog	
	:	block	
		@{ @i @block.env@ = newEnv(lambdaEnv,
		                           lambdaSym, 
		                           @block.varLoc@,
		                           @block.funcLoc@,
		                           @block.maxRegNum@
		                          ); 
		@}  
	; 

block	
	:	'{'	blockElemList	'}' 
		@{ @i @block.varLoc@ = @blockElemList.varLoc@; 
		   @i @block.funcLoc@ = @blockElemList.funcLoc@; 
		   @t cgBlockExit(@block.env@); 
		@} 
	; 

blockElemList 
	:
		@{ @i @blockElemList.varLoc@ = lambdaSym;
		   @i @blockElemList.funcLoc@ = lambdaSym; 
		   @i @blockElemList.maxRegNum@ = FIRSTREGNUM - 1;
		   @t cgBlockEnter(@blockElemList.env@); 
		@}
	|	blockElemList	execElem	
		@{  
		   @i @blockElemList.maxRegNum@ = 
		         max(@blockElemList.1.maxRegNum@,
		             @execElem.maxRegNum@ 
		            ); 
		   @i @blockElemList.varLoc@ = @blockElemList.1.varLoc@; 
		   @i @blockElemList.funcLoc@ = @blockElemList.1.funcLoc@; 
		   @i @execElem.env@ = @blockElemList.env@; 
		@} 
	|	blockElemList	stgDecl	
		@{ @i @blockElemList.varLoc@ =  
		        concatLocs(@blockElemList.1.varLoc@,@stgDecl.loc@); 
		   @i @blockElemList.funcLoc@ = @blockElemList.1.funcLoc@; 
		   @i @stgDecl.Class@ = VARIABLEC;
		@}
	|	blockElemList	funcDecl	
		@{ @i @blockElemList.varLoc@ = @blockElemList.1.varLoc@; 
		   @i @blockElemList.funcLoc@ = 
		        concatLocs(@blockElemList.1.funcLoc@,@funcDecl.loc@); 
		@}
	; 
 
execElem	
	:	statement
	|	block	
		@{ @i @block.env@ = newEnv(@execElem.env@,
		                           lambdaSym,
		                           @block.varLoc@,
		                           @block.funcLoc@,
		                           @block.maxRegNum@
		                          ); 
		   @i @execElem.maxRegNum@ = FIRSTREGNUM - 1;
		@} 
	;

statement 
	:	';'	
		@{ @i @statement.maxRegNum@ = FIRSTREGNUM - 1;
		@}
	|	expr	';'	
		@{ @i @expr.regNum@ = FIRSTREGNUM; 
		   @i @expr.formalMatch@ = lambdaSym; 
		@}
	|	ifStatement
	|	whileStatement
	|	returnStatement
	|	exitStatement
	; 

expr	
	:	assignExpr
		@{ @i @expr.type@ = @assignExpr.type@;
		   @i @assignExpr.regNum@ = @expr.regNum@;
		   @i @expr.isStgRef@ = False;
		@}
	|	simpleExpr
		@{ @i @expr.type@ = @simpleExpr.type@;
		   @i @simpleExpr.regNum@ = @expr.regNum@; 
		   @i @simpleExpr.formalMatch@ = @expr.formalMatch@;
		   @i @expr.isStgRef@ = @simpleExpr.isStgRef@;
		@}
	|	'('	expr	')'
		@{ @i @expr.type@ = @expr.1.type@;
		   @i @expr.1.regNum@ = @expr.regNum@; 
		   @i @expr.1.formalMatch@ = @expr.formalMatch@;  
		   @i @expr.isStgRef@ = @expr.1.isStgRef@;
		@}
	|	'-'	expr		
		@{ unrOpExprdefs('-',) 
		   @t cgUnrArithExpr(@expr.regNum@,'-',@expr.type@); 
		@}
	|	'+'	expr	
		@{ unrOpExprdefs('+',) 
		   @t cgUnrArithExpr(@expr.regNum@,'+',@expr.type@); 
		@}
	|	NOT	expr		
		@{ unrOpExprdefs(NOT,) 
		   @t cgLogNegExpr(@expr.regNum@);
		@}
	|	expr	'*'	expr
		@{ binOpExprdefs('*',) 
		   binArithExpr('*',) 
		@}
	|	expr	'/'	expr
		@{ binOpExprdefs('/',) 
		   binArithExpr('/',) 
		@}
	|	expr	'+'	expr
		@{ binOpExprdefs('+',) 
		   binArithExpr('+',) 
		@}
	|	expr	'-'	expr
		@{ binOpExprdefs('-',) 
		   binArithExpr('-',) 
		@}
	|	expr	EQ	expr
		@{ binOpExprdefs(EQ,) 
		   relExpr(EQ,)
		@}
	|	expr	NEQ	expr
		@{ binOpExprdefs(NEQ,) 
		   relExpr(NEQ,)
		@}
	|	expr	LT	expr
		@{ binOpExprdefs(LT,) 
		   relExpr(LT,)
		@}
	|	expr	GT	expr
		@{ binOpExprdefs(GT,) 
		   relExpr(GT,)
		@}
	|	expr	LEQ	expr
		@{ binOpExprdefs(LEQ,) 
		   relExpr(LEQ,)
		@}
	|	expr	GEQ	expr
		@{ binOpExprdefs(GEQ,) 
		   relExpr(GEQ,)
		@}
	|	expr	AND	expr
		@{ binOpExprdefs(AND,) 
		   binLogExpr(AND,)
		@}
	|	expr	OR	expr
		@{ binOpExprdefs(OR,) 
		   binLogExpr(OR,)
		@}
	;

assignExpr	
	:	stgRef 	GETS	expr 
		@{ @i @assignExpr.type@ = assignmentTypeCheck(@stgRef.type@,
		                                              @expr.type@,
		                                              @GETS.line@
		                                             );
		   @i @expr.regNum@ = @assignExpr.regNum@ + 1; 
		   @i @stgRef.regNum@ = @assignExpr.regNum@; 
		   @i @assignExpr.maxRegNum@ = 
		         max(@stgRef.maxRegNum@,@expr.maxRegNum@);
		   @i @stgRef.formalMatch@ = lambdaSym; 
		   @i @expr.formalMatch@ = lambdaSym; 
		   @t cgAssign(@stgRef.regNum@,@assignExpr.type@); 
		@}
	;

simpleExpr	
	:	stgRef 
		@{ @i @simpleExpr.type@ = @stgRef.type@; 
		   @i @stgRef.regNum@ = @simpleExpr.regNum@;
		   @i @stgRef.formalMatch@ = @simpleExpr.formalMatch@; 
		   @i @simpleExpr.isStgRef@ = True;
		   @t cgCondDeref(@simpleExpr.formalMatch@,@simpleExpr.regNum@,
		                  @simpleExpr.type@
		                 ); 
		@}
	|	funcInvoc
		@{ @i @simpleExpr.type@ = @funcInvoc.type@; 
		   @i @funcInvoc.regNum@ = @simpleExpr.regNum@;
		   @i @simpleExpr.isStgRef@ = False;
		@}
 	|	ICONST
		@{ constSimpleExpr(ICONST,INTT,)   @}
 	|	FCONST
		@{ constSimpleExpr(FCONST,FLOATT,) @}
 	|	BCONST
		@{ constSimpleExpr(BCONST,BOOLT,)  @}
 	|	EOFCONST
		@{ @i @simpleExpr.type@ = INTT;   
   		   @i @simpleExpr.maxRegNum@ = @simpleExpr.regNum@;
   		   @i @simpleExpr.isStgRef@ = False;
   		   @t cgEOF(@simpleExpr.regNum@); 
		@}
	;

iConstExpr	
 	:	ICONST
		@{ @i @iConstExpr.val@ = @ICONST.val@.i;  
		@}
	|	'-'	iConstExpr
		@{ @i @iConstExpr.val@ = - @iConstExpr.1.val@ ; 
		@}
	|	'+'	iConstExpr
		@{ @i @iConstExpr.val@ =   @iConstExpr.1.val@ ; 
		@}
	|	'('	iConstExpr	')'
		@{ @i @iConstExpr.val@ =   @iConstExpr.1.val@ ; 
		@}
	|	iConstExpr	'*'	iConstExpr
		@{ @i @iConstExpr.val@ = @iConstExpr.1.val@ * 
                                           @iConstExpr.2.val@ ;  
		@}
	|	iConstExpr	'+'	iConstExpr
		@{ @i @iConstExpr.val@ = @iConstExpr.1.val@ + 
                                           @iConstExpr.2.val@ ;  
		@}
	|	iConstExpr	'/'	iConstExpr
		@{ @i @iConstExpr.val@ = @iConstExpr.1.val@ / 
                                           @iConstExpr.2.val@ ;  
		@}
	|	iConstExpr	'-'	iConstExpr
		@{ @i @iConstExpr.val@ = @iConstExpr.1.val@ - 
                                           @iConstExpr.2.val@ ;  
		@}
	;

stgRef	
	:	ID	indexSeq
		@{ @i @ID.sym@ = 
                        stgRefLookup(@stgRef.env@,@ID.str@,@ID.line@);
		   @i @indexSeq.regNum@ = @stgRef.regNum@;
		   @i @stgRef.type@ = @ID.sym@->type;
		   @i @indexSeq.dimList@ = 
		         adjustDimList(@stgRef.formalMatch@,@ID.sym@,@ID.line@);
		   @i @indexSeq.sym@ = @ID.sym@;
		   @i @indexSeq.line@ = @ID.line@;
		@}
	;

indexSeq
	:	
		@{ @i @indexSeq.maxRegNum@ = @indexSeq.regNum@; 
		   @t cgEmptyIndexSeq(@indexSeq.env@,@indexSeq.sym@,
		         @indexSeq.line@,@indexSeq.regNum@,@indexSeq.dimList@
		                     );
		@}
	|	indexSeq	'['	expr	']'
		@{ @i @indexSeq.1.regNum@ = @indexSeq.regNum@; 
		   @i @expr.regNum@ = @indexSeq.regNum@ + 1; 
		   @i @indexSeq.maxRegNum@ = max(@indexSeq.1.maxRegNum@,
		                               @expr.maxRegNum@
		                              );
		   @i @indexSeq.1.dimList@ = cdrDimList(@indexSeq.dimList@,
		                                        @indexSeq.sym@,
		                                        @indexSeq.line@
		                                       ); 
		   @i @indexSeq.1.sym@ = @indexSeq.sym@;
		   @i @indexSeq.1.line@ = @indexSeq.line@;
		   @i @expr.formalMatch@ = lambdaSym;
		   @t cgIndexSeq(@indexSeq.sym@,@indexSeq.regNum@,
		                 @indexSeq.dimList@
		                );
		@}
	;

funcInvoc
	:	ID	'('	')'
		@{ @i @funcInvoc.type@ = @ID.sym@->type; 
		   @i @ID.sym@ = 
		        funcInvocLookup(@funcInvoc.env@,@ID.str@,@ID.line@);
		   @i @funcInvoc.maxRegNum@ = @funcInvoc.regNum@;
		   @t cgFuncCall(@funcInvoc.env@,@ID.sym@,
				 @funcInvoc.regNum@,True,@ID.line@
		                ); 
		@}
	|	ID	'('	actParamList	')'
		@{ @i @funcInvoc.type@ = @ID.sym@->type; 
		   @i @ID.sym@ = 
		        funcInvocLookup(@funcInvoc.env@,@ID.str@,@ID.line@);
		   @i @actParamList.regNum@ = @funcInvoc.regNum@;
		   @i @actParamList.formParamList@ = @ID.sym@->paramLoc;
		   @i @actParamList.func@ = @ID.sym@;
		   @i @actParamList.line@ = @ID.line@;
		   @t cgFuncCall(@funcInvoc.env@,@ID.sym@,
		                 @funcInvoc.regNum@,False,@ID.line@
                                ); 
		@}
	|	typeSpec	'('	expr	')'
		@{ @i @funcInvoc.type@ = @typeSpec.type@; 
		   @i @expr.regNum@ = @funcInvoc.regNum@;
		   @i @funcInvoc.maxRegNum@ = @expr.maxRegNum@;
		   @i @expr.formalMatch@ = lambdaSym;
		   @t cgCast(@expr.regNum@,@typeSpec.type@,@expr.type@);
		@}
	|	INPUT	'('	STRING	','	stgRef	')' 
		@{ @i @funcInvoc.type@ = INTT; 
		   @i @stgRef.regNum@ = @funcInvoc.regNum@;
		   @i @stgRef.formalMatch@ = lambdaSym;
		   @t cgInput(@STRING.str@,@stgRef.regNum@,
		              @stgRef.type@,@'('.line@
		             ); 
		@}
	|	OUTPUT	'('	STRING	')' 
		@{ @i @funcInvoc.type@ = INTT; 
		   @i @funcInvoc.maxRegNum@ = @funcInvoc.regNum@;
		   @t cgOutputNoArg(@STRING.str@,@funcInvoc.regNum@); 
		@}
	|	OUTPUT	'('	STRING	','	expr	')' 
		@{ @i @funcInvoc.type@ = INTT; 
		   @i @expr.regNum@ = @funcInvoc.regNum@;
		   @i @expr.formalMatch@ = lambdaSym;
		   @t cgOutputOneArg(@STRING.str@,@expr.regNum@,@expr.type@); 
		@}
	;

actParamList
	:	expr
		@{ @i @expr.regNum@ = @actParamList.regNum@;
		   @i @expr.formalMatch@ = @actParamList.formParamList@; 
		   @t paramMatchCheck(@actParamList.formParamList@,
		                      @expr.type@,
		                      @expr.isStgRef@,True,
		                      @actParamList.func@,@actParamList.line@
		                     ); 
		      cgPush(@actParamList.regNum@);
		@}
	|	actParamList	','	expr	
		@{ @i @actParamList.1.regNum@ = @actParamList.regNum@;
		   @i @expr.regNum@ = @actParamList.regNum@;
		   @i @actParamList.maxRegNum@ = max(@actParamList.1.maxRegNum@,
		                                     @expr.maxRegNum@
		                                    );
		   @i @actParamList.1.formParamList@ = 
		        cdrParamList(@actParamList.formParamList@,
		                     @actParamList.func@,
		                     @actParamList.line@
		                    ); 
		   @i @actParamList.1.func@ = @actParamList.func@;
		   @i @actParamList.1.line@ = @actParamList.line@;
		   @i @expr.formalMatch@ = @actParamList.formParamList@; 
		   @t paramMatchCheck(@actParamList.formParamList@,
		                      @expr.type@,
		                      @expr.isStgRef@,False,
		                      @actParamList.func@,@actParamList.line@
		                     ); 
		      cgPush(@actParamList.regNum@);
		@}
	;

funcDecl
	:	typeSpec	ID	'('	paramDeclList	')'	block
		@{ @i @block.env@ = newEnv(@funcDecl.env@,
		                           @ID.sym@,
		                           @block.varLoc@,
		                           @block.funcLoc@,
		                           @block.maxRegNum@
		                          ); 
		   @i @funcDecl.loc@ = @ID.sym@; 
		   @i @ID.sym@ = newFuncSym(@ID.str@,@ID.line@,
		                            @typeSpec.type@,
		                            newLabelNum(),
		                            @paramDeclList.loc@ 
		                           );
		   @i @paramDeclList.funcSym@ = @ID.sym@; 
		   @t cgFuncTrailer(@ID.sym@); 
		@} 
	;

paramDeclList
	:
		@{ @i @paramDeclList.loc@ = lambdaSym; 
		   @t cgFuncAddress(@paramDeclList.funcSym@); 
		@}
	|	paramDeclList	paramDecl
		@{ @i @paramDeclList.loc@ = 
                        concatLocs(@paramDecl.loc@,@paramDeclList.1.loc@); 
		   @i @paramDeclList.1.funcSym@ = @paramDeclList.funcSym@; 
		@}
	;	

paramDecl	
	:		stgDecl		
		@{ @i @paramDecl.loc@ = @stgDecl.loc@; 
		   @i @stgDecl.Class@ = VALPARAMC;
		@}
	|	VAR	stgDecl	
		@{ @i @paramDecl.loc@ = @stgDecl.loc@; 
		   @i @stgDecl.Class@ = REFPARAMC;
		@}
	; 

stgDecl	
	:		typeSpec	stgDecl2List	';'
		@{ @i @stgDecl.loc@ = @stgDecl2List.loc@; 
		   @i @stgDecl2List.type@ = @typeSpec.type@;
		   @i @stgDecl2List.Class@ = @stgDecl.Class@;
		@}
	;

typeSpec
	:	INT
		@{ @i @typeSpec.type@ = INTT;
		   @i @typeSpec.line@ = @INT.line@;
		@}
	|	TKFLOAT
		@{ @i @typeSpec.type@ = FLOATT;
		   @i @typeSpec.line@ = @TKFLOAT.line@;
		@}
	|	BOOL
		@{ @i @typeSpec.type@ = BOOLT;
		   @i @typeSpec.line@ = @BOOL.line@;
		@}
	|	VOID
		@{ @i @typeSpec.type@ = VOIDT;
		   @i @typeSpec.line@ = @VOID.line@;
		@}
	;

stgDecl2List
	:	stgDecl2	
		@{ @i @stgDecl2List.loc@ = @stgDecl2.loc@;
		   @i @stgDecl2.type@ = @stgDecl2List.type@;
		   @i @stgDecl2.Class@ = @stgDecl2List.Class@;
		@}
	|	stgDecl2List	','	stgDecl2
		@{ @i @stgDecl2List.loc@ = concatLocs(@stgDecl2.loc@,
		                                      @stgDecl2List.1.loc@
		                                     ); 
		   @i @stgDecl2List.1.type@ = @stgDecl2List.type@;
		   @i @stgDecl2List.1.Class@ = @stgDecl2List.Class@;
		   @i @stgDecl2.type@ = @stgDecl2List.type@;
		   @i @stgDecl2.Class@ = @stgDecl2List.Class@;
		@}
	;

stgDecl2	
	:	ID	dimSeq
		@{ @i @stgDecl2.loc@ = @ID.sym@; 
		   @i @ID.sym@ = newStgSym(@ID.str@,@ID.line@,
		                           @stgDecl2.type@,
		                           @stgDecl2.Class@,
		                           @dimSeq.dimList@
		                          );
		@}
	;

dimSeq	:	
		@{ @i @dimSeq.dimList@ = lambdaDim; 
		@}
	|	dimSeq	'['	iConstExpr	']'
		@{ @i @dimSeq.dimList@ = 
		         consDimList(@iConstExpr.val@,@dimSeq.1.dimList@,
		                     @'['.line@  
		                    ); 
		@}
	;

ifStatement
	:	IF	expr	then	execElem	
		@{ @i @expr.regNum@ = FIRSTREGNUM;
		   @i @ifStatement.maxRegNum@ = max(@expr.maxRegNum@,
		                                    @execElem.maxRegNum@
		                                   );
		   @i @expr.formalMatch@ = lambdaSym;
		   @i @then.label@ = newLabelNum(); 
		   @i @then.decisionRegNum@ = @expr.regNum@;
		   @t cgIfThen(@expr.type@,@IF.line@,@then.label@); 
		@} 

	|	IF	expr	then	execElem	else	execElem
		@{ @i @expr.regNum@ = FIRSTREGNUM;
		   @i @ifStatement.maxRegNum@ = 
                         max(@expr.maxRegNum@,
		             max(@execElem.maxRegNum@,
		                 @execElem.1.maxRegNum@
		                )
		            );
		   @i @expr.formalMatch@ = lambdaSym;
		   @i @then.label@ = newLabelNum(); 
		   @i @then.decisionRegNum@ = @expr.regNum@;
		   @i @else.label@ = @then.label@; 
		   @t cgIfThenElse(@expr.type@,@IF.line@,@then.label@); 
		@} 
	;

then 	
	:	THEN
		@{ @t cgThen(@then.decisionRegNum@,@then.label@); 
		@}
	;

else	
	:	ELSE
		@{ @t cgElse(@else.label@); 
		@}
	;

whileStatement
	:	while	'(' 	expr	')'	wDecision	execElem
		@{ @i @expr.regNum@ = FIRSTREGNUM;
		   @i @whileStatement.maxRegNum@ = max(@expr.maxRegNum@,
		                                       @execElem.maxRegNum@
		                                      );
		   @i @expr.formalMatch@ = lambdaSym;
		   @i @while.label@ = newLabelNum(); 
		   @i @wDecision.label@ = @while.label@;
		   @i @wDecision.decisionRegNum@ = @expr.regNum@;
		   @t cgWhileStatement(@expr.type@,@'('.line@,@while.label@); 
		@} 
	;

while	
	:	WHILE
		@{ @t cgWhile(@while.label@); 
		@}
	;

wDecision
	:
		@{ @t cgWdecision(@wDecision.decisionRegNum@,@wDecision.label@);
		@}
	;

returnStatement
	:	RETURN	expr	';'
		@{ @i @expr.regNum@ = FIRSTREGNUM;
		   @i @expr.formalMatch@ = lambdaSym;
		   @t cgReturnStmt(@returnStatement.env@,@expr.regNum@,
		                   @expr.type@,@RETURN.line@
		                  ); 
		@} 
	|	RETURN	';'
		@{ @i @returnStatement.maxRegNum@ = FIRSTREGNUM - 1;
		   @t cgReturnStmt(@returnStatement.env@,DONTCARE,
		                   VOIDT,@RETURN.line@
		                  ); 
		@} 
exitStatement
	:	EXIT	expr	';'
		@{ @i @expr.regNum@ = FIRSTREGNUM;
		   @i @expr.formalMatch@ = lambdaSym;
		   @t cgExitStmt(@expr.regNum@,@expr.type@,@EXIT.line@); 
		@} 
	;

%% 
#include <stdio.h>

void yyyCheckForResizes();



main(argc,argv) 
  int argc;
  char *argv[];
  {int parseStatus;

   yyyCheckForResizes(argc,argv);
   scanSetup(); 
   semSetup(); 
   tempOut = safeOpen(tempOutID,"w"); 
   cgHeader();  
   parseStatus = yyparse();
   cgTrailer();  
   fclose(tempOut); 
   return(parseStatus || (doCodeGen == False)); 
  } 



@EOF
set `sum $sumopt <oxDistG1.04/gppl/gppl.Y.A`; if test $1 -ne 46064
then
	echo ERROR: oxDistG1.04/gppl/gppl.Y.A checksum is $1 should be 46064
fi
set `wc -lwc <oxDistG1.04/gppl/gppl.Y.A`
if test $1$2$3 != 781175620609
then
	echo ERROR: wc results of oxDistG1.04/gppl/gppl.Y.A are $* should be 781 1756 20609
fi

chmod 755 oxDistG1.04/gppl/gppl.Y.A

if test -f oxDistG1.04/gppl/util.c
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/util.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/util.c
	if test -f oxDistG1.04/gppl/util.c
	then
		echo Error: could not remove oxDistG1.04/gppl/util.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/util.c
cat >oxDistG1.04/gppl/util.c <<'@EOF'
/* $Header: util.c,v 1.7 93/11/09 19:16:58 bischoff Exp $ */ 
 
#include "glob.h"

extern int yylineno; 

void yyerror(cp) 
  char *cp; 
  {fprintf(stderr,"Syntax error near line %d: %s\n",yylineno,cp); 
   yyyerror(); 
  }  



void fatal(cp) 
  char *cp; 
  {fprintf(stderr,"Fatal error: %s\n",cp); 
   exit(-1); 
  }



void internal(s) 
  char *s; 
  {fprintf(stderr,"gppl/gc internal error: \n\t"); 
   fatal(s);
  }



void handleOverflow(cp) 
  char *cp;
  {internal(cp); 
  } 



FILE *safeOpen(name,mode) 
  char *name,*mode;  
  {FILE *dum; 
   if ((dum = fopen(name,mode)) 
       == 
       ((FILE *)NULL) 
      ) 
      {fprintf(stderr,"fatal error opening %s.\n",name); 
       exit(-1); 
      } 
      else 
      return dum; 
  } 



void printStringArray(arr,sizeofArr,fp) 
  char **arr; 
  int sizeofArr;
  FILE *fp;  
  {long i; 
   for (i=0;i<(sizeofArr/sizeof(char *));i++)  
       fprintf(fp,arr[i]); 
  } 



@EOF
set `sum $sumopt <oxDistG1.04/gppl/util.c`; if test $1 -ne 19210
then
	echo ERROR: oxDistG1.04/gppl/util.c checksum is $1 should be 19210
fi
set `wc -lwc <oxDistG1.04/gppl/util.c`
if test $1$2$3 != 6491936
then
	echo ERROR: wc results of oxDistG1.04/gppl/util.c are $* should be 64 91 936
fi

chmod 755 oxDistG1.04/gppl/util.c

if test -f oxDistG1.04/gppl/scan.c
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/scan.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/scan.c
	if test -f oxDistG1.04/gppl/scan.c
	then
		echo Error: could not remove oxDistG1.04/gppl/scan.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/scan.c
cat >oxDistG1.04/gppl/scan.c <<'@EOF'
/* $Header: scan.c,v 1.7 93/11/09 19:17:01 bischoff Exp $ */ 

#include <stdio.h> 
#include <limits.h> 
#include "glob.h"
#include "util.h"

extern int yylineno; 
#define DFAACCEPT 0 

 

void eatComment() 
  {char c; 
   int state = 1; 
   while (state != DFAACCEPT)  
     {c = yyinput();  
      switch (state)   
        {case 1: switch(c) 
                   {case '*' : state = 2; break;  
                    default : ;
                   } 
                 break;  
         case 2: switch(c) 
                   {case '*' : break;  
                    case '/' : state = DFAACCEPT; 
			       break;  
                    default  : state = 1;  
                   }
                 break; 
         default : ;   
        } 
     }  /* while */ 
  } 



#define strBufSize 512

char *copyLexemeOfSTRING() 
  {char c; 
   char *cp,*afterBuf,*temp;
   char buf[strBufSize]; 
   int state = 1; 

   cp = buf; 
   *cp++ = '\"';
   afterBuf = buf + strBufSize; 
   while (state != DFAACCEPT)  
     {*cp++ = c = yyinput();  
      if (cp == afterBuf) internal("string too long\n");  
      switch (state)   
        {case 1: switch(c) 
                   {case '\\' : state = 2; break;  
                    case '\"' : state = DFAACCEPT; break;  
                    default : ;  
                   }
                 break;  
         case 2: state = 1; 
                 break; 
         default : ;   
        } 
     }  /* while */
   if ((temp = (char *)malloc((size_t)(1 + cp - buf))) 
       == 
       ((char *)NULL)
      )
      internal("malloc error in string allocation\n");
   *cp = '\0';
   strcpy(temp,buf); 
   return temp; 
  } 



/* The size of the array of pointers to permanent null-terminated copies 
 * of lexemes of identifiers.  
 */  
int maxNstrings = 509;  


/* stringTable[i] is either (char *)NULL or a 
 * permanent null-terminated copy of the lexeme of an identifier. 
 */ 
static char **stringTable; 



/*  generates and returns a pointer to a permanent null-terminated copy 
 *  of the first len characters of the string cp.
 */  
static char *allocString(cp,len) 
  char *cp; 
  int len; 
  {char *ncp, *str_save; 
   if ((ncp = ((char *) malloc((size_t)(len+1)))) 
       == 
       ((char *) NULL) 
      )  
      internal("malloc error in allocString\n"); 
   str_save = ncp; 
   while (len--) 
         *ncp++ = *cp++; 
   *ncp = '\0';  
   return(str_save); 
  } 



/*  compute a hash value for a string */  
static long stringHash(cp,len) 
  char *cp; 
  int len; 
  {int hashval; 
   switch (hashval = len) 
     {default: hashval += cp[len - 2] * 512; 
      case 3:  hashval += cp[len - 1] * 64; 
      case 2:  hashval += cp[1] * 8; 
      case 1:  hashval += cp[0]; break;  
      case 0:  internal("can't seek the empty string\n"); 
     }
   return(hashval); 
  } 



/* Search the string table for a string matching the first len characters of
 * cp.  If it is absent and insertion is requested, try to insert it, returning
 * a pointer to a permanent null-terminated copy if successful, null pointer 
 * if unsuccessful (due to a full table).  If absent and insertion not 
 * requested, return null pointer.  If present, return pointer to the copy. 
 */  
char *stringLookup(cp,len,insertIfAbsent) 
  char *cp; 
  int len; 
  int insertIfAbsent; 
  {int i,try;  
   char **dum; 
   try = stringHash(cp,len) % maxNstrings; 
   for (i=0; i<maxNstrings; i++) 
       {dum = stringTable + try;  
        try = (try + 1) % maxNstrings;     
        if (*dum == (char *)NULL) 
           {if (insertIfAbsent) *dum = allocString(cp,len); 
            return(*dum); 
           } 
        if (strlen(*dum) != len) continue; /* don't match proper prefixes */ 
        if (!strncmp(*dum,cp,(size_t)len)) return(*dum); 
       } 
   handleOverflow("out of room in string table");  
  } 



void scanSetup() 
  {int i;

   if ((stringTable = (char **) malloc((size_t)(maxNstrings * sizeof(char *))))
       != 
       ((char **) NULL) 
      )   
      for (i=0; i<maxNstrings; i++) stringTable[i] = (char *)NULL; 
      else 
      internal("malloc error in string table allocation\n");  
  }


@EOF
set `sum $sumopt <oxDistG1.04/gppl/scan.c`; if test $1 -ne 20055
then
	echo ERROR: oxDistG1.04/gppl/scan.c checksum is $1 should be 20055
fi
set `wc -lwc <oxDistG1.04/gppl/scan.c`
if test $1$2$3 != 1675254153
then
	echo ERROR: wc results of oxDistG1.04/gppl/scan.c are $* should be 167 525 4153
fi

chmod 755 oxDistG1.04/gppl/scan.c

if test -f oxDistG1.04/gppl/sem.c
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/sem.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/sem.c
	if test -f oxDistG1.04/gppl/sem.c
	then
		echo Error: could not remove oxDistG1.04/gppl/sem.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/sem.c
cat >oxDistG1.04/gppl/sem.c <<'@EOF'
/* $Header: sem.c,v 1.7 93/11/09 19:17:04 bischoff Exp $ */

#include "glob.h" 
#include "y.tab.h"
#include "util.h"
#include "code.h"

static int symSpaceSize = 1000; 
       struct sym *symSpace; 
static struct sym *symStock,*afterSymSpace; 


static int envSpaceSize = 1000; 
       struct env *envSpace; 
static struct env *envStock,*afterEnvSpace; 

static int dimListSpaceSize = 1000; 
       struct dim *dimListSpace; 
static struct dim *dimListStock,*afterDimListSpace; 



void handleSemError() 
  {doCodeGen = False; 
  }



void semSetup() 
  {spaceSetup("symbol",struct sym,symSpace,
              symSpaceSize,3,afterSymSpace,symStock
             ) 

   spaceSetup("environment",struct env,envSpace,
              envSpaceSize,2,afterEnvSpace,envStock
             ) 

   spaceSetup("dimension list",struct dim,dimListSpace,
              dimListSpaceSize,2,afterDimListSpace,dimListStock
             ) 

   lambdaSym->next = lambdaSym;
   lambdaSym->dimList = lambdaDim;
   lambdaSym->paramLoc = lambdaSym;

   lambdaEnv->level = -1; 
   lambdaEnv->varLoc = lambdaSym;
   lambdaEnv->funcLoc = lambdaSym;
   lambdaEnv->outerEnv = lambdaEnv;  

   lambdaDim->next = lambdaDim;
  }
struct dim *consDimList(size,dimList,line)
  long size; 
  struct dim *dimList;
  lineNumType line;
  {struct dim *dum;
   if (size < 1) 
      {fprintf(stderr,
         "nonpositive dimension in array declaration near line %d.\n",line
              ); 
       handleSemError();
      }
   if ((dum = dimListStock++) == afterDimListSpace)
      handleOverflow("out of space for dimension lists\n"); 
   dum->size = size;
   dum->next = dimList;
   return dum; 
  }



static enum pred nameConflict(sym1,sym2)
  struct sym *sym1,*sym2; 
  {if (sym1->id == sym2->id) 
      {fprintf(stderr,
               "symbol %s multiply defined: lines %d and %d.\n",
               sym1->id,sym1->line,sym2->line
              );
       handleSemError();  
       return True; 
      }
      else 
      return False; 
  } 
      


static void *symDupCheck(loc1,loc2) 
  struct sym *loc1,*loc2; 
  {struct sym *dum;  
   while (loc1 != lambdaSym) 
     {dum = loc2;  
      while (dum != lambdaSym)
        {if (nameConflict(loc1,dum)) break; 
         dum = dum->next; 
        }
      loc1 = loc1->next;  
     }
  } 



/* returns the concatenation of two sequences of symbols, 
 * issuing an error message when there is a symbol E1 in
 * one sequence and a symbol E2 in the other sequence 
 * such that E1 and E2 have the same identifier. 
 * Tacks rightLoc onto the end of leftLoc and returns leftLoc. 
 */  
struct sym *concatLocs(leftLoc,rightLoc) 
  struct sym *leftLoc,*rightLoc; 
  {struct sym **prevLeftP;
   
   symDupCheck(rightLoc,leftLoc); 
   prevLeftP = &leftLoc;
   while (*prevLeftP != lambdaSym) prevLeftP = &((*prevLeftP)->next); 
   *prevLeftP = rightLoc; 
   return leftLoc; 
  } 



struct dim *cdrDimList(dimList,sym,line)
  struct dim *dimList;
  struct sym *sym;
  lineNumType line;
  {if (dimList == lambdaDim)
      {if (sym != lambdaSym) 
          fprintf(stderr,"extra index in line %d\'s reference to %s.\n",
                  line,sym->id
                 );
       handleSemError(); 
       return lambdaDim; 
      }
      else
      return dimList->next; 
  }



struct dim *adjustDimList(formalSym,actualSym,line) 
  struct sym *formalSym,*actualSym; 
  lineNumType line;
  {struct dim *formDL,*actDL;
   char *msg;

   if (formalSym == lambdaSym) return actualSym->dimList; 
   if (actualSym == lambdaSym) return lambdaDim;
   if (formalSym->type != actualSym->type) 
      {msg = "type mismatch.\n"; goto errD;}
   formDL = formalSym->dimList;
   actDL = actualSym->dimList;
   while (formDL != lambdaDim) 
     {if ((actDL == lambdaDim) || 
          (formDL->scale != actDL->scale) || 
          (formDL->size > actDL->size)
         )
         {msg = "incompatible dimensions.\n"; goto errD;}
      formDL = formDL->next; 
      actDL = actDL->next; 
     }
   return actDL;
errD:
   fprintf(stderr,
      "actual parameter %s matched to formal parameter %s\n  at line %d: %s", 
           actualSym->id,formalSym->id,line,msg
          ); 
   handleSemError(); 
   while (formDL != lambdaDim) {formDL = formDL->next; actDL = actDL->next;}
   return actDL;
  }



struct sym *cdrParamList(loc,func,line)
  struct sym *loc;
  struct sym *func;
  lineNumType line;
  {if ((loc == lambdaSym) || (loc->next == lambdaSym))
      {if (func != lambdaSym) 
          fprintf(stderr,"extra actual parameter in call to %s near line %d.\n",
                  func->id,line
                 );
       handleSemError(); 
      }
  if (loc == lambdaSym)
     return lambdaSym; 
     else
     return loc->next; 
  }



void paramMatchCheck(formParamList,exprType,isStgRef,isFirstExpr,func,line)
  struct sym *formParamList;
  enum symType exprType;
  enum pred isStgRef,isFirstExpr; 
  struct sym *func;
  lineNumType line;

  {enum pred mismatch = False;
   struct sym *symDum;

   if ((func == lambdaSym) || (formParamList == lambdaSym)) return;
   if (isFirstExpr)
      {symDum = formParamList;
       symDum = symDum->next;
       while (symDum != lambdaSym) 
         {fprintf(stderr,"missing actual parameter in line %d's call to %s.\n",
                         line,func->id
                 ); 
          handleSemError();
          mismatch = True;
          symDum = symDum->next;
         }
      }
   if (mismatch) return;
   if ((formParamList->Class == REFPARAMC) && !isStgRef)
      {fprintf(stderr,
       "actual parameter in call to %s near line %d is not a reference,\n\
   but matched to formal reference parameter %s.\n",
       func->id,line,formParamList->id 
              );
       handleSemError(); 
      }
   if (formParamList->type != exprType)
      {fprintf(stderr,
       "parameter type mismatch in call to %s near line %d: \n\
    formal parameter %s.\n",
       func->id,line,formParamList->id 
              );
       handleSemError(); 
      }
  }

 

static long scaleCalc(dimList,type)
  struct dim *dimList;
  enum symType type; 
  {long prevScale,prevSize,sizeOfEach;

   sizeOfEach = stgSize(type,1L); 
   prevScale = 1; 
   prevSize = 1;
   while (dimList != lambdaDim) 
     {dimList->scale = prevScale * prevSize;   
      prevScale = dimList->scale; 
      prevSize = dimList->size; 
      dimList->scale *= sizeOfEach;
      dimList = dimList->next; 
     } 
   return (prevScale * prevSize * sizeOfEach); 
  }



struct sym *newStgSym(lexeme,line,type,Class,dimList)
  char *lexeme; 
  lineNumType line;  
  enum symType type;
  enum stgClass Class; 
  struct dim *dimList;

  {struct sym *dum; 
   
   if (type == VOIDT) 
      {fprintf(stderr,"line %d: declared storage of type void for %s.\n",
               line,lexeme
              ); 
       handleSemError();
       type = INTT;
      }

   if ((dum = symStock++) == afterSymSpace)
      handleOverflow("out of space in symbol table\n"); 
   dum->id = lexeme; 
   dum->line = line; 
   dum->type = type; 
   dum->Class = Class; 
   dum->size = scaleCalc(dimList,dum->type); 
   if ((Class == VALPARAMC) && (dimList != lambdaDim))
      {fprintf(stderr,"array %s declared as value parameter at line %d.\n",
               lexeme,line
              ); 
       handleSemError();
      }
   if (Class == REFPARAMC) dum->size = stgSize(type,1L); 
   dum->dimList = dimList; 
   dum->next = lambdaSym; 
   return dum; 
  }
static long assignAddresses(loc)
  struct sym *loc; 
  {long size = 0;

   while (loc != lambdaSym) 
     {loc->addr = size; 
      size += loc->size,
      loc = loc->next; 
     } 
   return size;
  }



static void *assignLevel(loc,level)
  struct sym *loc; 
  levelType level;
  {while (loc != lambdaSym) 
     {loc->level = level; 
      loc = loc->next; 
     } 
  }



struct sym *newFuncSym(lexeme,line,type,label,paramLoc)
  char *lexeme; 
  lineNumType line;  
  enum symType type;
  labelType label;
  struct sym *paramLoc; 
  {struct sym *dum; 

   if ((dum = symStock++) == afterSymSpace)
      handleOverflow("out of space in symbol table\n"); 
   dum->id = lexeme; 
   dum->line = line; 
   dum->type = type; 
   dum->paramsSize = assignAddresses(paramLoc); 
   dum->label = label;
   dum->paramLoc = paramLoc; 
   dum->next = lambdaSym; 
   return dum; 
  }



struct env *newEnv(outerEnv,funcSym,varLoc,funcLoc,maxRegNum) 
  struct env *outerEnv; 
  struct sym *funcSym;
  struct sym *varLoc,*funcLoc;
  regNumType maxRegNum; 
  {struct env *innerEnv; 

   if ((innerEnv = envStock++) == afterEnvSpace)
      handleOverflow("out of space in environment table\n"); 
   symDupCheck(funcSym->paramLoc,varLoc); 
   symDupCheck(varLoc,funcLoc); 
   symDupCheck(funcSym->paramLoc,funcLoc); 
   innerEnv->funcSym = funcSym;
   innerEnv->level = outerEnv->level + 1; 
   assignLevel(funcSym->paramLoc,innerEnv->level);  
   assignLevel(varLoc,innerEnv->level);    
   assignLevel(funcLoc,innerEnv->level);   
   innerEnv->funcSym->paramLoc = funcSym->paramLoc; 
   innerEnv->varLoc =   varLoc; 
   innerEnv->funcLoc =  funcLoc; 
   innerEnv->nRegs = maxRegNum + 1;
   innerEnv->exitLabel = newLabelNum();
   innerEnv->varsSize = assignAddresses(varLoc);  
   innerEnv->outerEnv = outerEnv; 
   return innerEnv; 
  } 



struct sym *stgRefLookup(env,str,line)
  struct env *env; 
  char *str;
  lineNumType line;  
  {struct sym *dumSym; 

   while (env != lambdaEnv) 
     {dumSym = env->funcSym->paramLoc; 
      while ((dumSym != lambdaSym) && (dumSym->id != str))
        dumSym = dumSym->next; 
      if (dumSym != lambdaSym) return dumSym; 

      dumSym = env->varLoc; 
      while ((dumSym != lambdaSym) && (dumSym->id != str))
        dumSym = dumSym->next; 
      if (dumSym != lambdaSym) return dumSym; 

      env = env->outerEnv; 
     } 
   fprintf(stderr,"undeclared storage identifier %s at line %d.\n",
                  str,line
          );
   handleSemError(); 
   return lambdaSym; 
  }



struct sym *funcInvocLookup(env,str,line)
  struct env *env; 
  char *str;
  lineNumType line;  
  {struct sym *dumSym; 

   while (env != lambdaEnv) 
     {dumSym = env->funcLoc; 
      while ((dumSym != lambdaSym) && (dumSym->id != str))
        dumSym = dumSym->next; 
      if (dumSym != lambdaSym) return dumSym; 

      env = env->outerEnv; 
     } 
   fprintf(stderr,"undeclared function identifier %s at line %d.\n",
                  str,line
          );
   handleSemError(); 
   return lambdaSym; 
  }



static enum mapType inTypeOf(op) 
  int op;
  {switch (op) 
     {
      case '*':  
      case '+':  
      case '-':  
      case '/': 
      case LT:  
      case GT:  
      case EQ:  
      case LEQ:  
      case GEQ:  
      case NEQ: return ARITHM; 
      case NOT:
      case AND:  
      case OR: return LOGM; 
      default: internal("unknown operator 1\n"); 
     } 
  }



static enum mapType outTypeOf(op) 
  int op;
  {switch (op) 
     {
      case '*':  
      case '+':  
      case '-':  
      case '/': return ARITHM; 
      case LT:  
      case GT:  
      case EQ:  
      case LEQ:  
      case GEQ:  
      case NEQ:  
      case AND:  
      case OR:  
      case NOT: return LOGM; 
      default: internal("unknown operator 2\n"); 
     } 
  }



enum symType binOpTypeCheck(type1,type2,op,line) 
  enum symType type1,type2; 
  int op; 
  lineNumType line; 
  {if ((type1 == ERRT) || (type2 == ERRT)) return ERRT; 
   if (
       (type1 != type2) 
       || 
       (type1 == VOIDT)  
       || 
       ((inTypeOf(op) == ARITHM) != ((type1 == INTT) || (type1 == FLOATT)))
      ) 
      {fprintf(stderr,"binary operator type mismatch at line %d.\n",line);  
       handleSemError();  
       return ERRT;
      }
   return (outTypeOf(op) == ARITHM)?type1:BOOLT;
  } 



enum symType unrOpTypeCheck(type,op,line) 
  enum symType type; 
  int op; 
  lineNumType line; 
  {if (type == ERRT) return ERRT; 
   if (
       (type == VOIDT)  
       || 
       ((inTypeOf(op) == ARITHM) != ((type == INTT) || (type == FLOATT)))
      ) 
      {fprintf(stderr,"unary operator type mismatch at line %d.\n",line);  
       handleSemError();  
       return ERRT;
      }
   return (outTypeOf(op) == ARITHM)?type:BOOLT;
  } 



enum symType assignmentTypeCheck(type1,type2,line) 
  enum symType type1,type2; 
  lineNumType line; 
  {if ((type1 == ERRT) || (type2 == ERRT)) return ERRT; 
   if (type1 != type2) 
      {fprintf(stderr,
               "type mismatch in assignment at line %d.\n",line
              );
       handleSemError();  
       return ERRT;
      } 
   return type1; 
  }



@EOF
set `sum $sumopt <oxDistG1.04/gppl/sem.c`; if test $1 -ne 9423
then
	echo ERROR: oxDistG1.04/gppl/sem.c checksum is $1 should be 9423
fi
set `wc -lwc <oxDistG1.04/gppl/sem.c`
if test $1$2$3 != 521128812592
then
	echo ERROR: wc results of oxDistG1.04/gppl/sem.c are $* should be 521 1288 12592
fi

chmod 755 oxDistG1.04/gppl/sem.c

if test -f oxDistG1.04/gppl/code.c
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/code.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/code.c
	if test -f oxDistG1.04/gppl/code.c
	then
		echo Error: could not remove oxDistG1.04/gppl/code.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/code.c
cat >oxDistG1.04/gppl/code.c <<'@EOF'
/* $Header: code.c,v 1.7 93/11/09 19:17:16 bischoff Exp $ */

#include "glob.h"
#include "y.tab.h"
#include "util.h"

#define ALIGNSIZE   4
#define STACKSIZE1 1000000L
#define STACKSIZE  (ceiling(STACKSIZE1,ALIGNSIZE)) 

#define nFREGS 3 
#define RETREGADDR1   -2    /* relative to the callee's fp */
#define RETREGADDR2   -4    /* relative to sp upon return  */ 

/* RA, VA, PA are for calculations of frame-pointer-relative addresses */
#define RA(regNum)       (-(nFREGS + (regNum)))
#define VA(variableAddr) (-(nFREGS + dumEnv->nRegs + (variableAddr))) 
#define PA(paramAddr)    ((paramAddr) + 1 + 1)


enum pred doCodeGen = True;

FILE *tempOut; 



long stgSize(type,howMany) 
  enum symType type;  
  long howMany;
  {return(howMany);
  } 



static labelType labelSeq = 0; 
static labelType returnLabelSeq = 0; 



labelType newLabelNum() 
  {return (labelSeq++); 
  }



labelType newReturnLabelNum() 
  {return (returnLabelSeq++); 
  }

 

char *cHeaderCode[] =
{ 
"\n",
"#include <stdio.h>\n",
"\n",
"union stackItem {\n",
"   int i; \n",
"   float f;\n",
"   int b; \n",
"   int *ip;\n",
"   float *fp;\n",
"   int *bp; \n",
"   union stackItem *up;\n",
"  };\n",
"\n",
"\n",
"main()\n",
"{\n",
" register union stackItem *sp,*fp;\n",
"\n",
" if ((sp = (union stackItem *)malloc(STACKSIZE * sizeof(union stackItem)))\n",
"     ==\n",
"     ((union stackItem *)NULL)\n",
"    )\n",
"    fprintf(stderr,\"malloc error in stack allocation\\n\");\n",
" sp = sp + STACKSIZE;\n",
"\n",
}; 



void cgHeader() 
  {if (doCodeGen == False) return; 
   fprintf(tempOut,"#define STACKSIZE %d\n",STACKSIZE); 
   printStringArray(cHeaderCode,sizeof(cHeaderCode),tempOut); 
  }



void cgTrailer() 
  {long i;
   
   if (doCodeGen == False) return; 
   fprintf(tempOut,"\n\texit(0);\n");  
   fprintf(tempOut,"rts:\n");
   fprintf(tempOut,"  switch ((*(sp++)).i)  \n    {\n");
   for (i=0; i<returnLabelSeq; i++) 
       fprintf(tempOut,"     case %4d: goto r%d;\n",i,i); 
   fprintf(tempOut,"    } /* rts switch */ \n"); 
   fprintf(tempOut,"IOBtrap:\n"); 
   fprintf(tempOut,"\tfprintf(stderr,\"array index out of bounds.\\n\");\n"); 
   fprintf(tempOut,"\texit(-1);\n"); 
   fprintf(tempOut,"} /* main */ \n"); 
  }



void cgFuncCall(env,funcSym,regNum,isEmptyActList,line) 
  struct env *env; 
  struct sym *funcSym;
  regNumType regNum;
  enum pred isEmptyActList;
  lineNumType line;
  {int retLabel; 
   int staticDist,i;
   struct sym *dum;

   if ((doCodeGen == False) || (funcSym == lambdaSym)) return; 
   if (isEmptyActList)
      {dum = funcSym->paramLoc;
       while (dum != lambdaSym)
         {fprintf(stderr,"missing actual parameter in line %d's call to %s.\n",
                         line,funcSym->id
                 ); 
          handleSemError();
          dum = dum->next;
         }
      }
   staticDist = env->level - funcSym->level;
   retLabel = newReturnLabelNum(); 
   fprintf(tempOut,"\t(*--sp).i = %d;\n",retLabel);  
   fprintf(tempOut,"\t(*--sp).up = fp;\n");  
   for (i=0; i<staticDist; i++) 
       fprintf(tempOut,"\t*sp = *(*sp).up;\n");  
   fprintf(tempOut,"\tgoto f%d;\n",funcSym->label);  
   fprintf(tempOut,"r%d:\n",retLabel); 
   if (funcSym->type != VOIDT)
      fprintf(tempOut,"\tfp[%d] = sp[%d];\n",RA(regNum),RETREGADDR2); 
   fprintf(tempOut,"\tsp += %d;\n",funcSym->paramsSize);  
  }



void cgBlockEnter(env) 
  struct env *env; 
  {if (doCodeGen == False) return; 
   if (env != lambdaEnv) 
      {if (env->funcSym == lambdaSym) 
          fprintf(tempOut,"\t(*--sp).up = fp;\n"); 
       fprintf(tempOut,"\t(*--sp).up = fp;\n"); 
       fprintf(tempOut,"\tfp = sp + 1;\n"); 
       fprintf(tempOut,"\tsp -= %d;\n",
               1 + env->nRegs + env->varsSize 
              ); 
      }
  }



void cgBlockExit(env) 
  struct env *env; 
  {if (doCodeGen == False) return; 
   if (env == lambdaEnv) return;
   fprintf(tempOut,"BE%d:\tsp = fp;\n",env->exitLabel); 
   fprintf(tempOut,"\tfp = (*(sp++ - 1)).up;\n"); 
  }



void cgFuncAddress(sym) 
  struct sym *sym;
  {if (doCodeGen == False) return; 
   if (sym != lambdaSym) 
      {fprintf(tempOut,"\tgoto j%d;\n",sym->label); 
       fprintf(tempOut,"f%d:\t\t\t\t\t\t/* %s */\n",sym->label,sym->id); 
      }
  }



void cgFuncTrailer(sym) 
  struct sym *sym;
  {if (doCodeGen == False) return; 
   fprintf(tempOut,"\tgoto rts;\n",sym->label); 
   fprintf(tempOut,"j%d:\n",sym->label); 
  }



void cgBinArithExpr(destReg,op,type) 
  int destReg; 
  int op; 
  enum symType type; 
  {char *typeExt;  

   if (doCodeGen == False) return; 
   switch(type) 
     {case INTT:    typeExt = "i";  break;
      case FLOATT:  typeExt = "f";  break;
     }
   fprintf(tempOut,"\tfp[%d].%s %c= fp[%d].%s;\n",
           RA(destReg),
           typeExt,
           op,
           RA(destReg + 1),
           typeExt 
          );
  }



void cgRelExpr(destReg,op,type) 
  int destReg; 
  int op; 
  enum symType type; 
  {char *typeExt,*opStr;  
   labelType label;

   if (doCodeGen == False) return; 
   switch(type) 
     {case INTT:    typeExt = "i";  break;
      case FLOATT:  typeExt = "f";  break;
     }
   switch (op) 
     {case EQ:  opStr = "=="; break;
      case LEQ: opStr = "<="; break;
      case GEQ: opStr = ">="; break;
      case NEQ: opStr = "!="; break;
      case LT:  opStr = "<"; break;
      case GT:  opStr = ">"; break;
     } 
   label = newLabelNum(); 
   fprintf(tempOut,"\tif (fp[%d].%s %s fp[%d].%s) goto b%d;\n",
           RA(destReg),typeExt,opStr,
           RA(destReg + 1),typeExt,label
          );
   fprintf(tempOut,"\tfp[%d].i = 0;\n",RA(destReg)); 
   fprintf(tempOut,"\tgoto B%d;\n",label); 
   fprintf(tempOut,"b%d:\tfp[%d].i = 1;\n",label,RA(destReg)); 
   fprintf(tempOut,"B%d:\n",label); 
  }



void cgBinLogExpr(destReg,op) 
  int destReg; 
  int op; 
  {labelType label;
   char unrOp,rslt1,rslt2; 

   if (doCodeGen == False) return; 
   label = newLabelNum(); 
   switch(op)
     {case AND: unrOp = '!'; rslt1 = '1'; rslt2 = '0'; break;  
      case OR : unrOp = ' '; rslt1 = '0'; rslt2 = '1'; break;  
     }
   fprintf(tempOut,"\tif (%c(fp[%d].i)) goto b%d;\n",
           unrOp,RA(destReg),label
          );
   fprintf(tempOut,"\tif (%c(fp[%d].i)) goto b%d;\n",
           unrOp,RA(destReg + 1),label
          );
   fprintf(tempOut,"\tfp[%d].i = %c;\n",RA(destReg),rslt1); 
   fprintf(tempOut,"\tgoto B%d;\n",label); 
   fprintf(tempOut,"b%d:\tfp[%d].i = %c;\n",label,RA(destReg),rslt2); 
   fprintf(tempOut,"B%d:\n",label); 
  }



void cgUnrArithExpr(destReg,op,type) 
  int destReg; 
  int op; 
  enum symType type; 
  {char *typeExt;  

   if (doCodeGen == False) return; 
   if (op == '+') return; 
   switch(type) 
     {case INTT:    typeExt = "i";  break;
      case FLOATT:  typeExt = "f";  break;
     }
   fprintf(tempOut,"\tfp[%d].%s = -fp[%d].%s;\n",
           RA(destReg),typeExt,RA(destReg),typeExt 
          );
  }



void cgLogNegExpr(regNum) 
  int regNum;
  {labelType label;
   
   if (doCodeGen == False) return; 
   label = newLabelNum(); 
   fprintf(tempOut,"\tif ((fp[%d].i) == 0) goto b%d;\n",
           RA(regNum),label
          );
   fprintf(tempOut,"\tfp[%d].i = 0;\n",RA(regNum)); 
   fprintf(tempOut,"\tgoto B%d;\n",label); 
   fprintf(tempOut,"b%d:\tfp[%d].i = 1;\n",label,RA(regNum)); 
   fprintf(tempOut,"B%d:\n",label); 
  }



void cgEmptyIndexSeq(env,sym,line,regNum,dimList) 
  struct env *env;
  struct sym *sym;
  lineNumType line;
  int regNum;
  struct dim *dimList;
  {long addr; 
   int staticDist,i;
   struct env *dumEnv;
   
   if (doCodeGen == False) return; 
   if (sym == lambdaSym) return; 
   staticDist = env->level - sym->level;
   while (dimList != lambdaDim) 
      {fprintf(stderr,
               "missing index for line %d\'s reference to array %s.\n",
               line,sym->id
              ); 
       dimList = dimList->next;
       handleSemError();   
      }
   fprintf(tempOut,"\tfp[%d].up = fp;\n",RA(regNum)); 
   dumEnv = env; 
   for (i=0; i<staticDist; i++) 
       {dumEnv = dumEnv->outerEnv;
        fprintf(tempOut,"\tfp[%d] = *(fp[%d].up);\n",RA(regNum),RA(regNum)); 
       }
   addr = (sym->Class == VARIABLEC)?(VA(sym->addr)):(PA(sym->addr));
   fprintf(tempOut,"\tfp[%d].up += %d;\n",RA(regNum),addr); 
   if (sym->Class == REFPARAMC)
      fprintf(tempOut,"\tfp[%d] = *(fp[%d].up);\n",
                      RA(regNum),RA(regNum) 
             );
  }



void cgIndexSeq(sym,regNum,dimList) 
  struct sym *sym;
  int regNum;
  struct dim *dimList;
  {if (doCodeGen == False) return; 
   if (sym == lambdaSym) return; 
   fprintf(tempOut,"\tif (fp[%d].i < 0) goto IOBtrap;\n",
           RA(regNum + 1)
          ); 
   fprintf(tempOut,"\tif (fp[%d].i > %d) goto IOBtrap;\n",
           RA(regNum + 1),
           dimList->size - 1
          ); 
   fprintf(tempOut,"\tfp[%d].i *= %d;\n",RA(regNum + 1),dimList->scale); 
   fprintf(tempOut,"\tfp[%d].up -= fp[%d].i;\n",
           RA(regNum),RA(regNum + 1)
          ); 
  }



void cgConstSimpleExpr(regNum,type,value) 
  int regNum;
  enum symType type;
  union num value; 
  {if (doCodeGen == False) return; 
   switch(type)
     {case INTT:    
        fprintf(tempOut,"\tfp[%d].i = %d;\n",RA(regNum),value.i);  
        break;
      case FLOATT:  
        fprintf(tempOut,"\tfp[%d].f = %f;\n",RA(regNum),value.f);  
        break;
      case BOOLT:   
        fprintf(tempOut,"\tfp[%d].b = %d;\n",RA(regNum),value.b);  
        break;
     }
  }



void cgEOF(regNum) 
  int regNum;
  {if (doCodeGen == False) return; 
   fprintf(tempOut,"\tfp[%d].i = EOF;\n",RA(regNum));  
  }



void cgAssign(regNum,type) 
  int regNum;
  enum symType type; 
  {char *typeExt;
   
   if (doCodeGen == False) return; 
   switch(type) 
     {case INTT:    typeExt = "i";  break;
      case FLOATT:  typeExt = "f";  break;
      case BOOLT:   typeExt = "b";  break;
     }
   fprintf(tempOut,"\t*(fp[%d].%sp) = fp[%d].%s;\n",
           RA(regNum),typeExt,RA(regNum + 1),typeExt
          ); 
   fprintf(tempOut,"\tfp[%d].%s = fp[%d].%s;\n",
           RA(regNum),typeExt,RA(regNum + 1),typeExt
          ); 
  }



void cgPush(regNum) 
  int regNum;
  {if (doCodeGen == False) return; 
   fprintf(tempOut,"\t*--sp = fp[%d];\n",RA(regNum));  
  }



void cgCondDeref(formal,regNum,type) 
  struct sym *formal;
  int regNum;
  enum symType type; 
  {char *typeExt;

   if (doCodeGen == False) return; 
   if ((formal != lambdaSym) && (formal->Class == REFPARAMC)) return;
   switch(type) 
     {case INTT:    typeExt = "i";  break;
      case FLOATT:  typeExt = "f";  break;
      case BOOLT:   typeExt = "b";  break;
     }
   fprintf(tempOut,"\tfp[%d].%s = *(fp[%d].%sp);\n",
           RA(regNum),typeExt,
           RA(regNum),typeExt
          ); 
  }



void cgCast(regNum,newType,oldType) 
  int regNum;
  enum symType newType,oldType; 
  {char *ext1,*ext2,*cCast;
  
   if (doCodeGen == False) return; 
   switch(newType) 
     {case INTT:    ext1 = "i"; cCast = "(int)"; break; 
      case FLOATT:  ext1 = "f"; cCast = "(float)"; break; 
      case BOOLT:   ext1 = "b"; cCast = "(int)"; break; 
     }
   switch(oldType) 
     {case INTT:    ext2 = "i";  break;
      case FLOATT:  ext2 = "f";  break;
      case BOOLT:   ext2 = "b";  break;
     }
   fprintf(tempOut,"\tfp[%d].%s = %sfp[%d].%s;\n",
           RA(regNum),ext1,cCast,RA(regNum),ext2
          );
  }



void cgOutputNoArg(str,regNum) 
  char *str;
  regNumType regNum; 
  {if (doCodeGen == False) return; 
   fprintf(tempOut,"\tfp[%d].i = printf(%s);\n",RA(regNum),str);
    /*  fprintf(tempOut,"\tfflush(stdout);\n"); */
  }



void cgOutputOneArg(str,regNum,type) 
  char *str; 
  int regNum;
  enum symType type; 
  {if (doCodeGen == False) return; 
   switch(type) 
     {case INTT: 
        fprintf(tempOut,"\tfp[%d].i = printf(%s,fp[%d].i);\n",
                RA(regNum),str,RA(regNum));
        break;
      case FLOATT:    
        fprintf(tempOut,
                "\tfp[%d].i = printf(%s,fp[%d].f);\n",
                RA(regNum),str,RA(regNum)
               );
        break;
      case BOOLT:   
        fprintf(tempOut,
          "\tfp[%d].i = printf(%s,(*(fp[%d].b)?\"true\":\"false\"));\n",
                RA(regNum),str,RA(regNum)
               );
        break;
     }
   /*  fprintf(tempOut,"\tfflush(stdout);\n"); */
  }



void cgInput(str,regNum,type,line) 
  char *str; 
  int regNum;
  enum symType type; 
  lineNumType line;
  {if (doCodeGen == False) return; 
   fprintf(tempOut,"\tfp[%d].i = ",RA(regNum));
   switch(type) 
     {case INTT: 
        fprintf(tempOut,"scanf(%s,fp[%d].ip);\n",
                str,RA(regNum));
        break;
      case FLOATT:    
        fprintf(tempOut,"scanf(%s,fp[%d].fp);\n",
                str,RA(regNum));
        break;
      case BOOLT:   
        fprintf(stderr,"attempted input of boolean near line %d.\n",line); 
        handleSemError(); 
        break;
     }
  }



static void condCheck(type,line)
  enum symType type; 
  lineNumType line;
  {if (type != BOOLT) 
      {fprintf(stderr,
   "non-boolean expression as condition in control statement near line %d.\n",
               line
              );
       handleSemError();  
      } 
  } 



void cgIfThen(type,line,label) 
  enum symType type; 
  lineNumType line;
  labelType label;
  {condCheck(type,line); 
   if (doCodeGen == False) return; 
   fprintf(tempOut,"e%d:\n",label); 
  }



void cgIfThenElse(type,line,label) 
  enum symType type; 
  lineNumType line;
  labelType label;
  {condCheck(type,line); 
   if (doCodeGen == False) return; 
   fprintf(tempOut,"i%d:\n",label); 
  }



void cgThen(regNum,label) 
  int regNum;
  labelType label;
  {if (doCodeGen == False) return; 
   fprintf(tempOut,"\tif (!(fp[%d].i)) goto e%d;\n",RA(regNum),label); 
  }



void cgElse(label) 
  labelType label;
  {if (doCodeGen == False) return; 
        fprintf(tempOut,"kl%d:\tgoto i%d;\n",label,label); 
        fprintf(tempOut,"e%d:\n",label); 
   /* labels prefixed by kl are kludges to silence the C compiler's
    *   "statement not reached" warnings when the then clause ends
    *   with a return statement.
    */
  }



void cgWdecision(regNum,label) 
  int regNum;
  labelType label;
  {if (doCodeGen == False) return; 
   fprintf(tempOut,"\tif (!(fp[%d].i)) goto W%d;\n",RA(regNum),label); 
  }



void cgWhileStatement(type,line,label) 
  enum symType type; 
  lineNumType line;
  labelType label;
  {condCheck(type,line); 
   if (doCodeGen == False) return; 
   fprintf(tempOut,"\tgoto w%d;\n",label); 
   fprintf(tempOut,"W%d:\n",label); 
  }



void cgWhile(label) 
  labelType label;
  {if (doCodeGen == False) return; 
   fprintf(tempOut,"w%d:\n",label); 
  }



void cgReturnStmt(env,regNum,type,line) 
  struct env *env;
  regNumType regNum;
  enum symType type; 
  lineNumType line; 

  {if (doCodeGen == False) goto err; 
   if (type != VOIDT) 
      fprintf(tempOut,"\tfp[%d] = fp[%d];\n",RETREGADDR1,RA(regNum)); 
   while (env->funcSym == lambdaSym) 
     {fprintf(tempOut,"\tsp = fp;\n"); 
      fprintf(tempOut,"\tfp = (*fp).up;\n"); 
      if (type != VOIDT) 
         fprintf(tempOut,"\tfp[%d] = sp[%d];\n",RETREGADDR1,RETREGADDR1); 
      if ((env = env->outerEnv) == lambdaEnv)
         {fprintf(stderr,"line %d: return from no function.\n",line); 
          goto err; 
         }
     }
   if (env->funcSym->type != VOIDT)  
      {if (type == VOIDT)
          {fprintf(stderr,
           "line %d: missing object of return in non-void function %s.\n",
                   line,env->funcSym->id 
                  ); 
           goto err; 
          }
       if (env->funcSym->type != type) 
          {fprintf(stderr,
           "line %d: mismatched type of object returned from function %s.\n",
                  line,env->funcSym->id 
                 ); 
           goto err; 
          }
      }
      else
      {if (type != VOIDT)
          {fprintf(stderr,"line %d: object returned by void function %s.\n",
                   line,env->funcSym->id 
                  ); 
           goto err; 
          }
      }
   fprintf(tempOut,"\tgoto BE%d;\n",env->exitLabel); 
   return;
err:
   handleSemError(); 
   return;
  }



void cgExitStmt(regNum,type,line) 
  regNumType regNum;
  enum symType type; 
  lineNumType line; 
  {if (doCodeGen == False) return; 
   if (type != INTT) 
      {fprintf(stderr,"line %d: non-integer object of exit statement.\n",
               line
              );
       handleSemError();
       return;
      }
   fprintf(tempOut,"\texit(fp[%d].i);\n",RA(regNum)); 
  }



@EOF
set `sum $sumopt <oxDistG1.04/gppl/code.c`; if test $1 -ne 27178
then
	echo ERROR: oxDistG1.04/gppl/code.c checksum is $1 should be 27178
fi
set `wc -lwc <oxDistG1.04/gppl/code.c`
if test $1$2$3 != 685153616539
then
	echo ERROR: wc results of oxDistG1.04/gppl/code.c are $* should be 685 1536 16539
fi

chmod 755 oxDistG1.04/gppl/code.c

if test -f oxDistG1.04/gppl/gppl.ps
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gppl.ps\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gppl.ps
	if test -f oxDistG1.04/gppl/gppl.ps
	then
		echo Error: could not remove oxDistG1.04/gppl/gppl.ps, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gppl.ps
cat >oxDistG1.04/gppl/gppl.ps <<'@EOF'
%!PS-Adobe-2.0
%%Creator: dvips 5.480 Copyright 1986-92 Radical Eye Software
%%Title: gppl.dvi
%%Pages: 32 1
%%BoundingBox: 0 0 612 792
%%EndComments
%DVIPSCommandLine: dvips gppl.dvi
%%BeginProcSet: tex.pro
/TeXDict 250 dict def TeXDict begin /N{def}def /B{bind def}N /S{exch}N /X{S N}
B /TR{translate}N /isls false N /vsize 11 72 mul N /@rigin{isls{[0 -1 1 0 0 0]
concat}if 72 Resolution div 72 VResolution div neg scale isls{Resolution hsize
-72 div mul 0 TR}if Resolution VResolution vsize -72 div 1 add mul TR matrix
currentmatrix dup dup 4 get round 4 exch put dup dup 5 get round 5 exch put
setmatrix}N /@landscape{/isls true N}B /@manualfeed{statusdict /manualfeed
true put}B /@copies{/#copies X}B /FMat[1 0 0 -1 0 0]N /FBB[0 0 0 0]N /nn 0 N
/IE 0 N /ctr 0 N /df-tail{/nn 8 dict N nn begin /FontType 3 N /FontMatrix
fntrx N /FontBBox FBB N string /base X array /BitMaps X /BuildChar{
CharBuilder}N /Encoding IE N end dup{/foo setfont}2 array copy cvx N load 0 nn
put /ctr 0 N[}B /df{/sf 1 N /fntrx FMat N df-tail}B /dfs{div /sf X /fntrx[sf 0
0 sf neg 0 0]N df-tail}B /E{pop nn dup definefont setfont}B /ch-width{ch-data
dup length 5 sub get}B /ch-height{ch-data dup length 4 sub get}B /ch-xoff{128
ch-data dup length 3 sub get sub}B /ch-yoff{ch-data dup length 2 sub get 127
sub}B /ch-dx{ch-data dup length 1 sub get}B /ch-image{ch-data dup type
/stringtype ne{ctr get /ctr ctr 1 add N}if}B /id 0 N /rw 0 N /rc 0 N /gp 0 N
/cp 0 N /G 0 N /sf 0 N /CharBuilder{save 3 1 roll S dup /base get 2 index get
S /BitMaps get S get /ch-data X pop /ctr 0 N ch-dx 0 ch-xoff ch-yoff ch-height
sub ch-xoff ch-width add ch-yoff setcachedevice ch-width ch-height true[1 0 0
-1 -.1 ch-xoff sub ch-yoff .1 add]{ch-image}imagemask restore}B /D{/cc X dup
type /stringtype ne{]}if nn /base get cc ctr put nn /BitMaps get S ctr S sf 1
ne{dup dup length 1 sub dup 2 index S get sf div put}if put /ctr ctr 1 add N}
B /I{cc 1 add D}B /bop{userdict /bop-hook known{bop-hook}if /SI save N @rigin
0 0 moveto}N /eop{SI restore showpage userdict /eop-hook known{eop-hook}if}N
/@start{userdict /start-hook known{start-hook}if /VResolution X /Resolution X
1000 div /DVImag X /IE 256 array N 0 1 255{IE S 1 string dup 0 3 index put cvn
put}for 65781.76 div /vsize X 65781.76 div /hsize X}N /p{show}N /RMat[1 0 0 -1
0 0]N /BDot 260 string N /rulex 0 N /ruley 0 N /v{/ruley X /rulex X V}B /V
statusdict begin /product where{pop product dup length 7 ge{0 7 getinterval
(Display)eq}{pop false}ifelse}{false}ifelse end{{gsave TR -.1 -.1 TR 1 1 scale
rulex ruley false RMat{BDot}imagemask grestore}}{{gsave TR -.1 -.1 TR rulex
ruley scale 1 1 false RMat{BDot}imagemask grestore}}ifelse B /a{moveto}B
/delta 0 N /tail{dup /delta X 0 rmoveto}B /M{S p delta add tail}B /b{S p tail}
B /c{-4 M}B /d{-3 M}B /e{-2 M}B /f{-1 M}B /g{0 M}B /h{1 M}B /i{2 M}B /j{3 M}B
/k{4 M}B /w{0 rmoveto}B /l{p -4 w}B /m{p -3 w}B /n{p -2 w}B /o{p -1 w}B /q{p 1
w}B /r{p 2 w}B /s{p 3 w}B /t{p 4 w}B /x{0 S rmoveto}B /y{3 2 roll p a}B /bos{
/SS save N}B /eos{SS restore}B end
%%EndProcSet
TeXDict begin 40258431 52099146 1000 300 300 @start /Fa 3 119
df<007F0001FFC007FFE00FFFF01FC1F83F007C3E007C7C003C78003EF8001EFFFFFEFFFFFEFF
FFFEFFFFFEF00000F80000F800007800007C001E3E001E3F803E1FF07C0FFFF807FFF001FFE000
7F80171A7D991F>101 D<FF87E000FF9FF000FFBFF800FFFFFC0007F87E0007E03E0007E01E00
07C01E0007C01E0007801E0007801E0007801E0007801E0007801E0007801E0007801E0007801E
0007801E0007801E0007801E0007801E0007801E00FFFC7FF0FFFC7FF0FFFC7FF0FFFC7FF01C1A
7F991F>110 D<7FE07FE0FFF0FFF0FFF0FFF07FE07FE007000E0007000E0007801E0003801C00
03801C0003C03C0001C0380001C0380001E0780000E0700000E0700000E070000070E0000070E0
000070E0000039C0000039C0000039C000001F8000001F8000001F8000000F00001C1A7F991F>
118 D E /Fb 1 49 df<060F0F0E1E1E1C3C383830707060E0C04008117F910A>48
D E /Fc 1 82 df<FFFFFFFFC0FFFFFFFFC01F00003E000F00003C000F00003C000F00003C000F
00003C000F00003C000F00003C000F00003C000F00003C000F00003C000F00003C000F00003C00
0F00003C000F00003C000F00003C000F00003C000F00003C000F00003C000F00003C000F00003C
000F00003C000F00003C000F00003C000F00003C000F00003C000F00003C000F00003C000F0000
3C000F00003C000F00003C000F00003C000F00003C000F00003C000F00003C000F00003C000F00
003C000F00003C001F80007E00FFF003FFC0FFF003FFC0222A7E7F27>81
D E /Fd 5 62 df<00300000300000300000300000300000300000300000300000300000300000
3000FFFFFCFFFFFC00300000300000300000300000300000300000300000300000300000300000
300016187E931B>43 D<07C018303018701C600C600CE00EE00EE00EE00EE00EE00EE00EE00EE0
0E600C600C701C30181C7007C00F157F9412>48 D<03000700FF00070007000700070007000700
070007000700070007000700070007000700070007007FF00C157E9412>I<0F8030E040708030
C038E0384038003800700070006000C00180030006000C08080810183FF07FF0FFF00D157E9412
>I<FFFFFCFFFFFC000000000000000000000000000000000000FFFFFCFFFFFC160A7E8C1B>61
D E /Fe 4 111 df<0300038003000000000000000000000000001C002400460046008C000C00
18001800180031003100320032001C0009177F960C>105 D<0018003800100000000000000000
0000000001C0022004300430086000600060006000C000C000C000C001800180018001806300E3
00C60078000D1D80960E>I<1F0006000600060006000C000C000C000C00181C1866188E190C32
003C003F00318060C060C460C460C8C0C8C0700F177E9612>I<383C0044C6004702004602008E
06000C06000C06000C0C00180C00180C40181840181880300880300F00120E7F8D15>110
D E /Ff 5 104 df<70F8F8F87005057C8E0E>1 D<03F0000FFC001FFE003FFF007FFF807FFF80
FFFFC0FFFFC0FFFFC0FFFFC0FFFFC0FFFFC0FFFFC0FFFFC07FFF807FFF803FFF001FFE000FFC00
03F00012147D9519>15 D<0000000C0000003C000000F0000003C000000F0000003C000000F000
0007C000001F00000078000001E00000078000001E00000078000000E0000000780000001E0000
000780000001E0000000780000001F00000007C0000000F00000003C0000000F00000003C00000
00F00000003C0000000C0000000000000000000000000000000000000000000000000000000000
000000FFFFFFFCFFFFFFFC1E277C9F27>20 D<000F0038007000E001C001C001C001C001C001C0
01C001C001C001C001C001C001C001C001C001C001C0038007001E00F0001E000700038001C001
C001C001C001C001C001C001C001C001C001C001C001C001C001C001C001C000E000700038000F
10317CA419>102 D<F0001E000700038001C001C001C001C001C001C001C001C001C001C001C0
01C001C001C001C001C001C000E000700038000F0038007000E001C001C001C001C001C001C001
C001C001C001C001C001C001C001C001C001C001C0038007001E00F00010317CA419>I
E /Fg 45 124 df<00000FE0000030180000E01C0001C03C0001803C0003803800038000000380
000007000000070000000700000007000000070000000E000000FFFFE0000E00E0000E00E0000E
01C0001C01C0001C01C0001C01C0001C0380001C03800038038000380380003807000038070000
3807000070070800700E1000700E1000700E1000700E2000E0062000E003C000E0000000E00000
00C0000001C0000001C0000071800000F1800000F3000000620000003C0000001E2D82A21B>12
D<0C1E3F3F1D02020204040810204080080F75A20F>39 D<0E1E1E1E1E02020404080810204080
070F7D840F>44 D<FFF0FFF0FFE00C037C8B11>I<07000F800F800F000E000000000000000000
00000000000000000000000000007000F800F800F000E00009157A940F>58
D<0000030000000300000007000000070000000F0000000F0000001F0000002F0000002F000000
4F0000004F80000087800000878000010780000207800002078000040780000407800008078000
080780001007800030078000200780007FFF80004007C0008007C0008003C0010003C0030003C0
020003C0040003C0040003C00C0003C03C0007C0FF003FFC1E237DA224>65
D<00FFFFE0000F0038000F001C000F001E001E000E001E000F001E000F001E000F003C000E003C
001E003C001E003C003C00780078007800F0007801E00078078000FFFF8000F001E000F000F000
F0007801E0007801E0003801E0003C01E0003C03C0007803C0007803C0007803C000F0078000F0
078001E0078003C0078007000F801E00FFFFF00020227DA122>I<00007F00800003808100000E
00630000380027000070001F0000E0000E0001C0000E000380000E000700000E000F000004000E
000004001E000004003C000004003C00000800780000000078000000007800000000F000000000
F000000000F000000000F000000000F000000000E000000000E000002000E000002000E0000040
00E000004000F00000800070000080007000010000380002000018000400001C00080000060030
00000381C0000000FE000000212479A223>I<00007F00800003808100000E0063000038002700
0070001F0000E0000E0001C0000E000380000E000700000E000F000004000E000004001E000004
003C000004003C00000800780000000078000000007800000000F000000000F000000000F00000
0000F000000000F0003FFC00E00001E000E00001E000E00001E000E00003C000E00003C000F000
03C000700003C0007000078000380007800018000F80001C0013800006002300000381C1000000
FE000000212479A226>71 D<00FFF8000F00000F00000F00001E00001E00001E00001E00003C00
003C00003C00003C0000780000780000780000780000F00000F00000F00000F00001E00001E000
01E00001E00003C00003C00003C00003C0000780000780000780000780000F8000FFF80015227D
A113>73 D<00FFFC00000F8000000F0000000F0000001E0000001E0000001E0000001E0000003C
0000003C0000003C0000003C00000078000000780000007800000078000000F0000000F0000000
F0000000F0000001E0000001E0000001E0002001E0002003C0004003C0004003C0008003C00080
07800180078001000780030007800F000F803E00FFFFFE001B227DA11F>76
D<00FF800007FC000F80000F80000F80001780000F80001780001780002F000013C0002F000013
C0004F000013C0008F000023C0009E000023C0011E000023C0011E000023C0021E000043C0043C
000043C0043C000043C0083C000041E0083C000081E01078000081E02078000081E02078000081
E04078000101E040F0000101E080F0000101E100F0000101E100F0000200F201E0000200F201E0
000200F401E0000200F801E0000400F803C0000400F003C0000400F003C0000C00E003C0001E00
C007C000FFC0C07FFC002E227DA12C>I<00FF000FFC000F8001E0000F800180000FC000800013
C001000013C001000011E001000011E001000021E002000020F002000020F002000020F0020000
407804000040780400004078040000403C040000803C080000803E080000801E080000801E0800
01001F100001000F100001000F10000100079000020007A000020007A000020003E000020003E0
00040003C000040001C000040001C0000C0001C0001E00008000FFC000800026227DA124>I<00
00FE0000078380000C00E0003800700070003800E0003801C0001C0380001C0700001C0F00001E
1E00001E1C00001E3C00001E3C00001E7800001E7800001E7800001EF000003CF000003CF00000
3CF0000078F0000078E0000078E00000F0E00000F0E00001E0E00001C0F00003C0F00007807000
070078000E0038001C001C0038000E00E0000703800001FC00001F2479A225>I<00FFFFE0000F
0038000F001E000F000E001E0007001E0007001E0007001E0007003C000F003C000F003C000F00
3C001E0078001E0078003C00780078007800E000F003C000FFFE0000F0000000F0000001E00000
01E0000001E0000001E0000003C0000003C0000003C0000003C000000780000007800000078000
00078000000F800000FFF8000020227DA121>I<0001F020000E0C40001802C0003001C0006001
C000E0018000C0018001C0018001C0018003C0010003C0010003C0000003C0000003E0000001F8
000001FF000000FFE000007FF000001FF8000003FC0000007C0000003C0000001E0000001E0000
001E0020001C0020001C0020001C00200018006000380060003000700060007000C000C8018000
C607000081FC00001B247DA21B>83 D<3FFE03FF03C0007803C0006003C0002007800040078000
4007800040078000400F0000800F0000800F0000800F0000801E0001001E0001001E0001001E00
01003C0002003C0002003C0002003C0002007800040078000400780004007800040070000800F0
000800F00010007000100070002000700040003000400038018000180200000E0C000003F00000
202377A124>85 D<FFF001FF1F8000780F0000600F0000600F0000400F0000800F0000800F0001
000F0003000F0002000F8004000F80040007800800078008000780100007802000078020000780
400007804000078080000781000007C1000003C2000003C2000003C4000003C8000003C8000003
D0000003D0000003E0000003C0000003C00000038000000180000001000000202376A124>I<00
7FF81FF8000FC007C000078003000007C002000003C004000003C008000003E010000001E03000
0001E020000001F040000000F080000000F100000000FA000000007C000000007C000000007C00
0000003C000000003C000000007E000000009E000000011E000000031F000000060F000000040F
000000080F80000010078000002007C000004007C00000C003C000018003E000010001E0000700
01E0001F0003F000FFC01FFE0025227EA124>88 D<FFF001FF1F8000780F0000600F0000400F80
00C0078000800780010007C0020003C0060003C0040003E0080001E0100001E0200001F0600000
F0400000F0800000F9000000FB0000007A0000007C000000780000007800000078000000780000
00F0000000F0000000F0000000F0000001E0000001E0000001E0000001E0000003E000003FFC00
00202276A124>I<00F8C00185C00705C00E03800E03801C03803C038038070078070078070078
0700F00E00F00E00F00E00F00E10F01C20701C20703C20305C40308C400F078014157B9419>97
D<03C03F8003800380038007000700070007000E000E000E000E001C001CF81D0C1E0E3C063807
3807380F700F700F700F700FE01EE01EE01EE03CE038E038607060E031C01F0010237BA216>I<
007E0001C1000301800703800E07801C07803C0000380000780000780000780000F00000F00000
F00000F00000F00100700100700200300C001830000FC00011157B9416>I<00003C0003F80000
380000380000380000700000700000700000700000E00000E00000E00000E00001C000F9C00185
C00705C00E03800E03801C03803C0380380700780700780700780700F00E00F00E00F00E00F00E
10F01C20701C20703C20305C40308C400F078016237BA219>I<00F803840E021C023C02380278
04F018FFE0F000F000E000E000E000E000E002E0026004701830600F800F157A9416>I<00003E
0000470000CF00018F000186000380000380000380000700000700000700000700000700000E00
00FFF0000E00000E00000E00001C00001C00001C00001C00001C00003800003800003800003800
00380000700000700000700000700000700000E00000E00000E00000E00000C00001C00001C000
718000F18000F300006200003C0000182D82A20F>I<001F180030B800E0B801C07001C0700380
700780700700E00F00E00F00E00F00E01E01C01E01C01E01C01E01C01E03800E03800E0780060B
8006170001E700000700000700000E00000E00000E00701C00F01800F0300060E0003F8000151F
7E9416>I<00F0000FE00000E00000E00000E00001C00001C00001C00001C00003800003800003
8000038000070000071F0007218007C0C00F00E00F00E00E00E00E00E01C01C01C01C01C01C01C
01C0380380380380380380380704700708700E08700E10700610E006206003C016237DA219>I<
00C001E001C001C0000000000000000000000000000000001C002300430043008700870087000E
000E001C001C001C00380038003840708070807080710032001C000B217BA00F>I<00F0000FE0
0000E00000E00000E00001C00001C00001C00001C0000380000380000380000380000700000701
E0070210070C700E10F00E10F00E20600E40001D80001E00001FC0001C7000383800383800381C
00381C20703840703840703840701880E01880600F0014237DA216>107
D<01E01FC001C001C001C0038003800380038007000700070007000E000E000E000E001C001C00
1C001C0038003800380038007000700070007100E200E200E200E200640038000B237CA20C>I<
1C0F80F8002610C10C00476066060087807807008780780700870070070087007007000E00E00E
000E00E00E000E00E00E000E00E00E001C01C01C001C01C01C001C01C01C001C01C03820380380
384038038070403803807080380380308070070031003003001E0023157B9428>I<1C0F002631
C04740C08780E08780E08700E08700E00E01C00E01C00E01C00E01C01C03801C03801C03801C07
04380708380E08380E103806107006203003C016157B941B>I<007E0001C3000381800701C00E
01C01C01E03C01E03801E07801E07801E07801E0F003C0F003C0F00380F00780700700700E0070
0C0030180018700007C00013157B9419>I<01C1F002621804741C08780C08700E08700E08701E
00E01E00E01E00E01E00E01E01C03C01C03C01C03C01C07803807003807003C0E003C1C0072380
071E000700000700000E00000E00000E00000E00001C00001C00001C0000FFC000171F7F9419>
I<1C1F002620804741C08783C08703C08701808700000E00000E00000E00000E00001C00001C00
001C00001C000038000038000038000038000070000030000012157B9415>114
D<00FC000183000200800401800C03800C03000C00000F00000FF00007FC0003FE00003E00000F
00000700700700F00600F00600E004004008002030001FC00011157D9414>I<00C001C001C001
C001C003800380038003800700FFF8070007000E000E000E000E001C001C001C001C0038003800
38003810702070207040708031001E000D1F7C9E10>I<1E00602300E04380E04381C08381C087
01C08701C00703800E03800E03800E03801C07001C07001C07001C07081C0E10180E101C0E101C
1E200C262007C3C015157B941A>I<1E03802307C04387C04383C08381C08700C08700C0070080
0E00800E00800E00801C01001C01001C01001C02001C02001C04001C08001C08000C300003C000
12157B9416>I<1E0060E02300E1F04380E1F04381C0F08381C0708701C0308701C03007038020
0E0380200E0380200E0380201C0700401C0700401C0700401C0700801C0700801C0701001C0F01
000C0F020006138C0003E0F0001C157B9420>I<03C1E0046210083470103CF02038F020386020
380000700000700000700000700000E00000E00000E00000E02061C040F1C040F1C080E2C10044
6200383C0014157D9416>I<1E00302300704380704380E08380E08700E08700E00701C00E01C0
0E01C00E01C01C03801C03801C03801C03801C07001C07001C07001C0F000C3E0003CE00000E00
000E00001C00601C00F03800F03000E0600080C0004380003E0000141F7B9418>I<01E02003F0
6007F8C0041F800801000802000004000008000010000020000040000080000100000200000400
800801001003003F060061FC0040F80080700013157D9414>I<FFFFFC16017C8C19>I
E /Fh 53 122 df<0001FF0000001FFFC000007F80F00000FE00F80003FC01FC0003F803FC0007
F003FC0007F003FC0007F003FC0007F001F80007F000F00007F000000007F000000007F0000000
07F0000000FFFFFFFC00FFFFFFFC00FFFFFFFC0007F001FC0007F001FC0007F001FC0007F001FC
0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001
FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F0
01FC0007F001FC007FFF1FFFC07FFF1FFFC07FFF1FFFC0222A7FA926>12
D<1C007F00FF80FF80FFC0FFC0FFC07FC01CC000C000C001C0018001800380070006000E001C00
380030000A157BA913>39 D<1C007F00FF80FF80FFC0FFC0FFC07FC01CC000C000C001C0018001
800380070006000E001C00380030000A157B8813>44 D<FFFF80FFFF80FFFF80FFFF80FFFF80FF
FF8011067F9017>I<1C007F00FF80FF80FF80FF80FF807F001C0009097B8813>I<003F800001FF
F00007E0FC000FC07E001F803F001F803F003F001F803F001F807F001FC07F001FC07F001FC07F
001FC0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0
FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE07F001FC07F001FC07F001FC07F001F
C03F001F803F001F801F803F001F803F000FC07E0007E0FC0001FFF000003F80001B277DA622>
48 D<000E00001E00007E0007FE00FFFE00FFFE00F8FE0000FE0000FE0000FE0000FE0000FE00
00FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE00
00FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE007FFFFE7FFFFE
7FFFFE17277BA622>I<00FF800003FFF0000FFFFC003F03FF007C00FF807C007FC0FE007FC0FF
003FE0FF003FE0FF003FE0FF001FE07E001FE03C003FE000003FE000003FC000003FC000007F80
00007F800000FF000001FE000001FC000003F0000007E000000FC000001F0000003E0000007C00
E0007800E000F000E001E001C0038001C0070001C00FFFFFC01FFFFFC03FFFFFC07FFFFFC0FFFF
FF80FFFFFF80FFFFFF801B277DA622>I<007F800003FFF00007FFFC001F81FE001F00FF003F80
FF003F807F803FC07F803F807F803F807F801F007F800000FF800000FF000000FF000001FE0000
03F8000007F00000FFC00000FFF0000001FC000000FF0000007F8000007FC000003FC000003FE0
00003FE000003FE03C003FE07E003FE0FF003FE0FF003FE0FF003FC0FF007FC0FE007F807C00FF
803F01FF001FFFFC0007FFF00000FF80001B277DA622>I<00000E0000001E0000003E0000007E
000000FE000000FE000001FE000003FE0000077E00000E7E00000E7E00001C7E0000387E000070
7E0000E07E0000E07E0001C07E0003807E0007007E000E007E000E007E001C007E0038007E0070
007E00E0007E00FFFFFFF8FFFFFFF8FFFFFFF80000FE000000FE000000FE000000FE000000FE00
0000FE000000FE000000FE00007FFFF8007FFFF8007FFFF81D277EA622>I<0C0003000F803F00
0FFFFE000FFFFE000FFFFC000FFFF8000FFFE0000FFFC0000FFE00000E0000000E0000000E0000
000E0000000E0000000E0000000E7FC0000FFFF8000F80FE000E007F000C003F8000003F800000
1FC000001FC000001FE000001FE018001FE07E001FE0FE001FE0FE001FE0FE001FE0FE001FE0FE
001FC078003FC078003F803C007F001F01FE000FFFFC0003FFF00000FF80001B277DA622>I<00
07F000003FFC0000FFFF0001FC0F0007F01F800FE03F800FC03F801FC03F803F803F803F801F00
7F8000007F0000007F0000007F000000FF000000FF0FC000FF3FF800FF70FE00FFE03F00FFC03F
80FF801FC0FF801FC0FF801FC0FF001FE0FF001FE0FF001FE0FF001FE07F001FE07F001FE07F00
1FE07F001FE03F801FC03F801FC01F803F800FC03F8007E0FF0003FFFC0000FFF000003FC0001B
277DA622>I<380000003E0000003FFFFFF03FFFFFF03FFFFFF07FFFFFE07FFFFFC07FFFFFC07F
FFFF8070000F0070001E0070003C00E0003800E0007800E000F0000001E0000003C0000003C000
0007800000078000000F0000001F0000001F0000001F0000003F0000003F0000003E0000007E00
00007E0000007E0000007E000000FE000000FE000000FE000000FE000000FE000000FE000000FE
000000FE000000FE0000003800001C297CA822>I<003FC00001FFF00003FFFC000FC07E000F00
3F001F001F001E001F803E000F803E000F803F000F803F800F803FC01F803FF01F003FFC3F001F
FE7E001FFFF8000FFFE00007FFF80001FFFC0001FFFF0007FFFF801F8FFF803F03FFC07E01FFC0
7C007FE0FC001FE0F8000FE0F80007E0F80003E0F80003E0F80003E0FC0003C07C0007C07E0007
803F000F801FC03F000FFFFC0003FFF800007FC0001B277DA622>I<007F800001FFF00007FFF8
000FE0FE001FC07E003F803F007F003F807F003F80FF001FC0FF001FC0FF001FC0FF001FC0FF00
1FE0FF001FE0FF001FE0FF001FE07F003FE07F003FE07F003FE03F807FE01F80FFE00FE1DFE003
FF9FE0007E1FE000001FE000001FC000001FC000001FC000003FC01F003F803F803F803F807F00
3F807F003F80FE003F01FC001E03F8000FFFE00007FF800001FE00001B277DA622>I<00000380
0000000007C00000000007C0000000000FE0000000000FE0000000000FE0000000001FF0000000
001FF0000000003FF8000000003FF8000000003FF80000000073FC0000000073FC00000000F3FE
00000000E1FE00000000E1FE00000001C0FF00000001C0FF00000003C0FF80000003807F800000
07807FC0000007003FC0000007003FC000000E003FE000000E001FE000001E001FF000001C000F
F000001FFFFFF000003FFFFFF800003FFFFFF80000780007FC0000700003FC0000700003FC0000
E00001FE0000E00001FE0001E00001FF0001C00000FF0001C00000FF00FFFE001FFFFEFFFE001F
FFFEFFFE001FFFFE2F297EA834>65 D<FFFFFFF80000FFFFFFFF8000FFFFFFFFC00003F8001FF0
0003F8000FF80003F80007FC0003F80003FC0003F80003FC0003F80003FE0003F80001FE0003F8
0001FE0003F80001FE0003F80003FE0003F80003FC0003F80003FC0003F80007F80003F8000FF0
0003F8001FE00003F800FFC00003FFFFFE000003FFFFFFE00003F80007F00003F80003FC0003F8
0001FE0003F80001FE0003F80000FF0003F80000FF0003F80000FF8003F80000FF8003F80000FF
8003F80000FF8003F80000FF8003F80000FF8003F80000FF0003F80001FF0003F80003FE0003F8
0007FC0003F8001FF800FFFFFFFFF000FFFFFFFFC000FFFFFFFE000029297DA831>I<00003FF0
01800003FFFE0780000FFFFF8F80003FF007FF8000FF8001FF8001FE00007F8007FC00003F8007
F800001F800FF000000F801FE000000F803FE0000007803FC0000007807FC0000003807FC00000
03807FC000000380FF8000000000FF8000000000FF8000000000FF8000000000FF8000000000FF
8000000000FF8000000000FF8000000000FF8000000000FF8000000000FF80000000007FC00000
00007FC0000003807FC0000003803FC0000003803FE0000003801FE0000007800FF00000070007
F800000F0007FC00001E0001FE00003C0000FF8000F800003FF007F000000FFFFFC0000003FFFF
000000003FF8000029297CA832>I<FFFFFFF80000FFFFFFFF8000FFFFFFFFE00003FC001FF800
03FC0007FC0003FC0001FE0003FC0000FF0003FC00007F8003FC00003FC003FC00001FC003FC00
001FE003FC00001FE003FC00000FF003FC00000FF003FC00000FF003FC00000FF003FC00000FF8
03FC00000FF803FC00000FF803FC00000FF803FC00000FF803FC00000FF803FC00000FF803FC00
000FF803FC00000FF803FC00000FF803FC00000FF003FC00000FF003FC00000FF003FC00001FE0
03FC00001FE003FC00001FC003FC00003FC003FC00007F8003FC00007F0003FC0001FE0003FC00
03FC0003FC001FF800FFFFFFFFE000FFFFFFFF8000FFFFFFFC00002D297DA835>I<FFFFFFFFE0
FFFFFFFFE0FFFFFFFFE003FC001FE003FC0007F003FC0001F003FC0001F003FC0000F003FC0000
7003FC00007003FC00007003FC01C07803FC01C03803FC01C03803FC01C03803FC03C00003FC03
C00003FC0FC00003FFFFC00003FFFFC00003FFFFC00003FC0FC00003FC03C00003FC03C00003FC
01C00E03FC01C00E03FC01C00E03FC01C01C03FC00001C03FC00001C03FC00001C03FC00003C03
FC00003803FC00007803FC0000F803FC0001F803FC0003F803FC001FF8FFFFFFFFF0FFFFFFFFF0
FFFFFFFFF027297DA82D>I<FFFFFFFFC0FFFFFFFFC0FFFFFFFFC003FC003FC003FC000FE003FC
0003E003FC0001E003FC0001E003FC0000E003FC0000E003FC0000E003FC0000F003FC03807003
FC03807003FC03807003FC03800003FC07800003FC07800003FC1F800003FFFF800003FFFF8000
03FFFF800003FC1F800003FC07800003FC07800003FC03800003FC03800003FC03800003FC0380
0003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00
000003FC000000FFFFFC0000FFFFFC0000FFFFFC000024297DA82B>I<00007FE003000003FFFC
0F00001FFFFF1F00007FF00FFF0000FF8001FF0003FE0000FF0007FC00007F000FF800003F000F
F000001F001FE000001F003FE000000F003FC000000F007FC0000007007FC0000007007FC00000
0700FF8000000000FF8000000000FF8000000000FF8000000000FF8000000000FF8000000000FF
8000000000FF8000000000FF8000000000FF8001FFFFF8FF8001FFFFF87FC001FFFFF87FC00000
FF007FC00000FF003FC00000FF003FE00000FF001FE00000FF000FF00000FF000FF80000FF0007
FC0000FF0003FE0001FF0000FF8001FF00007FF007FF00001FFFFFBF000003FFFE0F0000007FF0
03002D297CA836>I<FFFFFCFFFFFCFFFFFC01FE0001FE0001FE0001FE0001FE0001FE0001FE00
01FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE00
01FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE00
01FE0001FE00FFFFFCFFFFFCFFFFFC16297EA81A>73 D<FFFFFC0000FFFFFC0000FFFFFC000003
FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC000000
03FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC0000
0003FC00000003FC00000003FC00000003FC00000003FC00000003FC0001C003FC0001C003FC00
01C003FC0001C003FC0003C003FC00038003FC00038003FC00078003FC00078003FC000F8003FC
000F8003FC001F8003FC007F8003FC01FF00FFFFFFFF00FFFFFFFF00FFFFFFFF0022297DA829>
76 D<FFFE0000001FFFC0FFFE0000001FFFC0FFFF0000003FFFC003FF0000003FF00003FF0000
003FF00003BF80000077F00003BF80000077F000039FC00000E7F000039FC00000E7F000038FE0
0001C7F000038FE00001C7F0000387F0000387F0000387F0000387F0000387F0000387F0000383
F8000707F0000383F8000707F0000381FC000E07F0000381FC000E07F0000380FE001C07F00003
80FE001C07F0000380FF003807F00003807F003807F00003807F003807F00003803F807007F000
03803F807007F00003801FC0E007F00003801FC0E007F00003800FE1C007F00003800FE1C007F0
0003800FE1C007F000038007F38007F000038007F38007F000038003FF0007F000038003FF0007
F000038001FE0007F000038001FE0007F000038000FC0007F000038000FC0007F000FFFE00FC01
FFFFC0FFFE007801FFFFC0FFFE007801FFFFC03A297DA841>I<0000FFE000000007FFFC000000
3FC07F8000007F001FC00001FC0007F00003F80003F80007F00001FC000FF00001FE001FE00000
FF001FE00000FF003FC000007F803FC000007F807FC000007FC07F8000003FC07F8000003FC07F
8000003FC0FF8000003FE0FF8000003FE0FF8000003FE0FF8000003FE0FF8000003FE0FF800000
3FE0FF8000003FE0FF8000003FE0FF8000003FE0FF8000003FE07F8000003FC07FC000007FC07F
C000007FC03FC000007F803FC000007F801FE00000FF001FE00000FF000FF00001FE0007F00001
FC0003F80003F80001FC0007F00000FF001FE000003FC07F8000000FFFFE00000000FFE000002B
297CA834>79 D<FFFFFFF800FFFFFFFF00FFFFFFFFC003FC003FE003FC000FF003FC0007F803FC
0007FC03FC0003FC03FC0003FE03FC0003FE03FC0003FE03FC0003FE03FC0003FE03FC0003FE03
FC0003FE03FC0003FC03FC0007FC03FC0007F803FC000FF003FC003FE003FFFFFF8003FFFFFE00
03FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC0000
0003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00
0000FFFFF00000FFFFF00000FFFFF0000027297DA82F>I<FFFFFFE00000FFFFFFFE0000FFFFFF
FF800003FC007FE00003FC000FF00003FC0007F80003FC0007FC0003FC0003FC0003FC0003FE00
03FC0003FE0003FC0003FE0003FC0003FE0003FC0003FE0003FC0003FE0003FC0003FC0003FC00
07F80003FC0007F80003FC001FE00003FC007FC00003FFFFFE000003FFFFF0000003FC01FC0000
03FC007F000003FC007F800003FC003FC00003FC003FC00003FC001FE00003FC001FE00003FC00
1FE00003FC001FE00003FC001FF00003FC001FF00003FC001FF00003FC001FF00003FC001FF007
03FC001FF80703FC000FF80703FC000FFC0FFFFFF007FE1EFFFFF001FFFCFFFFF0003FF030297D
A834>82 D<007F806003FFF0E00FFFFFE01F807FE03F001FE07E0007E07E0003E07C0003E0FC00
01E0FC0001E0FC0000E0FE0000E0FE0000E0FF000000FFC000007FFE00007FFFE0003FFFFC003F
FFFF001FFFFF8007FFFFC003FFFFE000FFFFF00007FFF000007FF000000FF8000007F8000003F8
E00003F8E00001F8E00001F8E00001F8F00001F8F00001F0F80003F0FC0003E0FF0007E0FFE01F
C0FFFFFF00E0FFFE00C01FF0001D297CA826>I<7FFFFFFFFFC07FFFFFFFFFC07FFFFFFFFFC07F
803FC03FC07E003FC007C078003FC003C078003FC003C070003FC001C0F0003FC001E0F0003FC0
01E0E0003FC000E0E0003FC000E0E0003FC000E0E0003FC000E0E0003FC000E000003FC0000000
003FC0000000003FC0000000003FC0000000003FC0000000003FC0000000003FC0000000003FC0
000000003FC0000000003FC0000000003FC0000000003FC0000000003FC0000000003FC0000000
003FC0000000003FC0000000003FC0000000003FC0000000003FC0000000003FC0000000003FC0
000000003FC00000007FFFFFE000007FFFFFE000007FFFFFE0002B287EA730>I<01FF800007FF
F0000F81FC001FC0FE001FC07F001FC07F001FC03F800F803F8000003F8000003F8000003F8000
0FFF8000FFFF8007FC3F801FE03F803F803F807F803F807F003F80FE003F80FE003F80FE003F80
FE007F80FF007F807F00FFC03F83DFFC0FFF0FFC01FC03FC1E1B7E9A21>97
D<FFE0000000FFE0000000FFE00000000FE00000000FE00000000FE00000000FE00000000FE000
00000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE1
FE00000FE7FF80000FFE07E0000FF803F8000FF001FC000FE000FE000FE000FE000FE0007F000F
E0007F000FE0007F800FE0007F800FE0007F800FE0007F800FE0007F800FE0007F800FE0007F80
0FE0007F800FE0007F800FE0007F000FE000FF000FE000FE000FF000FE000FF001FC000FF803F8
000F9E07E0000F0FFF80000E01FC0000212A7EA926>I<001FF80000FFFE0003F01F000FE03F80
1FC03F803F803F803F803F807F801F007F000000FF000000FF000000FF000000FF000000FF0000
00FF000000FF000000FF000000FF0000007F0000007F8000003F8001C03FC001C01FC003C00FE0
078003F01F0000FFFC00001FE0001A1B7E9A1F>I<00003FF80000003FF80000003FF800000003
F800000003F800000003F800000003F800000003F800000003F800000003F800000003F8000000
03F800000003F800000003F800000003F800001FE3F80000FFFBF80003F03FF8000FE00FF8001F
C007F8003F8003F8003F8003F8007F8003F8007F0003F800FF0003F800FF0003F800FF0003F800
FF0003F800FF0003F800FF0003F800FF0003F800FF0003F800FF0003F8007F0003F8007F0003F8
003F8003F8003F8007F8001FC00FF8000FE01FF80003F03FFF8000FFF3FF80003FC3FF80212A7E
A926>I<003FE00001FFF80003F07E000FE03F001FC01F803F800FC03F800FC07F000FC07F0007
E0FF0007E0FF0007E0FF0007E0FFFFFFE0FFFFFFE0FF000000FF000000FF000000FF0000007F00
00007F8000003F8000E03F8001E01FC001C00FE003C003F81F8000FFFE00001FF0001B1B7E9A20
>I<0007F0003FFC00FE3E01FC7F03F87F03F87F07F07F07F03E07F00007F00007F00007F00007
F00007F00007F000FFFFC0FFFFC0FFFFC007F00007F00007F00007F00007F00007F00007F00007
F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007
F0007FFF807FFF807FFF80182A7EA915>I<00FF81F003FFE7FC0FC1FE7C1F80FC7C3F80FE7C3F
007E107F007F007F007F007F007F007F007F007F007F007F007F003F007E003F80FE001F80FC00
0FC1F8001FFFE00018FF8000380000003C0000003C0000003E0000003FFFF8003FFFFF001FFFFF
C00FFFFFE007FFFFF01FFFFFF07E0007F87C0001F8F80001F8F80000F8F80000F8F80000F8FC00
01F87E0003F03F0007E00FC01F8003FFFE00007FF0001E287E9A22>I<FFE0000000FFE0000000
FFE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000
000FE00000000FE00000000FE00000000FE00000000FE00000000FE07F00000FE1FFC0000FE787
E0000FEE07F0000FFC03F8000FF803F8000FF003F8000FF003F8000FF003F8000FE003F8000FE0
03F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000F
E003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F800FFFE3FFF80FFFE3FFF80
FFFE3FFF80212A7DA926>I<07001FC01FE03FE03FE03FE01FE01FC00700000000000000000000
0000000000FFE0FFE0FFE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE0
0FE00FE00FE00FE00FE00FE00FE0FFFEFFFEFFFE0F2B7DAA14>I<FFE00000FFE00000FFE00000
0FE000000FE000000FE000000FE000000FE000000FE000000FE000000FE000000FE000000FE000
000FE000000FE000000FE01FFC0FE01FFC0FE01FFC0FE007C00FE00F800FE01E000FE07C000FE0
F8000FE1F0000FE3E0000FE7C0000FEFE0000FFFF0000FFFF0000FFFF8000FF3FC000FE1FE000F
C0FE000FC0FF000FC07F800FC03F800FC03FC00FC01FE00FC00FF0FFFC3FFEFFFC3FFEFFFC3FFE
1F2A7EA924>107 D<FFE0FFE0FFE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE0
0FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00F
E00FE00FE00FE00FE0FFFEFFFEFFFE0F2A7DA914>I<FFC07F800FF000FFC1FFE03FFC00FFC783
F0F07E000FCE03F9C07F000FDC01FB803F000FF801FF003F800FF001FE003F800FF001FE003F80
0FF001FE003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC
003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC003F800F
E001FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC003F80FFFE1FFFC3
FFF8FFFE1FFFC3FFF8FFFE1FFFC3FFF8351B7D9A3A>I<FFC07F0000FFC1FFC000FFC787E0000F
CE07F0000FDC03F8000FF803F8000FF003F8000FF003F8000FF003F8000FE003F8000FE003F800
0FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8
000FE003F8000FE003F8000FE003F8000FE003F8000FE003F800FFFE3FFF80FFFE3FFF80FFFE3F
FF80211B7D9A26>I<003FE00001FFFC0003F07E000FC01F801F800FC03F800FE03F0007E07F00
07F07F0007F07F0007F0FF0007F8FF0007F8FF0007F8FF0007F8FF0007F8FF0007F8FF0007F8FF
0007F87F0007F07F0007F03F800FE03F800FE01F800FC00FC01F8007F07F0001FFFC00003FE000
1D1B7E9A22>I<FFE1FE0000FFE7FF8000FFFE07E0000FF803F8000FF001FC000FE001FE000FE0
00FE000FE000FF000FE000FF000FE0007F800FE0007F800FE0007F800FE0007F800FE0007F800F
E0007F800FE0007F800FE0007F800FE0007F800FE000FF000FE000FF000FE000FE000FF001FE00
0FF003FC000FF803F8000FFE0FE0000FEFFF80000FE1FC00000FE00000000FE00000000FE00000
000FE00000000FE00000000FE00000000FE00000000FE00000000FE0000000FFFE000000FFFE00
0000FFFE00000021277E9A26>I<FFC1F0FFC7FCFFCE3E0FDC7F0FD87F0FF87F0FF07F0FF03E0F
F0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000F
E0000FE0000FE000FFFF00FFFF00FFFF00181B7E9A1C>114 D<03FE300FFFF03E03F07800F070
00F0F00070F00070F80070FC0000FFE000FFFE007FFFC03FFFE01FFFF007FFF800FFFC0003FC00
00FCE0007CE0003CF0003CF0003CF80078FC0078FF01F0F7FFC0C1FF00161B7E9A1B>I<007000
00700000700000700000F00000F00000F00001F00003F00003F00007F0001FFFF0FFFFF0FFFFF0
07F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F000
07F03807F03807F03807F03807F03807F03807F03803F87001F8F000FFE0001F8015267FA51B>
I<FFE03FF800FFE03FF800FFE03FF8000FE003F8000FE003F8000FE003F8000FE003F8000FE003
F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE0
03F8000FE003F8000FE003F8000FE003F8000FE003F8000FE007F8000FE007F8000FE00FF80007
E01FF80003F03BFF8001FFF3FF80003FC3FF80211B7D9A26>I<FFFE03FF80FFFE03FF80FFFE03
FF8007F000700007F000700007F800F00003F800E00003FC01E00001FC01C00001FC01C00000FE
03800000FE038000007F070000007F070000007F8F0000003F8E0000003FDE0000001FDC000000
1FDC0000000FF80000000FF80000000FF800000007F000000007F000000003E000000003E00000
0001C00000211B7F9A24>I<FFFE7FFC0FFEFFFE7FFC0FFEFFFE7FFC0FFE0FE007E000E007F003
F001C007F003F001C007F807F803C003F807F8038003F807F8038001FC0EFC070001FC0EFC0700
01FE1EFC0F0000FE1C7E0E0000FE1C7E0E0000FF383F1E00007F383F1C00007F783F3C00003FF0
1FB800003FF01FB800003FF01FF800001FE00FF000001FE00FF000000FC007E000000FC007E000
000FC007E00000078003C00000078003C0002F1B7F9A32>I<FFFC0FFF00FFFC0FFF00FFFC0FFF
0007F003C00003F807800001FC07800000FE0F000000FF1E0000007F3C0000003FF80000001FF0
0000000FF00000000FF000000007F000000007F80000000FFC0000001FFE0000001EFE0000003C
7F000000783F800000F01FC00001E01FE00001C00FE00003C007F000FFF01FFF80FFF01FFF80FF
F01FFF80211B7F9A24>I<FFFE03FF80FFFE03FF80FFFE03FF8007F000700007F000700007F800
F00003F800E00003FC01E00001FC01C00001FC01C00000FE03800000FE038000007F070000007F
070000007F8F0000003F8E0000003FDE0000001FDC0000001FDC0000000FF80000000FF8000000
0FF800000007F000000007F000000003E000000003E000000001C000000001C000000003800000
000380000038078000007C07000000FE0F000000FE0E000000FE1E000000FE3C0000007C780000
003FE00000000FC000000021277F9A24>I E /Fi 69 126 df<60F0F0F0F0F0F0F0F0F0F0F0F0
F0F0F0600000000060F0F0600419779816>33 D<6030F078F078F078F078F078F078F078F078E0
38E038E0380D0C7C9916>I<3801807C0380FE0780FE0700EE0700EE0F00EE0E00EE1E00FE1C00
FE3C007C380038380000780000700000F00000E00000E00001E00001C00003C000038000038380
0787C0070FE00F0EE00E0EE01E0EE01C0EE01C0EE03C0FE03807C018038013207F9C16>37
D<03C00007E0000FE0001EF0001C70001C70001C70001CF7E01CE7E01DE7E01FC7000F8F000F0E
001F0E003F1E007F9C00F3BC00E3F800E1F800E1F1C0E0F1C0F1F9C07FFFC03F9F801F0F001319
7F9816>I<183C3E1E0E0E0E1E1C3C78F060070D799816>I<00E001E007C007000F001E003C0038
007800700070007000F000E000E000E000E000E000E000E000F000700070007000780038003C00
1E000F00070007C001E000E00B217A9C16>I<E000F0007C001C001E000F000780038003C001C0
01C001C001E000E000E000E000E000E000E000E001E001C001C001C003C0038007800F001E001C
007C00F000E0000B217C9C16>I<01C00001C00001C00001C00071C700F9CF807FFF001FFC0007
F00007F0001FFC007FFF00F9CF8071C70001C00001C00001C00001C00011127E9516>I<01C000
01C00001C00001C00001C00001C00001C00001C000FFFF80FFFF80FFFF8001C00001C00001C000
01C00001C00001C00001C00001C00011137E9516>I<387C7E7E3E0E1E3C7CF860070B798416>I<
FFFF80FFFF80FFFF8011037E8D16>I<70F8F8F8700505788416>I<000180000380000780000700
000F00000E00001E00001C00003C0000380000780000700000F00000E00001E00001C00001C000
03C0000380000780000700000F00000E00001E00001C00003C0000380000780000700000F00000
E00000E0000011207E9C16>I<03E0000FF8001FFC001E3C00380E00780F00700700700700E003
80E00380E00380E00380E00380E00380E00380E00380F00780700700700700780F003C1E001E3C
001FFC000FF80003E00011197E9816>I<01800380078007801F807F80FF807380038003800380
038003800380038003800380038003800380038003807FF87FFC7FF80E197C9816>I<07E0001F
F8007FFE00783F00F00F00F00780F00380F00380000380000380000780000700000F00001E0000
3C0000780000F00003E0000780000F00001E03803C03807FFF80FFFF807FFF8011197E9816>I<
07E0001FFC007FFE00781F00780F00780700000700000F00000F00003E0007FC0007F80007FC00
001E00000700000780000380000380F00380F00780F00700F81F007FFE003FFC0007E00011197E
9816>I<007C0000FC0000DC0001DC00039C00039C00071C000F1C000E1C001E1C003C1C00381C
00781C00F01C00FFFFE0FFFFE0FFFFE0001C00001C00001C00001C00001C0001FFC001FFC001FF
C013197F9816>I<3FFE003FFE003FFE003800003800003800003800003800003800003800003F
F0003FFC003FFE003C0F00300700000780000380600380F00380F00780F00F00F81F007FFE001F
F80007E00011197E9816>I<E00000FFFF80FFFF80FFFF80E00F00E01E00003C00003800007800
00700000F00000E00001E00001C00003C000038000038000038000078000070000070000070000
070000070000070000070000111A7E9916>55 D<07F0001FFC003FFE007C1F00F00780E00380E0
0380E003807007007C1F001FFC0007F0001FFC003C1E00700700F00780E00380E00380E00380F0
07807007007C1F003FFE001FFC0007F00011197E9816>I<70F8F8F870000000000000000070F8
F8F8700512789116>58 D<387C7C7C380000000000000000387C7C7C3C1C3C38F8F06006187991
16>I<000380000780001F80003E0000FC0003F00007E0001F80003E0000FC0000F00000FC0000
3E00001F800007E00003F00000FC00003E00001F8000078000038011157E9616>I<7FFF00FFFF
80FFFF80000000000000000000000000000000FFFF80FFFF807FFF00110B7E9116>I<E00000F0
0000FC00003E00001F800007E00003F00000FC00003E00001F80000780001F80003E0000FC0003
F00007E0001F80003E0000FC0000F00000E0000011157E9616>I<00E00001F00001F00001B000
01B00003B80003B80003B800031800071C00071C00071C00071C00071C000E0E000E0E000FFE00
0FFE001FFF001C07001C07001C07007F1FC0FF1FE07F1FC013197F9816>65
D<01F18007FF800FFF801F0F803C0780780780780380700380F00000E00000E00000E00000E000
00E00000E00000E00000F000007003807803807803803C07801F0F000FFE0007FC0001F0001119
7E9816>67 D<7FF800FFFE007FFF001C0F001C07801C03C01C01C01C01C01C01E01C00E01C00E0
1C00E01C00E01C00E01C00E01C00E01C00E01C01C01C01C01C03C01C07801C0F807FFF00FFFE00
7FF8001319809816>I<7FFFC0FFFFC07FFFC01C01C01C01C01C01C01C01C01C00001C00001C1C
001C1C001FFC001FFC001FFC001C1C001C1C001C00001C00E01C00E01C00E01C00E01C00E07FFF
E0FFFFE07FFFE013197F9816>I<FFFFE0FFFFE0FFFFE01C00E01C00E01C00E01C00E01C00001C
00001C1C001C1C001FFC001FFC001FFC001C1C001C1C001C00001C00001C00001C00001C00001C
0000FF8000FFC000FF800013197F9816>I<FFC000FFC000FFC0001C00001C00001C00001C0000
1C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00401C00E01C00E0
1C00E01C00E0FFFFE0FFFFE0FFFFE013197F9816>76 D<1FFC003FFE007FFF00780F00F00780E0
0380E00380E00380E00380E00380E00380E00380E00380E00380E00380E00380E00380E00380E0
0380F00780F00780780F007FFF003FFE001FFC0011197E9816>79 D<7FF800FFFE007FFF001C0F
801C03801C03C01C01C01C01C01C01C01C03C01C03801C0F801FFF001FFE001FF8001C00001C00
001C00001C00001C00001C00001C00007F0000FF80007F000012197F9816>I<7FE000FFF8007F
FC001C1E001C0F001C07001C07001C07001C07001C0F001C1E001FFC001FF8001FFC001C3E001C
0E001C0E001C0E001C0E001C0E201C0E701C0E707F0FF0FF87E07F03C014197F9816>82
D<07E3001FFF007FFF00781F00F00F00E00700E00700E00000F000007800007F80001FF00007FC
0000FE00000F00000780000380000380E00380E00380F00780F80F00FFFE00FFFC00C7F0001119
7E9816>I<7FFFE0FFFFE0FFFFE0E0E0E0E0E0E0E0E0E0E0E0E000E00000E00000E00000E00000
E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00007FC000FFE0007
FC0013197F9816>I<7F07F0FF8FF87F07F01C01C01C01C01C01C01C01C01C01C01C01C01C01C0
1C01C01C01C01C01C01C01C01C01C01C01C01C01C01C01C01C01C01E03C00E03800F8F8007FF00
03FE0000F8001519809816>I<FFF0FFF0FFF0E000E000E000E000E000E000E000E000E000E000
E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000FFF0FFF0FFF00C
20789C16>91 D<E00000E00000F000007000007800003800003C00001C00001E00000E00000F00
0007000007800003800003C00001C00001C00001E00000E00000F000007000007800003800003C
00001C00001E00000E00000F0000070000078000038000018011207E9C16>I<FFF0FFF0FFF000
700070007000700070007000700070007000700070007000700070007000700070007000700070
007000700070007000700070FFF0FFF0FFF00C207F9C16>I<1FE0007FF8007FFC00783C00301E
00000E00000E0003FE001FFE007E0E00F00E00E00E00E00E00F01E00F83E007FFFE03FE7E00F83
E013127E9116>97 D<7E0000FE00007E00000E00000E00000E00000E00000E3E000EFF800FFFC0
0F83E00F01E00E00F00E00F00E00700E00700E00700E00700E00F00F00E00F01E00F83C00FFFC0
0EFF00063C001419809816>I<03F80FFE1FFE3C1E780C7000F000E000E000E000E000F0007007
78073E0F1FFE0FFC03F010127D9116>I<003F00007F00003F0000070000070000070000070003
C7000FF7003FFF003C1F00780F00F00700F00700E00700E00700E00700E00700F00700F00F0078
1F007C3F003FFFE01FF7F007C7E014197F9816>I<07E00FF81FFC3C3E780E700FF007FFFFFFFF
FFFFE000F000700778073E1F1FFE0FFC03F010127D9116>I<001F00007F8000FF8001E78001C3
0001C00001C0007FFF00FFFF00FFFF0001C00001C00001C00001C00001C00001C00001C00001C0
0001C00001C00001C00001C0003FFE007FFF003FFE0011197F9816>I<03E3C00FFFE01FFFE01E
3CC03C1E00380E00380E00380E003C1E001E3C001FFC001FF8003BE0003800003800001FFC001F
FF003FFFC07803C0F001E0E000E0E000E0E000E0F001E07C07C03FFF800FFE0003F800131C7F91
16>I<7E0000FE00007E00000E00000E00000E00000E00000E3C000EFF000FFF800F87800F0380
0F03800E03800E03800E03800E03800E03800E03800E03800E03800E03807FC7F0FFE7F87FC7F0
1519809816>I<018003C003C0018000000000000000007FC07FC07FC001C001C001C001C001C0
01C001C001C001C001C001C001C07FFFFFFF7FFF101A7D9916>I<003000780078003000000000
000000001FF81FF81FF80038003800380038003800380038003800380038003800380038003800
3800380038003800386078F0F0FFE07FC03F800D237E9916>I<7E0000FE00007E00000E00000E
00000E00000E00000E7FE00E7FE00E7FE00E0F000E1E000E3C000E78000EF0000FF8000FF8000F
BC000F1E000E0E000E0F000E07807F87F0FFCFF07F87F01419809816>I<FFC000FFC000FFC000
01C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C000
01C00001C00001C00001C00001C00001C000FFFF80FFFF80FFFF8011197E9816>I<F9C380FFEF
C0FFFFE03E7CE03C78E03870E03870E03870E03870E03870E03870E03870E03870E03870E03870
E0FE7CF8FE7CF8FE7CF81512809116>I<7E3C00FEFF007FFF800F87800F03800F03800E03800E
03800E03800E03800E03800E03800E03800E03800E03807FC7F0FFE7F87FC7F01512809116>I<
03E0000FF8001FFC003C1E00780F00700700E00380E00380E00380E00380E00380F00780700700
780F003C1E001FFC000FF80003E00011127E9116>I<7E3E00FEFF807FFFC00F83E00F01E00E00
F00E00F00E00700E00700E00700E00700E00F00F00E00F01E00F83C00FFFC00EFF000E3C000E00
000E00000E00000E00000E00000E00007FC000FFE0007FC000141B809116>I<07C7001FF7003F
FF007C3F00781F00F00F00F00700E00700E00700E00700E00700F00700F00F00781F007C3F003F
FF001FF70007C700000700000700000700000700000700000700003FE0007FF0003FE0141B7E91
16>I<FF0FC0FF3FE0FF7FE007F04007E00007C000078000078000070000070000070000070000
070000070000070000FFFC00FFFC00FFFC0013127F9116>I<0FEC3FFC7FFCF03CE01CE01CF000
7F801FF007FC003EE00EE00EF00EF81EFFFCFFF8C7E00F127D9116>I<03000007000007000007
00000700007FFF00FFFF00FFFF0007000007000007000007000007000007000007000007010007
038007038007078007878003FF0003FE0000F80011177F9616>I<7E1F80FE3F807E1F800E0380
0E03800E03800E03800E03800E03800E03800E03800E03800E03800E07800F0F800FFFF007FFF8
03E3F01512809116>I<7F1FC0FF1FE07F1FC01C07001E0F000E0E000E0E000E0E00071C00071C
00071C00071C0003B80003B80003B80001F00001F00000E00013127F9116>I<FF1FE0FFBFE0FF
1FE038038038038038038038038038E38019F30019F30019B3001DB7001DB7001DB7001DB7000F
1E000F1E000F1E0013127F9116>I<7F1FC07F3FC07F1FC00F1C00073C0003B80003F00001F000
00E00001E00001F00003B800073C00071C000E0E007F1FC0FF3FE07F1FC013127F9116>I<3FFF
C07FFFC07FFFC0700780700F00701E00003C0000F80001F00003E00007C0000F00001E01C03C01
C07801C0FFFFC0FFFFC0FFFFC012127F9116>122 D<001F80007F8001FF8001E00001C00001C0
0001C00001C00001C00001C00001C00001C00001C00003C0007F8000FF0000FF00007F800003C0
0001C00001C00001C00001C00001C00001C00001C00001C00001C00001E00001FF80007F80001F
8011207E9C16>I<E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0
E00320779C16>I<FC0000FF0000FFC00003C00001C00001C00001C00001C00001C00001C00001
C00001C00001C00001E00000FF00007F80007F8000FF0001E00001C00001C00001C00001C00001
C00001C00001C00001C00001C00003C000FFC000FF0000FC000011207E9C16>I
E /Fj 56 123 df<0038007800F801E003C007800F001E001C003C0038007800700070007000F0
00E000E000E000E000E000E000E000E000F000700070007000780038003C001C001E000F000780
03C001E000F8007800380D2878A21A>40 D<6000F00078003C001E000F00078003C001C001E000
E000F0007000700070007800380038003800380038003800380038007800700070007000F000E0
01E001C003C007800F001E003C007800F00060000D287CA21A>I<003000007800007800007800
0078000078000078000078000078007FFFF0FFFFF8FFFFF87FFFF0007800007800007800007800
00780000780000780000780000300015167E991A>43 D<7FFFC0FFFFE0FFFFE07FFFC013047D90
1A>45 D<78FCFCFCFC78060676851A>I<01F00007FC000FFE001F1F001C070038038038038070
01C07001C07001C0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0F001E070
01C07001C07803C03803803C07801C07001F1F000FFE0007FC0001F000131E7D9D1A>48
D<00C001C003C003C007C00FC07FC0FDC079C001C001C001C001C001C001C001C001C001C001C0
01C001C001C001C001C001C001C001C07FFF7FFF7FFF101E7B9D1A>I<07F8000FFE001FFF003C
0F807803C0F001C0E001E0F000E0F000E06000E00000E00000E00001E00001C00003C000078000
0F00000E00003E00007C0000F80001E00003C0000780000F00001E00E03C00E07FFFE0FFFFE07F
FFE0131E7D9D1A>I<78FCFCFCFC7800000000000000000078FCFCFCFC78061576941A>58
D<3C7E7E7E7E3C0000000000000000003C7C7E7E7E3E0E1E1C3CF8F0E0071C77941A>I<003800
007C00007C00006C0000EE0000EE0000EE0000C60000C60001C70001C70001C70001C700038380
0383800383800383800701C00701C007FFC007FFC00FFFE00E00E00E00E00E00E00E00E01C0070
7F01FCFF83FE7F01FC171E7F9D1A>65 D<FFFE00FFFF80FFFFC01C03E01C00E01C00F01C00701C
00701C00701C00701C00E01C01E01C07C01FFF801FFF801FFFC01C01E01C00F01C00701C00381C
00381C00381C00381C00381C00781C00F01C01F0FFFFE0FFFFC0FFFF00151E7E9D1A>I<00FE38
03FFB807FFF80F83F81E00F81C00783C0078780038700038700038F00000E00000E00000E00000
E00000E00000E00000E00000E00000F000007000387000387800383C00781C00701E00F00F83E0
07FFC003FF8000FE00151E7E9D1A>I<7FFE00FFFF007FFF801C07C01C01E01C00F01C00701C00
781C00381C00381C003C1C001C1C001C1C001C1C001C1C001C1C001C1C001C1C001C1C003C1C00
381C00381C00781C00701C00F01C01E01C07C07FFFC0FFFF007FFE00161E7F9D1A>I<FFFFF8FF
FFF8FFFFF81C00381C00381C00381C00381C00001C00001C00001C0E001C0E001C0E001FFE001F
FE001FFE001C0E001C0E001C0E001C00001C00001C00001C001C1C001C1C001C1C001C1C001CFF
FFFCFFFFFCFFFFFC161E7E9D1A>I<7FFFFCFFFFFC7FFFFC0E001C0E001C0E001C0E001C0E0000
0E00000E00000E03800E03800E03800FFF800FFF800FFF800E03800E03800E03800E00000E0000
0E00000E00000E00000E00000E00000E00007FE000FFE0007FE000161E7F9D1A>I<FF83FEFF83
FEFF83FE1C00701C00701C00701C00701C00701C00701C00701C00701C00701C00701FFFF01FFF
F01FFFF01C00701C00701C00701C00701C00701C00701C00701C00701C00701C00701C0070FF83
FEFF83FEFF83FE171E7F9D1A>72 D<FFFF80FFFF80FFFF8001C00001C00001C00001C00001C000
01C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C000
01C00001C00001C00001C00001C00001C000FFFF80FFFF80FFFF80111E7C9D1A>I<7FE000FFF0
007FE0000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00
000E00000E00000E00000E00000E00000E00000E00000E001C0E001C0E001C0E001C0E001C7FFF
FCFFFFFC7FFFFC161E7F9D1A>76 D<7E003F00FF007F807F007F001D80DC001D80DC001D80DC00
1DC1DC001DC1DC001CC19C001CC19C001CE39C001CE39C001C631C001C771C001C771C001C361C
001C361C001C3E1C001C1C1C001C1C1C001C001C001C001C001C001C001C001C001C001C001C00
1C001C001C007F007F00FF80FF807F007F00191E809D1A>I<FE03FEFF03FEFF03FE1D80701D80
701DC0701CC0701CC0701CE0701CE0701C60701C70701C70701C30701C38701C38701C18701C1C
701C1C701C0C701C0E701C0E701C06701C06701C07701C03701C0370FF81F0FF81F0FF80F0171E
7F9D1A>I<0FFE003FFF807FFFC07C07C07001C0F001E0E000E0E000E0E000E0E000E0E000E0E0
00E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0F001E0F0
01E07001C07C07C07FFFC03FFF800FFE00131E7D9D1A>I<FFFE00FFFF80FFFFC01C03E01C00F0
1C00701C00781C00381C00381C00381C00381C00781C00701C00F01C03E01FFFC01FFF801FFE00
1C00001C00001C00001C00001C00001C00001C00001C00001C0000FF8000FF8000FF8000151E7E
9D1A>I<FFFC00FFFF00FFFF801C07C01C01E01C00F01C00701C00701C00701C00701C00F01C01
E01C07C01FFF801FFF001FFF801C07C01C01E01C00E01C00E01C00E01C00E01C00E01C00E21C00
E71C00E71C00E7FF80FFFF807EFF803C181E7F9D1A>82 D<07F1C01FFDC03FFFC07C1FC07007C0
F003C0E001C0E001C0E001C0E00000F000007800003F00001FF8000FFE0001FF00000F800003C0
0001C00001E00000E06000E0E000E0E000E0F001E0F003C0FE0780FFFF80FFFE00E3FC00131E7D
9D1A>I<7FFFFEFFFFFEFFFFFEE0380EE0380EE0380EE0380E0038000038000038000038000038
000038000038000038000038000038000038000038000038000038000038000038000038000038
0000380000380003FF8003FF8003FF80171E7F9D1A>I<FF83FEFF83FEFF83FE1C00701C00701C
00701C00701C00701C00701C00701C00701C00701C00701C00701C00701C00701C00701C00701C
00701C00701C00701C00701C00701E00F00E00E00F01E007C7C003FF8001FF00007C00171E7F9D
1A>I<FF01FEFF01FEFF01FE1C00700E00E00E00E00701C00701C00783C003838003C78001C700
01C70000EE0000EE00007C00007C00003800003800003800003800003800003800003800003800
00380000380001FF0001FF0001FF00171E7F9D1A>89 D<FFF8FFF8FFF8E000E000E000E000E000
E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E0
00E000E000E000E000E000E000E000E000FFF8FFF8FFF80D2776A21A>91
D<FFF8FFF8FFF80038003800380038003800380038003800380038003800380038003800380038
00380038003800380038003800380038003800380038003800380038003800380038FFF8FFF8FF
F80D277EA21A>93 D<1FF0003FFC007FFE00781F0030078000038000038000FF8007FF801FFF80
3F83807C0380F00380E00380E00380E00380F007807C1F803FFFFC1FFDFC07F0FC16157D941A>
97 D<FE0000FE0000FE00000E00000E00000E00000E00000E00000E00000E3F000EFFC00FFFE0
0FE1F00F80700F00780F00380E003C0E001C0E001C0E001C0E001C0E001C0F003C0F00380F0078
0F80F00FC3E00FFFC00EFF80067E00161E7F9D1A>I<01FF8007FFC00FFFE01F01E03C00C07800
00700000F00000E00000E00000E00000E00000E00000F000007000007800703C00701F01F00FFF
E007FFC001FF0014157D941A>I<001FC0001FC0001FC00001C00001C00001C00001C00001C000
01C001F9C007FDC00FFFC01F0FC03C07C07803C07003C0F001C0E001C0E001C0E001C0E001C0E0
01C0F003C07003C07807C03807C03E1FC01FFFFC0FFDFC03F1FC161E7E9D1A>I<01FC0007FF00
0FFF801F07C03C01E07800E07000F0F00070E00070FFFFF0FFFFF0FFFFF0E00000F00000700000
7800703C00701F01F00FFFE007FFC001FF0014157D941A>I<000FF0001FF8003FF800787800F0
3000E00000E00000E00000E0007FFFF0FFFFF0FFFFF000E00000E00000E00000E00000E00000E0
0000E00000E00000E00000E00000E00000E00000E00000E00000E0003FFF807FFFC03FFF80151E
7F9D1A>I<01F8FC07FFFE0FFFFE1F0F8C1C03803C03C03801C03801C03801C03C03C01C03801F
0F801FFF003FFE0039F8003800003C00001C00001FFF801FFFF03FFFF87C00FC70001CF0001EE0
000EE0000EE0000EF0001E78003C3F01F81FFFF00FFFE001FF0017217F941A>I<FE0000FE0000
FE00000E00000E00000E00000E00000E00000E00000E3F000EFF800FFFC00FE1E00F80E00F00E0
0F00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E0FFE3FE
FFE7FEFFE3FE171E7F9D1A>I<00C00001E00001E00000C0000000000000000000000000000000
000000007FE0007FE0007FE00000E00000E00000E00000E00000E00000E00000E00000E00000E0
0000E00000E00000E00000E00000E00000E0007FFF80FFFFC07FFF80121F7C9E1A>I<000C001E
001E000C0000000000000000000000000FFE0FFE0FFE000E000E000E000E000E000E000E000E00
0E000E000E000E000E000E000E000E000E000E000E000E000E000E000E001EF01CF07CFFF87FF0
3FC00F2A7E9E1A>I<FE0000FE0000FE00000E00000E00000E00000E00000E00000E00000E0FFC
0E1FFE0E0FFC0E03C00E07800E0F000E1E000E3C000E78000EFC000FFC000FDE000F8F000E0780
0E03C00E03C00E01E00E00F0FFE3FEFFE3FFFFE3FE181E7F9D1A>I<FFE000FFE000FFE00000E0
0000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E0
0000E00000E00000E00000E00000E00000E00000E00000E00000E00000E000FFFFE0FFFFE0FFFF
E0131E7D9D1A>I<7DF1F000FFFBF8007FFFFC001F1F1C001E1E1C001E1E1C001C1C1C001C1C1C
001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C
1C007F1F1F00FF9F9F807F1F1F00191580941A>I<FE3F00FEFF80FFFFC00FE1E00F80E00F00E0
0F00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E0FFE3FE
FFE7FEFFE3FE17157F941A>I<01F00007FC001FFF003E0F803C07807803C07001C0E000E0E000
E0E000E0E000E0E000E0E000E0F001E07001C07803C03C07803E0F801FFF0007FC0001F0001315
7D941A>I<FE3F00FEFFC0FFFFE00FE1F00F80700F00780F00380E003C0E001C0E001C0E001C0E
001C0E001C0F003C0F00380F00780F80F00FC3E00FFFC00EFF800E7E000E00000E00000E00000E
00000E00000E00000E00000E0000FFE000FFE000FFE00016207F941A>I<01F8E007FEE00FFFE0
1F0FE03C03E07801E07001E0F000E0E000E0E000E0E000E0E000E0E000E0F001E07001E07803E0
3C07E01E0FE00FFFE007FCE003F8E00000E00000E00000E00000E00000E00000E00000E00000E0
000FFE000FFE000FFE17207E941A>I<7F87F0FF9FFC7FBFFC03FC3C03F01803E00003E00003C0
0003C0000380000380000380000380000380000380000380000380000380007FFF00FFFF007FFF
0016157E941A>I<0FFB803FFF807FFF80F80F80E00380E00380E00380F800007FC0003FFC000F
FF00007F800007C06001C0E001C0F001C0F003C0FC0F80FFFF00FFFE00E7F80012157C941A>I<
00C00001C00001C00001C00001C00001C00001C0007FFFE0FFFFE0FFFFE001C00001C00001C000
01C00001C00001C00001C00001C00001C00001C00001C07001C07001C07001C0F001E1E000FFE0
007FC0003F00141C7F9B1A>I<FE0FE0FE0FE0FE0FE00E00E00E00E00E00E00E00E00E00E00E00
E00E00E00E00E00E00E00E00E00E00E00E00E00E01E00E01E00F07E007FFFE03FFFE01FCFE1715
7F941A>I<7F83FCFFC7FE7F83FC0E00E00E00E00E00E00701C00701C00701C003838003838003
838001C70001C70001C70000EE0000EE0000EE00007C00007C0000380017157F941A>I<FF83FE
FFC7FEFF83FE3800383800381C00701C00701C00701C38701C7C701C7C700E6CE00E6CE00EEEE0
0EEEE00EEEE00EC6E006C6C007C7C007C7C003838017157F941A>I<7FC7F87FCFFC7FC7F80703
C003838003C70001EF0000FE00007C00007800003800007C0000EE0001EE0001C7000383800783
C00F01C07FC7FCFFC7FE7FC7FC17157F941A>I<7FC3FCFFC7FE7FC3FC0E00E00E00E00700E007
01C00781C00381C003838003C38001C38001C70000E70000E70000E600006600006E00003C0000
3C00003C0000380000380000380000700000700030700078E00071E0007FC0003F80001E000017
207F941A>I<7FFFF0FFFFF0FFFFF0E001E0E003C0E00780000F00001E00003C0000780000F000
01E00003C0000780000F00381E00383C0038780038FFFFF8FFFFF8FFFFF815157E941A>I
E /Fk 21 122 df<70F8F8F87005057C840E>58 D<0000001800000078000001E0000007800000
1E00000078000003E000000F8000003C000000F0000003C000000F0000003C000000F0000000F0
0000003C0000000F00000003C0000000F00000003C0000000F80000003E0000000780000001E00
00000780000001E000000078000000181D1C7C9926>60 D<C0000000F00000003C0000000F0000
0003C0000000F00000003E0000000F80000001E0000000780000001E0000000780000001E00000
007800000078000001E00000078000001E00000078000001E000000F8000003E000000F0000003
C000000F0000003C000000F0000000C00000001D1C7C9926>62 D<007FFFFFC000078003C00007
8000C000078000C0000F0000C0000F0000C0000F000080000F000080001E000080001E00008000
1E008080001E008000003C010000003C010000003C030000003C070000007FFE00000078060000
0078060000007806000000F004000000F004000000F004010000F000020001E000020001E00002
0001E000040001E0000C0003C000080003C000180003C000300003C000700007C003F000FFFFFF
E00022227EA124>69 D<0003F010000E0C2000180260002001E0004000E000C000C0008000C001
8000C0018000C00380008003800080038000000380000003C0000001F0000001FE000000FFE000
007FF000001FF8000001FC0000003C0000001C0000000E0000000E0000000E0020000C0020000C
0020000C002000080060001800600010007000200070004000C8008000C603000081FC00001C24
7DA21E>83 D<00001E0001FC00001C00001C00001C000038000038000038000038000070000070
0000700000700000E00078E001C4E00302E00601C00E01C01C01C03C01C0380380780380780380
780380F00700F00700F00700F00708F00E10700E10701E1030262018C6200F01C017237EA219>
100 D<007C000382000701000E01001C0100380100780200700400FFF800F00000F00000E00000
E00000E00000E00000E00080E000807003003004001838000FC00011157D9417>I<00F0000FE0
0000E00000E00000E00001C00001C00001C00001C000038000038000038000038000070000071F
0007218007C0C00F00E00F00E00E00E00E00E01C01C01C01C01C01C01C01C03803803803803807
00380704700708700E08700E08700610E006206003C016237DA21C>104
D<00E000E001E000C00000000000000000000000000000000000001E0023004380438083808380
870007000E000E000E001C001C0038003820384070407040308031001E000B227EA111>I<0000
E00001E00001E00000C0000000000000000000000000000000000000000000000000000000001E
00002300004380008380010380010380010380000700000700000700000700000E00000E00000E
00000E00001C00001C00001C00001C0000380000380000380000380000700000700000700070E0
00F0C000F180006300003E0000132C81A114>I<00F0000FE00000E00000E00000E00001C00001
C00001C00001C0000380000380000380000380000700000700F00703080704380E08780E10780E
20300E40001C80001F00001FC0001C7000383800383800381C00381C1070382070382070382070
1840E00C8060070015237DA219>I<01E01FC001C001C001C00380038003800380070007000700
07000E000E000E000E001C001C001C001C0038003800380038007000700070007100E200E200E2
00620064001C000B237DA20F>I<3C07E01F00461830618047201880C087401D00E087801E00E0
87801C00E087001C00E00E003801C00E003801C00E003801C00E003801C01C007003801C007003
801C007007001C007007043800E007083800E00E083800E00E083800E006107001C006203000C0
03C026157E942B>I<3C07C04618604720308740388780388700388700380E00700E00700E0070
0E00701C00E01C00E01C01C01C01C13801C23803823803823801847001883000F018157E941D>
I<003E0000C1800380C00700E00E00E01C00F03C00F03C00F07800F07800F07800F0F001E0F001
E0F001C0F003C0700380700700700600381C001C380007E00014157E9417>I<03C0F004631C04
740E08780E08700708700708700F00E00F00E00F00E00F00E00F01C01E01C01E01C01E01C03C03
803803803803C07003C0E0072180071E000700000700000E00000E00000E00000E00001C00001C
00001C0000FFC000181F819418>I<3C0F004630C04741C08783C08783C08701808700000E0000
0E00000E00000E00001C00001C00001C00001C0000380000380000380000380000700000300000
12157E9416>114 D<007E0000810003008002018006038006030006000007000007F80003FE00
01FF00003F00000780000380700380F00300F00300E002004004003018000FE00011157E9417>
I<006000E000E000E000E001C001C001C001C00380FFFC0380038007000700070007000E000E00
0E000E001C001C001C001C08381038103820182018C007000E1F7F9E12>I<01E0F006310C081A
1C101A3C201C3C201C18201C0000380000380000380000380000700000700000700000700860E0
10F0E010F0E020E170404230803C1F0016157E941C>120 D<1E00302300704380704380E08380
E08380E08700E00701C00E01C00E01C00E01C01C03801C03801C03801C03801C07001C07001C07
001C0F000C3E0003CE00000E00000E00001C00601C00F03800F03000E0600080C0004180003E00
00141F7E9418>I E /Fl 33 122 df<0001E0000003E000000FE000007FE0001FFFE000FFFFE0
00FFBFE000E03FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003F
E000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE00000
3FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000
003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE0007FFFFFF07FFFFF
F07FFFFFF01C2E7AAD29>49 D<003FF00001FFFE0007FFFF801FC07FE03F003FF07C001FF87F00
0FFCFF8007FEFFC007FEFFC003FFFFC003FFFFC003FFFFC003FF7F8003FF3F0003FF000003FF00
0003FF000007FE000007FE000007FC00000FF800001FF800001FF000003FE000007F8000007F00
0000FE000001FC000003F0000007E000000FC007001F8007003E0007007C000F00F8000E01F000
0E01E0001E03FFFFFE07FFFFFE0FFFFFFE1FFFFFFE3FFFFFFE7FFFFFFCFFFFFFFCFFFFFFFCFFFF
FFFC202E7CAD29>I<000FFC0000007FFF800001F01FE00003C00FF00007800FF8000FE007FC00
1FF007FE001FF807FE001FF807FE001FF807FE001FF807FE001FF807FE000FF007FE0007E007FC
0001800FFC0000000FF80000000FF80000001FF00000003FE00000007F8000001FFE0000001FFC
0000001FFF800000001FF00000000FF800000007FE00000003FF00000003FF00000001FF800000
01FF800E0001FFC03F8001FFC07FC001FFC0FFE001FFC0FFE001FFC0FFE001FFC0FFE001FFC0FF
E001FF80FFE003FF807FC003FF007F0007FE003F000FFC001FE01FF80007FFFFE00001FFFF8000
001FFC0000222E7DAD29>I<0000007800000000F800000001F800000003F800000007F8000000
07F80000000FF80000001FF80000003FF80000007FF800000077F8000000F7F8000001E7F80000
03C7F800000787F800000707F800000F07F800001E07F800003C07F800007807F800007007F800
00F007F80001E007F80003C007F800078007F8000F0007F8000F0007F8001E0007F8003C0007F8
00780007F800F00007F800FFFFFFFFF0FFFFFFFFF0FFFFFFFFF000000FF80000000FF80000000F
F80000000FF80000000FF80000000FF80000000FF80000000FF80000000FF800000FFFFFF0000F
FFFFF0000FFFFFF0242E7EAD29>I<0C0000380FC003F80FFFFFF80FFFFFF00FFFFFE00FFFFFC0
0FFFFF800FFFFF000FFFFC000FFFF0000FFF00000F0000000F0000000F0000000F0000000F0000
000F0000000F0000000F1FF8000FFFFF000FFFFFC00FF01FE00F800FF00F0007F80E0007FC0000
03FE000003FE000003FE000003FF000003FF1E0003FF7F8003FFFF8003FFFFC003FFFFC003FFFF
C003FFFF8003FEFF8003FE7F0007FC7C0007FC3C000FF81E001FF00FC07FE007FFFF8001FFFE00
003FE000202E7CAD29>I<00007F80000007FFF000001FC07800007F001C0000FE001E0001FC00
7E0003F800FF0007F001FF000FF001FF001FE001FF001FE001FF003FE000FE003FE0007C007FC0
0000007FC00000007FC00000007FC0000000FFC3FF8000FFC7FFE000FFCFBFF000FFDC03FC00FF
F803FE00FFF001FF00FFF000FF00FFE000FF80FFE000FF80FFE000FFC0FFC000FFC0FFC000FFC0
FFC000FFC0FFC000FFC07FC000FFC07FC000FFC07FC000FFC07FC000FFC03FC000FFC03FC000FF
801FE000FF801FE000FF000FE001FF000FF001FE0007F803FC0001FC0FF80000FFFFE000003FFF
80000007FC0000222E7DAD29>I<000003FF80038000003FFFF007800001FFFFFC0F800007FF00
7F1F80001FF8000FFF80007FE00003FF8000FFC00001FF8001FF000000FF8003FE0000007F8007
FE0000003F800FFC0000001F801FF80000001F801FF80000000F803FF80000000F803FF0000000
0F803FF000000007807FF000000007807FF000000007807FE00000000000FFE00000000000FFE0
0000000000FFE00000000000FFE00000000000FFE00000000000FFE00000000000FFE000000000
00FFE00000000000FFE00000000000FFE00000000000FFE000000000007FE000000000007FF000
000000007FF000000003803FF000000003803FF000000003803FF800000003801FF80000000780
1FF800000007000FFC0000000F0007FE0000000E0003FF0000001E0001FF0000003C0000FFC000
007800007FE00001F000001FF80003E0000007FF003F80000001FFFFFE000000003FFFF8000000
0003FF80000031317BB03C>67 D<FFFFFFFFFFF000FFFFFFFFFFF000FFFFFFFFFFF00000FFC000
3FF00000FFC00007F80000FFC00003F80000FFC00000F80000FFC00000F80000FFC00000780000
FFC00000780000FFC00000380000FFC00000380000FFC00000380000FFC000001C0000FFC00700
1C0000FFC007001C0000FFC007001C0000FFC00700000000FFC00700000000FFC00F00000000FF
C01F00000000FFC03F00000000FFFFFF00000000FFFFFF00000000FFFFFF00000000FFC03F0000
0000FFC01F00000000FFC00F00000000FFC00700000000FFC00700000000FFC00700038000FFC0
0700038000FFC00700038000FFC00000070000FFC00000070000FFC00000070000FFC000000700
00FFC000000F0000FFC000000F0000FFC000001E0000FFC000001E0000FFC000003E0000FFC000
007E0000FFC00000FE0000FFC00003FE0000FFC0001FFE00FFFFFFFFFFFC00FFFFFFFFFFFC00FF
FFFFFFFFFC0031317EB036>69 D<FFFFFFC0FFFFFFC0FFFFFFC000FFC00000FFC00000FFC00000
FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC000
00FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC0
0000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FF
C00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000
FFC000FFFFFFC0FFFFFFC0FFFFFFC01A317EB01F>73 D<FFFFFFF00000FFFFFFF00000FFFFFFF0
000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000
FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000
000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000
FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000
000000FFC000000000FFC000007000FFC000007000FFC000007000FFC00000F000FFC00000F000
FFC00000E000FFC00000E000FFC00001E000FFC00001E000FFC00003E000FFC00003E000FFC000
07E000FFC0000FE000FFC0001FE000FFC0007FC000FFC003FFC0FFFFFFFFFFC0FFFFFFFFFFC0FF
FFFFFFFFC02C317EB032>76 D<00000FFE0000000000FFFFE000000007FFFFFC0000001FFC07FF
0000003FE000FF800000FF80003FE00001FF00001FF00003FE00000FF80007FC000007FC0007FC
000007FC000FF8000003FE001FF8000003FF001FF0000001FF003FF0000001FF803FF0000001FF
803FF0000001FF807FE0000000FFC07FE0000000FFC07FE0000000FFC0FFE0000000FFE0FFE000
0000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0
FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE07FE0000000FFC07FE00000
00FFC07FF0000001FFC07FF0000001FFC03FF0000001FF803FF0000001FF801FF8000003FF001F
F8000003FF000FFC000007FE000FFC000007FE0007FE00000FFC0003FF00001FF80001FF80003F
F00000FFC0007FE000003FE000FF8000001FFC07FF00000007FFFFFC00000000FFFFE000000000
0FFE00000033317BB03E>79 D<FFFFFFFFC0000000FFFFFFFFFC000000FFFFFFFFFF80000000FF
C001FFE0000000FFC0003FF0000000FFC0000FFC000000FFC00007FC000000FFC00007FE000000
FFC00003FF000000FFC00003FF000000FFC00003FF800000FFC00003FF800000FFC00003FF8000
00FFC00003FF800000FFC00003FF800000FFC00003FF800000FFC00003FF000000FFC00003FF00
0000FFC00007FE000000FFC00007FC000000FFC0000FFC000000FFC0003FF0000000FFC001FFE0
000000FFFFFFFF80000000FFFFFFFC00000000FFFFFFFE00000000FFC007FF80000000FFC000FF
C0000000FFC0007FE0000000FFC0003FE0000000FFC0003FF0000000FFC0001FF8000000FFC000
1FF8000000FFC0001FF8000000FFC0001FF8000000FFC0001FF8000000FFC0001FFC000000FFC0
001FFC000000FFC0001FFC000000FFC0001FFC000000FFC0001FFC004000FFC0001FFC00E000FF
C0001FFE00E000FFC0000FFE01E000FFC0000FFF01C000FFC00007FF87C0FFFFFFC003FFFF80FF
FFFFC000FFFF00FFFFFFC0001FFC003B317EB03E>82 D<001FF0038000FFFF078003FFFFCF8007
F00FFF801FC001FF801F80007F803F00003F807F00001F807E00000F807E00000F80FE00000780
FE00000780FF00000380FF00000380FF80000380FFC0000000FFE0000000FFFC0000007FFFE000
007FFFFE00003FFFFFC0003FFFFFF0001FFFFFFC000FFFFFFE0007FFFFFF0001FFFFFF00007FFF
FF80001FFFFFC00000FFFFC0000007FFC0000000FFE00000007FE00000003FE00000001FE0E000
001FE0E000000FE0E000000FE0E000000FE0F000000FE0F000000FC0F800000FC0F800001F80FC
00001F80FF00003F00FFC0007E00FFFC01FC00F9FFFFF800F03FFFE000E007FF000023317BB02E
>I<007FF8000003FFFF00000FFFFFC0001FE01FF0001FF007F8001FF007FC001FF003FC001FF0
01FE000FE001FE0007C001FE00010001FE00000001FE00000001FE000001FFFE00003FFFFE0001
FFF1FE0007FE01FE001FF001FE003FE001FE007FC001FE007F8001FE00FF8001FE00FF0001FE00
FF0001FE00FF0001FE00FF8003FE00FF8007FE007FC00FFE003FF03EFF001FFFF87FF807FFF03F
F800FF801FF825207E9F28>97 D<0007FF00007FFFE001FFFFF803FC03FC07F807FC0FF007FC1F
E007FC3FC007FC3FC003F87FC001F07F800040FF800000FF800000FF800000FF800000FF800000
FF800000FF800000FF800000FF800000FF8000007FC000007FC000003FC0000E3FE0000E1FE000
1E0FF0003C07F8007803FF01F001FFFFE0007FFF800007FC001F207D9F25>99
D<00000007E0000003FFE0000003FFE0000003FFE00000003FE00000001FE00000001FE0000000
1FE00000001FE00000001FE00000001FE00000001FE00000001FE00000001FE00000001FE00000
001FE00000001FE00000001FE0000FF81FE0007FFF1FE001FFFFDFE003FE03FFE00FF800FFE01F
F0007FE01FE0003FE03FC0001FE03FC0001FE07FC0001FE07F80001FE0FF80001FE0FF80001FE0
FF80001FE0FF80001FE0FF80001FE0FF80001FE0FF80001FE0FF80001FE0FF80001FE0FF80001F
E07F80001FE07FC0001FE07FC0001FE03FC0003FE01FE0007FE01FE000FFE00FF001FFE007FC07
DFF001FFFF9FFF007FFE1FFF000FF01FFF28327DB12E>I<000FFE0000007FFFC00001FFFFE000
03FE0FF00007F801F8000FF000FC001FE000FE003FC0007F003FC0007F007FC0003F007F80003F
807F80003F80FF80003F80FF80003F80FFFFFFFF80FFFFFFFF80FFFFFFFF80FF80000000FF8000
0000FF800000007F800000007F800000007FC00000003FC00003803FE00003801FE00007800FF0
000F0007F8003E0003FF01FC0000FFFFF800003FFFE0000007FF000021207E9F26>I<0000FF00
0007FFC0001FFFF0007FC7F000FF0FF801FF0FF801FE0FF803FE0FF803FC0FF803FC07F003FC01
C003FC000003FC000003FC000003FC000003FC000003FC000003FC0000FFFFF800FFFFF800FFFF
F80003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC000003
FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC0000
03FC000003FC000003FC000003FC000003FC000003FC000003FC00007FFFF0007FFFF0007FFFF0
001D327EB119>I<001FF007E000FFFE3FF003FFFFFFF807F83FF1F80FE00FE1F81FE00FF1F81F
C007F0603FC007F8003FC007F8003FC007F8003FC007F8003FC007F8003FC007F8003FC007F800
1FC007F0001FE00FF0000FE00FE00007F83FC00007FFFF80000EFFFE00000E1FF000000E000000
001E000000001E000000001F000000001F800000001FFFFFC0000FFFFFF8000FFFFFFE0007FFFF
FF8007FFFFFFC007FFFFFFE01FFFFFFFE03F00007FE07E00000FF0FE000007F0FC000003F0FC00
0003F0FC000003F0FE000007F07E000007E07F00000FE03FC0003FC01FF801FF8007FFFFFE0000
FFFFF000001FFF8000252F7E9F29>I<01F800000000FFF800000000FFF800000000FFF8000000
000FF80000000007F80000000007F80000000007F80000000007F80000000007F80000000007F8
0000000007F80000000007F80000000007F80000000007F80000000007F80000000007F8000000
0007F80000000007F807F8000007F83FFF000007F87FFF800007F9F03FC00007FBC01FE00007FF
801FE00007FF000FF00007FE000FF00007FC000FF00007FC000FF00007F8000FF00007F8000FF0
0007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8
000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF0
0007F8000FF00007F8000FF00007F8000FF00007F8000FF000FFFFC1FFFF80FFFFC1FFFF80FFFF
C1FFFF8029327DB12E>I<03C0000FF0001FF8001FF8001FF8001FFC001FF8001FF8001FF8000F
F00003C00000000000000000000000000000000000000000000000000001F800FFF800FFF800FF
F8000FF80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007
F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F800FF
FF80FFFF80FFFF8011337DB217>I<01F800FFF800FFF800FFF8000FF80007F80007F80007F800
07F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F800
07F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F800
07F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F800
FFFFC0FFFFC0FFFFC012327DB117>108 D<03F007F8000FF000FFF03FFF007FFE00FFF07FFF80
FFFF00FFF1F03FC3E07F800FF3C01FE7803FC007F7801FEF003FC007F7000FFE001FE007FE000F
FC001FE007FC000FF8001FE007FC000FF8001FE007F8000FF0001FE007F8000FF0001FE007F800
0FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8
000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007
F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE0
07F8000FF0001FE007F8000FF0001FE0FFFFC1FFFF83FFFFFFFFC1FFFF83FFFFFFFFC1FFFF83FF
FF40207D9F45>I<03F007F80000FFF03FFF0000FFF07FFF8000FFF1F03FC0000FF3C01FE00007
F7801FE00007F7000FF00007FE000FF00007FC000FF00007FC000FF00007F8000FF00007F8000F
F00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007
F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000F
F00007F8000FF00007F8000FF00007F8000FF00007F8000FF000FFFFC1FFFF80FFFFC1FFFF80FF
FFC1FFFF8029207D9F2E>I<0007FE0000003FFFC00000FFFFF00003FC03FC0007F000FE000FE0
007F001FC0003F803FC0003FC03FC0003FC07F80001FE07F80001FE07F80001FE0FF80001FF0FF
80001FF0FF80001FF0FF80001FF0FF80001FF0FF80001FF0FF80001FF0FF80001FF07F80001FE0
7F80001FE07F80001FE03FC0003FC03FC0003FC01FE0007F800FE0007F0007F801FE0003FE07FC
0001FFFFF800003FFFC0000007FE000024207E9F29>I<01F80FF000FFF87FFE00FFF9FFFF80FF
FFE07FE00FFF001FF007FE000FF807FC0007F807F80007FC07F80003FE07F80003FE07F80003FE
07F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80001
FF07F80001FF07F80003FF07F80003FE07F80003FE07F80003FC07FC0007FC07FC000FF807FE00
0FF007FF801FE007FFE07FC007F9FFFF8007F87FFE0007F81FE00007F800000007F800000007F8
00000007F800000007F800000007F800000007F800000007F800000007F800000007F800000007
F8000000FFFFC00000FFFFC00000FFFFC00000282E7E9F2E>I<03F03F00FFF0FFC0FFF1FFF0FF
F3C7F00FF78FF807F70FF807FE0FF807FE0FF807FC07F007FC03E007FC008007FC000007F80000
07F8000007F8000007F8000007F8000007F8000007F8000007F8000007F8000007F8000007F800
0007F8000007F8000007F8000007F8000007F8000007F80000FFFFE000FFFFE000FFFFE0001D20
7E9F22>114 D<00FF870007FFEF001FFFFF003F007F007C001F007C000F00F8000F00F8000700
FC000700FC000700FF000000FFF800007FFFC0007FFFF0003FFFFC001FFFFE0007FFFF0001FFFF
80001FFF800000FFC000001FC0E0000FC0E0000FC0F00007C0F00007C0F80007C0FC000F80FE00
1F80FF803F00FFFFFE00F3FFF800E07FC0001A207D9F21>I<0038000038000038000038000038
0000780000780000780000F80000F80001F80003F80007F8001FF800FFFFFEFFFFFEFFFFFE07F8
0007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F8
0007F80007F80007F80707F80707F80707F80707F80707F80707F80707FC0F03FC0E03FE1E01FF
FC007FF8000FE0182E7EAD20>I<01F80003F000FFF801FFF000FFF801FFF000FFF801FFF0000F
F8001FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000F
F00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007
F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8001F
F00007F8001FF00007F8003FF00007F8007FF00003FC00FFF00003FE03EFF80001FFFFCFFF8000
7FFF0FFF80000FFC0FFF8029207D9F2E>I<FFFF0FFFF01FFEFFFF0FFFF01FFEFFFF0FFFF01FFE
0FF0007E0003F00FF8007F0001E007F8007F0001C007F8003F8003C003FC003F80038003FC007F
C0038003FE007FC0078001FE00FFC0070001FF00EFE00F0000FF00EFE00E0000FF01C7F00E0000
7F81C7F01C00007F83C7F01C00007FC383F83C00003FC383F83800003FC701FC3800001FE701FC
7000001FEF01FC7000001FFE00FEF000000FFE00FEE000000FFC007FE0000007FC007FC0000007
FC007FC0000007F8003FC0000003F8003F80000003F0001F80000001F0001F00000001E0000F00
000000E0000E000037207E9F3C>119 D<FFFF00FFFCFFFF00FFFCFFFF00FFFC07F8001F8003FC
001E0001FE003C0000FF00780000FF80F000007FC1E000003FC1E000001FE3C000000FF7800000
07FF00000007FE00000003FE00000001FE00000000FF00000001FF80000001FFC0000003FFE000
00079FF000000F0FF000001E07F800003C03FC00007801FE0000F001FF0001E000FF8001E0007F
C007E0003FC0FFF801FFFEFFF801FFFEFFF801FFFE27207E9F2C>I<FFFF801FFEFFFF801FFEFF
FF801FFE07F80003E007F80001C007FC0003C003FC00038003FE00078001FE00070001FF000F00
00FF000E0000FF801E00007F801C00007FC03C00003FC03800003FE03800001FE07000001FE070
00000FF0E000000FF0E000000FF9E0000007F9C0000007FFC0000003FF80000003FF80000001FF
00000001FF00000000FE00000000FE000000007C000000007C0000000038000000003800000000
70000000007000000000F000003C00E000007E01E00000FF01C00000FF03800000FF07800000FF
0F0000007A3E0000007FFC0000003FF80000000FC0000000272E7E9F2C>I
E /Fm 25 90 df<0004000C007C079C001C001C00380038003800380038003800700070007000
700070007000E000E000E000E000E000E001C001C001C001C001C001C003C003C0FFFE0F217CA0
18>49 D<001F8000E0E00100700200780400780780780F80780F80780700F80000F00000F00001
E00001C0000380000E0000FC000007000003800003C00001E00001E00001E00001F03001F07803
E0F803E0F803E0F003C08007C0400780400F00200E00183C0007E00015227DA018>51
D<0000400000C00001C00001C00003C00005C0000F80000B8000138000238000438000C3800087
00010700020700060700040700080700100E00300E00200E00400E00800E00FFFFF8001C00001C
00001C00001C00001C00001C00003800003C0007FFC015217DA018>I<00800801E03801FFF001
FFE001FF80017E00010000020000020000020000020000020000023E0004C3800501C00600C004
00E00000E00000F00000F00000F00000F00000F07000F0F801E0F001E0E001E08001C040038040
0780400700200C0018380007E00015227DA018>I<0007C000183000601000C038018078038078
0700700E00000E00001C00001C00003C00003C7C003987007A03807C01807C01C07801C0F801E0
F801E0F001E0F001E0F001E0F001E0F003C0F003C0E003C0E00380700700700700300E00381C00
1C300007C00015227CA018>I<0000040000000006000000000E000000001E000000001E000000
003E000000003F000000004F000000004F000000008F000000008F000000010F00000001078000
0002078000000207800000040780000004078000000807C000000803C000001003C000001003C0
00002003C000003FFFE000004001E000004001E000008001E000008001E000010001E000010000
F000020000F000060000F000040000F0000C0000F0003E0001F800FF800FFF8021237EA225>65
D<0001FC02000F0306003C008C0070005C00E0003C01C0003C0380001C0700001C0F0000181E00
00181E0000083E0000083C0000087C0000087C000000F8000000F8000000F8000000F8000000F8
000000F0000000F0000000F0000000F0000020F0000020F0000040F80000407800004078000080
380001003C0001001C0002000E000C000700100001C0E000003F00001F247AA223>67
D<03FFFFC000003E00F000003C003C00003C001E00003C000E00003C000F00003C000780007800
0780007800078000780007C000780003C000780003C000780007C000F00007C000F00007C000F0
0007C000F00007C000F00007C000F00007C001E0000F8001E0000F8001E0000F8001E0000F0001
E0001F0001E0001E0003C0001E0003C0003C0003C000780003C000700003C000E00003C001C000
078007800007C01E0000FFFFF8000022227EA125>I<03FFFFFF003E001F003C000E003C000600
3C0002003C0002003C000200780002007800020078000200780202007802000078060000F00400
00F0040000F01C0000FFFC0000F01C0000F00C0001E0080001E0080001E0080001E0080201E000
0401E0000403C0000403C0000803C0000803C0001803C0001003C00030078000F007C003E0FFFF
FFE020227EA121>I<03FFFFFF003E001F003C000E003C0006003C0002003C0002003C00020078
0002007800020078000200780202007802000078060000F0040000F0040000F01C0000FFFC0000
F01C0000F00C0001E0080001E0080001E0080001E0080001E0000001E0000003C0000003C00000
03C0000003C0000003C0000003C0000007C0000007C00000FFFE000020227EA120>I<0000FE01
00070183001C00460070002E00E0001E01C0001E0380000E0780000E0F00000C1E00000C1E0000
043E0000043C0000047C0000047C000000F8000000F8000000F8000000F8000000F8000000F000
0000F0003FFFF00001F0F00000F0F00000F0F00000F0F80001E0780001E0780001E0380001E01C
0001E00E0003E0060004C0038008C001E07040003F800020247AA226>I<03FFE0FFF8003E000F
80003C000F00003C000F00003C000F00003C000F00003C000F000078001E000078001E00007800
1E000078001E000078001E000078001E0000F0003C0000F0003C0000F0003C0000FFFFFC0000F0
003C0000F0003C0001E000780001E000780001E000780001E000780001E000780001E000780003
C000F00003C000F00003C000F00003C000F00003C000F00003C000F000078001E00007C001F000
FFFC3FFF0025227EA125>I<03FFF0003E00003C00003C00003C00003C00003C00007800007800
00780000780000780000780000F00000F00000F00000F00000F00000F00001E00001E00001E000
01E00001E00001E00003C00003C00003C00003C00003C00003C00007800007C000FFFC0014227E
A112>I<03FFF000003E0000003C0000003C0000003C0000003C0000003C000000780000007800
000078000000780000007800000078000000F0000000F0000000F0000000F0000000F0000000F0
000001E0000001E0000001E0000001E0002001E0002001E0004003C0004003C0004003C000C003
C0008003C0018003C003800780078007C01F00FFFFFF001B227EA11E>76
D<03FE00000FF8003E00001F80002F00001F00002F00002F00002F00002F00002F00004F00002F
00004F00004780009E00004780009E00004780011E00004780011E00004780021E000043C0041E
000083C0043C000083C0083C000083C0083C000083C0103C000081E0103C000081E0203C000101
E02078000101E04078000101E04078000100F08078000100F08078000100F10078000200F100F0
000200F200F00002007C00F00002007C00F00002007800F00006007800F00006007001E0001F00
3001F000FFE0203FFF002D227EA12D>I<03FE001FF8003E0003C0003F000180002F000100002F
80010000278001000027C001000043C002000043C002000041E002000041E002000040F0020000
40F002000080780400008078040000803C040000803C040000801E040000801E040001000F0800
01000F080001000F88000100078800010007C800010003C800020003D000020001F000020001F0
00020000F000020000F000060000700006000060001F00002000FFE000200025227EA125>I<00
01FC00000E0700003801C0007000E001E000F003C00078078000780700003C0F00003C1E00003C
1E00003E3C00003E3C00003E7C00003E7C00003EF800003EF800003EF800003EF800003EF80000
3EF800007CF000007CF000007CF00000F8F00000F8F80000F0F80001F0780001E0780003C07800
07803C0007001C000E000E001C000700780003C1E000007F00001F247AA226>I<03FFFFC0003E
00F0003C0078003C003C003C003E003C001E003C003E0078003E0078003E0078003E0078003E00
78003C0078007C00F0007800F000F000F001E000F0078000FFFE0000F0000001E0000001E00000
01E0000001E0000001E0000001E0000003C0000003C0000003C0000003C0000003C0000003C000
000780000007C00000FFFC00001F227EA121>I<03FFFF0000003E01E000003C007800003C003C
00003C003C00003C003E00003C003E000078003E000078003E000078003E000078003E00007800
7C00007800780000F000F00000F001E00000F007800000FFFC000000F00C000000F007000001E0
07000001E003800001E003800001E003C00001E003C00001E003C00003C007C00003C007C00003
C007C00003C007C00003C007C04003C007C080078007C08007C003E100FFFC01E3000000007C00
22237EA124>82 D<000FC0800030318000C00B0001800700038007000300030007000300070003
000E0002000E0002000F0002000F0000000F0000000F80000007E0000007FE000003FFC00001FF
E000007FF000000FF8000000F8000000780000003C0000003C0000003C0020003C004000380040
00380040003800600030006000700060006000F000C000E8018000C607000081FC000019247DA2
1B>I<1FFFFFFE3C03E03E3803C00C3003C0042003C0046003C0044003C00440078004C0078004
80078004800780040007800000078000000F0000000F0000000F0000000F0000000F0000000F00
00001E0000001E0000001E0000001E0000001E0000001E0000003C0000003C0000003C0000003C
0000003C0000003C0000007C000000FC00003FFFF0001F227AA123>I<FFF807FE0F8000F00F00
00600F0000400F0000400F0000400F0000401E0000801E0000801E0000801E0000801E0000801E
0000803C0001003C0001003C0001003C0001003C0001003C000100780002007800020078000200
7800020078000200780004007800040078000400780008007800080038001000380020001C0040
000E0080000703000000FC00001F2378A125>I<FFF83FFC03FF1F8007E000F80F0003C000700F
0003C000200F0003C000600F8003E00040078001E00040078003E00080078003E00080078005E0
0100078005E00100078009E0020007C009F0020003C010F0040003C010F0040003C020F0080003
C020F0080003C040F0100003C040F0100001E08078200001E08078200001E10078400001E10078
400001E20078800001E20078800001E40079000000F4003D000000F8003E000000F8003E000000
F8003C000000F0003C000000F0003C000000E00038000000600018000000400010000030237AA1
32>87 D<03FFE01FF8003F800FC0001F000700001F000600000F000400000F8008000007801000
0007C020000003C060000003E040000001E080000001F100000000F200000000FC000000007C00
0000007C000000003C000000003E000000005E000000009F000000010F000000030F8000000207
8000000407C000000803C000001003E000002001E000006001F000004000F000008000F8000100
0078000300007C001F8000FC00FFE007FFC025227FA125>I<FFF8003FE00FC0001F000F80000C
00078000080007C000100003C000100003E000200001E000400001F000800000F001800000F001
000000F80200000078040000007C0C0000003C080000003E100000001E200000001F400000001F
C00000000F800000000F000000000F000000000F000000000F000000000E000000001E00000000
1E000000001E000000001E000000001E000000001C000000003C000000003E00000007FFE00000
23227AA125>I E /Fn 1 14 df<0001FE0000000FFFC000003E01F00000F0003C0001C0000E00
038000070007000003800E000001C00C000000C01C000000E03800000070300000003030000000
30700000003860000000186000000018E00000001CC00000000CC00000000CC00000000CC00000
000CC00000000CC00000000CC00000000CC00000000CC00000000CE00000001C60000000186000
00001870000000383000000030300000003038000000701C000000E00C000000C00E000001C007
00000380038000070001C0000E0000F0003C00003E01F000000FFFC0000001FE0000262B7DA02D
>13 D E /Fo 43 122 df<001F83E000F06E3001C078780380F8780300F0300700700007007000
0700700007007000070070000700700007007000FFFFFF80070070000700700007007000070070
000700700007007000070070000700700007007000070070000700700007007000070070000700
7000070070000700700007007000070070007FE3FF001D20809F1B>11 D<000300C0000300C000
0300C0000701C000060180000601800006018000060180000E0380000C0300000C0300000C0300
000C0300001C0700001806007FFFFFFCFFFFFFFE00300C0000300C0000300C0000701C00006018
00006018000060180000601800FFFFFFFE7FFFFFFC01C070000180600001806000018060000180
60000380E0000300C0000300C0000300C0000300C0000701C0000601800006018000060180001F
297D9F26>35 D<70F8FCFC74040404080810102040060E7C840D>44 D<FFC0FFC00A027F8A0F>
I<70F8F8F87005057C840D>I<03F0000E1C001C0E001806003807007003807003807003807003
80F003C0F003C0F003C0F003C0F003C0F003C0F003C0F003C0F003C0F003C0F003C0F003C0F003
C07003807003807003807807803807001806001C0E000E1C0003F000121F7E9D17>48
D<018003800F80F380038003800380038003800380038003800380038003800380038003800380
03800380038003800380038003800380038007C0FFFE0F1E7C9D17>I<03F0000C1C00100E0020
0700400780800780F007C0F803C0F803C0F803C02007C00007C0000780000780000F00000E0000
1C0000380000700000600000C0000180000300000600400C00401800401000803FFF807FFF80FF
FF80121E7E9D17>I<03F0000C1C00100E00200F00780F80780780780780380F80000F80000F00
000F00000E00001C0000380003F000003C00000E00000F000007800007800007C02007C0F807C0
F807C0F807C0F00780400780400F00200E001C3C0003F000121F7E9D17>I<1803001FFE001FFC
001FF8001FE00010000010000010000010000010000010000011F000161C00180E001007001007
800003800003800003C00003C00003C07003C0F003C0F003C0E00380400380400700200600100E
000C380003E000121F7E9D17>53 D<007C000182000701000E03800C07801C0780380300380000
780000700000700000F1F000F21C00F40600F80700F80380F80380F003C0F003C0F003C0F003C0
F003C07003C07003C07003803803803807001807000C0E00061C0001F000121F7E9D17>I<03F0
000E18001C0C00380600380700700700700380F00380F00380F003C0F003C0F003C0F003C0F003
C07007C07007C03807C0180BC00E13C003E3C0000380000380000380000700300700780600780E
00700C002018001070000FC000121F7E9D17>57 D<000100000003800000038000000380000007
C0000007C0000007C0000009E0000009E0000009E0000010F0000010F0000010F0000020780000
2078000020780000403C0000403C0000403C0000801E0000801E0000FFFE0001000F0001000F00
01000F00020007800200078002000780040003C00E0003C01F0007E0FFC03FFE1F207F9F22>65
D<FFFFE0000F80380007801E0007801F0007800F0007800F8007800F8007800F8007800F800780
0F8007800F0007801F0007801E0007803C0007FFF00007803C0007801E0007800F0007800F8007
800780078007C0078007C0078007C0078007C0078007C00780078007800F8007800F0007801F00
0F803C00FFFFF0001A1F7E9E20>I<000FC040007030C001C009C0038005C0070003C00E0001C0
1E0000C01C0000C03C0000C07C0000407C00004078000040F8000000F8000000F8000000F80000
00F8000000F8000000F8000000F8000000F8000000780000007C0000407C0000403C0000401C00
00401E0000800E000080070001000380020001C0040000703800000FC0001A217D9F21>I<FFFF
E0000F803C0007801E000780070007800380078003C0078001E0078001E0078001F0078000F007
8000F0078000F8078000F8078000F8078000F8078000F8078000F8078000F8078000F8078000F8
078000F0078000F0078000F0078001E0078001E0078003C0078003800780070007800E000F803C
00FFFFE0001D1F7E9E23>I<FFF8FFF80F800F8007800F0007800F0007800F0007800F0007800F
0007800F0007800F0007800F0007800F0007800F0007800F0007800F0007FFFF0007800F000780
0F0007800F0007800F0007800F0007800F0007800F0007800F0007800F0007800F0007800F0007
800F0007800F0007800F000F800F80FFF8FFF81D1F7E9E22>72 D<FFFC0FC00780078007800780
078007800780078007800780078007800780078007800780078007800780078007800780078007
800780078007800FC0FFFC0E1F7F9E10>I<FFFC0FFC0FC003E007800180078001000780020007
8004000780080007801000078020000780400007808000078100000783000007878000078F8000
0793C0000791E00007A1E00007C0F0000780F0000780780007803C0007803C0007801E0007801E
0007800F000780078007800780078007C00FC007E0FFFC3FFC1E1F7E9E23>75
D<FF80001FF80F80001F800780001F0005C0002F0005C0002F0005C0002F0004E0004F0004E000
4F000470008F000470008F000470008F000438010F000438010F000438010F00041C020F00041C
020F00041C020F00040E040F00040E040F00040E040F000407080F000407080F000407080F0004
03900F000403900F000401E00F000401E00F000401E00F000E00C00F001F00C01F80FFE0C1FFF8
251F7E9E2A>77 D<FFFF80000F80F0000780780007803C0007801E0007801E0007801F0007801F
0007801F0007801F0007801E0007801E0007803C00078078000780F00007FF80000781C0000780
E0000780F0000780700007807800078078000780780007807C0007807C0007807C0007807C0407
807E0407803E040FC01E08FFFC0F10000003E01E207E9E21>82 D<07E0800C1980100780300380
600180600180E00180E00080E00080E00080F00000F000007800007F00003FF0001FFC000FFE00
03FF00001F800007800003C00003C00001C08001C08001C08001C08001C0C00180C00380E00300
F00600CE0C0081F80012217D9F19>I<7FFFFFE0780F01E0600F0060400F0020400F0020C00F00
30800F0010800F0010800F0010800F0010000F0000000F0000000F0000000F0000000F0000000F
0000000F0000000F0000000F0000000F0000000F0000000F0000000F0000000F0000000F000000
0F0000000F0000000F0000000F0000001F800007FFFE001C1F7E9E21>I<FFFC3FF80FC007C007
800380078001000780010007800100078001000780010007800100078001000780010007800100
078001000780010007800100078001000780010007800100078001000780010007800100078001
000780010007800100038002000380020001C0020001C0040000E008000070180000382000000F
C0001D207E9E22>I<1FE000303000781800781C00300E00000E00000E00000E0000FE00078E00
1E0E00380E00780E00F00E10F00E10F00E10F01E10781E103867200F83C014147E9317>97
D<0E0000FE00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E3E
000EC3800F01C00F00E00E00E00E00700E00700E00780E00780E00780E00780E00780E00780E00
700E00700E00E00F00E00D01C00CC300083E0015207F9F19>I<03F80E0C1C1E381E380C700070
00F000F000F000F000F000F00070007000380138011C020E0C03F010147E9314>I<03F0000E1C
001C0E00380700380700700700700380F00380F00380FFFF80F00000F00000F000007000007000
003800801800800C010007060001F80011147F9314>101 D<007C00C6018F038F070607000700
07000700070007000700FFF0070007000700070007000700070007000700070007000700070007
0007000700070007007FF01020809F0E>I<0E0000FE00000E00000E00000E00000E00000E0000
0E00000E00000E00000E00000E00000E3E000E43000E81800F01C00F01C00E01C00E01C00E01C0
0E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C0FFE7FC16207F
9F19>104 D<1C001E003E001E001C000000000000000000000000000E007E000E000E000E000E
000E000E000E000E000E000E000E000E000E000E000E000E000E00FFC00A1F809E0C>I<0E00FE
000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E00
0E000E000E000E000E000E000E000E000E000E00FFE00B20809F0C>108
D<0E1F01F000FE618618000E81C81C000F00F00E000F00F00E000E00E00E000E00E00E000E00E0
0E000E00E00E000E00E00E000E00E00E000E00E00E000E00E00E000E00E00E000E00E00E000E00
E00E000E00E00E000E00E00E000E00E00E00FFE7FE7FE023147F9326>I<0E3E00FE43000E8180
0F01C00F01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C0
0E01C00E01C00E01C0FFE7FC16147F9319>I<01F800070E001C03803801C03801C07000E07000
E0F000F0F000F0F000F0F000F0F000F0F000F07000E07000E03801C03801C01C0380070E0001F8
0014147F9317>I<0E3E00FEC3800F01C00F00E00E00E00E00F00E00700E00780E00780E00780E
00780E00780E00780E00700E00F00E00E00F01E00F01C00EC3000E3E000E00000E00000E00000E
00000E00000E00000E00000E0000FFE000151D7F9319>I<0E78FE8C0F1E0F1E0F0C0E000E000E
000E000E000E000E000E000E000E000E000E000E000E00FFE00F147F9312>114
D<1F9030704030C010C010C010E00078007F803FE00FF00070803880188018C018C018E030D060
8F800D147E9312>I<020002000200060006000E000E003E00FFF80E000E000E000E000E000E00
0E000E000E000E000E000E080E080E080E080E080610031001E00D1C7F9B12>I<0E01C0FE1FC0
0E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C0
0E01C00E03C00603C0030DC001F1FC16147F9319>I<FF83F81E01E01C00C00E00800E00800E00
8007010007010003820003820003820001C40001C40001EC0000E80000E8000070000070000070
0000200015147F9318>I<FF9FE1FC3C0780701C0300601C0380200E0380400E0380400E03C040
0707C0800704C0800704E080038861000388710003C8730001D0320001D03A0000F03C0000E01C
0000E01C0000601800004008001E147F9321>I<FF83F81E01E01C00C00E00800E00800E008007
010007010003820003820003820001C40001C40001EC0000E80000E80000700000700000700000
2000002000004000004000004000F08000F08000F100006200003C0000151D7F9318>121
D E /Fp 80 123 df<001F83E000706E3000C07C780180F8780380F07807007000070070000700
7000070070000700700007007000070070000700700007007000FFFFFFC0070070000700700007
007000070070000700700007007000070070000700700007007000070070000700700007007000
070070000700700007007000070070000700700007007000070078007FE3FF801D2380A21C>11
D<001FC0000070200000C010000180380003807800070078000700300007000000070000000700
000007000000070000000700000007000000FFFFF8000700780007003800070038000700380007
003800070038000700380007003800070038000700380007003800070038000700380007003800
07003800070038000700380007003800070038007FE1FF80192380A21B>I<001FD80000703800
00C078000180780003807800070038000700380007003800070038000700380007003800070038
000700380007003800FFFFF8000700380007003800070038000700380007003800070038000700
380007003800070038000700380007003800070038000700380007003800070038000700380007
00380007003800070038007FF3FF80192380A21B>I<000FC07F00007031C08000E00B00400180
1E00E003803E01E007003C01E007001C00C007001C000007001C000007001C000007001C000007
001C000007001C000007001C0000FFFFFFFFE007001C01E007001C00E007001C00E007001C00E0
07001C00E007001C00E007001C00E007001C00E007001C00E007001C00E007001C00E007001C00
E007001C00E007001C00E007001C00E007001C00E007001C00E007001C00E007001C00E07FF1FF
CFFE272380A229>I<7038F87CFC7EFC7E743A0402040204020402080408041008100820104020
0F0F7EA218>34 D<0000C018000000C018000000C018000001C038000001803000000180300000
018030000003807000000300600000030060000003006000000700E000000600C000000600C000
000600C000000E01C000000C018000FFFFFFFFC0FFFFFFFFC00018030000001803000000180300
0000380700000030060000003006000000300600000030060000FFFFFFFFC0FFFFFFFFC000600C
000000E01C000000C018000000C018000000C018000001C0380000018030000001803000000180
30000003807000000300600000030060000003006000000700E000000600C000000600C0000022
2D7DA229>I<003C000000006200000000C2000000018100000001810000000381000000038100
000003810000000381000000038200000003820000000384000000038800000001C800000001D0
00000001E003FF8001C0007C0000E000380001E000300001F00020000270004000047000400008
38008000183C008000301C010000701E020000700E020000F007040000F007880000F003880000
F001D00100F000E0010078007003003800B802003C031C04000E0C0E0C0003F003F00021257EA3
26>38 D<70F8FCFC7404040404080810102040060F7CA20E>I<00200040008001000300060004
000C000C00180018003000300030007000600060006000E000E000E000E000E000E000E000E000
E000E000E000E000E000E0006000600060007000300030003000180018000C000C000400060003
0001000080004000200B327CA413>I<800040002000100018000C000400060006000300030001
800180018001C000C000C000C000E000E000E000E000E000E000E000E000E000E000E000E000E0
00E000C000C000C001C0018001800180030003000600060004000C00180010002000400080000B
327DA413>I<000180000001800000018000000180000001800000018000000180000001800000
01800000018000000180000001800000018000000180000001800000018000FFFFFFFEFFFFFFFE
000180000001800000018000000180000001800000018000000180000001800000018000000180
000001800000018000000180000001800000018000000180001F227D9C26>43
D<70F8FCFC7404040404080810102040060F7C840E>I<FFE0FFE00B027F8B10>I<70F8F8F87005
057C840E>I<000180000180000380000300000300000700000600000600000E00000C00000C00
001C0000180000180000180000380000300000300000700000600000600000E00000C00000C000
01C0000180000180000380000300000300000700000600000600000E00000C00000C00000C0000
1C0000180000180000380000300000300000700000600000600000E00000C00000C0000011317D
A418>I<01F000071C000C06001803003803803803807001C07001C07001C07001C0F001E0F001
E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E07001
C07001C07001C07803C03803803803801C07000C0600071C0001F00013227EA018>I<00800380
0F80F3800380038003800380038003800380038003800380038003800380038003800380038003
8003800380038003800380038003800380038007C0FFFE0F217CA018>I<03F0000C1C00100700
2007804003C04003C08003E0F003E0F801E0F801E0F801E02003E00003E00003C00003C0000780
000700000E00001C0000180000300000600000C000018000010000020020040020080020180060
3000403FFFC07FFFC0FFFFC013217EA018>I<03F8000C1E001007002007804007C07807C07803
C07807C03807C0000780000780000700000F00000E0000380003F000001C00000F000007800007
800003C00003C00003E02003E07003E0F803E0F803E0F003C04003C0400780200780100F000C1C
0003F00013227EA018>I<000200000600000E00000E00001E00001E00002E00004E00004E0000
8E00008E00010E00020E00020E00040E00040E00080E00100E00100E00200E00200E00400E0080
0E00FFFFF8000E00000E00000E00000E00000E00000E00000E00001F0001FFF015217FA018>I<
1000801E07001FFF001FFE001FF80013E00010000010000010000010000010000010000010F800
130E001407001803801003800001C00001C00001E00001E00001E00001E07001E0F001E0F001E0
E001C08001C04003C04003802007001006000C1C0003F00013227EA018>I<007E0001C1000300
800601C00E03C01C03C0180180380000380000780000700000700000F0F800F30C00F40600F403
00F80380F801C0F001C0F001E0F001E0F001E0F001E0F001E07001E07001E07001E03801C03801
C01803801C03000C0600070C0001F00013227EA018>I<4000006000007FFFE07FFFC07FFFC040
0080C0010080010080020080020000040000080000080000100000300000200000600000600000
600000E00000C00000C00001C00001C00001C00001C00003C00003C00003C00003C00003C00003
C00003C00003C00001800013237DA118>I<01F800060E000803001001802001802000C06000C0
6000C06000C07000C07801803E01003F02001FC4000FF80003F80003FC00067F00083F80100F80
3007C06001C06000E0C000E0C00060C00060C00060C000606000406000C03000801803000E0E00
03F00013227EA018>I<01F000060C000C0600180700380380700380700380F001C0F001C0F001
C0F001E0F001E0F001E0F001E0F001E07001E07003E03803E01805E00C05E00619E003E1E00001
C00001C00001C0000380000380300300780700780600700C002018001030000FC00013227EA018
>I<70F8F8F870000000000000000000000070F8F8F87005157C940E>I<FFFFFFFEFFFFFFFE0000
000000000000000000000000000000000000000000000000000000000000FFFFFFFEFFFFFFFE1F
0C7D9126>61 D<0001800000018000000180000003C0000003C0000003C0000005E0000005E000
000DF0000008F0000008F0000010F800001078000010780000203C0000203C0000203C0000401E
0000401E0000401E0000800F0000800F0000FFFF000100078001000780030007C0020003C00200
03C0040003E0040001E0040001E00C0000F00C0000F03E0001F8FF800FFF20237EA225>65
D<FFFFF8000F800E0007800780078003C0078003E0078001E0078001F0078001F0078001F00780
01F0078001F0078001E0078003E0078007C007800F8007803E0007FFFE0007800780078003C007
8001E0078001F0078000F0078000F8078000F8078000F8078000F8078000F8078000F8078001F0
078001F0078003E0078007C00F800F00FFFFFC001D227EA123>I<0007E0100038183000E00630
01C00170038000F0070000F00E0000701E0000701C0000303C0000303C0000307C000010780000
1078000010F8000000F8000000F8000000F8000000F8000000F8000000F8000000F80000007800
0000780000107C0000103C0000103C0000101C0000201E0000200E000040070000400380008001
C0010000E0020000381C000007E0001C247DA223>I<FFFFF0000F801E0007800700078003C007
8001C0078000E0078000F007800078078000780780007C0780003C0780003C0780003C0780003E
0780003E0780003E0780003E0780003E0780003E0780003E0780003E0780003E0780003C078000
3C0780007C0780007807800078078000F0078000E0078001E0078003C0078007000F801E00FFFF
F8001F227EA125>I<FFFFFFC00F8007C0078001C0078000C00780004007800040078000600780
0020078000200780002007802020078020000780200007802000078060000780E00007FFE00007
80E000078060000780200007802000078020000780200807800008078000080780001007800010
07800010078000300780003007800070078000E00F8003E0FFFFFFE01D227EA121>I<FFFFFFC0
0F8007C0078001C0078000C0078000400780004007800060078000200780002007800020078020
20078020000780200007802000078060000780E00007FFE0000780E00007806000078020000780
200007802000078020000780000007800000078000000780000007800000078000000780000007
800000078000000FC00000FFFE00001B227EA120>I<0007F008003C0C1800E0021801C001B803
8000F8070000780F0000381E0000381E0000183C0000183C0000187C0000087800000878000008
F8000000F8000000F8000000F8000000F8000000F8000000F8000000F8001FFF780000F8780000
787C0000783C0000783C0000781E0000781E0000780F00007807000078038000B801C000B800E0
0318003C0C080007F00020247DA226>I<FFFC3FFF0FC003F0078001E0078001E0078001E00780
01E0078001E0078001E0078001E0078001E0078001E0078001E0078001E0078001E0078001E007
8001E007FFFFE0078001E0078001E0078001E0078001E0078001E0078001E0078001E0078001E0
078001E0078001E0078001E0078001E0078001E0078001E0078001E00FC003F0FFFC3FFF20227E
A125>I<FFFC0FC007800780078007800780078007800780078007800780078007800780078007
80078007800780078007800780078007800780078007800780078007800FC0FFFC0E227EA112>
I<03FFF0001F00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F
00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F
00700F00F80F00F80F00F80E00F01E00401C0020380018700007C00014237EA119>I<FFFC03FF
000FC000F800078000600007800040000780008000078001000007800200000780040000078008
0000078010000007802000000780400000078080000007818000000783C000000787E000000789
E000000788F000000790F0000007A078000007C03C000007803C000007801E000007800F000007
800F00000780078000078007C000078003C000078001E000078001E000078000F000078000F800
0FC000FC00FFFC07FF8021227EA126>I<FFFE00000FC000000780000007800000078000000780
000007800000078000000780000007800000078000000780000007800000078000000780000007
800000078000000780000007800000078000000780000007800000078000800780008007800080
07800080078001800780018007800100078003000780030007800F000F803F00FFFFFF0019227E
A11E>I<FFC00003FF0FC00003F007C00003E005E00005E005E00005E004F00009E004F00009E0
04F00009E004780011E004780011E004780011E0043C0021E0043C0021E0043C0021E0041E0041
E0041E0041E0040F0081E0040F0081E0040F0081E004078101E004078101E004078101E00403C2
01E00403C201E00401E401E00401E401E00401E401E00400F801E00400F801E00400F801E00400
7001E00E007001E01F007003F0FFE0203FFF28227EA12D>I<FF8007FF07C000F807C0007005E0
002004F0002004F0002004780020047C0020043C0020041E0020041F0020040F00200407802004
0780200403C0200401E0200401E0200400F0200400F8200400782004003C2004003E2004001E20
04000F2004000F20040007A0040003E0040003E0040001E0040001E0040000E00E0000601F0000
60FFE0002020227EA125>I<000FE00000783C0000E00E0003C00780078003C00F0001E00E0000
E01E0000F03C0000783C0000787C00007C7C00007C7800003C7800003CF800003EF800003EF800
003EF800003EF800003EF800003EF800003EF800003EF800003E7800003C7C00007C7C00007C3C
0000783E0000F81E0000F00F0001E00F0001E0078003C003C0078000E00E0000783C00000FE000
1F247DA226>I<FFFFF0000F803C0007800F0007800780078007C0078003C0078003E0078003E0
078003E0078003E0078003E0078003E0078003C0078007C00780078007800F0007803C0007FFF0
000780000007800000078000000780000007800000078000000780000007800000078000000780
0000078000000780000007800000078000000FC00000FFFC00001B227EA121>I<FFFFE000000F
803C000007800E00000780078000078007C000078003C000078003E000078003E000078003E000
078003E000078003E000078003C000078007C000078007800007800E000007803C000007FFE000
000780700000078038000007801C000007801E000007800E000007800F000007800F000007800F
000007800F000007800F800007800F800007800F800007800F808007800FC080078007C0800FC0
03C100FFFC01E2000000007C0021237EA124>82 D<03F0200C0C601802603001E07000E0600060
E00060E00060E00020E00020E00020F00000F000007800007F00003FF0001FFE000FFF0003FF80
003FC00007E00001E00000F00000F0000070800070800070800070800070C00060C00060E000C0
F000C0C80180C6070081FC0014247DA21B>I<7FFFFFF878078078600780184007800840078008
40078008C007800C80078004800780048007800480078004000780000007800000078000000780
000007800000078000000780000007800000078000000780000007800000078000000780000007
800000078000000780000007800000078000000780000007800000078000000FC00003FFFF001E
227EA123>I<FFFC07FF0FC000F807800070078000200780002007800020078000200780002007
800020078000200780002007800020078000200780002007800020078000200780002007800020
07800020078000200780002007800020078000200780002007800020078000200380004003C000
4003C0004001C0008000E000800060010000300600001C08000003F00020237EA125>I<FFF000
7FC01F80001F000F00000C000780000C000780000800078000080003C000100003C000100003E0
00300001E000200001E000200000F000400000F000400000F00040000078008000007800800000
7C018000003C010000003C010000001E020000001E020000001F020000000F040000000F040000
000F8C0000000788000000078800000003D000000003D000000003F000000001E000000001E000
000000C000000000C000000000C0000022237FA125>I<FFF03FFC03FE1F8007E000F80F0003C0
00700F0003C000200F0003C00020078001E00040078001E00040078001E0004003C002F0008003
C002F0008003C002F0008001E00478010001E00478010001E00478010000F0083C020000F0083C
020000F0083C020000F8183E06000078101E04000078101E0400007C101E0400003C200F080000
3C200F0800003C200F0800001E40079000001E40079000001E40079000000F8003E000000F8003
E000000F8003E00000070001C00000070001C00000070001C0000003000180000002000080002F
237FA132>I<FFF0007FC01F80001F000F80000C00078000080007C000180003E000100001E000
200001F000200000F000400000F800C000007C008000003C010000003E010000001E020000001F
040000000F84000000078800000007D800000003D000000003E000000001E000000001E0000000
01E000000001E000000001E000000001E000000001E000000001E000000001E000000001E00000
0001E000000001E000000003E00000003FFF000022227FA125>89 D<7FFFFE7E003E78003C7000
786000784000F0C000F0C001E08003C08003C0800780000780000F00001F00001E00003C00003C
0000780000780000F00001F00001E00103C00103C0010780010780030F00031E00021E00023C00
063C000E78001EF8007EFFFFFE18227DA11E>I<FEFEC0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0
C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0FEFE07317BA40E>I<0804
100820102010402040208040804080408040B85CFC7EFC7E7C3E381C0F0F7AA218>I<FEFE0606
060606060606060606060606060606060606060606060606060606060606060606060606060606
06060606FEFE07317FA40E>I<0FE0001838003C0C003C0E0018070000070000070000070000FF
0007C7001E07003C0700780700700700F00708F00708F00708F00F087817083C23900FC1E01515
7E9418>97 D<0E0000FE00001E00000E00000E00000E00000E00000E00000E00000E00000E0000
0E00000E00000E00000E1F000E61C00E80600F00300E00380E003C0E001C0E001E0E001E0E001E
0E001E0E001E0E001E0E001E0E001C0E003C0E00380F00700C80600C41C0083F0017237FA21B>
I<01FE000703000C07801C0780380300780000700000F00000F00000F00000F00000F00000F000
00F000007000007800403800401C00800C010007060001F80012157E9416>I<0000E0000FE000
01E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E001F8E007
04E00C02E01C01E03800E07800E07000E0F000E0F000E0F000E0F000E0F000E0F000E0F000E070
00E07800E03800E01801E00C02E0070CF001F0FE17237EA21B>I<01FC000707000C03801C01C0
3801C07801E07000E0F000E0FFFFE0F00000F00000F00000F00000F00000700000780020380020
1C00400E008007030000FC0013157F9416>I<003C00C6018F038F030F07000700070007000700
0700070007000700FFF80700070007000700070007000700070007000700070007000700070007
0007000700070007807FF8102380A20F>I<00007001F198071E180E0E181C07001C07003C0780
3C07803C07803C07801C07001C07000E0E000F1C0019F0001000001000001800001800001FFE00
0FFFC00FFFE03800F0600030400018C00018C00018C000186000306000303800E00E038003FE00
15217F9518>I<0E0000FE00001E00000E00000E00000E00000E00000E00000E00000E00000E00
000E00000E00000E00000E1F800E60C00E80E00F00700F00700E00700E00700E00700E00700E00
700E00700E00700E00700E00700E00700E00700E00700E00700E00700E0070FFE7FF18237FA21B
>I<1C001E003E001E001C00000000000000000000000000000000000E00FE001E000E000E000E
000E000E000E000E000E000E000E000E000E000E000E000E000E000E00FFC00A227FA10E>I<01
C003E003E003E001C00000000000000000000000000000000001E00FE001E000E000E000E000E0
00E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E060
E0F0C0F18061803E000B2C82A10F>I<0E0000FE00001E00000E00000E00000E00000E00000E00
000E00000E00000E00000E00000E00000E00000E03FC0E01F00E01C00E01800E02000E04000E08
000E10000E38000EF8000F1C000E1E000E0E000E07000E07800E03C00E01C00E01E00E00F00E00
F8FFE3FE17237FA21A>I<0E00FE001E000E000E000E000E000E000E000E000E000E000E000E00
0E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E
00FFE00B237FA20E>I<0E1FC07F00FE60E183801E807201C00F003C00E00F003C00E00E003800
E00E003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E0038
00E00E003800E00E003800E00E003800E00E003800E00E003800E00E003800E0FFE3FF8FFE2715
7F942A>I<0E1F80FE60C01E80E00F00700F00700E00700E00700E00700E00700E00700E00700E
00700E00700E00700E00700E00700E00700E00700E00700E0070FFE7FF18157F941B>I<01FC00
0707000C01801800C03800E0700070700070F00078F00078F00078F00078F00078F00078F00078
7000707800F03800E01C01C00E038007070001FC0015157F9418>I<0E1F00FE61C00E80600F00
700E00380E003C0E001C0E001E0E001E0E001E0E001E0E001E0E001E0E001E0E003C0E003C0E00
380F00700E80E00E41C00E3F000E00000E00000E00000E00000E00000E00000E00000E00000E00
00FFE000171F7F941B>I<01F8200704600E02601C01603801E07800E07800E0F000E0F000E0F0
00E0F000E0F000E0F000E0F000E07000E07800E03801E01C01E00C02E0070CE001F0E00000E000
00E00000E00000E00000E00000E00000E00000E00000E0000FFE171F7E941A>I<0E3CFE461E8F
0F0F0F060F000E000E000E000E000E000E000E000E000E000E000E000E000E000F00FFF010157F
9413>I<0F8830786018C018C008C008E008F0007F803FE00FF001F8003C801C800C800CC00CC0
08E018D0308FC00E157E9413>I<02000200020002000600060006000E001E003E00FFF80E000E
000E000E000E000E000E000E000E000E000E000E040E040E040E040E040E040708030801F00E1F
7F9E13>I<0E0070FE07F01E00F00E00700E00700E00700E00700E00700E00700E00700E00700E
00700E00700E00700E00700E00700E00F00E00F006017003827800FC7F18157F941B>I<FFC1FE
1E00780E00300E00200E002007004007004003808003808003808001C10001C10000E20000E200
00E20000740000740000380000380000380000100017157F941A>I<FF8FF8FF1E01E03C1C01C0
180E01C0180E01E0100E01E01007026020070270200702702003843040038438400384384001C8
188001C81C8001C81C8000F00D0000F00F0000F00F0000600600006006000060060020157F9423
>I<FF83FE1F01F00E00C007008003810003830001C20000E400007800007800003800003C0000
4E00008E000187000103800201C00401E00C00E03E01F0FF03FE17157F941A>I<FFC1FE1E0078
0E00300E00200E002007004007004003808003808003808001C10001C10000E20000E20000E200
007400007400003800003800003800001000001000002000002000002000004000F04000F08000
F180004300003C0000171F7F941A>I<3FFFC0380380300780200700600E00401C00403C004038
0000700000E00001E00001C0000380400700400F00400E00C01C0080380080780180700780FFFF
8012157F9416>I E /Fq 55 122 df<000FF83F00007FFDFFC001F81FE3E003E03F87E007C03F
87E00F803F07E00F803F03C00F801F00000F801F00000F801F00000F801F00000F801F00000F80
1F0000FFFFFFFC00FFFFFFFC000F801F00000F801F00000F801F00000F801F00000F801F00000F
801F00000F801F00000F801F00000F801F00000F801F00000F801F00000F801F00000F801F0000
0F801F00000F801F00000F801F00000F801F00000F801F00007FF0FFF0007FF0FFF00023237FA2
21>11 D<000FF000007FFC0001F80E0003E01F0007C03F000F803F000F803F000F801E000F800C
000F8000000F8000000F8000000F800000FFFFFF00FFFFFF000F801F000F801F000F801F000F80
1F000F801F000F801F000F801F000F801F000F801F000F801F000F801F000F801F000F801F000F
801F000F801F000F801F000F801F000F801F007FF0FFE07FF0FFE01B237FA21F>I<387CFEFFFF
7F3B03030706060C1C18702008117CA210>39 D<387CFEFEFE7C3807077C8610>46
D<00FE0007FFC00F83E01F01F03E00F83E00F87C007C7C007C7C007CFC007CFC007EFC007EFC00
7EFC007EFC007EFC007EFC007EFC007EFC007EFC007EFC007EFC007EFC007E7C007C7C007C7C00
7C3E00F83E00F81F01F00F83E007FFC000FE0017207E9F1C>48 D<00180000780001F800FFF800
FFF80001F80001F80001F80001F80001F80001F80001F80001F80001F80001F80001F80001F800
01F80001F80001F80001F80001F80001F80001F80001F80001F80001F80001F80001F80001F800
7FFFE07FFFE013207C9F1C>I<03FC000FFF003C1FC07007E07C07F0FE03F0FE03F8FE03F8FE01
F87C01F83803F80003F80003F00003F00007E00007C0000F80001F00003E0000380000700000E0
1801C0180380180700180E00380FFFF01FFFF03FFFF07FFFF0FFFFF0FFFFF015207D9F1C>I<00
FE0007FFC00F07E01E03F03F03F03F81F83F81F83F81F81F03F81F03F00003F00003E00007C000
1F8001FE0001FF000007C00001F00001F80000FC0000FC3C00FE7E00FEFF00FEFF00FEFF00FEFF
00FC7E01FC7801F81E07F00FFFC001FE0017207E9F1C>I<0000E00001E00003E00003E00007E0
000FE0001FE0001FE00037E00077E000E7E001C7E00187E00307E00707E00E07E00C07E01807E0
3807E07007E0E007E0FFFFFEFFFFFE0007E00007E00007E00007E00007E00007E00007E000FFFE
00FFFE17207E9F1C>I<1000201E01E01FFFC01FFF801FFF001FFE001FF8001BC0001800001800
0018000018000019FC001FFF001E0FC01807E01803E00003F00003F00003F80003F83803F87C03
F8FE03F8FE03F8FC03F0FC03F07007E03007C01C1F800FFF0003F80015207D9F1C>I<001F8000
FFE003F07007C0F00F01F81F01F83E01F83E01F87E00F07C00007C0000FC0800FC7FC0FCFFE0FD
80F0FF00F8FE007CFE007CFC007EFC007EFC007EFC007E7C007E7C007E7C007E3C007C3E007C1E
00F80F00F00783E003FFC000FF0017207E9F1C>I<6000007800007FFFFE7FFFFE7FFFFC7FFFF8
7FFFF87FFFF0E00060E000C0C00180C00300C00300000600000C00001C00001800003800007800
00780000F00000F00000F00001F00001F00001F00003F00003F00003F00003F00003F00003F000
03F00001E00017227DA11C>I<00FE0003FFC00703E00E00F01C00F01C00783C00783E00783F00
783F80783FE0F01FF9E01FFFC00FFF8007FFC003FFE007FFF01E7FF83C1FFC7807FC7801FEF000
FEF0003EF0001EF0001EF0001CF8001C7800383C00381F01F00FFFC001FF0017207E9F1C>I<01
FE0007FF800F83E01E01F03E00F07C00F87C0078FC007CFC007CFC007CFC007EFC007EFC007EFC
007E7C00FE7C00FE3E01FE1E037E0FFE7E07FC7E00207E00007C00007C1E007C3F00F83F00F83F
00F03F01E01E03C01C0F800FFE0003F80017207E9F1C>I<000070000000007000000000F80000
0000F800000000F800000001FC00000001FC00000003FE00000003FE00000003FE00000006FF00
0000067F0000000E7F8000000C3F8000000C3F800000183FC00000181FC00000381FE00000300F
E00000300FE00000600FF000006007F00000E007F80000FFFFF80000FFFFF800018001FC000180
01FC00038001FE00030000FE00030000FE000600007F000600007F00FFE00FFFF8FFE00FFFF825
227EA12A>65 D<FFFFFF8000FFFFFFE00007F001F80007F000FC0007F0007E0007F0007E0007F0
007F0007F0007F0007F0007F0007F0007F0007F0007F0007F0007E0007F000FE0007F000FC0007
F003F80007FFFFF00007FFFFF00007F001FC0007F0007E0007F0003F0007F0003F8007F0001F80
07F0001FC007F0001FC007F0001FC007F0001FC007F0001FC007F0001FC007F0003F8007F0003F
8007F0007F0007F001FE00FFFFFFF800FFFFFFC00022227EA128>I<0003FE0080001FFF818000
FF01E38001F8003F8003E0001F8007C0000F800F800007801F800007803F000003803F00000380
7F000001807E000001807E00000180FE00000000FE00000000FE00000000FE00000000FE000000
00FE00000000FE00000000FE000000007E000000007E000001807F000001803F000001803F0000
03801F800003000F8000030007C000060003F0000C0001F800380000FF00F000001FFFC0000003
FE000021227DA128>I<FFFFFF8000FFFFFFF00007F003FC0007F0007E0007F0003F0007F0001F
8007F0000FC007F00007E007F00007E007F00007F007F00003F007F00003F007F00003F007F000
03F807F00003F807F00003F807F00003F807F00003F807F00003F807F00003F807F00003F807F0
0003F807F00003F007F00003F007F00003F007F00007E007F00007E007F0000FC007F0001F8007
F0003F0007F0007E0007F003FC00FFFFFFF000FFFFFF800025227EA12B>I<FFFFFFFCFFFFFFFC
07F000FC07F0003C07F0001C07F0000C07F0000E07F0000E07F0000607F0180607F0180607F018
0607F0180007F0380007F0780007FFF80007FFF80007F0780007F0380007F0180007F0180007F0
180307F0180307F0000307F0000607F0000607F0000607F0000E07F0000E07F0001E07F0003E07
F001FCFFFFFFFCFFFFFFFC20227EA125>I<FFFFFFF8FFFFFFF807F001F807F0007807F0003807
F0001807F0001C07F0001C07F0000C07F0000C07F0180C07F0180C07F0180007F0180007F03800
07F0780007FFF80007FFF80007F0780007F0380007F0180007F0180007F0180007F0180007F000
0007F0000007F0000007F0000007F0000007F0000007F0000007F00000FFFFE000FFFFE0001E22
7EA123>I<0003FE0040001FFFC0C0007F00F1C001F8003FC003F0000FC007C00007C00FC00003
C01F800003C03F000001C03F000001C07F000000C07E000000C07E000000C0FE00000000FE0000
0000FE00000000FE00000000FE00000000FE00000000FE00000000FE000FFFFC7E000FFFFC7F00
001FC07F00001FC03F00001FC03F00001FC01F80001FC00FC0001FC007E0001FC003F0001FC001
FC003FC0007F80E7C0001FFFC3C00003FF00C026227DA12C>I<FFFFE0FFFFE003F80003F80003
F80003F80003F80003F80003F80003F80003F80003F80003F80003F80003F80003F80003F80003
F80003F80003F80003F80003F80003F80003F80003F80003F80003F80003F80003F80003F80003
F80003F800FFFFE0FFFFE013227FA115>73 D<FFFFE000FFFFE00007F0000007F0000007F00000
07F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F000
0007F0000007F0000007F0000007F0000007F0000007F0000007F0001807F0001807F0001807F0
001807F0003807F0003807F0007007F0007007F000F007F001F007F007F0FFFFFFF0FFFFFFF01D
227EA122>76 D<FFF000000FFFFFF800001FFF07F800001FE006FC000037E006FC000037E006FC
000037E0067E000067E0067E000067E0063F0000C7E0063F0000C7E0061F800187E0061F800187
E0060FC00307E0060FC00307E0060FC00307E00607E00607E00607E00607E00603F00C07E00603
F00C07E00601F81807E00601F81807E00601F81807E00600FC3007E00600FC3007E006007E6007
E006007E6007E006003FC007E006003FC007E006001F8007E006001F8007E006001F8007E00600
0F0007E0FFF00F00FFFFFFF00600FFFF30227EA135>I<FFF8001FFEFFFC001FFE07FC0000C007
FE0000C006FF0000C0067F8000C0063FC000C0061FE000C0060FE000C0060FF000C00607F800C0
0603FC00C00601FE00C00600FE00C00600FF00C006007F80C006003FC0C006001FE0C006000FF0
C0060007F0C0060007F8C0060003FCC0060001FEC0060000FFC00600007FC00600007FC0060000
3FC00600001FC00600000FC006000007C006000003C006000003C0FFF00001C0FFF00000C02722
7EA12C>I<0007FC0000003FFF800000FC07E00003F001F80007E000FC000FC0007E001F80003F
001F80003F003F00001F803F00001F807F00001FC07E00000FC07E00000FC0FE00000FE0FE0000
0FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE07E00
000FC07F00001FC07F00001FC03F00001F803F80003F801F80003F000FC0007E0007E000FC0003
F001F80000FC07E000003FFF80000007FC000023227DA12A>I<FFFFFF00FFFFFFE007F007F007
F001FC07F000FC07F0007E07F0007E07F0007F07F0007F07F0007F07F0007F07F0007F07F0007E
07F0007E07F000FC07F001FC07F007F007FFFFE007FFFF0007F0000007F0000007F0000007F000
0007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F00000FFFF
8000FFFF800020227EA126>I<FFFFFE0000FFFFFFC00007F007F00007F001F80007F000FC0007
F0007E0007F0007F0007F0007F0007F0007F0007F0007F0007F0007F0007F0007F0007F0007E00
07F000FC0007F001F80007F007F00007FFFFC00007FFFF800007F00FE00007F007F00007F003F8
0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001
FC0007F001FC0607F000FE0607F000FF0CFFFF803FF8FFFF800FF027227EA12A>82
D<01FC0407FF8C1F03FC3C007C7C003C78001C78001CF8000CF8000CFC000CFC0000FF0000FFE0
007FFF007FFFC03FFFF01FFFF80FFFFC03FFFE003FFE0003FF00007F00003F00003FC0001FC000
1FC0001FE0001EE0001EF0003CFC003CFF00F8C7FFE080FF8018227DA11F>I<7FFFFFFF807FFF
FFFF807E03F80F807803F807807003F803806003F80180E003F801C0E003F801C0C003F800C0C0
03F800C0C003F800C0C003F800C00003F800000003F800000003F800000003F800000003F80000
0003F800000003F800000003F800000003F800000003F800000003F800000003F800000003F800
000003F800000003F800000003F800000003F800000003F800000003F800000003F8000003FFFF
F80003FFFFF80022227EA127>I<FFFF800FFEFFFF800FFE07F00000C007F80000C003F8000180
03F800018001FC00030001FC00030001FE00070000FE00060000FF000600007F000C00007F800C
00003F801800003F801800003FC03800001FC03000001FE03000000FE06000000FF060000007F0
C0000007F0C0000007F9C0000003F980000003FD80000001FF00000001FF00000000FE00000000
FE00000000FE000000007C000000007C00000000380000000038000027227FA12A>86
D<FFFF800FFEFFFF800FFE07F80000C007F80001C003FC00018001FE00030001FE00070000FF00
060000FF000C00007F801C00003FC01800003FC03000001FE07000000FF06000000FF0E0000007
F8C0000003FD80000003FF80000001FF00000001FE00000000FE00000000FE00000000FE000000
00FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE0000
0000FE0000001FFFF000001FFFF00027227FA12A>89 D<07FC001FFF803F07C03F03E03F01E03F
01F01E01F00001F00001F0003FF003FDF01FC1F03F01F07E01F0FC01F0FC01F0FC01F0FC01F07E
02F07E0CF81FF87F07E03F18167E951B>97 D<FF000000FF0000001F0000001F0000001F000000
1F0000001F0000001F0000001F0000001F0000001F0000001F0000001F0000001F0FE0001F3FF8
001FF07C001F801E001F001F001F000F801F000F801F000FC01F000FC01F000FC01F000FC01F00
0FC01F000FC01F000FC01F000FC01F000F801F001F801F801F001FC03E001EE07C001C3FF80018
0FC0001A237EA21F>I<00FF8007FFE00F83F01F03F03E03F07E03F07C01E07C0000FC0000FC00
00FC0000FC0000FC0000FC00007C00007E00007E00003E00301F00600FC0E007FF8000FE001416
7E9519>I<0001FE000001FE0000003E0000003E0000003E0000003E0000003E0000003E000000
3E0000003E0000003E0000003E0000003E0001FC3E0007FFBE000F81FE001F007E003E003E007E
003E007C003E00FC003E00FC003E00FC003E00FC003E00FC003E00FC003E00FC003E00FC003E00
7C003E007C003E003E007E001E00FE000F83BE0007FF3FC001FC3FC01A237EA21F>I<00FE0007
FF800F87C01E01E03E01F07C00F07C00F8FC00F8FC00F8FFFFF8FFFFF8FC0000FC0000FC00007C
00007C00007E00003E00181F00300FC07003FFC000FF0015167E951A>I<003F8000FFC001E3E0
03C7E007C7E00F87E00F83C00F80000F80000F80000F80000F80000F8000FFFC00FFFC000F8000
0F80000F80000F80000F80000F80000F80000F80000F80000F80000F80000F80000F80000F8000
0F80000F80000F80000F80007FF8007FF80013237FA211>I<03FC1E0FFF7F1F0F8F3E07CF3C03
C07C03E07C03E07C03E07C03E07C03E03C03C03E07C01F0F801FFF0013FC003000003000003800
003FFF801FFFF00FFFF81FFFFC3800FC70003EF0001EF0001EF0001EF0001E78003C7C007C3F01
F80FFFE001FF0018217E951C>I<FF000000FF0000001F0000001F0000001F0000001F0000001F
0000001F0000001F0000001F0000001F0000001F0000001F0000001F07E0001F1FF8001F307C00
1F403C001F803E001F803E001F003E001F003E001F003E001F003E001F003E001F003E001F003E
001F003E001F003E001F003E001F003E001F003E001F003E001F003E00FFE1FFC0FFE1FFC01A23
7EA21F>I<1C003F007F007F007F003F001C000000000000000000000000000000FF00FF001F00
1F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F00FFE0FFE00B
247EA310>I<FF000000FF0000001F0000001F0000001F0000001F0000001F0000001F0000001F
0000001F0000001F0000001F0000001F0000001F00FF801F00FF801F0038001F0060001F01C000
1F0380001F0700001F0E00001F1C00001F7E00001FFF00001FCF00001F0F80001F07C0001F03E0
001F01E0001F01F0001F00F8001F007C001F003C00FFE0FFC0FFE0FFC01A237EA21E>107
D<FF00FF001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F00
1F001F001F001F001F001F001F001F001F001F001F001F001F001F00FFE0FFE00B237EA210>I<
FF07F007F000FF1FFC1FFC001F303E303E001F403E403E001F801F801F001F801F801F001F001F
001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F00
1F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F
001F00FFE0FFE0FFE0FFE0FFE0FFE02B167E9530>I<FF07E000FF1FF8001F307C001F403C001F
803E001F803E001F003E001F003E001F003E001F003E001F003E001F003E001F003E001F003E00
1F003E001F003E001F003E001F003E001F003E001F003E00FFE1FFC0FFE1FFC01A167E951F>I<
00FE0007FFC00F83E01E00F03E00F87C007C7C007C7C007CFC007EFC007EFC007EFC007EFC007E
FC007EFC007E7C007C7C007C3E00F81F01F00F83E007FFC000FE0017167E951C>I<FF0FE000FF
3FF8001FF07C001F803E001F001F001F001F801F001F801F000FC01F000FC01F000FC01F000FC0
1F000FC01F000FC01F000FC01F000FC01F001F801F001F801F803F001FC03E001FE0FC001F3FF8
001F0FC0001F0000001F0000001F0000001F0000001F0000001F0000001F0000001F000000FFE0
0000FFE000001A207E951F>I<FE1F00FE3FC01E67E01EC7E01E87E01E87E01F83C01F00001F00
001F00001F00001F00001F00001F00001F00001F00001F00001F00001F00001F0000FFF000FFF0
0013167E9517>114 D<0FF3003FFF00781F00600700E00300E00300F00300FC00007FE0007FF8
003FFE000FFF0001FF00000F80C00780C00380E00380E00380F00700FC0E00EFFC00C7F0001116
7E9516>I<0180000180000180000180000380000380000780000780000F80003F8000FFFF00FF
FF000F80000F80000F80000F80000F80000F80000F80000F80000F80000F80000F80000F81800F
81800F81800F81800F81800F830007C30003FE0000F80011207F9F16>I<FF01FE00FF01FE001F
003E001F003E001F003E001F003E001F003E001F003E001F003E001F003E001F003E001F003E00
1F003E001F003E001F003E001F003E001F003E001F007E001F00FE000F81BE0007FF3FC001FC3F
C01A167E951F>I<FFE01FE0FFE01FE00F8006000F8006000FC00E0007C00C0007E01C0003E018
0003E0180001F0300001F0300000F8600000F86000007CC000007CC000007FC000003F8000003F
8000001F0000001F0000000E0000000E00001B167F951E>I<FFE7FF07F8FFE7FF07F81F007800
C00F807801800F807C01800F807C018007C07E030007C0DE030007E0DE070003E0DF060003E18F
060001F18F0C0001F38F8C0001FB079C0000FB07D80000FE03D800007E03F000007E03F000007C
01F000003C01E000003800E000001800C00025167F9528>I<FFE07FC0FFE07FC00F801C0007C0
380003E0700003F0600001F8C00000F98000007F8000003F0000001F0000001F8000003FC00000
37C0000063E00000C1F00001C0F8000380FC0007007E000E003E00FF80FFE0FF80FFE01B167F95
1E>I<FFE01FE0FFE01FE00F8006000F8006000FC00E0007C00C0007E01C0003E0180003E01800
01F0300001F0300000F8600000F86000007CC000007CC000007FC000003F8000003F8000001F00
00001F0000000E0000000E0000000C0000000C00000018000078180000FC380000FC300000FC60
000069C000007F8000001F0000001B207F951E>I E end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 300
TeXDict begin

%%EndSetup
%%Page: 0 1
bop 605 474 a Fq(GPPL)p Fp(:)16 b(A)g(Small)f(Blo)q(c)o(k-Structured)595
534 y(Imp)q(erativ)o(e)e(Programming)i(Language)723 595 y(Implem)o(en)n(ted)e
(Using)j Fq(Ox)773 701 y Fo(b)o(y)g(Kurt)f(M.)f(Bisc)o(ho\013)868
757 y(TR#92-32)816 814 y(Decem)o(b)q(er,)h(1992)642 2140 y(Departmen)o(t)f
(of)h(Computer)f(Science)789 2196 y(226)g(A)o(tanaso\013)g(Hall)759
2253 y(Io)o(w)o(a)g(State)h(Univ)o(ersit)o(y)794 2309 y(Ames,)g(Io)o(w)o(a)f
(50011)742 2414 y(c)729 2415 y Fn(\015)q Fo(1992)g(Kurt)h(M.)f(Bisc)o(ho\013)
p eop
%%Page: 1 2
bop 164 162 a Fm(CONTENTS)1318 b Fp(1)164 315 y Fl(Con)n(ten)n(ts)164
424 y Fq(1)45 b(In)n(tro)r(duction)1209 b(3)164 533 y(2)45
b(Lexical)17 b(Elemen)n(ts)1101 b(3)164 642 y(3)45 b(Syn)n(tax)1349
b(4)237 703 y Fp(3.1)50 b(Programs)17 b(and)g(Blo)q(c)o(ks)25
b Fk(:)g(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f
(:)h(:)f(:)h(:)f(:)69 b Fp(4)237 763 y(3.2)50 b(Storage)17
b(Declarations)40 b Fk(:)25 b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f
(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)69 b Fp(4)237 823 y(3.3)50
b(F)l(unction)16 b(Declarations)51 b Fk(:)24 b(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)
h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)69 b Fp(4)237
883 y(3.4)50 b(Executable)16 b(Elemen)o(ts)32 b Fk(:)25 b(:)f(:)h(:)f(:)g(:)h
(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)69
b Fp(5)237 943 y(3.5)50 b(F)l(unction)16 b(In)o(v)o(o)q(cations)34
b Fk(:)25 b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h
(:)f(:)h(:)f(:)h(:)f(:)69 b Fp(6)237 1003 y(3.6)50 b(Con)o(trol)17
b(Statemen)o(ts)26 b Fk(:)e(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h
(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)69 b Fp(6)164 1112
y Fq(4)45 b(Comparison)18 b(with)h(Other)f(Languages)662 b(6)164
1221 y(5)45 b(Seman)n(tics)1272 b(7)237 1282 y Fp(5.1)50 b(Scop)q(e)17
b(of)f(Iden)o(ti\014ers)35 b Fk(:)24 b(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)
h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)69 b Fp(7)237
1342 y(5.2)50 b(Op)q(erators)38 b Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h
(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f
(:)69 b Fp(7)237 1402 y(5.3)50 b(T)o(yp)q(es)17 b(and)f(Casts)48
b Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f
(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)69 b Fp(8)237 1462 y(5.4)50
b(Input)16 b(and)h(Output)h Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)69 b
Fp(8)237 1522 y(5.5)50 b(Storage)17 b(Items)31 b Fk(:)25 b(:)f(:)h(:)f(:)h(:)
f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h
(:)f(:)69 b Fp(8)349 1583 y(5.5.1)56 b(Storage)18 b(Declarations)37
b Fk(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h
(:)f(:)69 b Fp(8)349 1643 y(5.5.2)56 b(Storage)18 b(References)38
b Fk(:)24 b(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)69 b Fp(9)349 1703 y(5.5.3)56 b(References)15 b(to)i(Arra)o(ys)35
b Fk(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h
(:)f(:)44 b Fp(10)237 1763 y(5.6)50 b(Compile-time)13 b(Error)k(Conditions)47
b Fk(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(10)164 1872 y Fq(6)h(Impleme)o(n)n(tation)1100 b(13)237
1932 y Fp(6.1)50 b(In)o(tro)q(duction)22 b Fk(:)i(:)h(:)f(:)h(:)f(:)h(:)f(:)h
(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f
(:)44 b Fp(13)349 1992 y(6.1.1)56 b(General)16 b(Design)h(Notes)f
Fk(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f
(:)44 b Fp(13)237 2053 y(6.2)50 b(Ov)o(erview)15 b(of)h Fq(gc)p
Fp('s)g(Source)g(Files)42 b Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g
(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(13)237 2113 y(6.3)50 b(Sym)o(b)q(ols,)15
b(Lo)q(cales,)h(and)h(En)o(vironmen)o(ts)41 b Fk(:)25 b(:)f(:)h(:)f(:)h(:)f
(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(14)237 2173 y(6.4)50
b(Construction)17 b(of)g(Sym)o(b)q(ols)e(and)i(Lo)q(cales)33
b Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(15)349 2233 y(6.4.1)56 b(Construction)17 b(of)g(Storage)g(Sym)o(b)q(ols)
44 b Fk(:)25 b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(16)349 2293 y(6.4.2)56 b(Construction)17 b(of)g(Storage)g(Lo)q(cales)29
b Fk(:)24 b(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(16)349 2354 y(6.4.3)56 b(Construction)17 b(of)g(F)l(unction)f(Sym)o(b)q
(ols)g Fk(:)25 b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(17)349 2414 y(6.4.4)56 b(Construction)17 b(of)g(F)l(unction)f(Lo)q
(cales)39 b Fk(:)25 b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(17)237 2474 y(6.5)50 b(Allo)q(cation)16 b(of)h(Registers)e(for)i
(Expression)f(Ev)m(aluation)45 b Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(17)p eop
%%Page: 2 3
bop 164 162 a Fm(CONTENTS)1318 b Fp(2)349 307 y(6.5.1)56 b(Need)16
b(for)g(Storage)h(of)g(In)o(termediate)c(Results)29 b Fk(:)24
b(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(17)349 367 y(6.5.2)56 b(Indication)16
b(of)h(a)f(Sc)o(heme)e(for)j(Register)e(Allo)q(cation)29 b
Fk(:)c(:)f(:)h(:)f(:)44 b Fp(18)349 428 y(6.5.3)56 b(A)o(ttributes)15
b(for)i(Register)f(Allo)q(cation)26 b Fk(:)f(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)44 b Fp(18)237 488 y(6.6)50 b(The)17 b Fj(env)e
Fp(A)o(ttribute)47 b Fk(:)24 b(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)
h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(19)349
548 y(6.6.1)56 b(Construction)49 b Fk(:)25 b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b
Fp(19)349 608 y(6.6.2)56 b(Inheritance)46 b Fk(:)24 b(:)h(:)f(:)h(:)f(:)g(:)h
(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(20)237 668 y(6.7)50 b(Resolution)16 b(of)h(Iden)o(ti\014er)e(References)
i Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(20)349 729 y(6.7.1)56 b(Storage)18 b(References)38 b Fk(:)24
b(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)
44 b Fp(21)349 789 y(6.7.2)56 b(F)l(unction)16 b(In)o(v)o(o)q(cations)32
b Fk(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h
(:)f(:)44 b Fp(21)237 849 y(6.8)50 b(P)o(arameter)15 b(List)i(Matc)o(hing)j
Fk(:)25 b(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)44 b Fp(21)349 909 y(6.8.1)56 b(Chec)o(king)16 b(List)g(Length)k
Fk(:)k(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)
44 b Fp(21)349 969 y(6.8.2)56 b(Other)16 b(Chec)o(ks)34 b Fk(:)25
b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)44 b Fp(22)237 1029 y(6.9)50 b(Index)16 b(Matc)o(hing)g(in)f
(Storage)j(References)d Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h
(:)f(:)44 b Fp(22)237 1090 y(6.10)26 b(Co)q(de)17 b(Generation)42
b Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f
(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(23)349 1150 y(6.10.1)32
b(T)l(arget)17 b(Language)44 b Fk(:)25 b(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h
(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(23)237 1210
y(6.11)26 b(Structure)16 b(and)h(Beha)o(vior)e(of)i(the)f(Generated)g
Fq(C)h Fp(Program)38 b Fk(:)25 b(:)f(:)h(:)f(:)44 b Fp(24)349
1270 y(6.11.1)32 b(The)17 b(Activ)m(ation)e(Stac)o(k)23 b Fk(:)h(:)h(:)f(:)h
(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(24)349 1330 y(6.11.2)32 b(F)l(unction)16 b(Calls)f Fk(:)25
b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)44 b Fp(25)349 1391 y(6.11.3)32 b(Blo)q(c)o(k)16
b(En)o(try)27 b Fk(:)d(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)
h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(25)349 1451 y(6.11.4)32
b(Blo)q(c)o(k)16 b(Exit)j Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b
Fp(25)349 1511 y(6.11.5)32 b(F)l(unction)16 b(Return)48 b Fk(:)25
b(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f
(:)44 b Fp(26)349 1571 y(6.11.6)32 b(Storage)18 b(References)c(and)j(Address)
f(Computations)i Fk(:)25 b(:)f(:)h(:)f(:)44 b Fp(26)237 1631
y(6.12)26 b Fq(C)17 b Fp(F)l(unctions)f(for)h(Co)q(de)g(Generation)33
b Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(27)349 1692 y(6.12.1)32 b Fj(newLabelNum)39 b Fk(:)25
b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)44 b Fp(27)349 1752 y(6.12.2)32 b Fj(newReturnLa)o(bel)o(Num)39
b Fk(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h
(:)f(:)44 b Fp(28)349 1812 y(6.12.3)32 b Fj(cgHeader)40 b Fk(:)25
b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f
(:)h(:)f(:)h(:)f(:)44 b Fp(28)349 1872 y(6.12.4)32 b Fj(cgTrailer)14
b Fk(:)25 b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f
(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(28)349 1932 y(6.12.5)32
b Fj(stgSize)c Fk(:)c(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h
(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(28)349 1993
y(6.12.6)32 b Fj(cgFuncAddre)o(ss)27 b Fk(:)d(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h
(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(29)349
2053 y(6.12.7)32 b Fj(cgFuncCall)27 b Fk(:)d(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h
(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(29)349 2113 y(6.12.8)32 b Fj(cgFuncTrail)o(er)27 b Fk(:)d(:)h(:)f(:)g(:)
h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fp(29)349 2173 y(6.12.9)32 b Fj(cgBlockEnte)o(r)14 b Fk(:)25
b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)44 b Fp(30)349 2233 y(6.12.10)8 b Fj(cgBlockExit)39
b Fk(:)25 b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h
(:)f(:)h(:)f(:)h(:)f(:)44 b Fp(30)p eop
%%Page: 3 4
bop 164 162 a Fm(1)49 b(INTR)o(ODUCTION)1122 b Fp(3)164 315
y Fl(1)83 b(In)n(tro)r(duction)164 425 y Fq(GPPL)19 b Fp(is)f(a)h(small,)f
(blo)q(c)o(k-structured,)g(imp)q(erativ)o(e)e(programming)h(language,)j(for)
164 485 y(whic)o(h)e(a)i(compiler,)c Fq(gc)p Fp(,)j(has)h(b)q(een)f(built)f
(using)i(the)e Fq(Y)-5 b(acc)p Fp(/)p Fq(Lex)p Fp(-based)20
b(attribute-)164 545 y(grammar)14 b(compiler)e Fq(Ox)j Fp(\(see)g([Bisc)o
(ho\013)o(]\).)20 b(This)c(pap)q(er)f(describ)q(es)g Fq(GPPL)h
Fp(and)f Fq(gc)p Fp(,)164 606 y(and)k(is)g(directed)e(mainly)f(to)j(those)g
(who)h(w)o(ould)e(lik)o(e)f(to)i(study)g(and)g(mo)q(dify)e(them.)164
666 y(The)g(implem)o(en)n(tation)e(of)i Fq(GPPL)g Fp(ma)o(y)e(b)q(e)i
(considered)g(as)g(an)g(example)e(of)i(the)g(use)164 726 y(of)g(attribute)f
(grammars)g(in)g(general)g(and)i(as)f(a)g(non)o(trivial)f(example)e
(application)j(of)164 786 y Fq(Ox)p Fp(.)237 846 y(The)j(syn)o(tax)g(of)g
Fq(GPPL)g Fp(b)q(ears)g(some)f(resem)o(blance)e(to)k(that)f(of)g
Fq(C)g Fp(but,)h(b)q(eing)164 907 y(describ)q(ed)i(in)g(only)h(ab)q(out)h
(eigh)o(t)o(y)d(grammar)g(rules,)j(lac)o(ks)e(man)o(y)f Fq(C)i
Fp(constructs.)164 967 y Fq(GPPL)p Fp('s)14 b(seman)o(tics)d(are)j(similar)e
(to)i(those)g(of)g Fq(P)n(ascal)p Fp(,)g(with)g(relativ)o(ely)d(strict)i
(error)164 1027 y(c)o(hec)o(king.)237 1087 y Fq(gc)p Fp('s)k(target)g
(language)h(is)e(a)h(v)o(ery)f(small)f(subset)i(of)g Fq(C)p
Fp(.)g(The)g(source)g(co)q(de)g(for)g Fq(gc)164 1147 y Fp(o)q(ccupies)f(ab)q
(out)i(sev)o(en)o(t)o(y)c(kilob)o(ytes)h(and)i(constitutes)f(ab)q(out)h(a)g
(dozen)f(\014les.)164 1314 y Fl(2)83 b(Lexical)26 b(Elemen)n(ts)164
1413 y Fp(The)16 b(follo)o(wing)g(are)g Fq(GPPL)p Fp('s)h(reserv)o(ed)e(w)o
(ords:)273 1504 y Fi(int)21 b(float)g(bool)g(void)g(var)273
1554 y(if)g(then)g(else)g(while)g(return)g(exit)273 1604 y(input)g(output)f
(EOF)273 1654 y(TRUE)h(FALSE)273 1703 y(,)43 b(;)h(\()f(\))g({)h(})f([)h(])
273 1753 y(!)273 1803 y(*)f(/)273 1853 y(+)g(-)273 1903 y(<)g(>)h(<=)f(>=)273
1952 y(==)g(!=)273 2002 y(&&)273 2052 y(||)273 2102 y(=)237
2204 y Fp(Iden)o(ti\014ers)11 b(are)h(sequences)g(of)g(one)g(or)h(more)e
(letters)g(or)i(digits,)f(the)g(\014rst)g(c)o(haracter)164
2264 y(b)q(eing)18 b(a)h(letter.)26 b(In)o(teger)17 b(constan)o(ts)i(are)f
(sequences)f(of)i(one)f(or)g(more)f(digits.)27 b(Eac)o(h)164
2324 y(\015oating)21 b(p)q(oin)o(t)f(constan)o(t)g(is)g(a)g(nonempt)o(y)e
(digit)i(sequence)e(follo)o(w)o(ed)h(b)o(y)h(a)g(p)q(erio)q(d,)164
2384 y(follo)o(w)o(ed)g(b)o(y)g(a)h(nonempt)o(y)e(digit)i(sequence.)33
b(Strings)22 b(and)f(commen)o(ts)d(are)i(lik)o(e)f Fq(C)164
2444 y Fp(strings)e(and)g(commen)n(ts.)p eop
%%Page: 4 5
bop 164 162 a Fm(3)49 b(SYNT)l(AX)1316 b Fp(4)164 315 y Fl(3)83
b(Syn)n(tax)164 424 y Fp(This)25 b(section)f(indicates)g(the)h(main)e
(features)i(of)g Fq(GPPL)p Fp('s)g(syn)o(tax.)47 b(The)25 b(Y-\014le)164
485 y Fj(gppl.Y)19 b Fp(ma)o(y)h(b)q(e)i(used)g(as)g(the)g(exact)f(syn)o
(tactic)f(sp)q(eci\014cation)i(for)g Fq(GPPL)p Fp(.)f(Sev-)164
545 y(eral)e(example)e Fq(GPPL)i Fp(programs)h(are)f(included)f(in)h(an)g
(app)q(endix,)h(and)g(these)f(to)q(o)164 605 y(ma)o(y)c(b)q(e)h(studied)g(to)
h(gain)f(an)h(appreciation)f(of)h Fq(GPPL)p Fp('s)f(syn)o(tax.)164
746 y Fh(3.1)70 b(Programs)24 b(and)f(Blo)r(c)n(ks)164 839
y Fp(Eac)o(h)e Fq(GPPL)f Fg(pr)n(o)n(gr)n(am)f Fp(is)h(a)h
Fg(blo)n(ck)p Fp(,)h(whic)o(h)e(is)g Ff(f)p Fp(,)i(follo)o(w)o(ed)d(b)o(y)h
(a)h(p)q(ossibly)g(empt)o(y)164 899 y(sequence)i(of)h Fg(blo)n(ck)i(elements)
g Fp(follo)o(w)o(ed)e(b)o(y)f Ff(g)p Fp(.)45 b(A)24 b(blo)q(c)o(k)f(elemen)o
(t)e(is)j(a)h Fg(variable)164 959 y(de)n(clar)n(ation)p Fp(,)h(a)e
Fg(function)j(de)n(clar)n(ation)p Fp(,)e(or)g(an)g Fg(exe)n(cutable)i
(element)p Fp(.)47 b(A)24 b(v)m(ariable)164 1019 y(declaration)16
b(is)g(a)h Fg(stor)n(age)g(de)n(clar)n(ation)p Fp(.)k(The)16
b(shortest)h Fq(GPPL)g Fp(program)f(is)g Ff(fg)p Fp(.)164 1160
y Fh(3.2)70 b(Storage)23 b(Declarations)164 1253 y Fp(Storage)16
b(declarations)g(are)f(similar)e(in)i(general)g(form)f(to)i(the)f
Fg(de\014nitions)i Fp(of)f Fq(C)p Fp(,)f(with)164 1313 y(a)21
b(t)o(yp)q(e)f(sp)q(eci\014er)g(\(one)h(of:)30 b Fj(int)p Fp(,)20
b Fj(float)p Fp(,)f Fj(bool)p Fp(\))g(preceding)h(a)h(comma-separated,)164
1373 y(semicolon-termi)o(nated)15 b(list)i(of)i(iden)o(ti\014ers,)d(eac)o(h)h
(follo)o(w)o(ed)g(optionally)h(b)o(y)f(a)h(list)g(of)164 1433
y(square-brac)o(k)o(eted)h(constan)o(t)j(in)o(teger)d(expressions.)34
b(Here)20 b(are)g(three)g(examples)f(of)164 1493 y(storage)e(declarations:)
273 1572 y Fi(int)k(i,j,a[5][5*7],k;)273 1622 y(float)g(r,s[50],t,v;)273
1672 y(bool)g(p[10],q;)164 1813 y Fh(3.3)70 b(F)-6 b(unction)22
b(Declarations)164 1905 y Fp(A)13 b(t)o(yp)q(e)h(sp)q(eci\014er)f
(\(de\014ned)g(ab)q(o)o(v)o(e\))h(or)g Fj(void)e Fp(b)q(egins)j(a)f
Fg(he)n(ading)g Fp(of)g(a)g Fg(function)j(de)n(cla-)164 1966
y(r)n(ation)p Fp(.)j(There)c(follo)o(ws)f(an)h(iden)o(ti\014er)e(and)i(a)g
(paren)o(thesized)e(list)h(of)h Fg(p)n(ar)n(ameter)f(de)n(c-)164
2026 y(lar)n(ations)p Fp(,)k(whic)o(h)f(are)g(storage)i(declarations)f
(optionally)f(preceded)g(b)o(y)g Fj(var)p Fp(.)28 b(Eac)o(h)164
2086 y(of)17 b(these)e(t)o(w)o(o)i(lines)e(is)h(an)h(example)d(heading:)273
2165 y Fi(void)21 b(qsort\(var)f(int)h(v[10000];)f(int)h(left,right;\))273
2264 y(int)g(mod)g(\(int)g(i,m;\))237 2354 y Fp(A)d(function)g(declaration)h
(is)f(suc)o(h)g(a)h(heading)g(follo)o(w)o(ed)f(b)o(y)g(a)h(blo)q(c)o(k)e
(\(describ)q(ed)164 2414 y(ab)q(o)o(v)o(e\).)k(Here)14 b(are)i(t)o(w)o(o)f
(function)g(declarations,)h(the)f(second)h(of)f(whic)o(h)g(has)h(another)164
2474 y(function)g(declaration)g(nested)g(within)g(its)g(blo)q(c)o(k:)p
eop
%%Page: 5 6
bop 164 162 a Fm(3)49 b(SYNT)l(AX)1316 b Fp(5)273 307 y Fi(int)21
b(fact\(int)f(i;\))317 357 y({if)h(\(i)g(==)g(0\))404 407 y(then)g(return)f
(1;)404 457 y(else)h(return)f(i)i(*)f(fact\(i)g(-)h(1\);)317
506 y(})273 656 y(void)f(printData\(var)e(int)i(a[10000];)f(int)h(size;\))317
706 y({int)f(i;)338 805 y(i)i(=)f(0;)338 855 y(while)g(\(i)g(<)h(size\))382
905 y({output\("\045d)63 b(",i\);)21 b(output\("\045d\\n",a[)o(i]\);)404
955 y(i)g(=)h(i)f(+)h(1;)404 1005 y(if)f(\(mod\(i,50\))f(==)h(0\))h(then)f
(output\("\\f"\);)382 1054 y(})338 1154 y(int)g(mod)h(\(int)f(i,m;\))f
({return)h(i-\(\(i/m\)*m\);})317 1204 y(})164 1348 y Fh(3.4)70
b(Executable)21 b(Elemen)n(ts)164 1441 y Fp(An)j(executable)e(elemen)o(t)f
(is)j(either)f(a)i Fg(statement)g Fp(or)g(a)f(blo)q(c)o(k.)44
b(A)24 b(statemen)o(t)e(is)164 1501 y(either)15 b(a)h(semicolon)e(\()p
Fg(empty)j(statement)p Fp(\),)g(an)f Fg(expr)n(ession)g Fp(follo)o(w)o(ed)f
(b)o(y)g(a)i(semicolon)164 1561 y(\()p Fg(expr)n(ession)k(statement)p
Fp(\),)i(or)d(a)h Fg(c)n(ontr)n(ol)g(statement)p Fp(.)35 b(The)20
b(expressions)g(of)h Fq(GPPL)164 1621 y Fp(are)14 b(rather)g(ordinary)l(.)20
b(The)14 b(exact)f(rules)h(for)g(expressions)f(ma)o(y)g(b)q(e)h(found)g(in)g
Fj(gppl.Y)p Fp(.)164 1681 y(Eac)o(h)20 b(line)e(b)q(elo)o(w)i(has)g(an)g
(example)e(expression.)31 b(T)l(erminating)18 b(an)o(y)h(one)h(of)g(these)164
1742 y(with)c(a)h(semicolon)d(yields)h(a)i(statemen)o(t.)273
1845 y Fi(7)273 1895 y(a)273 1945 y(7)22 b(*)f(a)273 1995 y(\(a\))273
2045 y(!p)g(&&)h(!q)f(||)g(\(b)h(!=)f(c\))273 2094 y(fact\(3\))273
2144 y(fun\(1,fun\(2,b\)\))273 2194 y(input\("\045f\\n",r[i])o([j]\))273
2244 y(i)h(=)f(int\(r\))273 2294 y(a)h(=)f(b[i])g(=)h(fact\(i\))273
2343 y(c)g(=)f(\(a)g(=)h(d\))f(*)h(\(b)f(+)h(88.3\))p eop
%%Page: 6 7
bop 164 162 a Fm(4)49 b(COMP)l(ARISON)15 b(WITH)h(OTHER)g(LANGUA)o(GES)503
b Fp(6)164 307 y Fh(3.5)70 b(F)-6 b(unction)22 b(In)n(v)n(o)r(cations)164
400 y Fp(Sev)o(eral)15 b(of)i(the)f(example)e(expressions)j(giv)o(en)e(ab)q
(o)o(v)o(e)h(con)o(tain)h Fg(function)i(invo)n(c)n(ations)164
460 y Fp(as)c(sub)q(expressions.)21 b(An)13 b(iden)o(ti\014er)g(follo)o(w)o
(ed)g(b)o(y)g(a)i(paren)o(thesized,)d(p)q(ossibly)j(empt)o(y)l(,)164
520 y(comma-separated)k(list)i(of)g(expressions)g(is)g(a)g(function)g(in)o(v)
o(o)q(cation.)35 b Fq(GPPL)21 b Fp(also)164 580 y(has)16 b(sev)o(eral)e
(built-in)h(functions:)21 b Fj(input)p Fp(,)13 b Fj(output)p
Fp(,)g(and)j(the)f Fg(c)n(ast)i(functions)p Fp(.)22 b Fj(input)164
640 y Fp(precedes)h(a)i(left)e(paren)o(thesis,)j(a)e Fq(C)p
Fp(-st)o(yle)g(format)f(string,)j(a)f(comma,)e(a)i(storage)164
700 y(reference,)10 b(and)i(a)f(righ)o(t)g(paren)o(thesis.)19
b(There)11 b(are)g(t)o(w)o(o)g(forms)f(of)i Fj(output)d Fp(in)o(v)o(o)q
(cations,)164 761 y(one)24 b(b)q(eing)g Fj(output)e Fp(follo)o(w)o(ed)h(b)o
(y)g(a)i(paren)o(thesized)e(string.)44 b(In)24 b(its)f(other)h(form,)164
821 y Fj(output)13 b Fp(has)i(b)q(oth)h(a)f(string)h(and)f(an)g(expression,)g
(paren)o(thesized)f(and)h(separated)g(b)o(y)164 881 y(a)e(comma,)e(as)i
(argumen)o(ts.)19 b(A)13 b(paren)o(thesized)e(expression)h(preceded)g(b)o(y)g
Fj(int)p Fp(,)g Fj(float)p Fp(,)164 941 y(or)17 b Fj(bool)d
Fp(is)i(a)h(cast)g(function)f(in)o(v)o(o)q(cation.)164 1086
y Fh(3.6)70 b(Con)n(trol)22 b(Statemen)n(ts)164 1178 y Fp(A)f(con)o(trol)g
(statemen)o(t)f(is)i(either)e(an)i Fg(if)h(statement)p Fp(,)h(a)e
Fg(while)h(statement)p Fp(,)h(a)e Fg(r)n(eturn)164 1238 y(statement)p
Fp(,)h(or)e(an)g Fg(exit)h(statement)p Fp(.)36 b(An)21 b(if)f(statemen)o(t)f
(is)h Fj(if)g Fp(follo)o(w)o(ed)g(b)o(y)g(an)h(ex-)164 1298
y(pression,)c Fj(then)p Fp(,)e(and)i(an)h(executable)d(elemen)o(t,)f
(optionally)j(follo)o(w)o(ed)e(b)o(y)i Fj(else)e Fp(and)164
1359 y(another)20 b(executable)f(elemen)o(t.)29 b Fj(while)18
b Fp(follo)o(w)o(ed)h(b)o(y)g(a)h(paren)o(thesized)f(expression)164
1419 y(and)f(an)g(executable)f(elemen)o(t)d(is)k(a)g(while)e(statemen)o(t.)24
b(An)17 b(exit)g(statemen)o(t)f(is)h Fj(exit)164 1479 y Fp(follo)o(w)o(ed)j
(b)o(y)g(an)i(in)o(teger)e(expression)g(and)i(a)f(semicolon.)34
b(A)20 b(return)h(statemen)o(t)e(is)164 1539 y Fj(return)c
Fp(follo)o(w)o(ed)g(either)h(b)o(y)g(an)i(expression)e(and)h(a)h(semicolon,)c
(or)j(b)o(y)g(a)g(semicolon)164 1599 y(alone.)164 1766 y Fl(4)83
b(Comparison)26 b(with)h(Other)g(Languages)164 1875 y Fp(The)c(reader)f(ma)o
(y)f(ha)o(v)o(e)g(noticed)h(that)h(man)o(y)e(fa)o(v)o(orite)h(constructs)h
(and)g(facilities)164 1935 y(of)e(some)e(p)q(opular)i(languages)h(\(notably)f
Fq(C)p Fp(\))f(are)h(not)g(men)o(tioned)d(ab)q(o)o(v)o(e.)34
b Fq(GPPL)164 1996 y Fp(lac)o(ks)23 b(comp)q(ound)h(data)g(t)o(yp)q(es,)h
(unions,)h(en)o(umerated)c(t)o(yp)q(es,)j(p)q(oin)o(ter)e(v)m(ariables,)164
2056 y Fj(for)p Fp(,)18 b Fj(do-while)p Fp(,)f Fj(continue)p
Fp(,)g Fj(break)p Fp(,)h Fj(switch)p Fp(,)f Fj(goto)h Fp(and)i(lab)q(els,)f
(incremen)o(t)d(and)164 2116 y(decremen)o(t)11 b(op)q(erators,)k(conditional)
f(expressions,)g(bit)f(op)q(erations,)i(automatic)e(t)o(yp)q(e)164
2176 y(con)o(v)o(ersions,)h(dynamic)f(memory)f(allo)q(cation,)j(separate)g
(compilation,)e(and)j(a)f(macro)164 2236 y(facilit)o(y)l(.)36
b(The)22 b(absence)g(of)g(these)g(features)g(k)o(eeps)f(the)g(compiler)f
(small)g(and)j(easy)164 2297 y(to)c(understand,)g(and)g(lea)o(v)o(es)e(man)o
(y)g(in)o(teresting)g(opp)q(ortunities)i(for)g(exercises)d(that)164
2357 y(expand)g(the)g(language.)p eop
%%Page: 7 8
bop 164 162 a Fm(5)49 b(SEMANTICS)1228 b Fp(7)164 315 y Fl(5)83
b(Seman)n(tics)164 425 y Fp(The)18 b(follo)o(wing)f(is)h(an)h(informal)d(and)
i(incomplete)e(description)h(of)h(the)g(meanings)f(of)164 485
y Fq(GPPL)p Fp('s)f(constructs.)21 b(The)15 b(reader)g(should)h(follo)o(w)g
(exp)q(erience)d(and)j(in)o(tuition,)e(and)164 545 y(if)20
b(these)g(fail,)h Fq(gc)p Fp('s)g(source)f(co)q(de,)i(in)e(resolving)g(seman)
o(tics-related)f(questions)h(not)164 606 y(addressed)d(in)f(this)g(section.)
164 750 y Fh(5.1)70 b(Scop)r(e)22 b(of)h(Iden)n(ti\014ers)164
842 y Fp(As)16 b(is)f(common)f(in)i(blo)q(c)o(k-structured)f(languages,)i
Fq(GPPL)f Fp(emplo)o(ys)e(static)h(scoping)164 903 y(rules)h(for)g
(resolution)h(of)f(storage)i(references)d(and)i(function)f(in)o(v)o(o)q
(cations.)21 b(When)16 b(an)164 963 y(iden)o(ti\014er)j(is)h(seen)g(in)g(the)
g(con)o(text)g(of)h(a)g(storage)g(reference,)e(the)i(list)e(of)i(v)m
(ariables)164 1023 y(declared)e(in)h(the)g(blo)q(c)o(k)g(and)h(\(if)e(the)h
(blo)q(c)o(k)g(is)g(the)g(blo)q(c)o(k)f(of)i(a)f(function\))g(the)g(for-)164
1083 y(mal)g(parameter)h(list)g(are)h(searc)o(hed.)38 b(When)22
b(seen)f(in)h(the)g(con)o(text)f(of)h(a)g(function)164 1143
y(in)o(v)o(o)q(cation,)g(the)g(list)f(of)h(functions)g(declared)f(in)h(the)g
(curren)o(t)f(blo)q(c)o(k)g(is)h(searc)o(hed.)164 1204 y(If)d(the)f(iden)o
(ti\014er)g(is)h(not)g(found)h(in)e(a)i(giv)o(en)e(blo)q(c)o(k,)h(the)g
(searc)o(h)f(pro)q(ceeds)h(out)o(w)o(ard)164 1264 y(to)f(enclosing)f(blo)q(c)
o(ks)h(un)o(til)e(there)i(is)f(a)h(matc)o(h)e(or)i(the)g(searc)o(h)f(fails)g
(in)h(the)f Fg(pr)n(o)n(gr)n(am)164 1324 y(blo)n(ck)j Fp(\(the)f(outermost)g
(blo)q(c)o(k\).)29 b(In)19 b(a)g(correct)g(input,)g(for)g(a)h(giv)o(en)e(blo)
q(c)o(k,)h(the)g(sets)164 1384 y(of)e(iden)o(ti\014ers)f(of)i(v)m(ariables,)e
(formal)g(parameters,)g(and)i(functions)f(declared)g(for)g(the)164
1444 y(blo)q(c)o(k)f(are)g(eac)o(h)g(disjoin)o(t)f(from)h(one)g(another.)237
1504 y(An)g(iden)o(ti\014er's)e(uses)j(need)f(not)g(precede)g(its)g
(declaration.)164 1649 y Fh(5.2)70 b(Op)r(erators)164 1731
y Fq(GPPL)p Fp('s)16 b(op)q(erators)i(are)e(as)h(follo)o(ws:)273
1822 y Fi(!)273 1872 y(*)43 b(/)273 1922 y(+)g(-)273 1972 y(<)g(>)h(<=)f(>=)
273 2021 y(==)g(!=)273 2071 y(&&)273 2121 y(||)273 2171 y(=)164
2273 y Fp(Their)18 b(precedences)e(and)j(asso)q(ciativities)f(are)g(as)h(in)f
Fq(C)p Fp(.)g(Whic)o(h)f(of)h(the)g(t)o(w)o(o)g(sub)q(ex-)164
2333 y(pressions)k(of)g(a)f(giv)o(en)g(binary)g(expression)g(is)h(executed)e
(\014rst)h(is)h(implem)o(en)n(tation-)164 2393 y(dep)q(enden)o(t.)p
eop
%%Page: 8 9
bop 164 162 a Fm(5)49 b(SEMANTICS)1228 b Fp(8)164 307 y Fh(5.3)70
b(T)n(yp)r(es)22 b(and)i(Casts)164 400 y Fp(Eac)o(h)18 b(expression)g(has)i
(one)e(of)h(the)f(t)o(yp)q(es)g(en)o(umerated)f(in)h(section)g(3.2.)28
b(There)18 b(are)164 460 y(no)d(automatic)e(t)o(yp)q(e)g(con)o(v)o(ersions.)
20 b(The)14 b(cast)h(functions)f(are)g(pro)o(vided)f(for)i(c)o(hanging)164
520 y(t)o(yp)q(es)i(of)g(expressions.)24 b Fj(int)16 b Fp(and)i
Fj(float)d Fp(expressions)i(cast)g(to)h Fj(bool)d Fp(are)i
Fj(FALSE)f Fp(for)164 580 y Fj(0)e Fp(and)h Fj(0.0)p Fp(,)f
Fj(TRUE)f Fp(otherwise.)20 b(A)14 b Fj(TRUE)f Fp(expression)h(cast)h(to)g
Fj(int)f Fp(or)g Fj(float)f Fp(b)q(ecomes)164 640 y(either)f
Fj(1)g Fp(or)h Fj(1.0)p Fp(,)f(while)g Fj(FALSE)f Fp(b)q(ecomes)h
Fj(0)h Fp(or)g Fj(0.0)p Fp(.)19 b(Casts)14 b(b)q(et)o(w)o(een)e
Fj(int)f Fp(and)j Fj(float)164 700 y Fp(b)q(eha)o(v)o(e)i(as)g(in)g
Fq(C)p Fp(.)237 761 y(The)h(arithmetic)d(and)j(relational)g(op)q(erators)h
(are)f(o)o(v)o(erloaded,)e(in)i(that)g(they)f(ap-)164 821 y(ply)j(to)h(b)q
(oth)h Fj(int)e Fp(and)h Fj(float)e Fp(op)q(erands.)34 b(The)20
b(logical)f(op)q(erators)i(apply)f(only)g(to)164 881 y(op)q(erands)f(of)f(t)o
(yp)q(e)f Fj(bool)p Fp(.)25 b(The)17 b(op)q(erands)i(of)f(a)h(binary)e(op)q
(eration)i(m)o(ust)d(b)q(e)i(of)g(the)164 941 y(same)h(t)o(yp)q(e.)31
b(The)20 b(t)o(yp)q(e)f(of)i(an)f(arithmetic)d(or)j(logical)g(expression)f
(is)h(the)f(same)g(as)164 1001 y(that)e(of)f(its)g(op)q(erand\(s\).)23
b(Relational)15 b(expressions)i(are)f(of)g(t)o(yp)q(e)g Fj(bool)p
Fp(.)237 1062 y(The)h(t)o(yp)q(e)g(sp)q(eci\014er)g(of)g(a)h(function)f(m)o
(ust)f(matc)o(h)g(the)h(t)o(yp)q(e)f(of)i(an)o(y)f(expressions)164
1122 y(whose)d(v)m(alue)e(it)h Fj(return)p Fp(s.)18 b(If)12
b(the)h(function)g(con)o(tains)g(an)h(empt)o(y)c Fj(return)h
Fp(statemen)o(t,)164 1182 y(its)16 b(t)o(yp)q(e)g(sp)q(eci\014er)f(m)o(ust)g
(b)q(e)i Fj(void)p Fp(.)164 1326 y Fh(5.4)70 b(Input)23 b(and)h(Output)164
1419 y Fp(The)14 b(built-in)f(I/O)h(functions)g(b)q(eha)o(v)o(e,)g(insofar)g
(as)h(the)f(syn)o(tax)f(of)i(eac)o(h)e(p)q(ermits,)g(lik)o(e)164
1479 y(the)g Fq(C)i Fp(functions)f Fj(printf)d Fp(and)j Fj(scanf)p
Fp(,)e(except)h(that)h(\(since)f Fq(GPPL)h Fp(has)h(no)f(p)q(oin)o(ter)164
1539 y(v)m(ariables\))i Fj(input)p Fp('s)e(storage)k(reference)c(argumen)o(t)
h(is)h(not)h(a)g(p)q(oin)o(ter.)237 1599 y(As)h(in)h Fq(C)p
Fp('s)g(standard)g(library)l(,)f Fj(EOF)g Fp(is)g(an)h(in)o(teger)f(constan)o
(t,)h(and)g(ma)o(y)e(app)q(ear)164 1660 y(an)o(ywhere)11 b(an)h(in)o(teger)f
(constan)o(t)h(ma)o(y)f(app)q(ear.)20 b(Its)12 b(v)m(alue)f(is)h(de\014ned)f
(only)h(in)f(relation)164 1720 y(to)17 b(v)m(alues)f(returned)g(b)o(y)f
Fj(input)p Fp(.)237 1780 y(It)h(is)g(illegal)f(to)i(call)e
Fj(input)f Fp(with)i(a)h(storage)g(reference)e(of)i(t)o(yp)q(e)e
Fj(bool)p Fp(.)164 1924 y Fh(5.5)70 b(Storage)23 b(Items)164
2017 y Fp(In)f(this)g(section,)h Fk(k)h Fp(is)e(some)f(non-negativ)o(e)h(in)o
(teger,)g(and)h Fk(E)i Fp(is)d(a)g(sequence)f(of)i Fk(k)164
2077 y Fp(constan)o(t)17 b(in)o(teger)e(expressions)h(suc)o(h)g(that)h
Fk(E)1028 2084 y Fe(i)1056 2077 y Fk(>)d Fp(0)i(for)h(1)d Ff(\024)g
Fk(i)f Ff(\024)h Fk(k)r Fp(.)164 2207 y Fq(5.5.1)55 b(Storage)19
b(Declarations)164 2299 y Fp(The)d(storage)i(declaration:)237
2420 y Fk(ty)r(pe)328 2427 y Fd(0)363 2420 y Fk(id)405 2427
y Fd(0)441 2420 y Fj([)e Fk(E)519 2427 y Fd(1)555 2420 y Fj(])g
Ff(\001)8 b(\001)g(\001)17 b Fj([)e Fk(E)749 2427 y Fe(k)787
2420 y Fj(])h(;)p eop
%%Page: 9 10
bop 164 162 a Fm(5)49 b(SEMANTICS)1228 b Fp(9)164 367 y(can)16
b(app)q(ear)i(in)e(the)g(t)o(w)o(o)g(distinct)f(con)o(texts)h(treated)g(b)q
(elo)o(w.)164 497 y Fq(V)-5 b(ariable)15 b(Declarations)48
b Fp(When)14 b(the)f(con)o(text)g(of)h(the)f(ab)q(o)o(v)o(e)h(declaration)f
(is)g(that)164 557 y(of)f(a)h(v)m(ariable)e(declaration)h(\(see)g(section)f
(3.1\),)i Fk(id)1080 564 y Fd(0)1112 557 y Fp(is)e(the)h(name)f(of)h(a)h
(storage)g(lo)q(cation)164 618 y(in)18 b(the)f(curren)o(t)g(blo)q(c)o(k,)h
(with)f(storage)i(for)983 584 y Fc(Q)1022 598 y Fe(k)1022 630
y(i)p Fd(=1)1089 618 y Fk(E)1125 625 y Fe(i)1157 618 y Fp(items)d(of)j(t)o
(yp)q(e)e Fk(ty)r(pe)1549 625 y Fd(0)1586 618 y Fp(that)h(ma)o(y)164
678 y(b)q(e)d(read)f(and)h(written)f(in)g(references)f(p)q(ermitted)g(b)o(y)h
(the)g(scop)q(e)h(rules)f(of)h(section)f(5.1.)164 738 y(If)i
Fk(k)g(>)d Fp(0,)k Fk(id)402 745 y Fd(0)438 738 y Fp(is)f(called)f(an)i
Fg(arr)n(ay)p Fp(.)164 868 y Fq(P)n(arameter)22 b(Declarations)48
b Fp(If)21 b(the)f(ab)q(o)o(v)o(e)h(storage)h(declaration)e(app)q(ears)i(in)f
(a)164 928 y(formal)15 b(parameter)g(list)h(\(see)f(section)h(3.3\))h(there)f
(are)g(t)o(w)o(o)g(cases:)224 1030 y(1.)24 b(The)c(declaration)f(is)h(not)g
(preceded)f(b)o(y)g Fj(var)p Fp(.)31 b(In)20 b(this)f(case,)i
Fk(k)h Fp(=)e(0)g(and)g Fk(id)1763 1037 y Fd(0)286 1090 y Fp(has)f(storage)g
(for)g(one)f(item.)25 b(Up)q(on)19 b(calling)f(the)g(function,)g(the)g
(result)g(of)g(the)286 1150 y(expression)13 b(matc)o(hed)e(to)i(the)g(formal)
f(parameter)g(is)h(written)f(to)i(that)f(lo)q(cation,)286 1210
y(whic)o(h)19 b(is)h(otherwise)h(inaccessible)d(to)j(the)f(caller.)32
b Fk(id)1323 1217 y Fd(0)1343 1210 y Fp('s)20 b(item)e(ma)o(y)g(b)q(e)j(read)
286 1271 y(and)e(written)f(in)g(references)e(p)q(ermitted)h(b)o(y)h(the)g
(scop)q(e)g(rules.)27 b(The)19 b(matc)o(hed)286 1331 y(actual)d(parameter)f
(is)h(said)h(to)f(b)q(e)h Fg(p)n(asse)n(d)f(by)i(value)p Fp(.)224
1432 y(2.)24 b(The)16 b(declaration)f(is)h(preceded)f(b)o(y)g
Fj(var)p Fp(.)20 b(In)15 b(this)h(case)g(no)g(storage)h(is)e(reserv)o(ed)286
1493 y(for)i(the)f(parameter.)21 b(The)16 b(actual)h(parameter)e(matc)o(hed)f
(to)j(the)f(giv)o(en)g(formal)286 1553 y(parameter)g(is)i(a)g(reference)e(to)
i(storage)h(in)e(the)h(scop)q(e)g(of)g(the)f(caller,)g(and)h(ref-)286
1613 y(erences)g(p)q(ermitted)e(b)o(y)j(the)f(scop)q(e)h(rules)g(read)g(or)g
(write)f(that)h(storage.)30 b(The)286 1673 y(actual)13 b(parameter)f(is)h
(said)g(to)g(b)q(e)g Fg(p)n(asse)n(d)h(by)g(r)n(efer)n(enc)n(e)p
Fp(.)21 b(If)12 b Fk(k)k(>)e Fp(0,)f Fk(id)1582 1680 y Fd(0)1615
1673 y Fp(is)g(called)286 1733 y(an)k Fg(arr)n(ay)p Fp(.)164
1863 y Fq(5.5.2)55 b(Storage)19 b(References)164 1956 y Fp(Assume)f(a)i(v)m
(alid)f(declaration)h(of)g Fk(id)870 1963 y Fd(0)909 1956 y
Fp(as)g(in)g(the)f(preceding)g(section.)31 b(If)19 b Fk(e)g
Fp(is)h(a)g(se-)164 2016 y(quence)15 b(of)i Fk(k)h Fp(in)o(teger)d
(expressions)h(suc)o(h)g(that)237 2136 y(0)e Ff(\024)g Fk(e)351
2143 y Fe(i)378 2136 y Fk(<)g(E)466 2143 y Fe(i)497 2136 y
Fp(for)i(1)e Ff(\024)g Fk(i)f Ff(\024)h Fk(k)164 2257 y Fp(then)23
b Fk(id)324 2264 y Fd(0)367 2257 y Fj([)h Fk(e)440 2264 y Fd(1)482
2257 y Fj(])g Ff(\001)8 b(\001)g(\001)23 b Fj([)g Fk(e)685
2264 y Fe(k)730 2257 y Fj(])g Fp(is)g(a)h(v)m(alid)f(reference)f(to)i(a)g(lo)
q(cation)f(reserv)o(ed)g(for)164 2317 y Fk(id)206 2324 y Fd(0)226
2317 y Fp(.)40 b(If)22 b(the)h(ab)q(o)o(v)o(e)f(condition)h(on)g(the)f
(indices)g(of)g(the)h(reference)e(to)i Fk(id)1593 2324 y Fd(0)1635
2317 y Fp(fails,)h(a)164 2377 y(run-time)14 b(error)j(is)f(rep)q(orted)g(and)
h(program)f(execution)f(is)h(terminated.)p eop
%%Page: 10 11
bop 164 162 a Fm(5)49 b(SEMANTICS)1203 b Fp(10)164 307 y Fq(5.5.3)55
b(References)17 b(to)i(Arra)n(ys)164 400 y Fp(Supp)q(ose)e(that)g(0)d
Ff(\024)g Fk(j)j(<)c(k)r Fp(,)j(and)h(that)g(an)f(arra)o(y)h
Fk(id)1135 407 y Fd(0)1171 400 y Fp(is)f(declared)f(as)i(follo)o(ws:)237
520 y Fk(ty)r(pe)328 527 y Fd(0)363 520 y Fk(id)405 527 y Fd(0)441
520 y Fj([)f Fk(E)519 527 y Fd(1)555 520 y Fj(])g Ff(\001)8
b(\001)g(\001)17 b Fj([)e Fk(E)749 527 y Fe(j)784 520 y Fj(])h([)g
Fk(E)904 527 y Fe(j)r Fd(+1)984 520 y Fj(])f Ff(\001)8 b(\001)g(\001)17
b Fj([)f Fk(E)1178 527 y Fe(k)1215 520 y Fj(])g(;)164 640 y
Fp(Let)g Fk(e)g Fp(b)q(e)h(a)f(sequence)f(of)i Fk(j)i Fp(in)o(teger)c
(expressions)i(suc)o(h)f(that)237 761 y(0)e Ff(\024)g Fk(e)351
768 y Fe(i)378 761 y Fk(<)g(E)466 768 y Fe(i)497 761 y Fp(for)i(1)e
Ff(\024)g Fk(i)f Ff(\024)h Fk(j)164 881 y Fp(Then)i Fk(id)333
888 y Fd(0)370 881 y Fj([)g Fk(e)435 888 y Fd(1)470 881 y Fj(])g
Ff(\001)8 b(\001)g(\001)17 b Fj([)f Fk(e)652 888 y Fe(j)686
881 y Fj(])g Fp(refers)g(to)h(one)f(of)h Fk(id)1107 888 y Fd(0)1127
881 y Fp('s)f(subarra)o(ys)h(of)1452 848 y Fc(Q)1491 861 y
Fe(k)1491 893 y(i)p Fd(=)p Fe(j)r Fd(+1)1602 881 y Fk(E)1638
888 y Fe(i)1669 881 y Fp(items)164 941 y(of)j(t)o(yp)q(e)f
Fk(ty)r(pe)427 948 y Fd(0)446 941 y Fp(.)33 b(This)20 b(is)f(legal)h(only)f
(when)h Fk(id)1061 948 y Fd(0)1101 941 y Fj([)f Fk(e)1169 948
y Fd(1)1209 941 y Fj(])g Ff(\001)8 b(\001)g(\001)20 b Fj([)g
Fk(e)1401 948 y Fe(j)1438 941 y Fj(])g Fp(app)q(ears)h(as)f(an)164
1001 y(actual)f(parameter)f(in)h(a)h(function)f(call,)g(and)h(is)f(matc)o
(hed)f(to)h(a)h(formal)e(parameter)164 1062 y Fk(id)206 1069
y Fd(1)242 1062 y Fp(whose)f(declaration)f(is)237 1182 y Fj(var)f
Fk(ty)r(pe)421 1189 y Fd(0)457 1182 y Fk(id)499 1189 y Fd(1)534
1182 y Fj([)h Fk(E)615 1164 y Fb(0)612 1194 y Fd(1)648 1182
y Fj(])g Ff(\001)8 b(\001)g(\001)17 b Fj([)f Fk(E)846 1164
y Fb(0)843 1194 y Fe(n)882 1182 y Fj(])g(;)164 1302 y Fp(where)g(the)g(follo)
o(wing)g(conditions)g(hold:)237 1393 y Ff(\017)24 b Fk(k)16
b Fp(=)e Fk(j)g Fp(+)d Fk(n)237 1492 y Ff(\017)24 b Fk(E)325
1474 y Fb(0)322 1504 y Fd(1)356 1492 y Ff(\024)13 b Fk(E)444
1499 y Fe(j)r Fd(+1)237 1590 y Ff(\017)24 b Fk(E)325 1572 y
Fb(0)322 1602 y Fe(i)350 1590 y Fp(=)14 b Fk(E)438 1597 y Fe(j)r
Fd(+)p Fe(i)512 1590 y Fp(for)j(2)d Ff(\024)g Fk(i)f Ff(\024)h
Fk(n)164 1732 y Fh(5.6)70 b(Compile-t)o(i)o(me)19 b(Error)25
b(Conditions)164 1825 y Fp(Belo)o(w)g(are)g(listed)g(the)g(seman)o(tic)f
(error)i(conditions)f(that)h(elicit)e(messages)h(from)164 1885
y Fq(GPPL)p Fp(.)20 b(Most)h(of)g(the)f(conditions)h(are)f(follo)o(w)o(ed)g
(b)o(y)g(example)e(programs)j(that)g(il-)164 1945 y(lustrate)16
b(the)g(errors.)237 2026 y Ff(\017)24 b Fp(Nonp)q(ositiv)o(e)15
b(dimension)g(in)h(arra)o(y)g(declaration.)373 2125 y Fi({int)21
b(a[0];)395 2175 y(float)g(r,s[-5)f(*)i(-4)f(*)h(-1];)373 2225
y(})237 2325 y Ff(\017)i Fp(Declared)15 b(storage)j(of)e(t)o(yp)q(e)g
Fj(void)p Fp(.)373 2424 y Fi({void)21 b(a[10];)373 2474 y(})p
eop
%%Page: 11 12
bop 164 162 a Fm(5)49 b(SEMANTICS)1203 b Fp(11)237 307 y Ff(\017)24
b Fp(Iden)o(ti\014er)15 b(declared)g(more)g(than)i(once)f(in)g(the)g(same)f
(blo)q(c)o(k.)373 419 y Fi({int)21 b(in;)395 469 y(void)g(in\(var)f(float)h
(r;\))g({)h(input\("\045f\\n",r\);)c(})373 519 y(})237 641
y Ff(\017)24 b Fp(Undeclared)15 b(storage)i(iden)o(ti\014er.)237
743 y Ff(\017)24 b Fp(Undeclared)15 b(function)h(iden)o(ti\014er.)237
834 y Ff(\017)24 b Fp(Binary)15 b(op)q(erator)j(t)o(yp)q(e)e(mismatc)n(h.)373
946 y Fi(bool)21 b(greater\(int)f(i;)h(float)g(r;\))417 996
y({return)f(i)i(>)f(r;)417 1046 y(})237 1158 y Ff(\017)j Fp(Unary)16
b(op)q(erator)h(t)o(yp)q(e)f(mismatc)o(h.)373 1270 y Fi({int)21
b(i;)g(bool)g(p;)395 1320 y(p)g(=)h(!i;)373 1370 y(})237 1482
y Ff(\017)i Fp(Assignmen)o(t)14 b(op)q(erator)k(t)o(yp)q(e)d(mismatc)o(h.)373
1594 y Fi({int)21 b(i;)g(bool)g(p;)395 1644 y(p)g(=)h(i;)373
1694 y(})237 1806 y Ff(\017)i Fp(Extra)16 b(index)g(in)g(storage)h
(reference.)373 1918 y Fi({int)k(i[5][5];)395 1968 y(output\("\045d\\n",i[3)o
(][4][)o(1]\);)373 2017 y(})237 2130 y Ff(\017)j Fp(Missing)16
b(index)f(in)h(arra)o(y)h(reference.)373 2242 y Fi({int)k(i[5][5];)395
2291 y(output\("\045d\\n",i[3)o(]\);)373 2341 y(})237 2464
y Ff(\017)j Fp(Extra)16 b(actual)h(parameter)e(in)h(function)g(in)o(v)o(o)q
(cation.)p eop
%%Page: 12 13
bop 164 162 a Fm(5)49 b(SEMANTICS)1203 b Fp(12)237 307 y Ff(\017)24
b Fp(Missing)16 b(actual)g(parameter)f(in)h(function)g(in)o(v)o(o)q(cation.)
237 407 y Ff(\017)24 b Fp(T)o(yp)q(e)16 b(of)g(actual)h(parameter)e(do)q(es)i
(not)g(matc)o(h)d(t)o(yp)q(e)i(of)h(formal)e(parameter.)237
507 y Ff(\017)24 b Fp(Dimensions)10 b(of)h(actual)g(parameter)f(incompatible)
f(with)i(dimensions)f(of)h(formal)286 567 y(parameter)k(\(see)h(section)g
(5.5.3\).)237 657 y Ff(\017)24 b Fp(Actual)f(parameter)g(is)h(not)g(a)h
(reference,)f(but)g(is)g(matc)o(hed)e(to)i(a)h(reference)286
707 y(formal)15 b(parameter.)373 813 y Fi({int)21 b(j;)395
863 y(j)g(=)h(5;)395 912 y(square\(j+1\);)395 962 y(void)f(square\(var)f(int)
h(i;\){i)f(=)i(i)g(*)f(i;})373 1012 y(})237 1118 y Ff(\017)j
Fp(Arra)o(y)15 b(declared)h(as)h(v)m(alue)f(formal)f(parameter.)395
1224 y Fi({void)21 b(qsort\(int)f(a[1000];int)f(left,right;\){)g(...)i(})395
1274 y(})237 1380 y Ff(\017)j Fp(A)o(ttempted)13 b(input)k(of)f(b)q(o)q
(olean.)373 1486 y Fi({bool)21 b(p;)395 1536 y(input\("\045d\\n",p\);)373
1585 y(})237 1691 y Ff(\017)j Fp(Non-b)q(o)q(olean)18 b(expression)e(as)h
(condition)f(in)g(con)o(trol)f(statemen)o(t.)373 1797 y Fi({int)21
b(i;)395 1847 y(i)g(=)h(100;)395 1897 y(while)f(\(i\))g
({output\("\045d\\n",i)o(\);)e(i)i(=)h(i)g(-)f(1;})373 1947
y(})237 2053 y Ff(\017)j Fp(Call)16 b(to)g Fj(return)f Fp(not)h(in)g(an)o(y)g
(function)g(blo)q(c)o(k.)373 2159 y Fi({return;)373 2209 y(})237
2315 y Ff(\017)24 b Fp(Missing)16 b(ob)s(ject)g(of)g Fj(return)e
Fp(in)i(non-)p Fj(void)g Fp(function.)373 2421 y Fi({int)21
b(fun\(\){return;})373 2471 y(})p eop
%%Page: 13 14
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(13)237
307 y Ff(\017)24 b Fp(Mismatc)o(hed)14 b(t)o(yp)q(e)i(of)g(ob)s(ject)g
(returned)g(from)f(function.)373 419 y Fi({int)21 b(fun\(\))g({return)f
(1.0;})373 469 y(})237 581 y Ff(\017)k Fp(Ob)s(ject)15 b(returned)h(b)o(y)g
Fj(void)e Fp(function.)373 693 y Fi({void)21 b(fun\(\))g({return)f(1.0;})373
743 y(})237 855 y Ff(\017)k Fp(Non-in)o(teger)15 b(ob)s(ject)h(of)h
Fj(exit)d Fp(statemen)o(t.)373 967 y Fi({bool)21 b(condCheck\(\))e({)j(...)f
(})395 1017 y(exit)g(condCheck\(\);)373 1067 y(})164 1233 y
Fl(6)83 b(Implemen)n(tation)164 1357 y Fh(6.1)70 b(In)n(tro)r(duction)164
1450 y Fp(The)17 b(reader)h(should)g(b)q(e)f(familiar)f(with)h(the)g(use)h
(of)g Fq(Ox)p Fp(,)f(or)g(should)h(ha)o(v)o(e)f(access)h(to)164
1510 y(the)e Fq(Ox)g Fp(user's)g(man)o(ual)f([Bisc)o(ho\013)o(].)237
1570 y(This)g(description)g(of)g(the)g(implem)o(en)o(tation)d(mak)o(es)i
(frequen)o(t)g(references)g(to)h Fq(gc)p Fp('s)164 1630 y(source)h(co)q(de)h
(and)g(ma)o(y)d(b)q(e)j(tak)o(en)e(as)i(a)g(general)f(guide)g(to)h(that)f(co)
q(de.)164 1760 y Fq(6.1.1)55 b(General)18 b(Design)g(Notes)164
1852 y Fp(Man)o(y)13 b(asp)q(ects)h(of)f(the)g(presen)o(t)f(impleme)o(n)o
(tation)f(are)i(in\015uenced)f(b)o(y)h(a)g(single)g(design)164
1913 y(decision:)19 b Fq(gc)13 b Fp(generates)g(a)h(single)e(stream)g(of)i
(co)q(de)f(during)g(a)h(single)e(p)q(ost-decoration)164 1973
y(left-to-righ)o(t)k(p)q(ostorder)h(tra)o(v)o(ersal)f(of)g(the)g(parse)h
(tree.)237 2033 y(T)l(o)h(impro)o(v)o(e)d(time)g(and)j(space)f(e\016ciency)l
(,)e(some)i(of)g(the)g(attributes)h(are)f(de\014ned)164 2093
y(as)g(p)q(oin)o(ters)f(to)h(lists)f(of)g(shared)h(data)g(items.)164
2238 y Fh(6.2)70 b(Ov)n(erview)21 b(of)i(gc's)g(Source)g(Files)237
2330 y Ff(\017)h Fj(Makefile)12 b Fp(is)i(used)h(to)f(main)o(tain)f
(consisten)o(t)h(and)h(up-to-date)h(v)o(ersions)e(of)h(the)286
2390 y(v)m(arious)21 b(comp)q(onen)o(t)e(\014les)h(of)g Fq(gc)p
Fp(,)h(and)g(is)f(input)g(to)h(the)f Fq(Mak)n(e)g Fp(utilit)o(y)e(\(see)286
2450 y([F)l(eldman)n(]\).)p eop
%%Page: 14 15
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(14)237
307 y Ff(\017)24 b Fj(glob.h)14 b Fp(con)o(tains)i(declarations)g(of)h(t)o
(yp)q(es)f(and)g(macros)g(that)g(need)g(b)q(e)g(visible)286
367 y(from)f(all)h(of)g Fq(gc)p Fp('s)g Fj(.c)g Fp(\014les,)f(including)h
Fj(y.tab.c)d Fp(and)k Fj(lex.yy.c)p Fp(.)237 469 y Ff(\017)24
b Fj(gppl.Y)14 b Fp(is)i(the)g(Y-\014le)f(and)i(con)o(tains)g(the)f
(de\014nition)f(of)i Fj(main)p Fp(.)237 571 y Ff(\017)24 b
Fj(gppl.L)14 b Fp(is)i(the)g(L-\014le.)237 672 y Ff(\017)24
b Fj(scan.c)16 b Fp(consists)j(of)f(routines)g(to)h(supp)q(ort)g(lexical)e
(analysis)h(and)h(ev)m(aluation)286 733 y(of)d(syn)o(thesized)f(attributes)i
(of)f(tok)o(ens.)237 834 y Ff(\017)24 b Fp(The)17 b(routines)h(called)e
(during)i(tree)e(decoration)i(are)f(con)o(tained)g(in)g Fj(sem.c)p
Fp(.)23 b(In)286 895 y(general,)17 b(the)g(seman)o(tic)f(errors)h(that)h(in)o
(terfere)e(with)h(normal)g(attribute)g(ev)m(al-)286 955 y(uation)g(are)f
(detected)f(and)i(rep)q(orted)f(b)o(y)g(these)g(routines.)237
1056 y Ff(\017)24 b Fj(code.c)19 b Fp(con)o(tains)h(all)h(of)g(the)f
(target-language-dep)q(enden)o(t)j(routines)d(of)h Fq(gc)p
Fp(.)286 1117 y(F)l(or)15 b(exp)q(edience,)d(these)i(p)q(erform)g(ab)q(out)i
(half)e(of)h(the)f(c)o(hec)o(ks)f(for)i(seman)o(tic)d(er-)286
1177 y(rors.)20 b(Nearly)11 b(all)g(of)h(these)f(routines)h(\(namely)e(those)
i(pre\014xed)f(b)o(y)g Fj(cg)p Fp(\))g(generate)286 1237 y(co)q(de)18
b(and)h(are)f(executed)e(during)j(the)e(p)q(ost-decoration)j(parse-tree)e
(tra)o(v)o(ersal)286 1297 y(men)o(tioned)c(ab)q(o)o(v)o(e.)237
1399 y Ff(\017)24 b Fj(util.c)14 b Fp(holds)j(utilit)o(y)d(routines)i(for)h
(error)f(handling)g(and)h(\014le)f(handling.)237 1501 y Ff(\017)24
b Fj(scan.h)p Fp(,)d Fj(sem.h)p Fp(,)h Fj(code.h)p Fp(,)f(and)j
Fj(util.h)c Fp(are)i(header)h(\014les,)g(eac)o(h)f(of)h(whic)o(h)286
1561 y(holds)15 b Fj(extern)e Fp(declarations)i(of)g(routines)g(declared)f
(in)g(the)h(corresp)q(onding)h Fj(.c)286 1621 y Fp(\014le.)164
1765 y Fh(6.3)70 b(Sym)n(b)r(ols,)22 b(Lo)r(cales,)g(and)i(En)n(vironmen)n
(ts)164 1858 y Fp(Conceptually)l(,)11 b(there)f(are)h(three)f(kinds)h(of)g
Fg(symb)n(ols)g Fp(created)f(b)o(y)g Fq(gc)p Fp(,)i(one)f(kind)f(for)h(eac)o
(h)164 1918 y(of)j Fq(GPPL)p Fp('s)h(w)o(a)o(ys)f(of)g(declaring)f(iden)o
(ti\014ers.)19 b(There)14 b(are)g(sym)o(b)q(ols)f(for)i(v)m(ariables,)f(for)
164 1978 y(formal)h(parameters,)g(and)h(for)h(functions.)k
Fj(glob.h)14 b Fp(has)j(the)f(declaration)g(of)g Fj(struct)164
2038 y(sym)p Fp(,)i(whic)o(h)g(is)g(the)h(t)o(yp)q(e)f(of)h
Fq(C)g Fp(v)m(ariable)g(used)g(to)g(represen)o(t)f(sym)o(b)q(ols)f(of)i(all)g
(three)164 2099 y(kinds.)24 b(Some)17 b(of)g(the)g Fj(struct)24
b(sym)16 b Fp(mem)o(b)q(ers)f(are)i(used)h(for)f(eac)o(h)g(kind)g(of)h(sym)o
(b)q(ol,)164 2159 y(while)e(some)h(mem)n(b)q(ers)e(are)j(un)o(used)f(for)h
(some)e(kinds)h(of)h(sym)o(b)q(ols.)24 b(This)17 b(facilitates)164
2219 y(use)g(of)h(a)g(single)f(set)g(of)h(routines)f(for)h(manipulating)e
(lists)h(of)g(eac)o(h)g(kind)g(of)h(sym)o(b)q(ol.)164 2279
y(The)23 b(uses)g(of)h(the)f(v)m(arious)h(mem)n(b)q(ers)d(are)i(describ)q(ed)
f(b)q(elo)o(w.)42 b(Source)23 b(co)q(de)g(that)164 2339 y(allo)q(cates)h(the)
g(sym)o(b)q(ol)f(space)i(is)f(lo)q(cated)g(in)g Fj(sem.c)p
Fp(.)43 b(After)23 b(allo)q(cation)i(of)f(that)164 2400 y(space,)18
b Fj(symStock)d Fp(p)q(oin)o(ts)j(to)g(the)f(next)h(a)o(v)m(ailable)f
Fj(struct)23 b(sym)17 b Fp(in)g(the)h(space,)f(and)164 2460
y(is)f(incremen)o(ted)d(eac)o(h)j(time)e(one)i(is)g(allo)q(cated.)p
eop
%%Page: 15 16
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(15)237
307 y(A)21 b Fg(lo)n(c)n(ale)i Fp(is)e(a)i(list)e(of)h(sym)o(b)q(ols,)g(all)f
(of)h(the)f(same)g(kind.)38 b(There)21 b(are)h Fg(variable)164
367 y(lo)n(c)n(ales)p Fp(,)16 b Fg(p)n(ar)n(ameter)g(lo)n(c)n(ales)p
Fp(,)h(and)g Fg(function)h(lo)n(c)n(ales)p Fp(.)237 428 y(Eac)o(h)13
b(function)g(sym)o(b)q(ol)f(has)i(a)g(parameter)e(lo)q(cale,)h(whic)o(h)g
(con)o(tains)g(the)g(sym)o(b)q(ols)164 488 y(of)k(the)f(function's)f(formal)g
(parameters.)237 548 y(There)i(is)g(a)h(one-to-one)g(corresp)q(ondence)g(b)q
(et)o(w)o(een)e Fg(envir)n(onments)j Fp(and)f(blo)q(c)o(ks.)164
608 y(Eac)o(h)f(en)o(vironmen)o(t)c(that)k(corresp)q(onds)h(to)f(a)g
(function)f(blo)q(c)o(k)g(has)i(a)f(function)f(sym-)164 668
y(b)q(ol)i(and)h(a)f(parameter)e(lo)q(cale)i(\(that)g(of)g(the)g(function)f
(sym)o(b)q(ol\).)25 b(En)o(vironmen)o(ts)16 b(of)164 729 y(unnamed)c
(\(non-function\))i(blo)q(c)o(ks)g(lac)o(k)e(function)h(sym)o(b)q(ols)f(and)i
(parameter)f(lo)q(cales.)164 789 y(Asso)q(ciated)h(with)f(eac)o(h)g(en)o
(vironmen)o(t)e(are)j(a)g(v)m(ariable)f(lo)q(cale)g(and)h(a)g(function)g(lo)q
(cale,)164 849 y(whic)o(h)19 b(are)g(lists)g(of)h(sym)o(b)q(ols)e(of)i(v)m
(ariables)f(and)h(functions)f(declared)g(in)g(the)g(corre-)164
909 y(sp)q(onding)f(blo)q(c)o(k.)k(F)l(or)17 b(eac)o(h)f(en)o(vironmen)o(t,)e
(except)h(the)i(one)f(corresp)q(onding)i(to)f(the)164 969 y(program)d(blo)q
(c)o(k,)g(there)f(is)h(an)h Fg(outer)f Fp(en)o(vironmen)o(t.)k(Eac)o(h)c(en)o
(vironmen)o(t)e(has)j(a)f Fg(level)p Fp(.)164 1029 y(Zero)k(is)g(the)g(lev)o
(el)f(of)h(the)g(program)g(blo)q(c)o(k's)g(en)o(vironmen)o(t.)25
b(Ev)o(ery)17 b(other)h(en)o(viron-)164 1090 y(men)o(t)d(has)i(a)g(lev)o(el)e
(greater)i(b)o(y)f(one)h(than)g(that)h(of)f(its)f(outer)h(en)o(vironmen)o(t.)
j(Lo)q(cales)164 1150 y(and)i(en)o(vironmen)o(ts)e(are)i(searc)o(hed)f
(during)h(iden)o(ti\014er)e(resolution)i(as)g(indicated)f(in)164
1210 y(section)16 b(5.1.)164 1353 y Fh(6.4)70 b(Construction)22
b(of)h(Sym)n(b)r(ols)g(and)g(Lo)r(cales)164 1446 y Fp(The)e(tok)o(en)f
Fj(ID)g Fp(has)i(the)e(inherited)f(attribute)i Fj(sym)p Fp(.)34
b Fj(ID)20 b Fp(no)q(des)h(that)g(are)g(parts)h(of)164 1506
y(subtrees)c(ro)q(oted)i(at)e Fj(funcDecl)e Fp(or)i Fj(stgDecl2)e
Fp(no)q(des)j(are)g(parts)g(of)f(sym)o(b)q(ol)f(decla-)164
1566 y(rations.)31 b(In)19 b(eac)o(h)g(of)h(those)g(con)o(texts,)f
Fj(sym)f Fp(is)h(ev)m(aluated)h(b)o(y)f(constructing)g(a)h(new)164
1626 y(sym)o(b)q(ol)12 b(\(cf.)20 b(section)14 b(6.7\).)20
b(Suc)o(h)14 b(construction)g(in)o(v)o(olv)o(es)d(allo)q(cating)j(a)h
Fj(struct)23 b(sym)164 1686 y Fp(and)18 b(assigning)g(the)f(mem)o(b)q(ers)d
(that)k(p)q(ertain)f(to)h(the)f(sym)o(b)q(ol's)e(kind.)24 b(The)17
b Fq(C)h Fp(func-)164 1747 y(tion)i Fj(newFuncSym)d Fp(is)j(de\014ned)g(in)g
Fj(sem.c)e Fp(and)j(is)f(used)g(for)h(constructing)f(function)164
1807 y(sym)o(b)q(ols.)f(P)o(arameter)12 b(sym)o(b)q(ols)h(and)h(v)m(ariable)g
(sym)o(b)q(ols)e(are)i(referred)f(to)h(generically)164 1867
y(as)h Fg(stor)n(age)h(symb)n(ols)p Fp(,)e(and)i(are)e(constructed)h(b)o(y)f
(calling)g Fj(newStgSym)p Fp(,)e(also)j(in)f Fj(sem.c)p Fp(.)164
1927 y(All)h(sym)o(b)q(ols)g(use)h(mem)o(b)q(ers)e(of)i(their)g
Fj(struct)23 b(sym)15 b Fp(to)i(store:)237 2022 y Ff(\017)24
b Fp(The)16 b(lexeme)d(of)k(the)f Fj(ID)f Fp(tok)o(en.)237
2121 y Ff(\017)24 b Fp(The)16 b(line)f(n)o(um)o(b)q(er)g(of)h(the)g(sym)o(b)q
(ol's)f(declaration.)237 2220 y Ff(\017)24 b Fp(a)17 b Fg(typ)n(e)p
Fp(,)e(corresp)q(onding)i(to)g(one)f(of:)22 b Fj(int)p Fp(,)15
b Fj(float)p Fp(,)f Fj(bool)p Fp(,)g Fj(void)p Fp(.)237 2319
y Ff(\017)24 b Fp(The)16 b(lev)o(el)e(of)j(the)f(en)o(vironmen)o(t)d(in)j
(whic)o(h)g(the)g(declaration)g(app)q(ears.)237 2414 y(Lo)q(cales)i(are)f
(represen)o(ted)g(as)g(link)o(ed)f(lists)h(of)g Fj(struct)24
b(sym)16 b Fp(v)m(ariables.)24 b(When)18 b(a)164 2474 y(sym)o(b)q(ol)c(app)q
(ears)j(in)e(a)g(lo)q(cale,)g(the)g Fj(next)f Fp(mem)n(b)q(er)f(of)j(the)f
(sym)o(b)q(ol's)e Fj(struct)24 b(sym)14 b Fp(is)p eop
%%Page: 16 17
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(16)164
307 y Fj(lambdaSym)12 b Fp(if)j(the)g(sym)o(b)q(ol)e(is)i(the)g(last)h(in)f
(the)g(list.)20 b(Otherwise)14 b Fj(next)g Fp(p)q(oin)o(ts)i(to)f(the)164
367 y(next)h(sym)o(b)q(ol)f(in)h(the)g(lo)q(cale.)164 497 y
Fq(6.4.1)55 b(Construction)19 b(of)g(Storage)f(Sym)n(b)r(ols)164
590 y(Dimension)e(Lists)48 b Fp(A)16 b(v)m(ariable)g(sym)o(b)q(ol)e(or)j
(parameter)e(sym)o(b)q(ol)f(ma)o(y)h(b)q(e)h(that)h(of)164
650 y(an)22 b(arra)o(y)l(,)g(so)g(for)f(these)g(kinds)h(of)f(sym)o(b)q(ols)f
(it)h(is)g(necessary)g(to)h(k)o(eep)e(an)i(ordered)164 710
y(list)16 b(of)h(the)f(sym)o(b)q(ol's)f(declared)h(dimensions.)21
b Fj(dimList)14 b Fp(is)i(a)h(syn)o(thesized)e(attribute)164
770 y(of)24 b Fj(dimSeq)e Fp(no)q(des.)44 b(Childless)23 b
Fj(dimSeq)f Fp(no)q(des)j(ha)o(v)o(e)e(empt)o(y)e Fj(dimLists)p
Fp(.)41 b(Ev)o(ery)164 830 y(other)18 b Fj(dimSeq)e Fp(no)q(de)j(has)g(a)f
Fj(dimList)e Fp(constructed)i(b)o(y)f(app)q(ending)i(the)f(v)m(alue)g(of)h(a)
164 891 y(brac)o(k)o(eted)f(constan)o(t)i(in)o(teger)f(expression)g(on)o(to)h
(the)f(head)h(of)g(the)f Fj(dimList)e Fp(of)j(the)164 951 y(no)q(de's)d
Fj(dimSeq)d Fp(c)o(hild.)19 b(Th)o(us)e(a)g Fj(dimSeq)d Fp(no)q(de)i(whose)h
(paren)o(t)f(is)g(a)h Fj(stgDecl2)c Fp(no)q(de)164 1011 y(has)k(a)g(rev)o
(erse-order)e(list)g(of)i(the)f(dimensions)f(of)h(the)g(sym)o(b)q(ol.)164
1141 y Fj(struct)23 b(sym)16 b Fq(Mem)n(b)r(ers)g(Sp)r(eci\014c)g(to)h
(Storage)f(Sym)n(b)r(ols)47 b Fp(In)15 b(addition)g(to)g(the)164
1201 y(ab)q(o)o(v)o(e-men)o(tioned)f(mem)o(b)q(ers)f(common)i(to)h(all)g(sym)
o(b)q(ols,)f(storage)i(sym)o(b)q(ols)e(ha)o(v)o(e:)237 1303
y Ff(\017)24 b Fp(a)16 b Fg(stor)n(age)i(class)p Fp(.)j(This)c(distinguishes)
f(sym)o(b)q(ols)f(of)h(v)m(ariables,)g(v)m(alue)f(parame-)286
1363 y(ters,)h(and)g(reference)f(parameters.)237 1465 y Ff(\017)24
b Fp(a)e Fg(sc)n(ale)n(d)g(dimension)h(list)p Fp(,)g(i.e.,)d(a)i
Fj(dimList)d Fp(whose)j(ev)o(ery)e(mem)o(b)q(er)e(has,)23 b(in)286
1525 y(addition)18 b(to)h(its)f(dimension,)f(a)i(scale)f(factor)h(used)f(in)h
(calculating)e(addresses)286 1585 y(at)g(run-time.)237 1687
y Ff(\017)24 b Fp(the)15 b Fg(size)g Fp(of)h(the)f(sym)o(b)q(ol,)e(i.e.,)h
(the)h(amoun)o(t)f(of)h(storage)i(to)e(b)q(e)g(reserv)o(ed)f(for)i(it.)164
1817 y Fq(6.4.2)55 b(Construction)19 b(of)g(Storage)f(Lo)r(cales)164
1909 y(V)-5 b(ariable)23 b(Lo)r(cales)48 b Fp(These)20 b(are)h(syn)o
(thesized)e(in)h(subtrees)h(whose)g(ro)q(ots)h(are)f(la-)164
1969 y(b)q(eled)16 b(with)h(the)f(non)o(terminal)f Fj(block)p
Fp(,)g(the)i(result)f(of)h(the)g(syn)o(thesis)f(b)q(eing)h
Fj(block)p Fp('s)164 2029 y Fj(varLoc)10 b Fp(attribute.)20
b(Examination)11 b(of)i(the)f(Y-\014le's)g(rules)g(in)o(v)o(olving)f
Fj(blockElem)o(Lis)o(t)164 2090 y Fp(rev)o(eals)i(that)i(it)f(also)h(has)g
(the)g Fj(varLoc)d Fp(attribute.)20 b(The)15 b(syn)o(thesis)f(is)g
(incomplete)e(for)164 2150 y Fj(blockElemL)o(ist)g Fp(no)q(des)18
b(whose)e(paren)o(ts)h(are)f(not)h Fj(block)d Fp(no)q(des.)164
2280 y Fq(P)n(arameter)27 b(Lo)r(cales)47 b Fp(The)24 b Fj(paramDeclLi)o(st)d
Fp(non)o(terminal)h(has)j(an)g(attribute)164 2340 y Fj(loc)19
b Fp(used)i(to)g(syn)o(thesize)e(parameter)g(lo)q(cales.)34
b(Complete)19 b(syn)o(thesis)h(en)o(tails)f(that)164 2400 y(the)25
b(paren)o(t)g(of)g(the)g Fj(paramDecl)o(Lis)o(t)d Fp(no)q(de)k(is)e(lab)q
(eled)h Fj(funcDecl)p Fp(.)45 b(A)o(t)24 b(suc)o(h)h(a)p eop
%%Page: 17 18
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(17)164
307 y Fj(paramDeclL)o(ist)20 b Fp(no)q(de,)25 b Fj(loc)d Fp(is)h(a)h(rev)o
(erse-order)e(list)h(of)h(the)f(sym)o(b)q(ols)f(of)i(a)f(for-)164
367 y(mal)14 b(parameter)f(list.)20 b(That)c(rev)o(ersal)e(of)h(the)g(order)g
(is)g(imp)q(ortan)o(t)f(to)h(parameter)f(list)164 428 y(matc)o(hing)h(\(cf.)
23 b(section)16 b(6.8.1\))h(and)g(is)g(easily)f(implem)o(en)o(te)o(d)e(using)
j(the)g Fq(C)g Fp(function)164 488 y Fj(concatLocs)c Fp(\(in)i
Fj(sem.c)p Fp(\).)164 618 y Fq(6.4.3)55 b(Construction)19 b(of)g(F)-5
b(unction)19 b(Sym)n(b)r(ols)164 710 y Fp(Besides)c(a)i(lexeme,)c(a)j(line)f
(n)o(um)o(b)q(er,)f(and)j(a)g(lev)o(el,)d(eac)o(h)h(function)h(sym)o(b)q(ol)f
(has:)237 812 y Ff(\017)24 b Fp(An)f(in)o(teger)f(v)m(alue)h(that)g
(determines)e(a)i(lab)q(el)g(for)g(the)g(en)o(try)g(p)q(oin)o(t)g(of)g(the)
286 872 y(function.)237 974 y Ff(\017)h Fp(The)16 b(amoun)o(t)f(of)h(stac)o
(k)g(space)g(used)g(to)h(store)f(the)g(actual)g(parameters)f(during)286
1034 y(calls)h(of)g(the)g(function.)237 1135 y Ff(\017)24 b
Fp(A)f(parameter)e(lo)q(cale.)42 b(This)23 b(di\013ers)g(sligh)o(tly)f(from)g
(the)g(parameter)g(lo)q(cale)286 1196 y(syn)o(thesized)14 b(at)i(the)g(nearb)
o(y)f Fj(paramDeclL)o(ist)d Fp(no)q(de)k(\(section)g(6.4.2\):)21
b(Before)286 1256 y Fj(newFuncSym)10 b Fp(\\attac)o(hes")15
b(the)f(lo)q(cale)g(to)g(the)g(incipien)o(t)e(function)i(sym)o(b)q(ol,)f(the)
286 1316 y(lo)q(cale)j(is)g(tra)o(v)o(ersed)f(and)i(an)g(address)g(is)f
(assigned)h(to)f(eac)o(h)g(of)g(its)h(sym)o(b)q(ols.)164 1446
y Fq(6.4.4)55 b(Construction)19 b(of)g(F)-5 b(unction)19 b(Lo)r(cales)164
1538 y Fp(This)13 b(is)g(analogous)h(to)g(the)e(syn)o(thesis)h(of)g(v)m
(ariable)f(lo)q(cales)h(\(see)f(section)h(6.4.2\).)20 b(F)l(rag-)164
1599 y(men)o(ts)d(of)i(lo)q(cales)g(are)f(concatenated)h(and)g(carried)g(ro)q
(ot)o(w)o(ard)g(in)g(a)g(subtree)f(whose)164 1659 y(\\main)d(lim)o(b")f(is)i
(a)h(c)o(hain)f(of)g Fj(blockElemLi)o(st)d Fp(no)q(des.)164
1803 y Fh(6.5)70 b(Allo)r(cation)16 b(of)i(Registers)f(for)i(Expression)g(Ev)
l(aluation)164 1895 y Fq(6.5.1)55 b(Need)18 b(for)h(Storage)f(of)h(In)n
(termediate)d(Results)164 1977 y Fp(In)k(addition)g(to)g(declared)f(storage)i
(\(v)m(ariables)f(and)h(formal)e(parameters\),)g(the)h Fq(gc)p
Fp(-)164 2027 y(generated)h(program)f(needs)h(undeclared)f(storage)h(where)g
(in)o(termedi)o(ate)d(results)j(of)164 2077 y(expressions)16
b(can)h(b)q(e)f(stored.)22 b(F)l(or)16 b(instance,)f(the)h(expression)273
2168 y Fi(\(b)21 b(+)h(c\))f(*)h(\(d)f(+)h(e\))164 2270 y Fp(requires)c(that)
h(the)g(results)g(of)g Fj(\(b)25 b(+)g(c\))18 b Fp(and)i Fj(\(d)25
b(+)g(e\))18 b Fp(b)q(e)i(a)o(v)m(ailable)e(at)h(the)g(same)164
2330 y(time,)e(so)j(that)g(they)f(can)g(b)q(e)h(m)o(ultipli)o(ed)c(without)k
(c)o(hanging)g(the)f(con)o(ten)o(ts)f(of)i(an)o(y)164 2391
y(declared)15 b(storage)j(lo)q(cation.)p eop
%%Page: 18 19
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(18)164
307 y Fq(6.5.2)55 b(Indication)18 b(of)h(a)g(Sc)n(heme)e(for)i(Register)e
(Allo)r(cation)164 400 y Fp(The)f(practice)e(of)i(generating)g(all)g(co)q(de)
f(in)h(one)g(con)o(tin)o(uous)f(stream,)g(during)g(a)i(p)q(ost-)164
460 y(decoration)12 b(left-to-righ)o(t)f(p)q(ostorder)i(tra)o(v)o(ersal,)f
(is)f(consisten)o(t)g(with)h(a)g(certain)f(simple)164 520 y(w)o(a)o(y)16
b(of)g(allo)q(cating)g(registers)g(for)g(expression)g(ev)m(aluation.)21
b(Supp)q(ose)c(that)f(eac)o(h)g(reg-)164 580 y(ister)j(is)g(iden)o(ti\014ed)f
(b)o(y)h(a)h(non-negativ)o(e)g(in)o(teger)e(serial)h(n)o(um)o(b)q(er,)f(and)i
(consider)f(an)164 640 y(expression)d(of)g(the)g(form)237 761
y Fk(expr)334 768 y Fd(1)386 761 y Fk(op)433 768 y Fd(0)486
761 y Fk(expr)583 768 y Fd(2)603 761 y Fp(.)164 881 y(In)e
Fq(gc)p Fp('s)h(output,)g(the)g(co)q(de)g(that)g(ev)m(aluates)g
Fk(expr)1100 888 y Fd(1)1134 881 y Fp(precedes)f(imme)o(diately)d(the)k(co)q
(de)164 941 y(that)g(ev)m(aluates)f Fk(expr)573 948 y Fd(2)593
941 y Fp(.)20 b(Th)o(us)15 b(an)o(y)f(register)g(needed)g(to)h(ev)m(aluate)f
Fk(expr)1516 948 y Fd(1)1536 941 y Fp(,)g(except)f(the)164
1001 y(one)18 b(in)f(whic)o(h)g(its)g(result)g(is)g(stored,)h(ma)o(y)e(b)q(e)
h(reused)g(for)h(the)f(ev)m(aluation)h(of)g Fk(expr)1750 1008
y Fd(2)1769 1001 y Fp(.)164 1062 y(If)i(ev)m(aluation)h(of)g
Fk(expr)613 1069 y Fd(1)653 1062 y Fp(requires)f(no)h(register)g(n)o(um)o(b)q
(ered)d(less)j(than)g Fk(n)p Fp(,)h(then)e(the)164 1122 y(ev)m(aluation)f(of)
h Fk(expr)557 1129 y Fd(2)596 1122 y Fp(can)f(use)g(registers)g(n)o(um)o(b)q
(ered)e Fk(n)d Fp(+)f(1)19 b(and)h(greater,)g(without)164 1182
y(in)o(terfering)e(with)h(the)f(ev)m(aluation)i(of)f Fk(expr)996
1189 y Fd(1)1016 1182 y Fp(.)29 b(F)l(urther,)19 b(the)g(results)g(in)g
(registers)g Fk(n)164 1242 y Fp(and)13 b Fk(n)s Fp(+)s(1)f(can)g(b)q(e)h(com)
o(bined)d(according)i(to)h Fk(op)1044 1249 y Fd(0)1064 1242
y Fp(,)g(the)f(result)g(b)q(eing)g(stored)h(in)e(register)164
1302 y Fk(n)p Fp(.)237 1363 y(The)17 b(result)f(of)h(a)g(unary)g(op)q
(eration)g(can)g(b)q(e)g(stored)g(in)f(the)g(same)g(register)g(as)h(its)164
1423 y(op)q(erand.)237 1483 y(The)d(indicated)g(sc)o(heme)e(a\013ords)j
(e\016cien)o(t)e(register)g(allo)q(cation)i(for)f(left-recursiv)o(e)164
1543 y(expressions.)21 b(It)16 b(is)g(w)o(asteful)g(for)g(expressions)h(that)
f(are)h(deeply)e(righ)o(t-recursiv)o(e.)164 1672 y Fq(6.5.3)55
b(A)n(ttributes)18 b(for)h(Register)e(Allo)r(cation)164 1765
y(The)f Fj(regNum)e Fq(A)n(ttribute)48 b Fp(Except)14 b(for)g(the)g
Fj(typeSpec)e Fp(non)o(terminal,)g(the)i(non)o(ter-)164 1825
y(minals)g(deriv)m(able)h(from)f(the)i Fj(expr)e Fp(non)o(terminal)f(inherit)
i(the)g(attribute)h Fj(regNum)p Fp(.)i(A)164 1885 y(no)q(de's)h
Fj(regNum)e Fp(is)i(the)g(serial)g(n)o(um)o(b)q(er)e(of)i(the)g(virtual)f
(register)h(whic)o(h)f(is)h(to)h(store)164 1945 y(an)o(y)c(in)o(termediate)d
(result)j(corresp)q(onding)h(to)g(the)f(no)q(de.)237 1995 y(The)g(Y-\014le)g
(has)h(the)f(rules:)273 2082 y Fi(actParamList)j(:)j(expr)f(;)164
2169 y Fp(and)273 2256 y Fi(actParamList)e(:)j(actParamList)d(',')i(expr)g(;)
164 2354 y Fp(F)l(or)13 b(eac)o(h)g Fj(expr)e Fp(in)i(the)g(list,)g
Fj(cgPush)d Fp(generates)k(co)q(de)f(to)g(push)h(the)f(result)f(of)i(the)f
(cor-)164 2414 y(resp)q(onding)i(expression)e(on)o(to)i(the)f(activ)m(ation)f
(stac)o(k.)21 b(After)13 b(that)h(co)q(de)g(is)g(executed,)164
2474 y Fj(expr)p Fp('s)19 b(register)i(can)g(b)q(e)g(reused.)35
b(It)20 b(follo)o(ws)h(that)g(eac)o(h)g(of)g(the)g Fj(expr)e
Fp(no)q(des)j(can)p eop
%%Page: 19 20
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(19)164
307 y(ha)o(v)o(e)14 b(the)g(same)g Fj(regNum)e Fp(v)m(alue.)21
b Fj(actParamL)o(is)o(t)p Fp('s)11 b Fj(regNum)i Fp(attribute)h(is)h(essen)o
(tially)164 367 y(a)20 b(dumm)o(y)d(that)k(carries)e(a)i(register)e(n)o(um)o
(b)q(er)f(leafw)o(ard)i(so)h(that)f(it)g(can)g(b)q(e)g(copied)164
428 y(in)o(to)c(eac)o(h)g(of)g(the)g Fj(expr)f Fp(no)q(des.)237
488 y(Consider)h(rules)f(other)h(than)g(the)f Fj(actParamLi)o(st)d
Fp(rules)j(men)o(tioned)f(ab)q(o)o(v)o(e.)21 b(F)l(or)164 548
y(those)c(other)f(rules)g(ha)o(ving)g(the)g(form:)237 668 y
Fk(l)q(hsS)s(y)r(m)f Fj(:)22 b Ff(\001)8 b(\001)g(\001)32 b
Fk(r)q(nS)s(y)r(m)713 675 y Fd(0)765 668 y Ff(\001)8 b(\001)g(\001)33
b Fk(r)q(nS)s(y)r(m)1010 675 y Fe(k)1063 668 y Ff(\001)8 b(\001)g(\001)16
b Fj(;)164 789 y Fp(where,)h(for)h(0)f Ff(\024)f Fk(i)f Ff(\024)h
Fk(k)r Fp(,)i(the)f Fk(r)q(nS)s(y)r(m)877 796 y Fe(i)909 789
y Fp(are)g(exactly)g(the)g(non)o(terminals)f(of)i(the)f(righ)o(t)164
849 y(hand)g(side)f(ha)o(ving)g(the)g Fj(regNum)e Fp(attribute:)237
951 y Ff(\017)24 b Fp(if)19 b Fk(l)q(hsS)s(y)r(m)g Fp(do)q(es)i(not)g(ha)o(v)
o(e)e(the)h Fj(regNum)e Fp(attribute,)i Fk(r)q(nS)s(y)r(m)1483
958 y Fe(i)1497 951 y Fp('s)f Fj(regNum)f Fp(at-)286 1011 y(tribute)d(is)i
Fk(i)p Fp(.)237 1112 y Ff(\017)24 b Fp(if)c Fk(l)q(hsS)s(y)r(m)g
Fp(has)i(the)f Fj(regNum)e Fp(attribute,)i Fk(r)q(nS)s(y)r(m)1259
1119 y Fe(i)1273 1112 y Fp('s)g Fj(regNum)e Fp(attribute)h(is)h
Fk(i)286 1173 y Fp(plus)16 b(the)g Fj(regNum)e Fp(attribute)i(of)h
Fk(l)q(hsS)s(y)r(m)p Fp(.)164 1303 y Fq(The)26 b Fj(maxRegNum)d
Fq(A)n(ttribute)48 b Fp(Registers)23 b(are)g(allo)q(cated)g(b)o(y)f(the)h
Fq(gc)p Fp(-generated)164 1363 y(program)16 b(at)h(blo)q(c)o(k-en)o(try)e
(time.)k Fq(gc)d Fp(determines)e(for)j(eac)o(h)f(blo)q(c)o(k)f(ho)o(w)i(man)o
(y)e(regis-)164 1423 y(ters)h(are)g(needed)f(for)h(activ)m(ations)h(of)f(the)
g(giv)o(en)f(blo)q(c)o(k.)20 b(The)d(syn)o(thesized)d(attribute)164
1483 y Fj(maxRegNum)g Fp(of)j(the)g(non)o(terminal)f Fj(statement)e
Fp(is)j(the)f(largest)i(serial)e(n)o(um)o(b)q(er)g(of)h(all)164
1543 y(the)g(registers)g(used)g(in)g(executing)g(the)g(statemen)o(t.)22
b(F)l(or)c Fj(block)d Fp(no)q(des,)j Fj(maxRegNum)164 1604
y Fp(is)f(the)f(largest)h(serial)f(n)o(um)o(b)q(er)g(of)h(all)f(the)h
(registers)f(used)h(in)g(executing)e(statemen)o(ts)164 1664
y(of)i(the)f(blo)q(c)o(k.)164 1808 y Fh(6.6)70 b(The)22 b Fa(env)i
Fh(A)n(ttribute)164 1901 y Fq(6.6.1)55 b(Construction)164 1993
y Fp(In)21 b Fj(glob.h)e Fp(is)i(the)g(declaration)g(of)h Fj(struct)h(env)p
Fp(,)e(whic)o(h)g(giv)o(es)f(the)h(form)g(of)g Fq(gc)p Fp('s)164
2053 y(represen)o(tations)c(of)h(en)o(vironmen)o(ts.)k(Eac)o(h)17
b(no)q(de)h(lab)q(eled)f Fj(block)e Fp(has)j(an)g(inherited)164
2113 y(attribute)j Fj(env)p Fp(,)g(whic)o(h)g(is)g(a)h(p)q(oin)o(ter)g(to)f
(a)h Fj(struct)i(env)p Fp(.)35 b(An)22 b Fj(env)e Fp(is)h(built)g(from)164
2173 y(attributes)11 b(describ)q(ed)g(ab)q(o)o(v)o(e)h(and)g(passed)g(as)g
(argumen)o(ts)f(to)h(the)f Fq(C)h Fp(function)f Fj(newEnv)164
2234 y Fp(\(see)16 b Fj(sem.c)p Fp(\).)j(The)d(argumen)o(ts)g(are)g(as)h
(follo)o(ws:)237 2335 y Ff(\017)24 b Fj(outerEnv)p Fp(,)12
b(a)k(p)q(oin)o(ter)f(to)g(the)g(outer)g(en)o(vironmen)o(t)e(of)i(the)g
(incipien)o(t)e(en)o(viron-)286 2396 y(men)o(t.)p eop
%%Page: 20 21
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(20)237
307 y Ff(\017)24 b Fj(funcSym)p Fp(.)43 b(If)23 b(the)h(new)g(en)o(vironmen)o
(t)e(is)i(that)h(of)f(a)h(function)f(blo)q(c)o(k,)h(this)286
367 y(p)q(oin)o(ts)13 b(to)g(the)f(blo)q(c)o(k's)g(function)g(sym)o(b)q(ol.)
19 b(Otherwise)12 b(this)g(is)g(the)h(n)o(ull)e(p)q(oin)o(ter)286
428 y Fj(lambdaSym)p Fp(.)23 b(F)l(or)c(a)f(function)g(blo)q(c)o(k,)g(the)f
(en)o(vironmen)o(t's)e(parameter)i(lo)q(cale)286 488 y(is)c(accessed)g
(indirectly)l(,)e(as)i(the)g Fj(paramLoc)e Fp(mem)n(b)q(er)f(of)k(the)f
Fj(funcSym)d Fp(mem)o(b)q(er)286 548 y(of)16 b(the)g Fj(struct)24
b(env)p Fp(.)237 650 y Ff(\017)g Fj(varLoc)18 b Fp(and)j Fj(funcLoc)p
Fp(,)d(the)j(lists)e(of)i(v)m(ariables)f(and)h(functions)g(declared)e(in)286
710 y(the)d(corresp)q(onding)h(blo)q(c)o(k.)237 812 y Ff(\017)24
b Fj(maxRegNum)p Fp(.)18 b(See)e(section)f(6.5.3.)164 913 y(By)i(three)g
(calls)g(of)g Fj(symDupCheck)o Fp(,)e Fj(newEnv)g Fp(v)o(eri\014es)h(that)i
(the)f(three)g(lo)q(cales)g(of)h(the)164 973 y(en)o(vironmen)o(t)10
b(are)j(disjoin)o(t)f(from)g(one)h(another.)21 b Fj(assignLeve)o(l)10
b Fp(is)j(called)f(to)h(tra)o(v)o(erse)164 1034 y(eac)o(h)19
b(lo)q(cale)h(and)g(write)g(the)f(en)o(vironmen)o(t's)e(lev)o(el)h(in)o(to)h
(the)h Fj(struct)j(sym)c Fp(of)h(eac)o(h)164 1094 y(sym)o(b)q(ol)c(of)h(the)g
(lo)q(cale.)24 b(The)17 b(v)m(ariable)g(lo)q(cale)g(is)g(tra)o(v)o(ersed)f(b)
o(y)h Fj(assignAddr)o(es)o(ses)o Fp(,)164 1154 y(whic)o(h)f(determines)f(for)
i(eac)o(h)g(v)m(ariable)f(a)i(frame-p)q(oin)o(ter-relativ)o(e)c(address,)j
(and)h(re-)164 1214 y(turns)f(the)f(size)f(of)i(the)f(storage)h(required)e(b)
o(y)h(the)g(blo)q(c)o(k's)f(v)m(ariables.)164 1344 y Fq(6.6.2)55
b(Inheritance)164 1436 y Fp(As)17 b(seen)g(ab)q(o)o(v)o(e,)g(en)o(vironmen)o
(ts)e(are)i(built)g(up)g(principally)f(from)g(information)h(syn-)164
1497 y(thesized)23 b(in)h(subtrees)g(that)g(corresp)q(ond)h(to)g
Fq(gc)p Fp('s)f(declarativ)o(e)e(constructs.)45 b(The)164 1557
y(information)13 b(con)o(tained)i(in)f(a)h(giv)o(en)e(en)o(vironmen)o(t)f(is)
i(carried)g(leafw)o(ard)h(via)f(the)g Fj(env)164 1617 y Fp(attribute:)237
1719 y Ff(\017)24 b Fp(for)16 b(iden)o(ti\014er)f(resolution)h(and)h(co)q(de)
f(generation,)g(and)237 1820 y Ff(\017)24 b Fp(to)18 b(b)q(e)f(passed)h(as)g
(the)g Fj(outerEnv)c Fp(argumen)o(t)i(when)i(calling)f Fj(newEnv)e
Fp(to)j(build)286 1881 y(en)o(vironmen)o(ts)c(of)i(the)g(next)g(higher)g(lev)
o(el.)164 2025 y Fh(6.7)70 b(Resolution)21 b(of)i(Iden)n(ti\014er)f
(References)164 2117 y Fj(ID)d Fp(no)q(des)i(that)g(are)f(parts)h(of)f
(subtrees)g(ro)q(oted)h(at)g Fj(stgRef)d Fp(or)i Fj(funcInvoc)d
Fp(no)q(des)164 2178 y(app)q(ear)i(in)e(the)g(con)o(text)g(of)h(iden)o
(ti\014er)e(references)g(\(storage)j(references)d(or)i(function)164
2238 y(in)o(v)o(o)q(cations\).)23 b(In)16 b(those)h(con)o(texts,)f
Fj(ID)p Fp('s)g(inherited)g(attribute)g Fj(sym)g Fp(is)h(ev)m(aluated)f(b)o
(y)164 2298 y(searc)o(hing)21 b(the)g(appropriate)h(lo)q(cales)g(of)f(a)h(c)o
(hain)f(of)h(en)o(vironmen)o(ts)d(for)i(a)h(sym)o(b)q(ol)164
2358 y(ha)o(ving)16 b(the)g(same)f(lexeme)f(\(cf.)20 b(section)c(6.4\).)p
eop
%%Page: 21 22
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(21)164
307 y Fq(6.7.1)55 b(Storage)19 b(References)164 400 y Fp(These)12
b(are)f(resolv)o(ed)g(b)o(y)g(calling)g Fj(stgRefLooku)o(p)p
Fp(,)e(whic)o(h)i(is)h(passed)g(a)g(string)g(\(the)g(lex-)164
460 y(eme)f(of)i(the)g Fj(ID)g Fp(of)g(the)g(reference\))e(and)j(an)f
Fj(env)f Fp(\(see)h(section)g(6.6.1\),)g(whic)o(h)g(indicates)164
520 y(the)i(en)o(vironmen)o(t)e(in)j(whic)o(h)f(the)g(reference)g(o)q(ccurs.)
21 b(The)16 b(men)o(tioned)d(lo)q(okup)k(func-)164 580 y(tion)i(follo)o(ws)f
(the)g(algorithm)g(indicated)g(in)g(section)g(5.1)h(and)g(is)f(easily)g
(understo)q(o)q(d)164 640 y(b)o(y)i(examining)e(its)i(text)g(in)g
Fj(sem.c)p Fp(.)32 b(If)20 b(the)g(searc)o(h)g(is)g(successful,)g
Fj(stgRefLooku)o(p)164 700 y Fp(returns)e(a)f(p)q(oin)o(ter)h(to)g(the)f(sym)
o(b)q(ol)f(found.)26 b(Otherwise)17 b(the)g(error)g(is)h(rep)q(orted)f(and)
164 761 y(the)f(n)o(ull)f(p)q(oin)o(ter)h Fj(lambdaSym)d Fp(is)j(returned.)
164 891 y Fq(6.7.2)55 b(F)-5 b(unction)19 b(In)n(v)n(o)r(cations)164
983 y Fp(The)g(b)q(eha)o(vior)g(of)h Fj(funcInvocL)o(ook)o(up)c
Fp(is)j(quite)f(lik)o(e)g(that)h(of)h Fj(stgRefLook)o(up)p
Fp(.)27 b(In-)164 1043 y(stead)17 b(of)g(searc)o(hing)g(the)f(v)m(ariable)h
(lo)q(cales)g(and)g(parameter)f(lo)q(cales)g(in)h(the)f(c)o(hain)h(of)164
1103 y(en)o(vironmen)o(ts,)c Fj(funcInvocLo)o(ok)o(up)g Fp(searc)o(hes)j(the)
g(function)g(lo)q(cales.)164 1248 y Fh(6.8)70 b(P)n(arameter)22
b(List)g(Matc)n(hing)164 1340 y Fp(This)14 b(section)g(considers)g(matc)o
(hing)f(of)i(non-empt)o(y)e(parameter)g(lists)g(of)i(non-built-in)164
1400 y(functions.)164 1530 y Fq(6.8.1)55 b(Chec)n(king)19 b(List)f(Length)164
1623 y Fp(The)24 b(seman)o(tics)e(of)j Fq(GPPL)f Fp(require)f(that)i(the)f(n)
o(um)o(b)q(ers)f(of)h(actual)g(and)h(formal)164 1683 y(parameters)c(b)q(e)g
(the)g(same.)36 b(Recall)21 b(from)f(section)h(6.4.3)h(that)g(construction)g
(of)g(a)164 1743 y(function)16 b(sym)o(b)q(ol)f(en)o(tails)h(syn)o(thesis)g
(of)g(a)h(rev)o(erse-order)f(list)f(of)i(the)f(function's)g(pa-)164
1803 y(rameters,)24 b(and)h(installation)f(of)g(that)g(list)g(in)g(the)f(sym)
o(b)q(ol's)g Fj(struct)g(sym)p Fp(.)44 b(The)164 1863 y Fj(actParamLi)o(st)15
b Fp(non)o(terminal)h(has)j(an)f(inherited)f(attribute)h Fj(formParam)o(Lis)o
(t)p Fp(.)24 b(F)l(or)164 1924 y Fj(actParamLi)o(st)16 b Fp(no)q(des)k(whose)
f(paren)o(t)g(no)q(des)h(are)f(lab)q(eled)g Fj(funcDecl)p Fp(,)d(this)j(is)g
(the)164 1984 y Fj(paramList)d Fp(mem)n(b)q(er)h(of)i(the)g
Fj(struct)k(sym)18 b Fp(of)i(the)f Fj(ID)f Fp(asso)q(ciated)i(with)f(the)g
(func-)164 2044 y(tion)h(in)o(v)o(o)q(cation.)31 b(The)19 b(paren)o(ts)h(of)g
(other)g Fj(actParamLi)o(st)c Fp(no)q(des)21 b(are)f(themselv)o(es)164
2104 y Fj(actParamLi)o(st)13 b Fp(no)q(des,)j(and)h(in)f(eac)o(h)g(suc)o(h)g
(case,)g(the)g(c)o(hild)f(inherits)g(the)164 2164 y Fj(formParamL)o(ist)f
Fp(of)19 b(the)f(paren)o(t,)g(less)g(the)g(list's)f(head.)27
b(The)19 b(decapitation)f(is)g(p)q(er-)164 2224 y(formed)11
b(b)o(y)h Fj(cdrParamLis)o(t)p Fp(,)e(whic)o(h,)i(if)g(passed)h(a)g(list)f
(of)h(length)f(zero)g(or)h(one,)g(rep)q(orts)164 2285 y(that)i(there)f(w)o
(ere)g(to)q(o)i(man)o(y)d(actual)i(parameters.)20 b(If)14 b(the)h
Fj(actParamLi)o(st)c Fp(no)q(de)16 b(cor-)164 2345 y(resp)q(onding)24
b(to)g(the)f Fj(expr)f Fp(no)q(de)j(of)e(the)h(leftmost)d(actual)j(parameter)
e(receiv)o(es)g(a)164 2405 y Fj(formParamL)o(ist)12 b Fp(of)j(more)f(than)i
(one)g(sym)o(b)q(ol,)d(the)i Fq(C)h Fp(function)f Fj(paramMatchC)o(hec)o(k)
164 2465 y Fp(rep)q(orts)i(a)g(missing)d(actual)j(parameter.)p
eop
%%Page: 22 23
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(22)164
307 y Fq(6.8.2)55 b(Other)18 b(Chec)n(ks)164 400 y Fp(Eac)o(h)g
(actual/formal)e(pair)i(m)o(ust)e(agree)i(in)f(t)o(yp)q(e)g(\(sections)g(3.2)
h(and)g(5.3\),)g(and)g(this)164 460 y(is)e(c)o(hec)o(k)o(ed)e(b)o(y)i
Fj(paramMatc)o(hCh)o(ec)o(k)p Fp(.)237 520 y(Reference)g(formal)g(parameters)
h(can)g(b)q(e)h(matc)o(hed)d(only)j(to)f(storage)i(references.)164
580 y(The)f Fj(isStgRef)d Fp(syn)o(thesized)i(attribute)h(of)g(the)g
Fj(expr)e Fp(non)o(terminal)h(is)g(a)i(predicate)164 640 y(that)j(is)g
Fj(TRUE)e Fp(exactly)h(when)h(the)g(no)q(de)g(to)h(whic)o(h)e(it)g(b)q
(elongs)i(corresp)q(onds)g(to)g(a)164 700 y(storage)12 b(reference.)18
b(P)o(assing)11 b(a)g Fj(FALSE)f Fp(instance)g(of)h Fj(isStgRef)d
Fp(to)j Fj(paramMatchC)o(hec)o(k)164 761 y Fp(along)17 b(with)f(the)g(sym)o
(b)q(ol)f(of)i(a)f(reference)f(parameter)g(results)h(in)g(an)h(error)f(rep)q
(ort.)164 905 y Fh(6.9)70 b(Index)23 b(Matc)n(hing)g(in)f(Storage)i
(References)164 997 y Fp(The)15 b(dimensions)f(of)i(a)f(storage)i(reference)c
(m)o(ust)h(b)q(e)i(consisten)o(t)f(\(sections)g(5.5.2)g(and)164
1058 y(5.5.3\))c(with)g(those)g(of)g(the)g(storage)h(declaration)e(to)h(whic)
o(h)f(it)h(is)f(matc)o(hed)g(b)o(y)g(the)g(scop)q(e)164 1118
y(rules)16 b(\(section)g(6.7.1\).)23 b(This)17 b(is)f(c)o(hec)o(k)o(ed)e
(using)j(list-matc)o(hing)e(metho)q(ds)h(similar)f(to)164 1178
y(those)k(for)g(parameter)e(lists)i(\(section)f(6.8.1\).)29
b(Recall)17 b(from)h(section)g(6.4.1)h(that)g(the)164 1238
y Fj(dimList)14 b Fp(of)k(the)f Fj(ID)f Fp(no)q(de)i(of)f(the)g(reference)e
(is)i(a)h(scaled,)e(rev)o(erse-order)g(list)h(of)g(the)164
1298 y(sym)o(b)q(ol's)e(storage)i(dimensions.)237 1359 y(There)f(are)g(t)o(w)
o(o)g(cases:)237 1460 y Ff(\017)24 b Fp(The)18 b(storage)i(reference)d(is)h
(matc)o(hed)f(to)i(a)g(formal)e(parameter.)27 b(In)18 b(this)h(case)286
1521 y(the)j Fj(formalMat)o(ch)d Fp(attribute)i(of)h(the)g(corresp)q(onding)h
Fj(stgRef)d Fp(no)q(de)i(is)g(the)286 1581 y(sym)o(b)q(ol)c(of)h(the)f(matc)o
(hed)g(parameter,)f(and)j Fq(gc)f Fp(m)o(ust)e(test)i(the)g(condition)g(of)
286 1641 y(section)d(5.5.3.)23 b(The)17 b Fq(C)g Fp(function)g
Fj(adjustDim)o(Lis)o(t)d Fp(\(in)i Fj(sem.c)p Fp(\))f(matc)o(hes)g(the)286
1701 y(less)20 b(signi\014can)o(t)g(dimensions)g(of)h(the)f(dimension)f(list)
h(of)h(its)f Fj(actualSym)d Fp(ar-)286 1761 y(gumen)o(t)22
b(one-b)o(y-one)i(with)f(the)g(dimensions)f(of)i(the)f(dimension)f(list)g(of)
i(its)286 1821 y Fj(formalSym)17 b Fp(argumen)o(t.)31 b(It)20
b(returns)g(the)f(dimension)g(list)g(of)h(its)g Fj(actualSym)286
1882 y Fp(argumen)o(t)15 b(truncated)h(b)o(y)g(the)g(dimensions)f(matc)o
(hed.)237 1983 y Ff(\017)24 b Fp(The)19 b(storage)h(reference)d(is)h(not)i
(matc)o(hed)d(to)i(a)g(formal)f(parameter,)g(and)h(the)286
2044 y Fj(formalMatc)o(h)14 b Fp(attribute)i(of)h(the)g Fj(stgRef)e
Fp(no)q(de)i(is)g Fj(lambdaSym)p Fp(.)j(In)c(this)h(case)286
2104 y(the)h(condition)h(of)g(section)f(5.5.2)h(is)f(tested.)28
b Fj(adjustDimL)o(is)o(t)16 b Fp(is)i(called,)g(but)286 2164
y(the)j(main)e(b)q(o)q(dy)j(of)g(its)e(co)q(de)i(is)e(not)i(executed,)e(and)i
(it)e(returns)h(the)g(whole)286 2224 y(dimension)15 b(list)g(of)i(its)f
Fj(actualSym)d Fp(argumen)o(t.)164 2326 y(In)19 b(eac)o(h)g(case)g(the)g
(list)g(returned)g(b)o(y)g Fj(adjustDim)o(Lis)o(t)d Fp(b)q(ecomes)i(the)h(v)m
(alue)h(of)f(the)164 2386 y Fj(dimList)9 b Fp(attribute)h(of)i(the)f
Fj(indexSeq)d Fp(no)q(de)k(whose)g(paren)o(t)f(is)g(the)g Fj(stgRef)e
Fp(no)q(de)j(cor-)164 2446 y(resp)q(onding)18 b(to)f(the)f(storage)i
(reference.)j(The)16 b Fj(dimList)e Fp(attribute)j(of)g(an)g
Fj(indexSeq)p eop
%%Page: 23 24
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(23)164
307 y(no)q(de)17 b(whose)f(paren)o(t)g(is)g(itself)f(an)h Fj(indexSeq)d
Fp(no)q(de)k(is)e(inherited)g(as)i(the)e Fj(dimList)f Fp(of)164
367 y(the)i(paren)o(t,)g(less)g(its)g(least)g(signi\014can)o(t)g(dimension.)
164 512 y Fh(6.10)70 b(Co)r(de)22 b(Generation)164 604 y Fp(Chapter)e(6,)f
Fg(Implementation)j(of)e(Blo)n(ck-Structur)n(e)n(d)i(L)n(anguages)p
Fp(,)e(of)f([MacLennan])164 664 y(pro)o(vides)g(go)q(o)q(d)j(bac)o(kground)f
(for)f(understanding)h Fq(gc)p Fp('s)f(co)q(de)g(generation)h(and)f(the)164
725 y(b)q(eha)o(vior)c(of)h(the)f(generated)g(programs.)237
785 y(The)e(reader)g(should)g(refer)f(to)h Fj(code.c)e Fp(and)j(some)d
(sample)h(generated)h(co)q(de)g(while)164 845 y(studying)i(this)h(section.)
164 975 y Fq(6.10.1)55 b(T)-5 b(arget)19 b(Language)164 1067
y Fp(F)l(or)g(the)f(presen)o(t)h(implem)o(e)o(n)o(tation,)d(the)j(target)g
(language)h(is)e Fq(C)p Fp(.)h(This)g(is)g(done)g(for)164 1127
y(the)d(follo)o(wing)g(reasons:)224 1229 y(1.)24 b(The)11 b(generated)h
(programs)g(can)f(b)q(e)h(run)g(on)g(an)o(y)f(system)f(ha)o(ving)i(a)g
Fq(C)g Fp(compiler.)224 1331 y(2.)24 b(The)d Fq(C)g Fp(library)f(functions)h
Fj(malloc)p Fp(,)f Fj(printf)p Fp(,)f Fj(scanf)p Fp(,)h(and)h
Fj(exit)p Fp(,)f(and)i Fq(C)p Fp('s)286 1391 y(\015oating)f(p)q(oin)o(t)g(op)
q(erations)h(can)e(b)q(e)h(used,)g(co)q(de)g(generation)g(for)g(the)f(corre-)
286 1451 y(sp)q(onding)d Fq(GPPL)g Fp(constructs)g(b)q(eing)f(of)h(p)q
(eripheral)e(in)o(terest.)164 1553 y(Except)d(as)i(men)o(tioned)c(in)j(p)q
(oin)o(t)g(2)g(ab)q(o)o(v)o(e,)g(the)g(generated)f Fq(C)i Fp(co)q(de)f(is)f
(v)o(ery)g(lo)o(w)h(lev)o(el,)164 1613 y(and)i(is)f(directly)f(comparable)g
(to)i(assem)o(bly)d(language.)22 b(The)14 b(only)g(uses)h(of)f
Fq(C)h Fp(con)o(trol)164 1673 y(constructs)i(constitute:)237
1775 y Ff(\017)24 b Fg(c)n(onditional)18 b(br)n(anch)f Fp(\(implem)o(e)o(n)o
(ted)c(using)k(an)g Fj(if)e Fp(together)h(with)h(a)f Fj(goto)p
Fp(\).)237 1877 y Ff(\017)24 b Fg(unc)n(onditional)19 b(br)n(anch)d
Fp(\(a)h Fj(goto)p Fp(\).)237 1978 y Ff(\017)24 b Fg(r)n(eturn)14
b(fr)n(om)f(function)i(c)n(al)r(l)p Fp(.)21 b Fq(C)13 b Fp(lab)q(els)g(are)g
(not)g(stored)g(in)f(v)m(ariables,)h(so)g(return)286 2039 y(addresses)19
b(are)g(represen)o(ted)f(on)h(the)f(stac)o(k)h(as)g(in)o(tegers.)28
b Fq(gc)19 b Fp(writes)f(a)h(single)286 2099 y Fj(switch)12
b Fp(statemen)o(t)g(whose)i Fj(case)p Fp(s)f(are)g(lab)q(eled)h(with)f(those)
h(in)o(teger)f(represen-)286 2159 y(tations.)22 b(The)16 b(co)q(de)g(fragmen)
o(t)f(executed)f(for)i(a)h(giv)o(en)e Fj(case)g Fp(is)g(a)i
Fj(goto)d Fp(whose)286 2219 y(target)j(is)f(the)g(lab)q(el)f(of)i(the)f(co)q
(de)g(follo)o(wing)g(the)g(co)q(de)h(for)f(the)g(function)g(call.)164
2321 y(Only)i(t)o(w)o(o)g(v)m(ariables)g(\(those)h(for)f(the)g(stac)o(k)g(p)q
(oin)o(ter)g(and)h(the)f(frame)f(p)q(oin)o(ter\))h(and)164
2381 y(only)e(one)g(function)g(\()p Fj(main)p Fp(\))f(are)h(declared)g(in)g
(the)g(generated)g(program.)p eop
%%Page: 24 25
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(24)164
307 y Fh(6.11)70 b(Structure)16 b(and)i(Beha)n(vior)e(of)h(the)f(Generated)g
(C)g(Pro-)355 382 y(gram)164 474 y Fq(6.11.1)55 b(The)19 b(Activ)m(ation)e
(Stac)n(k)164 567 y Fp(The)d(stac)o(k)g(is)g(allo)q(cated)g(b)o(y)g(a)g
Fj(malloc)e Fp(call,)i(then)g(the)f(stac)o(k)h(p)q(oin)o(ter)g(is)g(made)f
(ready)164 627 y(for)20 b(the)g(\014rst)g(push)h(op)q(eration.)33
b(The)20 b(stac)o(k)f(\\gro)o(ws")j(from)d(high)h(memory)d(to)j(lo)o(w)164
687 y(memory)l(.)j(Th)o(us)c(eac)o(h)e(p)q(op)i(giv)o(es)e(the)h(stac)o(k)f
(p)q(oin)o(ter)h(a)g(higher)g(address,)h(and)f(eac)o(h)164
747 y(push)c(is)g(a)g(subtraction)g(from)f(the)g(stac)o(k)g(p)q(oin)o(ter.)21
b(Casts)14 b(are)g(ob)o(viated)f(b)o(y)h(declaring)164 807
y(as)i(unions)f(the)g(items)e(on)j(the)e(stac)o(k.)21 b(In)15
b(the)g(follo)o(wing,)f Fg(top)h Fp(is)g(used)g(in)g(the)g(sense)g(of)164
868 y Fg(stack-as-an-abstr)n(act-data-typ)n(e)p Fp(,)i(and)e(without)f
(reference)f(to)h(the)g(impleme)o(n)o(tation.)237 928 y(An)g
Fg(activation)j(r)n(e)n(c)n(or)n(d)12 b Fp(is)i(a)h(segmen)o(t)e(of)i(the)f
(stac)o(k)g(corresp)q(onding)h(to)g(execution)164 988 y(of)i(a)f(blo)q(c)o(k)
g(and)h(con)o(taining)f(the)g(follo)o(wing)g(items)e(pushed)j(in)f(the)g
(follo)o(wing)g(order:)224 1090 y(1.)24 b(The)16 b Fg(actual)j(p)n(ar)n
(ameters)p Fp(.)i(These)16 b(are)h(presen)o(t)f(only)g(for)h(activ)m(ations)g
(of)g(func-)286 1150 y(tion)c(blo)q(c)o(ks,)g(b)q(eing)h(the)f(results)f(of)i
(the)f(expressions)g(in)g(the)g(actual)g(parameter)286 1210
y(list)i(of)h(the)g(in)o(v)o(o)q(cation.)21 b(They)15 b(are)h(pushed)g
(leftmost-\014rst,)f(so)h(the)g(righ)o(tmost)286 1270 y(parameter)f(is)h
(nearest)g(the)g(top.)224 1372 y(2.)24 b(The)e Fg(r)n(eturn)h(addr)n(ess)p
Fp(.)38 b(This)22 b(is)g(presen)o(t)g(only)g(for)g(activ)m(ations)h(of)f
(function)286 1432 y(blo)q(c)o(ks.)30 b(It)19 b(is)g(an)g(in)o(teger)g(and)g
(is)g(equiv)m(alen)o(t)f(to)i(the)f(lab)q(el)g(in)f(the)h(caller)g(to)286
1492 y(whic)o(h)c(to)i(return)f(con)o(trol)g(up)q(on)h(deactiv)m(ation.)224
1594 y(3.)24 b(The)d Fg(static)h(link)p Fp(.)36 b(This)21 b(p)q(oin)o(ts)g
(to)h(an)f(activ)m(ation)g(record)f(of)i(the)e(enclosing)286
1654 y(blo)q(c)o(k,)d(the)h(presen)o(t)g(activ)m(ation)g(ha)o(ving)g(ev)o(en)
o(tually)e(resulted)h(from)g(that)i(ac-)286 1714 y(tiv)m(ation)d(of)h(the)f
(enclosing)g(blo)q(c)o(k.)224 1816 y(4.)24 b(The)c Fg(dynamic)h(link)p
Fp(.)34 b(This)20 b(p)q(oin)o(ts)g(to)h(the)f(record)f(of)i(the)f(activ)m
(ation)g(whic)o(h)286 1876 y(imme)o(diately)13 b(preceded)i(the)h(presen)o(t)
g(activ)m(ation.)224 1978 y(5.)24 b(The)15 b Fg(r)n(eturn-value)j(r)n(e)n
(gister)c Fp(\(R)-5 b(VR\).)14 b(This)h(is)g(pro)o(vided)f(to)h(receiv)o(e,)e
(just)i(prior)286 2038 y(to)i(deactiv)m(ation,)e(a)i(v)m(alue)f(to)g(b)q(e)h
(returned)f(to)g(the)g(previous)g(activ)m(ation.)224 2140 y(6.)24
b(The)11 b Fg(expr)n(ession)i(r)n(e)n(gisters)p Fp(.)19 b(These)12
b(are)f(used)g(for)h(storing)g(in)o(termediate)c(results)286
2200 y(of)16 b(expressions,)g(as)h(discussed)f(in)g(section)g(6.5.3.)224
2302 y(7.)24 b Fg(V)l(ariables)p Fp(.)31 b(This)19 b(is)g(storage)i(corresp)q
(onding)f(to)f(v)m(ariable)g(declarations)g(\(see)286 2362
y(sections)d(3.1)h(and)33 b(5.5.1\).)p eop
%%Page: 25 26
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(25)164
307 y Fq(6.11.2)55 b(F)-5 b(unction)19 b(Calls)164 400 y Fp(Preparatory)i(to)
g(a)g(function)g(call,)f(the)g(expressions)h(constituting)f(the)h(actual)f
(pa-)164 460 y(rameters)f(are)i(executed,)f(and)h(their)f(results)g(are)h
(pushed)g(on)g(the)f(stac)o(k)h(one)g(at)g(a)164 520 y(time.)e(This)c(is)h
(follo)o(w)o(ed)e(b)o(y)h(pushing)h(the)g(return)f(address.)22
b(Then)15 b(the)g(static)h(link)e(is)164 580 y(computed)g(and)h(pushed,)g
(and)h(there)f(is)f(executed)g(an)i(unconditional)f(branc)o(h)g(to)g(the)164
640 y(b)q(eginning)i(of)f(the)g(function's)g(blo)q(c)o(k.)164
770 y Fq(6.11.3)55 b(Blo)r(c)n(k)18 b(En)n(try)164 863 y Fp(F)l(unction)i
(blo)q(c)o(ks)g(are)h(en)o(tered)e(as)i(the)f(targets)h(of)g
Fj(goto)e Fp(statemen)o(ts)g(in)h(the)g(co)q(de)164 923 y(generated)f(for)g
(the)f(caller.)27 b(Th)o(us)19 b(the)g(parameters,)e(the)i(return)f(address,)
i(and)f(the)164 983 y(static)d(link)f(are)i(presen)o(t)e(on)i(top)g(of)f(the)
g(stac)o(k)g(at)h(blo)q(c)o(k-en)o(try)e(time.)237 1043 y(Unnamed)20
b(blo)q(c)o(ks,)j(whic)o(h)e(are)h(lik)o(e)d(comp)q(ound)j(statemen)o(ts,)f
(are)h(en)o(tered)e(b)o(y)164 1103 y(virtue)e(of)h(their)e(p)q(osition)j(in)e
(the)g(program,)h(rather)g(than)g(pursuan)o(t)g(to)g(a)g(function)164
1164 y(call.)36 b(Activ)m(ation)21 b(records)h(of)g(unnamed)e(blo)q(c)o(ks)i
(ha)o(v)o(e)e(no)j(parameters)d(or)i(return)164 1224 y(address.)30
b(The)19 b(\014rst)h(instruction)e(in)h(the)g(co)q(de)g(generated)g(for)h(an)
f(unnamed)f(blo)q(c)o(k)164 1284 y(pushes)f(the)f(static)g(link)f(\(in)h
(this)g(case,)g(the)g(same)f(as)i(the)f(dynamic)e(link\).)237
1344 y(An)f(activ)m(ation)f(record)h(for)g(either)f(kind)g(of)h(blo)q(c)o(k)g
(has)g(a)h(dynamic)d(link,)h(registers,)164 1404 y(and)18 b(storage)g(for)g
(v)m(ariables.)25 b(The)17 b(blo)q(c)o(k-en)o(try)f(co)q(de)i(concerned)f
(with)g(these)g(items)164 1464 y(is)f(the)g(same)f(for)i(either)e(kind)h(of)g
(blo)q(c)o(k.)164 1594 y Fq(6.11.4)55 b(Blo)r(c)n(k)18 b(Exit)164
1687 y Fp(F)l(ollo)o(wing)g(the)g(co)q(de)g(generated)g(for)h(the)f(statemen)
o(ts)f(of)h(a)h(blo)q(c)o(k)e(is)h(the)g Fg(blo)n(ck-exit)164
1747 y(c)n(o)n(de)p Fp(.)28 b(Suc)o(h)19 b(co)q(de)g(restores)g(the)f(stac)o
(k)h(p)q(oin)o(ter)f(and)h(frame)f(p)q(oin)o(ter)g(to)h(the)g(v)m(alues)164
1807 y(they)j(con)o(tained)g(immedi)o(ately)d(prior)k(to)g(activ)m(ation)g
(of)f(the)h(blo)q(c)o(k)f(b)q(eing)h(exited,)164 1867 y(those)h(v)m(alues)g
(ha)o(ving)g(b)q(een)g(stored)h(on)f(the)g(stac)o(k)g(previously)l(.)43
b(The)24 b(blo)q(c)o(k-exit)164 1927 y(co)q(de:)237 2029 y
Ff(\017)g Fp(for)d(either)e(kind)h(of)g(blo)q(c)o(k)g(is)g(executed)f(when)i
(con)o(trol)f(\\falls)g(through")i(the)286 2089 y(co)q(de)16
b(of)h(the)f(curren)o(tly)f(activ)o(e)g(blo)q(c)o(k,)g(i.e.,)f(when)i(all)g
(of)h(its)f(statemen)o(ts)f(ha)o(v)o(e)286 2150 y(b)q(een)h(executed.)237
2251 y Ff(\017)24 b Fp(for)12 b(a)g(function)f(blo)q(c)o(k)h(is)f(executed)f
(to)i(carry)g(out)g(a)g Fj(return)e Fp(from)g(the)i(function.)286
2311 y(In)22 b(this)g(case)h(the)f(blo)q(c)o(k-exit)f(co)q(de)i(is)f(the)h
(target)g(of)f(a)h Fj(goto)e Fp(in)h(the)h(co)q(de)286 2372
y(generated)16 b(for)h(the)f Fj(return)e Fp(statemen)o(t)p
eop
%%Page: 26 27
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(26)164
307 y Fq(6.11.5)55 b(F)-5 b(unction)19 b(Return)164 400 y Fp(A)e
Fj(return)e Fp(statemen)o(t)h(in)h(a)h(function)f(blo)q(c)o(k)g(ma)o(y)f(b)q
(e)i(nested)f(in)g(unnamed)g(blo)q(c)o(ks.)164 460 y(Th)o(us)k(at)f(the)g
(time)f(of)h(its)g(execution,)g(there)g(ma)o(y)f(b)q(e)h(sev)o(eral)g(activ)m
(ation)g(records)164 520 y(on)h(top)f(of)h(that)f(of)h(the)f(giv)o(en)f
(function)h(blo)q(c)o(k.)32 b(Eac)o(h)20 b(of)h(the)f(activ)m(ation)g
(records)164 580 y(m)o(ust)13 b(b)q(e)h(p)q(opp)q(ed,)h(and)g(an)o(y)f
(returned)g(v)m(alue)g(m)o(ust)e(b)q(e)j(left)e(in)h(R)-5 b(VR)13
b(of)h(the)g(function)164 640 y(blo)q(c)o(k's)f(no)o(w-otherwise-useless)h
(activ)m(ation)g(record,)g(so)h(that)f(it)g(can)g(b)q(e)g(accessed)f(b)o(y)
164 700 y(the)j(caller.)237 761 y(Here)f(is)h(the)g(sequence)f(of)i(ev)o(en)o
(ts)e(e\013ecting)h(a)g Fj(return)p Fp(:)224 862 y(1.)24 b(If)13
b(the)f(function)h(is)g(non-)p Fj(void)p Fp(,)g(the)g(v)m(alue)g(to)g(b)q(e)h
(returned)f(is)f(copied)h(in)o(to)g(R)-5 b(VR)286 923 y(of)16
b(the)g(topmost)g(activ)m(ation)h(record.)224 1024 y(2.)24
b(F)l(or)16 b(eac)o(h)g(unnamed)f(blo)q(c)o(k)h(in)g(whic)o(h)g(the)g
Fj(return)e Fp(is)i(nested:)306 1126 y(\(a\))25 b(the)16 b(top)h(activ)m
(ation)f(record)g(is)g(p)q(opp)q(ed.)304 1207 y(\(b\))24 b(If)17
b(the)g(function)g(is)g(non-)p Fj(void)p Fp(,)f(the)h(v)m(alue)g(in)g(R)-5
b(VR)16 b(of)h(the)g(just-p)q(opp)q(ed)393 1267 y(activ)m(ation)f(record)g
(is)f(copied)g(in)o(to)h(R)-5 b(VR)15 b(of)h(the)f(activ)m(ation)h(record)g
(no)o(w)393 1327 y(on)h(top)g(of)f(the)g(stac)o(k.)224 1429
y(3.)24 b(The)12 b(function)g(blo)q(c)o(k's)f(activ)m(ation)i(record)f(is)g
(p)q(opp)q(ed.)21 b(This)12 b(is)g(done)g(b)o(y)g(trans-)286
1489 y(ferring)k(con)o(trol)g(to)g(the)g(function)g(blo)q(c)o(k's)g(blo)q(c)o
(k-exit)f(co)q(de.)224 1591 y(4.)24 b(The)g(return)f(address,)j(whic)o(h)d
(is)h(no)o(w)g(on)g(top)g(of)g(the)g(stac)o(k,)h(is)e(read)h(and)286
1651 y(p)q(opp)q(ed,)14 b(and)g(con)o(trol)f(is)g(returned)g(to)g(the)g
(statemen)o(t)e(follo)o(wing)i(the)g(function)286 1711 y(call.)224
1813 y(5.)24 b(The)16 b(space)h(for)f(the)g(function's)g(actual)g(parameters)
f(is)h(p)q(opp)q(ed.)164 1943 y Fq(6.11.6)55 b(Storage)19 b(References)d(and)
k(Address)f(Computations)164 2035 y Fp(F)l(or)d(eac)o(h)f(storage)i
(reference,)d(there)i(is)f(designated)h(a)h(register)e(to)h(hold)h(the)e
(address)164 2095 y(of)f(the)f(storage)i(to)f(b)q(e)f(accessed.)20
b(The)14 b Fg(static)i(distanc)n(e)e Fp(b)q(et)o(w)o(een)e(a)i(sym)o(b)q(ol)f
(reference)164 2156 y(and)j(its)f(declaration)f(is)h(the)g(lev)o(el)e(of)j
(the)f(en)o(vironmen)o(t)d(of)j(the)g(reference)f(min)o(us)f(the)164
2216 y(lev)o(el)h(of)j(the)f(en)o(vironmen)o(t)d(of)k(its)f(declaration.)p
eop
%%Page: 27 28
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(27)164
307 y Fq(Addressing)20 b(the)g(Correct)g(Activ)m(ation)f(Record)48
b Fp(The)18 b(static)g(link)e(of)i(an)h(ac-)164 367 y(tiv)m(ation)f(record)h
(is)f(the)g(head)h(of)f(a)h(link)o(ed)e(list)h(of)g(activ)m(ation)h(records.)
28 b(The)18 b(static)164 428 y(distance)i(is)f(the)h(n)o(um)o(b)q(er)e(of)i
(links)f(of)i(that)f(list)f(that)h(m)o(ust)f(b)q(e)h(tra)o(v)o(ersed)f(for)h
(cal-)164 488 y(culation)g(of)h(the)g(correct)f(address)h(for)h(the)e(giv)o
(en)g(storage)i(reference.)33 b(The)20 b(result)164 548 y(of)e(this)f(tra)o
(v)o(ersal)g(is)g(that)h(the)f(register)g(designated)g(to)h(hold)g(the)f
(address)h(con)o(tains)164 608 y(the)g(frame)f(p)q(oin)o(ter)g(of)i(an)g
(activ)m(ation)f(record)g(corresp)q(onding)h(to)f(the)g(blo)q(c)o(k)g(of)g
(the)164 668 y(sym)o(b)q(ol's)d(declaration.)164 796 y Fq(O\013set)d(within)g
(the)g(Activ)m(ation)f(Record)48 b Fp(The)11 b(sym)o(b)q(ol's)e(frame-p)q
(oin)o(ter-relativ)o(e)164 856 y(address)17 b(\(whose)f(arithmetic)e(sign)i
(dep)q(ends)g(on)h(whether)f(the)f(reference)g(is)g(to)i(a)f(pa-)164
916 y(rameter)f(or)h(a)h(v)m(ariable\))f(is)g(added)g(in)o(to)g(the)g
(register.)164 1044 y Fq(O\013set)21 b(within)h(the)f(Sym)n(b)r(ol's)f
(Storage)i(Area)49 b Fp(After)18 b(the)h(register)f(is)h(made)164
1104 y(to)d(con)o(tain)f(\(as)h(describ)q(ed)f(ab)q(o)o(v)o(e\))h(the)f
(address)h(of)g(the)f(b)q(eginning)h(of)g(the)f(sym)o(b)q(ol's)164
1164 y(storage)i(area,)g(there)f(is)g(a)h(p)q(ossibly-empt)o(y)e(sequence)g
(of)i(indexing)f(op)q(erations,)h(one)164 1225 y(for)i(eac)o(h)f(arra)o(y)h
(index)e(in)i(the)f(storage)i(reference.)26 b(The)19 b(follo)o(wing)f(steps)h
(are)g(done)164 1285 y(for)d(eac)o(h)g(suc)o(h)g(op)q(eration:)224
1373 y(1.)24 b(The)15 b(index)g(expression)f(is)h(ev)m(aluated)h(and)f(c)o
(hec)o(k)o(ed)e(against)j(the)f(appropriate)286 1433 y(dimension)g(for)h
(out-of-b)q(ound)j(condition.)224 1531 y(2.)24 b(The)13 b(v)m(alue)h(of)f
(the)g(index)g(expression)g(is)g(m)o(ultiplied)d(b)o(y)j(the)g(appropriate)h
(scale)286 1591 y(factor)k(and)h(the)f(result)f(is)h(added)h(in)o(to)e(the)h
(register)g(designated)g(for)g(the)g(ref-)286 1651 y(erence.)164
1779 y Fq(Conditional)g(Dereferencing)46 b Fp(The)16 b(address)g(is)g
(dereferenced)d(exactly)i(when)g(it)164 1839 y(is)23 b(not)h(matc)o(hed)d(to)
j(a)f(reference)f(formal)g(parameter)g(in)h(a)g(function)g(call)g(or)g(the)
164 1899 y(storage)17 b(reference)e(of)h(an)h Fj(input)e Fp(statemen)o(t.)164
2041 y Fh(6.12)70 b(C)22 b(F)-6 b(unctions)23 b(for)h(Co)r(de)e(Generation)
164 2134 y Fp(The)h(follo)o(wing)g(are)h(roughcast)g(descriptions)f(of)g
(some)g(of)g Fq(gc)p Fp('s)g(co)q(de)h(generation)164 2194
y(routines.)d(The)16 b(function)g(de\014nitions)g(are)h(to)f(b)q(e)h(found)g
(in)f Fj(code.c)p Fp(.)164 2322 y Fq(6.12.1)55 b Fj(newLabelNum)164
2414 y Fp(With)11 b(eac)o(h)g(call,)g(this)g(returns)g(the)g(next)g(in)g(an)h
(increasing)f(sequence)f(of)i(non-negativ)o(e)164 2474 y(in)o(tegers.)20
b(Used)c(for)h(generic)e(generation)i(of)f(lab)q(els.)p eop
%%Page: 28 29
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(28)164
307 y Fq(6.12.2)55 b Fj(newReturnLa)o(be)o(lNu)o(m)164 400
y Fp(Similar)12 b(to)j Fj(newLabelNu)o(m)p Fp(,)c(but)k(used)f(only)g(for)h
(generating)g(lab)q(els)f(for)h(returns)f(from)164 460 y(functions)i(\(cf.)21
b Fj(cgTrailer)p Fp(\).)164 590 y Fq(6.12.3)55 b Fj(cgHeader)164
682 y Fp(W)l(rites)16 b(whatev)o(er)f(co)q(de)i(needs)f(to)g(b)q(e)h(up)f
(fron)o(t,)g(in)g(particular)g(that)h(for:)237 784 y Ff(\017)24
b Fp(the)16 b(declaration)g(of)g(the)g(t)o(yp)q(e)g(of)h(the)f(stac)o(k)g
(items)237 885 y Ff(\017)24 b Fp(declaration)16 b(of)g(stac)o(k)g(p)q(oin)o
(ter)g(and)h(frame)e(p)q(oin)o(ter)237 987 y Ff(\017)24 b Fp(function)16
b(header)g(for)h Fj(main)237 1089 y Ff(\017)24 b Fp(stac)o(k)16
b(allo)q(cation)237 1191 y Ff(\017)24 b Fp(stac)o(k)16 b(initialization)164
1320 y Fq(6.12.4)55 b Fj(cgTrailer)164 1413 y Fp(W)l(rites)16
b(all)f(of)i(the)f(co)q(de)g(that)h(m)o(ust)e(b)q(e)h(at)h(the)f(end)g(of)h
(the)f(program:)237 1514 y Ff(\017)24 b Fp(a)19 b Fj(switch)e
Fp(statemen)o(t)g(that)j(con)o(v)o(erts)e(an)h(in)o(teger)f(on)h(top)h(of)f
(the)g(stac)o(k)f(in)o(to)286 1575 y(the)f(target)h(lab)q(el)f(of)h(a)f
Fj(goto)p Fp(.)24 b(The)17 b(switc)o(h)g(is)g(executed)f(after)h(eac)o(h)g
(function)286 1635 y(execution.)j(\(cf.)h Fj(newReturn)o(Lab)o(elN)o(um)p
Fp(\).)237 1737 y Ff(\017)j Fp(index)15 b(out-of-b)q(ounds)k(trap.)237
1838 y Ff(\017)24 b Fp(closing)16 b(curly)f(brace)h(of)h Fj(main)p
Fp(.)164 1968 y Fq(6.12.5)55 b Fj(stgSize)164 2061 y Fp(Calculates)17
b(the)h(amoun)o(t)e(of)i(storage)h(needed)e(for)g(a)h(giv)o(en)f(n)o(um)o(b)q
(er)f(of)h(lo)q(cations)i(of)164 2121 y(a)h(giv)o(en)f(t)o(yp)q(e.)32
b(This)21 b(is)e(an)i(abstraction)g(stub)f(for)g(future)g(implem)o(en)n
(tations)e(with)164 2181 y(di\013eren)o(t)d(target)i(languages.)p
eop
%%Page: 29 30
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(29)164
307 y Fq(6.12.6)55 b Fj(cgFuncAddre)o(ss)164 400 y Fp(Due)22
b(to)g(the)f(order)h(of)g(co)q(de)f(generation,)i(co)q(de)f(for)g(a)g
(function)f(declaration)g(ma)o(y)164 460 y(imme)o(diately)12
b(follo)o(w)j(co)q(de)h(for)g(an)g(executable)e(elemen)o(t)o(.)k(When)e(con)o
(trol)f(lea)o(v)o(es)f(the)164 520 y(co)q(de)21 b(for)f(suc)o(h)g(an)h
(executable)e(elemen)o(t,)f(con)o(trol)i(m)o(ust)f(jump)g(o)o(v)o(er)h(the)g
(co)q(de)h(for)164 580 y(the)14 b(function)f(in)h(order)g(to)g(a)o(v)o(oid)f
(execution)g(of)h(the)f(co)q(de)h(when)g(the)g(function)g(hasn't)164
640 y(b)q(een)i(called.)k(T)l(arget)d(lab)q(els)f(are)h(needed:)237
742 y Ff(\017)24 b Fp(for)16 b(the)g(jump-o)o(v)o(er.)237 844
y Ff(\017)24 b Fp(for)16 b(calls)g(of)h(the)f(function.)164
945 y(These)d(lab)q(els)g(are)g(built)f(b)o(y)g(giving)h(di\013eren)o(t)f
(alphab)q(etic)h(pre\014xes)g(to)g(the)g(same)f(in)o(te-)164
1006 y(ger,)h(namely)e(the)h Fj(label)f Fp(mem)o(b)q(er)f(of)j(the)f
Fj(struct)24 b(sym)11 b Fp(passed)j(to)f Fj(cgFuncAddr)o(ess)o
Fp(.)164 1135 y Fq(6.12.7)55 b Fj(cgFuncCall)164 1228 y Fp(Generates)16
b(co)q(de)h(that:)237 1330 y Ff(\017)24 b Fp(pushes)17 b(the)f(return)g
(address)237 1431 y Ff(\017)24 b Fp(computes)17 b(and)j(pushes)f(the)f
(static)g(link)g(\(one)h(dereference)d(for)j(eac)o(h)f(unit)h(of)286
1491 y(static)d(distance\))237 1593 y Ff(\017)24 b Fp(transfers)17
b(con)o(trol)f(to)g(the)g(co)q(de)h(generated)f(for)g(the)g(function)237
1695 y Ff(\017)24 b Fp(pro)o(vides)13 b(a)h(lab)q(el)f(as)h(the)f(target)h
(of)f(a)h Fj(goto)e Fp(executed)g(after)h(the)h(callee)d(is)j(done)237
1797 y Ff(\017)24 b Fp(stores)17 b(the)e(result)h(of)g(the)g(function)g(call)
g(in)f(the)h(register)g(designated)g(for)g(that)286 1857 y(purp)q(ose)h
(\(unless)f(calling)g(a)g Fj(void)f Fp(function\))237 1958
y Ff(\017)24 b Fp(p)q(ops)17 b(the)f(actual)h(parameters)164
2088 y Fq(6.12.8)55 b Fj(cgFuncTrail)o(er)164 2181 y Fp(Generates:)237
2282 y Ff(\017)24 b Fp(the)16 b Fj(goto)f Fp(that)h(causes)h(the)f(return)g
(of)h(con)o(trol)e(to)i(the)f(caller.)237 2384 y Ff(\017)24
b Fp(the)16 b(target)g(lab)q(el)g(for)g(the)g(function)g(jump-o)o(v)o(er)e
(describ)q(ed)h(in)h(section)g(6.12.6.)p eop
%%Page: 30 31
bop 164 162 a Fm(6)49 b(IMPLEMENT)l(A)l(TION)1031 b Fp(30)164
307 y Fq(6.12.9)55 b Fj(cgBlockEnte)o(r)164 400 y Fp(Co)q(de)17
b(generated)f(b)o(y)g(this)g(is)g(as)h(indicated)e(in)h(section)g(6.11.3.)164
529 y Fq(6.12.10)55 b Fj(cgBlockExit)164 622 y Fp(See)16 b(section)g(6.11.4.)
p eop
%%Page: 31 32
bop 164 162 a Fm(REFERENCES)1235 b Fp(31)164 315 y Fl(References)164
425 y Fp([Bisc)o(ho\013)s(])218 b(Kurt)23 b(M.)e(Bisc)o(ho\013,)j
Fg(User)f(Manual)h(for)e(Ox:)35 b(A)o(n)23 b(A)o(ttribute-)581
485 y(Gr)n(ammar)17 b(Compiling)j(System)g(b)n(ase)n(d)f(on)g(Y)l(ac)n(c,)i
(L)n(ex)e(and)g(C)p Fp(,)581 545 y(TR#92-30,)14 b(Departmen)o(t)d(of)i
(Computer)e(Science,)h(Io)o(w)o(a)g(State)581 606 y(Univ)o(ersit)o(y)l(,)h
(Ames,)h(Io)o(w)o(a.)i(Decem)o(b)q(er,)d(1992.)164 707 y([F)l(eldman])205
b(S.)20 b(I.)f(F)l(eldman,)g Fg(Make{A)i(Pr)n(o)n(gr)n(am)e(for)h
(Maintaining)i(Com-)581 767 y(puter)f(Pr)n(o)n(gr)n(ams)p Fp(,)e(A)l(T&T)h
(Bell)f(Lab)q(oratories,)j(Murra)o(y)e(Hill,)581 828 y(New)h(Jersey)l(.)f
(Revised)g(and)i(reprin)o(ted)e(as)i(PS1:12)h(in)e Fg(UNIX)581
888 y(Pr)n(o)n(gr)n(ammer's)15 b(Manual)p Fp(,)h(Usenix)f(Asso)q(ciation,)i
(1986.)164 990 y([MacLennan])141 b(Bruce)22 b(J.)h(MacLennan,)i
Fg(Principles)g(of)f(Pr)n(o)n(gr)n(amming)e(L)n(an-)581 1050
y(guages)p Fp(,)17 b(2nd.)g(Ed.,)e(Holt,)g(Rinehart)h(and)h(Winston,)f(1987.)
p eop
%%Trailer
end
userdict /end-hook known{end-hook}if
%%EOF
%!PS-Adobe-2.0
%%Creator: dvips 5.480 Copyright 1986-92 Radical Eye Software
%%Title: gppl.appA.dvi
%%Pages: 1 1
%%BoundingBox: 0 0 612 792
%%EndComments
%DVIPSCommandLine: dvips gppl.appA.dvi
%%BeginProcSet: tex.pro
/TeXDict 250 dict def TeXDict begin /N{def}def /B{bind def}N /S{exch}N /X{S N}
B /TR{translate}N /isls false N /vsize 11 72 mul N /@rigin{isls{[0 -1 1 0 0 0]
concat}if 72 Resolution div 72 VResolution div neg scale isls{Resolution hsize
-72 div mul 0 TR}if Resolution VResolution vsize -72 div 1 add mul TR matrix
currentmatrix dup dup 4 get round 4 exch put dup dup 5 get round 5 exch put
setmatrix}N /@landscape{/isls true N}B /@manualfeed{statusdict /manualfeed
true put}B /@copies{/#copies X}B /FMat[1 0 0 -1 0 0]N /FBB[0 0 0 0]N /nn 0 N
/IE 0 N /ctr 0 N /df-tail{/nn 8 dict N nn begin /FontType 3 N /FontMatrix
fntrx N /FontBBox FBB N string /base X array /BitMaps X /BuildChar{
CharBuilder}N /Encoding IE N end dup{/foo setfont}2 array copy cvx N load 0 nn
put /ctr 0 N[}B /df{/sf 1 N /fntrx FMat N df-tail}B /dfs{div /sf X /fntrx[sf 0
0 sf neg 0 0]N df-tail}B /E{pop nn dup definefont setfont}B /ch-width{ch-data
dup length 5 sub get}B /ch-height{ch-data dup length 4 sub get}B /ch-xoff{128
ch-data dup length 3 sub get sub}B /ch-yoff{ch-data dup length 2 sub get 127
sub}B /ch-dx{ch-data dup length 1 sub get}B /ch-image{ch-data dup type
/stringtype ne{ctr get /ctr ctr 1 add N}if}B /id 0 N /rw 0 N /rc 0 N /gp 0 N
/cp 0 N /G 0 N /sf 0 N /CharBuilder{save 3 1 roll S dup /base get 2 index get
S /BitMaps get S get /ch-data X pop /ctr 0 N ch-dx 0 ch-xoff ch-yoff ch-height
sub ch-xoff ch-width add ch-yoff setcachedevice ch-width ch-height true[1 0 0
-1 -.1 ch-xoff sub ch-yoff .1 add]{ch-image}imagemask restore}B /D{/cc X dup
type /stringtype ne{]}if nn /base get cc ctr put nn /BitMaps get S ctr S sf 1
ne{dup dup length 1 sub dup 2 index S get sf div put}if put /ctr ctr 1 add N}
B /I{cc 1 add D}B /bop{userdict /bop-hook known{bop-hook}if /SI save N @rigin
0 0 moveto}N /eop{SI restore showpage userdict /eop-hook known{eop-hook}if}N
/@start{userdict /start-hook known{start-hook}if /VResolution X /Resolution X
1000 div /DVImag X /IE 256 array N 0 1 255{IE S 1 string dup 0 3 index put cvn
put}for 65781.76 div /vsize X 65781.76 div /hsize X}N /p{show}N /RMat[1 0 0 -1
0 0]N /BDot 260 string N /rulex 0 N /ruley 0 N /v{/ruley X /rulex X V}B /V
statusdict begin /product where{pop product dup length 7 ge{0 7 getinterval
(Display)eq}{pop false}ifelse}{false}ifelse end{{gsave TR -.1 -.1 TR 1 1 scale
rulex ruley false RMat{BDot}imagemask grestore}}{{gsave TR -.1 -.1 TR rulex
ruley scale 1 1 false RMat{BDot}imagemask grestore}}ifelse B /a{moveto}B
/delta 0 N /tail{dup /delta X 0 rmoveto}B /M{S p delta add tail}B /b{S p tail}
B /c{-4 M}B /d{-3 M}B /e{-2 M}B /f{-1 M}B /g{0 M}B /h{1 M}B /i{2 M}B /j{3 M}B
/k{4 M}B /w{0 rmoveto}B /l{p -4 w}B /m{p -3 w}B /n{p -2 w}B /o{p -1 w}B /q{p 1
w}B /r{p 2 w}B /s{p 3 w}B /t{p 4 w}B /x{0 S rmoveto}B /y{3 2 roll p a}B /bos{
/SS save N}B /eos{SS restore}B end
%%EndProcSet
TeXDict begin 40258431 52099146 1000 300 300 @start /Fa 3 81
df<0003FE0040001FFFC0C0007F00F1C001F8003FC003F0000FC007C00007C00FC00003C01F80
0003C03F000001C03F000001C07F000000C07E000000C07E000000C0FE00000000FE00000000FE
00000000FE00000000FE00000000FE00000000FE00000000FE000FFFFC7E000FFFFC7F00001FC0
7F00001FC03F00001FC03F00001FC01F80001FC00FC0001FC007E0001FC003F0001FC001FC003F
C0007F80E7C0001FFFC3C00003FF00C026227DA12C>71 D<FFFFE000FFFFE00007F0000007F000
0007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0
000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0001807F0001807
F0001807F0001807F0003807F0003807F0007007F0007007F000F007F001F007F007F0FFFFFFF0
FFFFFFF01D227EA122>76 D<FFFFFF00FFFFFFE007F007F007F001FC07F000FC07F0007E07F000
7E07F0007F07F0007F07F0007F07F0007F07F0007F07F0007E07F0007E07F000FC07F001FC07F0
07F007FFFFE007FFFF0007F0000007F0000007F0000007F0000007F0000007F0000007F0000007
F0000007F0000007F0000007F0000007F0000007F00000FFFF8000FFFF800020227EA126>80
D E /Fb 19 121 df<70F8F8F87005057C840E>46 D<7FFFFFF878078078600780184007800840
07800840078008C007800C80078004800780048007800480078004000780000007800000078000
000780000007800000078000000780000007800000078000000780000007800000078000000780
000007800000078000000780000007800000078000000780000007800000078000000FC00003FF
FF001E227EA123>84 D<0FE0001838003C0C003C0E0018070000070000070000070000FF0007C7
001E07003C0700780700700700F00708F00708F00708F00F087817083C23900FC1E015157E9418
>97 D<0000E0000FE00001E00000E00000E00000E00000E00000E00000E00000E00000E00000E0
0000E00000E001F8E00704E00C02E01C01E03800E07800E07000E0F000E0F000E0F000E0F000E0
F000E0F000E0F000E07000E07800E03800E01801E00C02E0070CF001F0FE17237EA21B>100
D<01FC000707000C03801C01C03801C07801E07000E0F000E0FFFFE0F00000F00000F00000F000
00F000007000007800203800201C00400E008007030000FC0013157F9416>I<003C00C6018F03
8F030F070007000700070007000700070007000700FFF807000700070007000700070007000700
070007000700070007000700070007000700070007807FF8102380A20F>I<00007001F198071E
180E0E181C07001C07003C07803C07803C07803C07801C07001C07000E0E000F1C0019F0001000
001000001800001800001FFE000FFFC00FFFE03800F0600030400018C00018C00018C000186000
306000303800E00E038003FE0015217F9518>I<0E0000FE00001E00000E00000E00000E00000E
00000E00000E00000E00000E00000E00000E00000E00000E1F800E60C00E80E00F00700F00700E
00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E
00700E0070FFE7FF18237FA21B>I<1C001E003E001E001C000000000000000000000000000000
00000E00FE001E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E
000E00FFC00A227FA10E>I<0E00FE001E000E000E000E000E000E000E000E000E000E000E000E
000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E00
0E00FFE00B237FA20E>108 D<0E1FC07F00FE60E183801E807201C00F003C00E00F003C00E00E
003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E003800E0
0E003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E003800E0FFE3FF8F
FE27157F942A>I<0E1F80FE60C01E80E00F00700F00700E00700E00700E00700E00700E00700E
00700E00700E00700E00700E00700E00700E00700E00700E00700E0070FFE7FF18157F941B>I<
01FC000707000C01801800C03800E0700070700070F00078F00078F00078F00078F00078F00078
F000787000707800F03800E01C01C00E038007070001FC0015157F9418>I<0E1F00FE61C00E80
600F00700E00380E003C0E001C0E001E0E001E0E001E0E001E0E001E0E001E0E001E0E003C0E00
3C0E00380F00700E80E00E41C00E3F000E00000E00000E00000E00000E00000E00000E00000E00
000E0000FFE000171F7F941B>I<0E3CFE461E8F0F0F0F060F000E000E000E000E000E000E000E
000E000E000E000E000E000E000F00FFF010157F9413>114 D<0F8830786018C018C008C008E0
08F0007F803FE00FF001F8003C801C800C800CC00CC008E018D0308FC00E157E9413>I<020002
00020002000600060006000E001E003E00FFF80E000E000E000E000E000E000E000E000E000E00
0E000E040E040E040E040E040E040708030801F00E1F7F9E13>I<FF8FF8FF1E01E03C1C01C018
0E01C0180E01E0100E01E01007026020070270200702702003843040038438400384384001C818
8001C81C8001C81C8000F00D0000F00F0000F00F0000600600006006000060060020157F9423>
119 D<FF83FE1F01F00E00C007008003810003830001C20000E400007800007800003800003C00
004E00008E000187000103800201C00401E00C00E03E01F0FF03FE17157F941A>I
E /Fc 3 81 df<000003FF80038000003FFFF007800001FFFFFC0F800007FF007F1F80001FF800
0FFF80007FE00003FF8000FFC00001FF8001FF000000FF8003FE0000007F8007FE0000003F800F
FC0000001F801FF80000001F801FF80000000F803FF80000000F803FF00000000F803FF0000000
07807FF000000007807FF000000007807FE00000000000FFE00000000000FFE00000000000FFE0
0000000000FFE00000000000FFE00000000000FFE00000000000FFE00000000000FFE000000000
00FFE00000000000FFE00007FFFFFEFFE00007FFFFFE7FE00007FFFFFE7FF0000001FF807FF000
0001FF803FF0000001FF803FF0000001FF803FF8000001FF801FF8000001FF801FFC000001FF80
0FFC000001FF8007FE000001FF8003FF000001FF8001FF800001FF8000FFC00003FF80007FE000
03FF80001FF80007FF800007FF803FFF800001FFFFFE1F8000003FFFF80780000003FFC0018037
317BB041>71 D<FFFFFFF00000FFFFFFF00000FFFFFFF0000000FFC000000000FFC000000000FF
C000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FF
C000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000007000FF
C000007000FFC000007000FFC00000F000FFC00000F000FFC00000E000FFC00000E000FFC00001
E000FFC00001E000FFC00003E000FFC00003E000FFC00007E000FFC0000FE000FFC0001FE000FF
C0007FC000FFC003FFC0FFFFFFFFFFC0FFFFFFFFFFC0FFFFFFFFFFC02C317EB032>76
D<FFFFFFFFE000FFFFFFFFFE00FFFFFFFFFF8000FFC001FFE000FFC0003FF000FFC0001FF800FF
C0000FFC00FFC0000FFC00FFC00007FE00FFC00007FE00FFC00007FF00FFC00007FF00FFC00007
FF00FFC00007FF00FFC00007FF00FFC00007FF00FFC00007FF00FFC00007FE00FFC00007FE00FF
C0000FFC00FFC0000FFC00FFC0001FF800FFC0003FF000FFC001FFE000FFFFFFFF8000FFFFFFFE
0000FFFFFFE00000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FF
C000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FF
C0000000FFFFFFC00000FFFFFFC00000FFFFFFC0000030317EB038>80 D
E /Fd 17 121 df<78FCFCFCFC780000000000000000000000000000000000000078FCFCFCFC78
061F7A9E12>58 D<00000300000000000300000000000300000000000780000000000780000000
000FC0000000000FC0000000000FC00000000017E00000000013E00000000013E00000000023F0
0000000021F00000000021F00000000040F80000000040F80000000040F800000000807C000000
00807C00000001807E00000001003E00000001003E00000002003F00000002001F00000002001F
00000004000F80000004000F80000004000F800000080007C00000080007C00000180007E00000
1FFFFFE000001FFFFFE00000200003F00000200001F00000200001F00000400001F80000400000
F80000400000F800008000007C00008000007C00008000007C00010000003E00010000003E0003
0000003F00030000001F00070000001F001F8000003F80FFE00003FFFCFFE00003FFFC2E327EB1
32>65 D<FFFFFFC000FFFFFFF80007E0007E0003E0001F0003E000078003E00003C003E00001E0
03E00001F003E00001F003E00000F003E00000F803E00000F803E00000F803E00000F803E00000
F803E00000F803E00000F003E00001F003E00001E003E00003E003E00003C003E000078003E000
1F0003E0007C0003FFFFF00003E000000003E000000003E000000003E000000003E000000003E0
00000003E000000003E000000003E000000003E000000003E000000003E000000003E000000003
E000000003E000000003E000000003E000000003E000000003E000000003E000000003E0000000
07F0000000FFFF800000FFFF80000025317CB02D>80 D<007F802001FFE02007C078600F001C60
1E0006E03C0003E0380001E0780000E0700000E070000060F0000060F0000060F0000020F00000
20F0000020F8000020F80000007C0000007E0000003F0000003FC000001FF800000FFF800007FF
F80003FFFC0000FFFF00000FFF800000FFC000001FE0000007E0000003F0000001F0000000F000
0000F8000000F88000007880000078800000788000007880000078C0000078C0000070E00000F0
E00000E0F00000E0F80001C0EC000380C7000700C1F01E00807FFC00800FF0001D337CB125>83
D<00FE00000303C0000C00E00010007000100038003C003C003E001C003E001E003E001E000800
1E0000001E0000001E0000001E00000FFE0000FC1E0003E01E000F801E001F001E003E001E003C
001E007C001E00F8001E04F8001E04F8001E04F8003E04F8003E0478003E047C005E043E008F08
0F0307F003FC03E01E1F7D9E21>97 D<000001E000003FE000003FE0000003E0000001E0000001
E0000001E0000001E0000001E0000001E0000001E0000001E0000001E0000001E0000001E00000
01E0000001E0000001E0000001E0001F81E000F061E001C019E0078005E00F0003E00E0003E01E
0001E03C0001E03C0001E07C0001E0780001E0F80001E0F80001E0F80001E0F80001E0F80001E0
F80001E0F80001E0F80001E0F80001E0780001E0780001E03C0001E03C0001E01C0001E01E0003
E00E0005E0070009E0038011F000E061FF003F81FF20327DB125>100 D<003F800000E0E00003
80380007003C000E001E001E001E001C000F003C000F007C000F0078000F8078000780F8000780
F8000780FFFFFF80F8000000F8000000F8000000F8000000F8000000F8000000780000007C0000
003C0000003C0000801E0000800E0001000F0002000780020001C00C0000F03000001FC000191F
7E9E1D>I<000000F0007F030801C1C41C0380E81C070070080F0078001E003C001E003C003E00
3E003E003E003E003E003E003E003E003E003E003E001E003C001E003C000F0078000700700007
80E00009C1C000087F000018000000180000001800000018000000180000001C0000000E000000
0FFFF80007FFFF0003FFFF800E000FC0180001E0300000F070000070E0000038E0000038E00000
38E0000038E00000387000007070000070380000E01C0001C00700070001C01C00003FE0001E2F
7E9F21>103 D<07000F801F801F800F8007000000000000000000000000000000000000000000
00000780FF80FF800F800780078007800780078007800780078007800780078007800780078007
800780078007800780078007800780078007800FC0FFF8FFF80D307EAF12>105
D<0780FF80FF800F80078007800780078007800780078007800780078007800780078007800780
078007800780078007800780078007800780078007800780078007800780078007800780078007
80078007800780078007800780078007800FC0FFFCFFFC0E327EB112>108
D<0780FE001FC000FF83078060F000FF8C03C18078000F9001E2003C0007A001E4003C0007A000
F4001E0007C000F8001E0007C000F8001E00078000F0001E00078000F0001E00078000F0001E00
078000F0001E00078000F0001E00078000F0001E00078000F0001E00078000F0001E00078000F0
001E00078000F0001E00078000F0001E00078000F0001E00078000F0001E00078000F0001E0007
8000F0001E00078000F0001E00078000F0001E00078000F0001E00078000F0001E00078000F000
1E000FC001F8003F00FFFC1FFF83FFF0FFFC1FFF83FFF0341F7E9E38>I<0780FE0000FF830780
00FF8C03C0000F9001E00007A001E00007A000F00007C000F00007C000F000078000F000078000
F000078000F000078000F000078000F000078000F000078000F000078000F000078000F0000780
00F000078000F000078000F000078000F000078000F000078000F000078000F000078000F00007
8000F000078000F000078000F0000FC001F800FFFC1FFF80FFFC1FFF80211F7E9E25>I<001FC0
0000F0780001C01C00070007000F0007801E0003C01C0001C03C0001E03C0001E0780000F07800
00F0780000F0F80000F8F80000F8F80000F8F80000F8F80000F8F80000F8F80000F8F80000F878
0000F07C0001F03C0001E03C0001E01E0003C01E0003C00F00078007800F0001C01C0000F07800
001FC0001D1F7E9E21>I<0781FC00FF860700FF8803C00F9001E007A000F007C0007807800078
0780003C0780003C0780003E0780001E0780001F0780001F0780001F0780001F0780001F078000
1F0780001F0780001F0780001F0780003E0780003E0780003C0780007C0780007807C000F007A0
00F007A001E00798038007860F000781F800078000000780000007800000078000000780000007
80000007800000078000000780000007800000078000000FC00000FFFC0000FFFC0000202D7E9E
25>I<0783E0FF8C18FF907C0F907C07A07C07C03807C00007C00007C000078000078000078000
078000078000078000078000078000078000078000078000078000078000078000078000078000
0780000780000780000FC000FFFE00FFFE00161F7E9E19>114 D<01FC100E03301800F0300070
600030E00030E00010E00010E00010F00010F800007E00003FF0001FFF000FFFC003FFE0003FF0
0001F80000F880003C80003C80001CC0001CC0001CE0001CE00018F00038F00030CC0060C301C0
80FE00161F7E9E1A>I<FFF803FF00FFF803FF000FE001F80003C001E00003E001800001E00100
0000F00300000078020000007C040000003C080000001E100000000F300000000FA000000007C0
00000003C000000003E000000001F000000002F00000000478000000087C000000183E00000010
1E000000200F000000400F800000C007C000008003C000018001E000078001F0001F8003F800FF
C007FFC0FFC007FFC0221F7F9E23>120 D E end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 300
TeXDict begin

%%EndSetup
%%Page: 1 1
bop 237 315 a Fd(App)r(endix)20 b(A:)h(Sample)f Fc(GPPL)i Fd(Programs)237
496 y Fb(This)17 b(app)q(endix)f(sho)o(ws)h(some)e(examples)f(of)j(programs)f
(written)g(in)g Fa(GPPL)p Fb(.)p eop
%%Trailer
end
userdict /end-hook known{end-hook}if
%%EOF
%! a2ps 3.0

/$a2psdict 100 dict def
$a2psdict begin
% Initialize page description variables.
/inch {72 mul} bind def
/landscape true def
/twinpage true def
/sheetheight 5.15552e-314 inch def
/sheetwidth 8.5 inch def
/margin 1.2 inch def
/noborder false def
/noheader true def
/headersize 0.0 def
/bodyfontsize 7 def
/lines 68 def
/columns 83 def
/date (Dec 14 1992 13:56:43) def
/duplex false def
/fudge 36.97 22.5 add def
%!  PostScript Source Code
%
%  File: imag:/users/local/a2ps/header.ps
%  Created: Tue Nov 29 12:14:02 1988 by miguel@imag (Miguel Santana)
%  Version: 2.0
%  Description: PostScript prolog for a2ps ascii to PostScript program.
% 
%  Edit History:
%  - Original version by evan@csli (Evan Kirshenbaum).
%  - Modified by miguel@imag to:
%    1) Correct an overflow bug when printing page number 10 (operator
%	cvs).
%    2) Define two other variables (sheetwidth, sheetheight) describing
%	the physical page (by default A4 format).
%    3) Minor changes (reorganization, comments, etc).
%  - Modified by tullemans@apolloway.prl.philips.nl
%    1) Correct stack overflows with regard to operators cvs and copy.
%       The resulting substrings where in some cases not popped off 
%       the stack, what can result in a stack overflow.
%    2) Replaced copypage and erasepage by showpage. Page througput
%       degrades severely (see red book page 140) on our ps-printer
%       after printing sheet 16 (i.e. page 8) of a file which was 
%       actually bigger. For this purpose the definitions of startdoc
%       and startpage are changed.
%  - Modified by Tim Clark <T.Clark@uk.ac.warwick> to:
%    1) Print one page per sheet (portrait) as an option.
%    2) Reduce size of file name heading, if it's too big.
%    3) Save and restore PostScript state at begining/end. It now uses
%	conventional %%Page %%Trailer markers.
%    4) Print one wide page per sheet in landscape mode as an option.
%  - Modified by miguel@imag.fr to
%    1) Add new option to print n copies of a file.
%    2) Add new option to suppress heading printing.
%    3) Add new option to suppress page surrounding border printing.
%    4) Add new option to change font size. Number of lines and columns
%	are now automatically adjusted, depending on font size and
%	printing mode used.
%    5) Minor changes (best layout, usage message, etc).
%  - Modified (1-14-91) by Kelvin Nilsen <kelvin@cs.iastate.edu> to:
%    1) Support double sided printers
%

% Copyright (c) 1988, Miguel Santana, miguel@imag.imag.fr
%
% Permission is granted to copy and distribute this file in modified
% or unmodified form, for noncommercial use, provided (a) this copyright
% notice is preserved, (b) no attempt is made to restrict redistribution
% of this file, and (c) this file is not distributed as part of any
% collection whose redistribution is restricted by a compilation copyright.
%


% General macros.
/xdef {exch def} bind def
/getfont {exch findfont exch scalefont} bind def

% Page description variables and inch function are defined by a2ps program.

% Character size for differents fonts.
   landscape
   { /filenamefontsize 12 def }
   { /filenamefontsize 16 def }
ifelse
/datefontsize filenamefontsize 0.8 mul def
/headermargin filenamefontsize 0.25 mul def
/bodymargin bodyfontsize 0.7 mul def

% Font assignment to differents kinds of "objects"
/filenamefontname /Helvetica-Bold def
/stdfilenamefont filenamefontname filenamefontsize getfont def
/datefont /Helvetica datefontsize getfont def
/bodyfont /Courier bodyfontsize getfont def

% Logical page attributs (a half of a real page or sheet).
/pagewidth
   bodyfont setfont (0) stringwidth pop columns mul bodymargin dup add add
   def
/pageheight
   bodyfontsize lines mul bodymargin dup add add headersize add
   def

% Coordinates for upper corner of a logical page and for sheet number.
% Coordinates depend on format mode used.
% In twinpage mode, coordinate x of upper corner is not the same for left
% and right pages: upperx is an array of two elements, indexed by sheetside.
/rightmargin margin 3 div def
/leftmargin margin 2 mul 3 div def
/topmargin margin twinpage {3} {2} ifelse div def
landscape
{  % Landscape format
   /uppery rightmargin pageheight add bodymargin add def
   /sheetnumbery sheetwidth leftmargin pageheight add datefontsize add sub def
   twinpage
   {  % Two logical pages
      /upperx [ topmargin			% upperx for left page
		dup 2 mul pagewidth add		% upperx for right page
	      ] def
      /sheetnumberx sheetheight topmargin sub def
   }
   {  /upperx [ topmargin dup ] def
      /sheetnumberx sheetheight topmargin sub datefontsize sub def
   }
   ifelse
}
{  % Portrait format
   /uppery topmargin pageheight add def
   /upperx [ leftmargin dup ] def
   /sheetnumberx sheetwidth rightmargin sub datefontsize sub def
   /sheetnumbery
	 sheetheight 
	 topmargin pageheight add datefontsize add headermargin add
      sub
      def

}
ifelse

% Strings used to make easy printing numbers
/pnum 12 string def
/empty 12 string def

% Other initializations.
/datewidth date stringwidth pop def
/filenameroom
         pagewidth
	 filenamefontsize 4 mul datewidth add (Page 999) stringwidth pop add
      sub
   def


% Function startdoc: initializes printer and global variables.
/startdoc
    { /sheetside 0 def			% sheet side that contains current page
      /frontpage true def		%! added by kelvin
      /sheet 1 def			% sheet number
   } bind def

% Function newfile: init file name and reset page number for each new file.
/newfile
    { cleanup
      /filename xdef
      /filenamewidth filename stringwidth pop def
      /filenamefont
	 filenamewidth filenameroom gt
	 {
	       filenamefontname
	       filenamefontsize filenameroom mul filenamewidth div
	    getfont
	 }
	 {  stdfilenamefont }
	 ifelse
	 def
      /pagenum 1 def
    } bind def

% Function printpage: Print a physical page.
/printpage
    { /sheetside 0 def
      twinpage
      {  noborder not
	    { sheetnumber }
	 if
      }
      {  noheader noborder not and
	    { sheetnumber }
	 if
      }
      ifelse
      showpage 
%      pagesave restore
      /frontpage frontpage not def	% added by kelvin
      /sheet sheet 1 add def
    } bind def

% Function cleanup: terminates printing, flushing last page if necessary.
/cleanup
    { twinpage sheetside 1 eq and
         { printpage }
      if
      % added by kelvin
      duplex frontpage not and
         { printpage } 
      if
    } bind def

%
% Function startpage: prints page header and page border and initializes
% printing of the file lines.
/startpage
    { sheetside 0 eq
	{ % /pagesave save def
	  landscape
	    { sheetwidth 0 inch translate	% new coordinates system origin
	      90 rotate				% landscape format
	    } if
	} if
      noborder not { printborder } if
      noheader not { printheader } if
	 upperx sheetside get  bodymargin  add
	    uppery
               % added by kelvin
               duplex not frontpage or {0} {fudge} ifelse add
	    bodymargin bodyfontsize add  noheader {0} {headersize} ifelse  add
	 sub
      moveto
      bodyfont setfont
    } bind def

% Function printheader: prints page header.
/printheader
    { upperx sheetside get  uppery
           % added by kelvin
           duplex not frontpage or {0} {fudge} ifelse add
           headersize sub 1 add  moveto
      datefont setfont
      gsave
        datefontsize headermargin rmoveto
	date show					% date/hour
      grestore
      gsave
	pagenum pnum cvs pop
	   pagewidth (Page 999) stringwidth pop sub
	   headermargin
	rmoveto
        (Page ) show pnum show				% page number
      grestore
      empty pnum copy pop
      gsave
        filenamefont setfont
	      filenameroom filename stringwidth pop sub 2 div datewidth add
	      bodymargin 2 mul 
	   add 
	   headermargin
	rmoveto
        filename show						% file name
      grestore
    } bind def

% Function printborder: prints border page.
/printborder 
    { upperx sheetside get uppery
           % added by kelvin
           duplex not frontpage or {0} {fudge} ifelse add
      moveto
      gsave					% print the four sides
        pagewidth 0 rlineto			% of the square
        0 pageheight neg rlineto
        pagewidth neg 0 rlineto
        closepath stroke
      grestore
      noheader not
         { 0 headersize neg rmoveto pagewidth 0 rlineto stroke }
      if
    } bind def

%
% Function endpage: adds a sheet number to the page (footnote) and prints
% the formatted page (physical impression). Activated at the end of each
% source page (lines reached or FF character).
/endpage
   { /pagenum pagenum 1 add def
     twinpage  sheetside 0 eq  and
        { /sheetside 1 def }
        { printpage }
     ifelse
   } bind def

% Function sheetnumber: prints the sheet number.
/sheetnumber
    { sheetnumberx sheetnumbery moveto
      datefont setfont
      sheet pnum cvs
	 dup stringwidth pop (0) stringwidth pop sub neg 0 rmoveto show
      empty pnum copy pop
    } bind def

% Function s: print a source line
/s  { gsave
        show
      grestore
      0 bodyfontsize neg rmoveto
    } bind def
%%EndProlog

/docsave save def
startdoc
(tempprint1) newfile
/sheet 1 def
%%Page: 1 1
startpage
( ) s
( ) s
( Dec 14 11:24 1992  fib.g Page 1) s
( ) s
( ) s
( /* GPPL program for Fibonacci function */) s
( ) s
( {) s
( int i;) s
( ) s
( i = 0;) s
( while \(i<24\)) s
(   {output\("%d  ",i\);) s
(    output\("%d\\n",fib\(i\)\);) s
(    i = i + 1;) s
(   }) s
( ) s
( ) s
( int fib\(int i;\)) s
(   {if \(i == 0\)) s
(       then return 0;) s
(    if \(i == 1\)) s
(       then return 1;) s
(    return \(fib\(i-2\) + fib\(i-1\)\);) s
(   }) s
( }) s
endpage
startpage
( ) s
( ) s
( Dec 13 18:57 1992  fact.g Page 1) s
( ) s
( ) s
( /* GPPL program for factorial function */) s
( ) s
( /* stores in an array the factorials of the first ten integers,) s
(      then prints them.) s
(  */) s
( ) s
( {) s
( int i,f[10];) s
( ) s
( i = 0;) s
( while \(i<10\)) s
(   {f[i] = fact\(i\);) s
(    i = i + 1;) s
(   }) s
( ) s
( ) s
( int fact\(int i;\)) s
(   {if \(i == 0\)) s
(       then return 1;) s
(       else return i*fact\(i-1\);) s
(   }) s
( ) s
( ) s
( i = 0;) s
( while \(i<10\)) s
(   {output\("%d  ",i\);) s
(    output\("%d\\n",f[i]\);) s
(    i = i + 1;) s
(   }) s
( ) s
( ) s
( }) s
endpage
%%Page: 2 2
startpage
( ) s
( ) s
( Dec 13 18:57 1992  selSort.g Page 1) s
( ) s
( ) s
( /* GPPL selection sort program */) s
( ) s
( /* generates some data, prints it, sorts it, prints it */) s
( ) s
( {) s
( int b[1000];) s
( ) s
( genData\(b,100\);) s
( printData\(b,100\);) s
( selSort \(100,b\) ;) s
( printData\(b,100\);) s
( ) s
( ) s
( ) s
( int mod \(int i,m;\)) s
(   {int dum;) s
(    return i-\(\(i/m\)*m\);) s
(   }) s
( ) s
( ) s
( ) s
( void genData\(var int a[1000];int size;\)) s
(   {int i;) s
(    a[0] = 29;) s
(    i = 1;) s
(    while \(i < size\)) s
(      {a[i] = mod\(\(i*i + a[i-1]\),size\);) s
(       i = i + 1;) s
(      }) s
(   }) s
( ) s
( ) s
( ) s
( void printData\(var int a[1000];int size;\)) s
(   {int i;) s
(    i = 0;) s
(    while \(i < size\)) s
(      {output\("%d   ",i\);) s
(       output\("%d\\n",a[i]\);) s
(       i = i + 1;) s
(      }) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 13 18:57 1992  selSort.g Page 2) s
( ) s
( ) s
( void selSort\(int size; var int a[1000];\)) s
(   {int i,j,temp,min;) s
( ) s
(    i = 0;) s
(    while \(i < size\)) s
(      {) s
(       min = i;) s
(       j = i + 1;) s
(       while \(j < size\)) s
(         {) s
(          if \(a[j] < a[min]\) then min = j;) s
(          j = j + 1;) s
(         }) s
(       temp = a[i];) s
(       a[i] = a[min];) s
(       a[min] = temp;) s
(       i = i + 1;) s
(      }) s
(   }) s
( }) s
endpage
%%Page: 3 3
startpage
( ) s
( ) s
( Dec 13 18:57 1992  qsort.g Page 1) s
( ) s
( ) s
( /* quicksort--based on K&R's example in "The C Programming Language" */) s
( ) s
( /* reads some integers from standard input, quicksorts them and) s
(      prints them to standard output) s
(  */) s
( ) s
( {) s
( int b[10000];) s
( int inSize;) s
( ) s
( qsort \(b,0,\(inSize = getData\(b\)\) - 1\);) s
( printData\(b,inSize\);) s
( ) s
( ) s
( ) s
( int getData\(var int a[10000];\)) s
(   {int i,inStatus;) s
( ) s
(    i = 0;) s
(    inStatus = input\("%d\\n",a[i]\);) s
(    while \(inStatus != EOF && inStatus != 0\)) s
(      {i = i + 1;) s
(       inStatus = input\("%d\\n",a[i]\);) s
(      }) s
(    return i;) s
(   }) s
( ) s
( ) s
( ) s
( void printData\(var int a[10000]; int size;\)) s
(   {int i;) s
( ) s
(    i = 0;) s
(    while \(i < size\)) s
(      {output\("%d\\n",a[i]\);) s
(       i = i + 1;) s
(      }) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 13 18:57 1992  qsort.g Page 2) s
( ) s
( ) s
( void qsort\(var int v[10000]; int left,right;\)) s
(   {int i,last;) s
( ) s
(    if \(left >= right\)) s
(       then) s
(       return;) s
(    swap\(v,left,\(left+right\)/2\);) s
(    last = left;) s
(    i = left + 1;) s
(    while \(i <=  right\)) s
(      {if \(v[i] < v[left]\)) s
(          then) s
(          {last = last + 1;) s
(           swap \(v,last,i\);) s
(          }) s
(       i = i + 1;) s
(      }) s
(    swap\(v,left,last\);) s
(    qsort\(v,left,last-1\);) s
(    qsort\(v,last+1,right\);) s
(   }) s
( ) s
( ) s
( ) s
( void swap\(var int v[10000]; int i,j;\)) s
(   {int temp;) s
( ) s
(    temp = v[i];) s
(    v[i] = v[j];) s
(    v[j] = temp;) s
(   }) s
( ) s
( ) s
( }) s
endpage
%%Page: 4 4
startpage
( ) s
( ) s
( Dec 13 18:57 1992  primes.g Page 1) s
( ) s
( ) s
( /* GPPL program to find prime numbers */) s
( ) s
( /* reads a number from standard input, prints all primes less than that number.) s
(  */) s
( ) s
( {int n;) s
(  bool a[100001];) s
( ) s
(  input\("%d\\n",n\);) s
(  if \(n >= 100001\) then) s
(     {output\("\\n  too many\\n"\);) s
(      exit\(-1\);) s
(     }) s
(     else if \(n < 0\) then) s
(     {output\("\\n  must be positive\\n"\);) s
(      exit\(-1\);) s
(     }) s
(  calcPrimes\(n,a\);) s
(  printPrimes\(n,a\);) s
( ) s
( ) s
(  void calcPrimes\(int size; var bool a[100001];\)) s
(    {int i;) s
( ) s
(     a[0] = FALSE;) s
(     a[1] = FALSE;) s
(     i = 2; while \(i < size\) {a[i] = TRUE; i = i + 1;}) s
( ) s
(     i = 2;) s
(     while \(i < size\)) s
(       {int j;) s
( ) s
(        if a[i] then) s
(           {j = 2 * i;) s
(            while \(j < size\)) s
(              {a[j] = FALSE;) s
(               j = j + i;) s
(              }) s
(           }) s
(        i = i + 1;) s
(       }) s
(    }) s
( ) s
( ) s
( ) s
(  void printPrimes\(int size; var bool a[100001];\)) s
(    {int i;) s
( ) s
(     i = 2;) s
(     while \(i < size\)) s
(       {if a[i] then output\("%d\\n",i\);) s
(        i = i + 1;) s
(       }) s
(    }) s
( }) s
endpage

%%Trailer
cleanup
docsave restore end
%!PS-Adobe-2.0
%%Creator: dvips 5.480 Copyright 1986-92 Radical Eye Software
%%Title: gppl.appB.dvi
%%Pages: 1 1
%%BoundingBox: 0 0 612 792
%%EndComments
%DVIPSCommandLine: dvips gppl.appB.dvi
%%BeginProcSet: tex.pro
/TeXDict 250 dict def TeXDict begin /N{def}def /B{bind def}N /S{exch}N /X{S N}
B /TR{translate}N /isls false N /vsize 11 72 mul N /@rigin{isls{[0 -1 1 0 0 0]
concat}if 72 Resolution div 72 VResolution div neg scale isls{Resolution hsize
-72 div mul 0 TR}if Resolution VResolution vsize -72 div 1 add mul TR matrix
currentmatrix dup dup 4 get round 4 exch put dup dup 5 get round 5 exch put
setmatrix}N /@landscape{/isls true N}B /@manualfeed{statusdict /manualfeed
true put}B /@copies{/#copies X}B /FMat[1 0 0 -1 0 0]N /FBB[0 0 0 0]N /nn 0 N
/IE 0 N /ctr 0 N /df-tail{/nn 8 dict N nn begin /FontType 3 N /FontMatrix
fntrx N /FontBBox FBB N string /base X array /BitMaps X /BuildChar{
CharBuilder}N /Encoding IE N end dup{/foo setfont}2 array copy cvx N load 0 nn
put /ctr 0 N[}B /df{/sf 1 N /fntrx FMat N df-tail}B /dfs{div /sf X /fntrx[sf 0
0 sf neg 0 0]N df-tail}B /E{pop nn dup definefont setfont}B /ch-width{ch-data
dup length 5 sub get}B /ch-height{ch-data dup length 4 sub get}B /ch-xoff{128
ch-data dup length 3 sub get sub}B /ch-yoff{ch-data dup length 2 sub get 127
sub}B /ch-dx{ch-data dup length 1 sub get}B /ch-image{ch-data dup type
/stringtype ne{ctr get /ctr ctr 1 add N}if}B /id 0 N /rw 0 N /rc 0 N /gp 0 N
/cp 0 N /G 0 N /sf 0 N /CharBuilder{save 3 1 roll S dup /base get 2 index get
S /BitMaps get S get /ch-data X pop /ctr 0 N ch-dx 0 ch-xoff ch-yoff ch-height
sub ch-xoff ch-width add ch-yoff setcachedevice ch-width ch-height true[1 0 0
-1 -.1 ch-xoff sub ch-yoff .1 add]{ch-image}imagemask restore}B /D{/cc X dup
type /stringtype ne{]}if nn /base get cc ctr put nn /BitMaps get S ctr S sf 1
ne{dup dup length 1 sub dup 2 index S get sf div put}if put /ctr ctr 1 add N}
B /I{cc 1 add D}B /bop{userdict /bop-hook known{bop-hook}if /SI save N @rigin
0 0 moveto}N /eop{SI restore showpage userdict /eop-hook known{eop-hook}if}N
/@start{userdict /start-hook known{start-hook}if /VResolution X /Resolution X
1000 div /DVImag X /IE 256 array N 0 1 255{IE S 1 string dup 0 3 index put cvn
put}for 65781.76 div /vsize X 65781.76 div /hsize X}N /p{show}N /RMat[1 0 0 -1
0 0]N /BDot 260 string N /rulex 0 N /ruley 0 N /v{/ruley X /rulex X V}B /V
statusdict begin /product where{pop product dup length 7 ge{0 7 getinterval
(Display)eq}{pop false}ifelse}{false}ifelse end{{gsave TR -.1 -.1 TR 1 1 scale
rulex ruley false RMat{BDot}imagemask grestore}}{{gsave TR -.1 -.1 TR rulex
ruley scale 1 1 false RMat{BDot}imagemask grestore}}ifelse B /a{moveto}B
/delta 0 N /tail{dup /delta X 0 rmoveto}B /M{S p delta add tail}B /b{S p tail}
B /c{-4 M}B /d{-3 M}B /e{-2 M}B /f{-1 M}B /g{0 M}B /h{1 M}B /i{2 M}B /j{3 M}B
/k{4 M}B /w{0 rmoveto}B /l{p -4 w}B /m{p -3 w}B /n{p -2 w}B /o{p -1 w}B /q{p 1
w}B /r{p 2 w}B /s{p 3 w}B /t{p 4 w}B /x{0 S rmoveto}B /y{3 2 roll p a}B /bos{
/SS save N}B /eos{SS restore}B end
%%EndProcSet
TeXDict begin 40258431 52099146 1000 300 300 @start /Fa 9 121
df<0003FE0080001FFF818000FF01E38001F8003F8003E0001F8007C0000F800F800007801F80
0007803F000003803F000003807F000001807E000001807E00000180FE00000000FE00000000FE
00000000FE00000000FE00000000FE00000000FE00000000FE000000007E000000007E00000180
7F000001803F000001803F000003801F800003000F8000030007C000060003F0000C0001F80038
0000FF00F000001FFFC0000003FE000021227DA128>67 D<FFF000000FFFFFF800001FFF07F800
001FE006FC000037E006FC000037E006FC000037E0067E000067E0067E000067E0063F0000C7E0
063F0000C7E0061F800187E0061F800187E0060FC00307E0060FC00307E0060FC00307E00607E0
0607E00607E00607E00603F00C07E00603F00C07E00601F81807E00601F81807E00601F81807E0
0600FC3007E00600FC3007E006007E6007E006007E6007E006003FC007E006003FC007E006001F
8007E006001F8007E006001F8007E006000F0007E0FFF00F00FFFFFFF00600FFFF30227EA135>
77 D<0007FC0000003FFF800000FC07E00003F001F80007E000FC000FC0007E001F80003F001F
80003F003F00001F803F00001F807F00001FC07E00000FC07E00000FC0FE00000FE0FE00000FE0
FE00000FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE07E00000F
C07F00001FC07F00001FC03F00001F803F80003F801F80003F000FC0007E0007E000FC0003F001
F80000FC07E000003FFF80000007FC000023227DA12A>79 D<07FC001FFF803F07C03F03E03F01
E03F01F01E01F00001F00001F0003FF003FDF01FC1F03F01F07E01F0FC01F0FC01F0FC01F0FC01
F07E02F07E0CF81FF87F07E03F18167E951B>97 D<00FF8007FFE00F83F01F03F03E03F07E03F0
7C01E07C0000FC0000FC0000FC0000FC0000FC0000FC00007C00007E00007E00003E00301F0060
0FC0E007FF8000FE0014167E9519>99 D<00FE0007FF800F87C01E01E03E01F07C00F07C00F8FC
00F8FC00F8FFFFF8FFFFF8FC0000FC0000FC00007C00007C00007E00003E00181F00300FC07003
FFC000FF0015167E951A>101 D<03FC1E0FFF7F1F0F8F3E07CF3C03C07C03E07C03E07C03E07C
03E07C03E03C03C03E07C01F0F801FFF0013FC003000003000003800003FFF801FFFF00FFFF81F
FFFC3800FC70003EF0001EF0001EF0001EF0001E78003C7C007C3F01F80FFFE001FF0018217E95
1C>103 D<FF000000FF0000001F0000001F0000001F0000001F0000001F0000001F0000001F00
00001F0000001F0000001F0000001F0000001F00FF801F00FF801F0038001F0060001F01C0001F
0380001F0700001F0E00001F1C00001F7E00001FFF00001FCF00001F0F80001F07C0001F03E000
1F01E0001F01F0001F00F8001F007C001F003C00FFE0FFC0FFE0FFC01A237EA21E>107
D<FFE07FC0FFE07FC00F801C0007C0380003E0700003F0600001F8C00000F98000007F8000003F
0000001F0000001F8000003FC0000037C0000063E00000C1F00001C0F8000380FC0007007E000E
003E00FF80FFE0FF80FFE01B167F951E>120 D E /Fb 18 121 df<70F8FCFC74040404040808
10102040060F7C840E>44 D<70F8F8F87005057C840E>46 D<7FFFFFF878078078600780184007
80084007800840078008C007800C80078004800780048007800480078004000780000007800000
078000000780000007800000078000000780000007800000078000000780000007800000078000
000780000007800000078000000780000007800000078000000780000007800000078000000FC0
0003FFFF001E227EA123>84 D<0FE0001838003C0C003C0E0018070000070000070000070000FF
0007C7001E07003C0700780700700700F00708F00708F00708F00F087817083C23900FC1E01515
7E9418>97 D<01FE000703000C07801C0780380300780000700000F00000F00000F00000F00000
F00000F00000F000007000007800403800401C00800C010007060001F80012157E9416>99
D<0000E0000FE00001E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000
E00000E001F8E00704E00C02E01C01E03800E07800E07000E0F000E0F000E0F000E0F000E0F000
E0F000E0F000E07000E07800E03800E01801E00C02E0070CF001F0FE17237EA21B>I<01FC0007
07000C03801C01C03801C07801E07000E0F000E0FFFFE0F00000F00000F00000F00000F0000070
00007800203800201C00400E008007030000FC0013157F9416>I<003C00C6018F038F030F0700
07000700070007000700070007000700FFF8070007000700070007000700070007000700070007
00070007000700070007000700070007807FF8102380A20F>I<0E0000FE00001E00000E00000E
00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E1F800E60C00E80E00F
00700F00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E
00700E00700E00700E0070FFE7FF18237FA21B>104 D<1C001E003E001E001C00000000000000
000000000000000000000E00FE001E000E000E000E000E000E000E000E000E000E000E000E000E
000E000E000E000E000E00FFC00A227FA10E>I<0E1F80FE60C01E80E00F00700F00700E00700E
00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E
0070FFE7FF18157F941B>110 D<01FC000707000C01801800C03800E0700070700070F00078F0
0078F00078F00078F00078F00078F000787000707800F03800E01C01C00E038007070001FC0015
157F9418>I<0E1F00FE61C00E80600F00700E00380E003C0E001C0E001E0E001E0E001E0E001E
0E001E0E001E0E001E0E003C0E003C0E00380F00700E80E00E41C00E3F000E00000E00000E0000
0E00000E00000E00000E00000E00000E0000FFE000171F7F941B>I<0E3CFE461E8F0F0F0F060F
000E000E000E000E000E000E000E000E000E000E000E000E000E000F00FFF010157F9413>114
D<0F8830786018C018C008C008E008F0007F803FE00FF001F8003C801C800C800CC00CC008E018
D0308FC00E157E9413>I<02000200020002000600060006000E001E003E00FFF80E000E000E00
0E000E000E000E000E000E000E000E000E040E040E040E040E040E040708030801F00E1F7F9E13
>I<0E0070FE07F01E00F00E00700E00700E00700E00700E00700E00700E00700E00700E00700E
00700E00700E00700E00700E00F00E00F006017003827800FC7F18157F941B>I<FF83FE1F01F0
0E00C007008003810003830001C20000E400007800007800003800003C00004E00008E00018700
0103800201C00401E00C00E03E01F0FF03FE17157F941A>120 D E /Fc
2 104 df<0007FF00007FFFE001FFFFF803FC03FC07F807FC0FF007FC1FE007FC3FC007FC3FC0
03F87FC001F07F800040FF800000FF800000FF800000FF800000FF800000FF800000FF800000FF
800000FF800000FF8000007FC000007FC000003FC0000E3FE0000E1FE0001E0FF0003C07F80078
03FF01F001FFFFE0007FFF800007FC001F207D9F25>99 D<001FF007E000FFFE3FF003FFFFFFF8
07F83FF1F80FE00FE1F81FE00FF1F81FC007F0603FC007F8003FC007F8003FC007F8003FC007F8
003FC007F8003FC007F8003FC007F8001FC007F0001FE00FF0000FE00FE00007F83FC00007FFFF
80000EFFFE00000E1FF000000E000000001E000000001E000000001F000000001F800000001FFF
FFC0000FFFFFF8000FFFFFFE0007FFFFFF8007FFFFFFC007FFFFFFE01FFFFFFFE03F00007FE07E
00000FF0FE000007F0FC000003F0FC000003F0FC000003F0FE000007F07E000007E07F00000FE0
3FC0003FC01FF801FF8007FFFFFE0000FFFFF000001FFF8000252F7E9F29>103
D E /Fd 15 121 df<78FCFCFCFC780000000000000000000000000000000000000078FCFCFCFC
78061F7A9E12>58 D<000003000000000003000000000003000000000007800000000007800000
00000FC0000000000FC0000000000FC00000000017E00000000013E00000000013E00000000023
F00000000021F00000000021F00000000040F80000000040F80000000040F800000000807C0000
0000807C00000001807E00000001003E00000001003E00000002003F00000002001F0000000200
1F00000004000F80000004000F80000004000F800000080007C00000080007C00000180007E000
001FFFFFE000001FFFFFE00000200003F00000200001F00000200001F00000400001F800004000
00F80000400000F800008000007C00008000007C00008000007C00010000003E00010000003E00
030000003F00030000001F00070000001F001F8000003F80FFE00003FFFCFFE00003FFFC2E327E
B132>65 D<FFFFFFE000FFFFFFFC0007E0003E0003E0000F8003E00007C003E00003E003E00001
E003E00001F003E00000F003E00000F803E00000F803E00000F803E00000F803E00000F803E000
00F803E00000F003E00001F003E00001F003E00003E003E00007C003E0000F8003E0001F0003E0
007C0003FFFFF80003E0001F0003E000078003E00003E003E00001F003E00000F803E000007803
E000007C03E000007C03E000003E03E000003E03E000003E03E000003E03E000003E03E000003E
03E000003E03E000007C03E000007C03E000007C03E00000F803E00001F003E00003E003E00007
C007E0003F80FFFFFFFE00FFFFFFF80027317CB02F>I<00003FE0010001FFF8030007F01E0300
1F800307003E000087007800004F00F000002F01E000001F03C000000F078000000F0F80000007
0F000000071F000000031E000000033E000000033C000000017C000000017C000000017C000000
017800000000F800000000F800000000F800000000F800000000F800000000F800000000F80000
0000F800000000F800000000F800000000F80000000078000000007C000000007C000000017C00
0000013C000000013E000000011E000000011F000000020F000000020F80000006078000000403
C000000801E000000800F00000100078000020003E0000C0001F8003800007F00F000001FFFC00
00003FE00028337CB130>I<007F802001FFE02007C078600F001C601E0006E03C0003E0380001
E0780000E0700000E070000060F0000060F0000060F0000020F0000020F0000020F8000020F800
00007C0000007E0000003F0000003FC000001FF800000FFF800007FFF80003FFFC0000FFFF0000
0FFF800000FFC000001FE0000007E0000003F0000001F0000000F0000000F8000000F880000078
80000078800000788000007880000078C0000078C0000070E00000F0E00000E0F00000E0F80001
C0EC000380C7000700C1F01E00807FFC00800FF0001D337CB125>83 D<003F8000E06003801807
00040F00041E001E1C003E3C003E7C003E7C0008780000F80000F80000F80000F80000F80000F8
0000F80000F80000F800007800007C00007C00003C00011E00011E00020F000207000403801800
E060003F80181F7D9E1D>99 D<000001E000003FE000003FE0000003E0000001E0000001E00000
01E0000001E0000001E0000001E0000001E0000001E0000001E0000001E0000001E0000001E000
0001E0000001E0000001E0001F81E000F061E001C019E0078005E00F0003E00E0003E01E0001E0
3C0001E03C0001E07C0001E0780001E0F80001E0F80001E0F80001E0F80001E0F80001E0F80001
E0F80001E0F80001E0F80001E0780001E0780001E03C0001E03C0001E01C0001E01E0003E00E00
05E0070009E0038011F000E061FF003F81FF20327DB125>I<003F800000E0E000038038000700
3C000E001E001E001E001C000F003C000F007C000F0078000F8078000780F8000780F8000780FF
FFFF80F8000000F8000000F8000000F8000000F8000000F8000000780000007C0000003C000000
3C0000801E0000800E0001000F0002000780020001C00C0000F03000001FC000191F7E9E1D>I<
07000F801F801F800F800700000000000000000000000000000000000000000000000780FF80FF
800F80078007800780078007800780078007800780078007800780078007800780078007800780
0780078007800780078007800FC0FFF8FFF80D307EAF12>105 D<0780FE0000FF83078000FF8C
03C0000F9001E00007A001E00007A000F00007C000F00007C000F000078000F000078000F00007
8000F000078000F000078000F000078000F000078000F000078000F000078000F000078000F000
078000F000078000F000078000F000078000F000078000F000078000F000078000F000078000F0
00078000F000078000F0000FC001F800FFFC1FFF80FFFC1FFF80211F7E9E25>110
D<001FC00000F0780001C01C00070007000F0007801E0003C01C0001C03C0001E03C0001E07800
00F0780000F0780000F0F80000F8F80000F8F80000F8F80000F8F80000F8F80000F8F80000F8F8
0000F8780000F07C0001F03C0001E03C0001E01E0003C01E0003C00F00078007800F0001C01C00
00F07800001FC0001D1F7E9E21>I<0781FC00FF860700FF8803C00F9001E007A000F007C00078
078000780780003C0780003C0780003E0780001E0780001F0780001F0780001F0780001F078000
1F0780001F0780001F0780001F0780001F0780003E0780003E0780003C0780007C0780007807C0
00F007A000F007A001E00798038007860F000781F8000780000007800000078000000780000007
8000000780000007800000078000000780000007800000078000000FC00000FFFC0000FFFC0000
202D7E9E25>I<0783E0FF8C18FF907C0F907C07A07C07C03807C00007C00007C0000780000780
000780000780000780000780000780000780000780000780000780000780000780000780000780
000780000780000780000780000FC000FFFE00FFFE00161F7E9E19>114
D<078000F000FF801FF000FF801FF0000F8001F000078000F000078000F000078000F000078000
F000078000F000078000F000078000F000078000F000078000F000078000F000078000F0000780
00F000078000F000078000F000078000F000078000F000078000F000078000F000078000F00007
8001F000078001F000078001F000038002F00003C004F00001C008F800007030FF80001FC0FF80
211F7E9E25>117 D<FFF803FF00FFF803FF000FE001F80003C001E00003E001800001E0010000
00F00300000078020000007C040000003C080000001E100000000F300000000FA000000007C000
000003C000000003E000000001F000000002F00000000478000000087C000000183E000000101E
000000200F000000400F800000C007C000008003C000018001E000078001F0001F8003F800FFC0
07FFC0FFC007FFC0221F7F9E23>120 D E end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 300
TeXDict begin

%%EndSetup
%%Page: 1 1
bop 237 315 a Fd(App)r(endix)20 b(B:)h Fc(gc)h Fd(Source)f(Co)r(de)237
496 y Fb(This)c(app)q(endix)f(con)o(tains)g(the)g Fa(Mak)n(e)p
Fb(,)g Fa(Ox)p Fb(,)f(and)i Fa(C)g Fb(source)f(co)q(de)h(for)f
Fa(gc)p Fb(.)p eop
%%Trailer
end
userdict /end-hook known{end-hook}if
%%EOF
%! a2ps 3.0

/$a2psdict 100 dict def
$a2psdict begin
% Initialize page description variables.
/inch {72 mul} bind def
/landscape true def
/twinpage true def
/sheetheight 5.15552e-314 inch def
/sheetwidth 8.5 inch def
/margin 1.2 inch def
/noborder false def
/noheader true def
/headersize 0.0 def
/bodyfontsize 7 def
/lines 68 def
/columns 83 def
/date (Dec 14 1992 13:56:42) def
/duplex false def
/fudge 36.97 22.5 add def
%!  PostScript Source Code
%
%  File: imag:/users/local/a2ps/header.ps
%  Created: Tue Nov 29 12:14:02 1988 by miguel@imag (Miguel Santana)
%  Version: 2.0
%  Description: PostScript prolog for a2ps ascii to PostScript program.
% 
%  Edit History:
%  - Original version by evan@csli (Evan Kirshenbaum).
%  - Modified by miguel@imag to:
%    1) Correct an overflow bug when printing page number 10 (operator
%	cvs).
%    2) Define two other variables (sheetwidth, sheetheight) describing
%	the physical page (by default A4 format).
%    3) Minor changes (reorganization, comments, etc).
%  - Modified by tullemans@apolloway.prl.philips.nl
%    1) Correct stack overflows with regard to operators cvs and copy.
%       The resulting substrings where in some cases not popped off 
%       the stack, what can result in a stack overflow.
%    2) Replaced copypage and erasepage by showpage. Page througput
%       degrades severely (see red book page 140) on our ps-printer
%       after printing sheet 16 (i.e. page 8) of a file which was 
%       actually bigger. For this purpose the definitions of startdoc
%       and startpage are changed.
%  - Modified by Tim Clark <T.Clark@uk.ac.warwick> to:
%    1) Print one page per sheet (portrait) as an option.
%    2) Reduce size of file name heading, if it's too big.
%    3) Save and restore PostScript state at begining/end. It now uses
%	conventional %%Page %%Trailer markers.
%    4) Print one wide page per sheet in landscape mode as an option.
%  - Modified by miguel@imag.fr to
%    1) Add new option to print n copies of a file.
%    2) Add new option to suppress heading printing.
%    3) Add new option to suppress page surrounding border printing.
%    4) Add new option to change font size. Number of lines and columns
%	are now automatically adjusted, depending on font size and
%	printing mode used.
%    5) Minor changes (best layout, usage message, etc).
%  - Modified (1-14-91) by Kelvin Nilsen <kelvin@cs.iastate.edu> to:
%    1) Support double sided printers
%

% Copyright (c) 1988, Miguel Santana, miguel@imag.imag.fr
%
% Permission is granted to copy and distribute this file in modified
% or unmodified form, for noncommercial use, provided (a) this copyright
% notice is preserved, (b) no attempt is made to restrict redistribution
% of this file, and (c) this file is not distributed as part of any
% collection whose redistribution is restricted by a compilation copyright.
%


% General macros.
/xdef {exch def} bind def
/getfont {exch findfont exch scalefont} bind def

% Page description variables and inch function are defined by a2ps program.

% Character size for differents fonts.
   landscape
   { /filenamefontsize 12 def }
   { /filenamefontsize 16 def }
ifelse
/datefontsize filenamefontsize 0.8 mul def
/headermargin filenamefontsize 0.25 mul def
/bodymargin bodyfontsize 0.7 mul def

% Font assignment to differents kinds of "objects"
/filenamefontname /Helvetica-Bold def
/stdfilenamefont filenamefontname filenamefontsize getfont def
/datefont /Helvetica datefontsize getfont def
/bodyfont /Courier bodyfontsize getfont def

% Logical page attributs (a half of a real page or sheet).
/pagewidth
   bodyfont setfont (0) stringwidth pop columns mul bodymargin dup add add
   def
/pageheight
   bodyfontsize lines mul bodymargin dup add add headersize add
   def

% Coordinates for upper corner of a logical page and for sheet number.
% Coordinates depend on format mode used.
% In twinpage mode, coordinate x of upper corner is not the same for left
% and right pages: upperx is an array of two elements, indexed by sheetside.
/rightmargin margin 3 div def
/leftmargin margin 2 mul 3 div def
/topmargin margin twinpage {3} {2} ifelse div def
landscape
{  % Landscape format
   /uppery rightmargin pageheight add bodymargin add def
   /sheetnumbery sheetwidth leftmargin pageheight add datefontsize add sub def
   twinpage
   {  % Two logical pages
      /upperx [ topmargin			% upperx for left page
		dup 2 mul pagewidth add		% upperx for right page
	      ] def
      /sheetnumberx sheetheight topmargin sub def
   }
   {  /upperx [ topmargin dup ] def
      /sheetnumberx sheetheight topmargin sub datefontsize sub def
   }
   ifelse
}
{  % Portrait format
   /uppery topmargin pageheight add def
   /upperx [ leftmargin dup ] def
   /sheetnumberx sheetwidth rightmargin sub datefontsize sub def
   /sheetnumbery
	 sheetheight 
	 topmargin pageheight add datefontsize add headermargin add
      sub
      def

}
ifelse

% Strings used to make easy printing numbers
/pnum 12 string def
/empty 12 string def

% Other initializations.
/datewidth date stringwidth pop def
/filenameroom
         pagewidth
	 filenamefontsize 4 mul datewidth add (Page 999) stringwidth pop add
      sub
   def


% Function startdoc: initializes printer and global variables.
/startdoc
    { /sheetside 0 def			% sheet side that contains current page
      /frontpage true def		%! added by kelvin
      /sheet 1 def			% sheet number
   } bind def

% Function newfile: init file name and reset page number for each new file.
/newfile
    { cleanup
      /filename xdef
      /filenamewidth filename stringwidth pop def
      /filenamefont
	 filenamewidth filenameroom gt
	 {
	       filenamefontname
	       filenamefontsize filenameroom mul filenamewidth div
	    getfont
	 }
	 {  stdfilenamefont }
	 ifelse
	 def
      /pagenum 1 def
    } bind def

% Function printpage: Print a physical page.
/printpage
    { /sheetside 0 def
      twinpage
      {  noborder not
	    { sheetnumber }
	 if
      }
      {  noheader noborder not and
	    { sheetnumber }
	 if
      }
      ifelse
      showpage 
%      pagesave restore
      /frontpage frontpage not def	% added by kelvin
      /sheet sheet 1 add def
    } bind def

% Function cleanup: terminates printing, flushing last page if necessary.
/cleanup
    { twinpage sheetside 1 eq and
         { printpage }
      if
      % added by kelvin
      duplex frontpage not and
         { printpage } 
      if
    } bind def

%
% Function startpage: prints page header and page border and initializes
% printing of the file lines.
/startpage
    { sheetside 0 eq
	{ % /pagesave save def
	  landscape
	    { sheetwidth 0 inch translate	% new coordinates system origin
	      90 rotate				% landscape format
	    } if
	} if
      noborder not { printborder } if
      noheader not { printheader } if
	 upperx sheetside get  bodymargin  add
	    uppery
               % added by kelvin
               duplex not frontpage or {0} {fudge} ifelse add
	    bodymargin bodyfontsize add  noheader {0} {headersize} ifelse  add
	 sub
      moveto
      bodyfont setfont
    } bind def

% Function printheader: prints page header.
/printheader
    { upperx sheetside get  uppery
           % added by kelvin
           duplex not frontpage or {0} {fudge} ifelse add
           headersize sub 1 add  moveto
      datefont setfont
      gsave
        datefontsize headermargin rmoveto
	date show					% date/hour
      grestore
      gsave
	pagenum pnum cvs pop
	   pagewidth (Page 999) stringwidth pop sub
	   headermargin
	rmoveto
        (Page ) show pnum show				% page number
      grestore
      empty pnum copy pop
      gsave
        filenamefont setfont
	      filenameroom filename stringwidth pop sub 2 div datewidth add
	      bodymargin 2 mul 
	   add 
	   headermargin
	rmoveto
        filename show						% file name
      grestore
    } bind def

% Function printborder: prints border page.
/printborder 
    { upperx sheetside get uppery
           % added by kelvin
           duplex not frontpage or {0} {fudge} ifelse add
      moveto
      gsave					% print the four sides
        pagewidth 0 rlineto			% of the square
        0 pageheight neg rlineto
        pagewidth neg 0 rlineto
        closepath stroke
      grestore
      noheader not
         { 0 headersize neg rmoveto pagewidth 0 rlineto stroke }
      if
    } bind def

%
% Function endpage: adds a sheet number to the page (footnote) and prints
% the formatted page (physical impression). Activated at the end of each
% source page (lines reached or FF character).
/endpage
   { /pagenum pagenum 1 add def
     twinpage  sheetside 0 eq  and
        { /sheetside 1 def }
        { printpage }
     ifelse
   } bind def

% Function sheetnumber: prints the sheet number.
/sheetnumber
    { sheetnumberx sheetnumbery moveto
      datefont setfont
      sheet pnum cvs
	 dup stringwidth pop (0) stringwidth pop sub neg 0 rmoveto show
      empty pnum copy pop
    } bind def

% Function s: print a source line
/s  { gsave
        show
      grestore
      0 bodyfontsize neg rmoveto
    } bind def
%%EndProlog

/docsave save def
startdoc
(tempprint1) newfile
/sheet 1 def
%%Page: 1 1
startpage
( ) s
( ) s
( Dec 14 11:31 1992  Makefile Page 1) s
( ) s
( ) s
( # $Header: Makefile,v 1.3 92/12/14 11:31:46 bischoff Exp $) s
( ) s
( SHELL= /bin/sh) s
( CFLAGS =) s
( CC=cc) s
( ) s
( .IGNORE:) s
( ) s
( gc: y.tab.o lex.yy.o scan.o sem.o code.o util.o) s
(         $\(CC\) $\(CFLAGS\) -o gc y.tab.o lex.yy.o scan.o \\) s
(                               sem.o code.o util.o -ly -ll) s
( ) s
( ox.out.y ox.out.l: gppl.Y gppl.L) s
(         ox -YY -Yn500000 -Yc60000 -Yr30000 gppl.Y gppl.L) s
( ) s
( strip: gppl.Y gppl.L) s
(         ox -S gppl.Y gppl.L) s
( ) s
( lex.yy.c : ox.out.l) s
(         lex ox.out.l) s
( ) s
( y.tab.c y.tab.h: ox.out.y) s
(         yacc -dv ox.out.y) s
(         diff y.tab.h y.tab.h.bak > y.tab.h.diff 2>&1) s
(         if test -s y.tab.h.diff; then cp y.tab.h y.tab.h.bak; fi) s
(         rm y.tab.h.diff) s
( ) s
( scan.o: glob.h util.h scan.c) s
(         $\(CC\) $\(CFLAGS\) -c scan.c) s
( ) s
( sem.o: glob.h y.tab.h.bak util.h sem.c) s
(         $\(CC\) $\(CFLAGS\) -c sem.c) s
( ) s
( code.o: code.c y.tab.h.bak glob.h util.h) s
(         $\(CC\) $\(CFLAGS\) -c code.c) s
( ) s
( util.o: util.c) s
(         $\(CC\) $\(CFLAGS\) -c util.c) s
( ) s
( y.tab.o: y.tab.c y.tab.h.bak glob.h util.h scan.h sem.h code.h) s
(         $\(CC\) $\(CFLAGS\) -c y.tab.c) s
( ) s
( lex.yy.o: lex.yy.c y.tab.h.bak glob.h util.h scan.h) s
(         $\(CC\) $\(CFLAGS\) -c lex.yy.c) s
( ) s
( clean:) s
(         rm *.o ox.out.? lex.yy.c y.tab.c y.tab.h y.output gc) s
( ) s
( LC:) s
(         lint lex.yy.c y.tab.c sem.c scan.c code.c util.c) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  glob.h Page 1) s
( ) s
( ) s
( /* $Header: glob.h,v 1.3 92/12/14 11:31:56 bischoff Exp $ */) s
( ) s
( #include <stdio.h>) s
( ) s
( #define DONTCARE 0) s
( ) s
( #define ceiling\(num,inc\) \(\(\(inc\) * \(\(num\)/\(inc\)\)\) + \(\(\(num\)%\(inc\)\)?\(inc\):0\)\)) s
( ) s
( #define max\(t1,t2\) \(\(\(t1\)>\(t2\)\)?\(t1\):\(t2\)\)) s
( ) s
( #define spaceSetup\(string,type,name,size,minSize,after,stock\) \\) s
( if \(\(size\) < \(minSize\)\) {fprintf\(stderr,\\) s
( "allocation request for %s space too small.\\n",string\);\\) s
( exit\(-1\);}\\) s
( if \(\(\(name\) = \(type *\) malloc\(\(size\) * sizeof\(type\)\)\)  \\) s
(     == \\) s
(     \(\(type *\) NULL\) \\) s
(    \)   \\) s
( {fprintf\(stderr,"malloc error in %s space allocation.\\n",string\);exit\(-1\);}\\) s
( \(stock\) = \(name\) + 1; \\) s
( \(after\) = \(\(name\) + \(size\)\);) s
( ) s
( typedef unsigned short lineNumType;) s
( typedef unsigned short labelType;) s
( typedef unsigned short levelType;) s
( typedef short regNumType;) s
( ) s
( enum stgClass {VARIABLEC,VALPARAMC,REFPARAMC};) s
( enum symType  {INTT,FLOATT,BOOLT,VOIDT,ERRT};) s
( enum mapType  {ARITHM,LOGM};) s
( enum pred     {FALSE,TRUE};) s
( ) s
( extern enum pred doCodeGen;) s
( ) s
( extern long stgSize\(\);) s
( extern void handleSemError\(\);) s
( ) s
endpage
%%Page: 2 2
startpage
( ) s
( ) s
( Dec 14 11:32 1992  glob.h Page 2) s
( ) s
( ) s
( union num {int i;) s
(            float f;) s
(            int b;) s
(           };) s
( ) s
( struct dim {long size;) s
(             long scale;) s
(             struct dim *next;) s
(            };) s
( ) s
( struct sym {) s
(             /* members used for all kinds of symbols */) s
(             char *id;   ) s
(             lineNumType line;) s
(             enum symType type;) s
(             levelType level;) s
(             struct sym *next;) s
( ) s
(             /* members used only for storage symbols */) s
(             enum stgClass class;) s
(             long addr;) s
(             long size;) s
(             struct dim *dimList;) s
( ) s
(             /* members used only for function symbols */) s
(             long paramsSize;) s
(             labelType label;) s
(             struct sym *paramLoc;) s
(            };) s
( ) s
( struct env {struct sym *funcSym;) s
(             struct sym *varLoc;) s
(             struct sym *funcLoc;) s
(             levelType level;) s
(             short nRegs;) s
(             labelType exitLabel;) s
(             long varsSize;) s
(             struct env *outerEnv;) s
(            };) s
( ) s
( extern struct dim *dimListSpace;) s
( #define lambdaDim dimListSpace) s
( ) s
( extern struct sym *symSpace;) s
( #define lambdaSym symSpace) s
( ) s
( extern struct env *envSpace;) s
( #define lambdaEnv envSpace) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  scan.h Page 1) s
( ) s
( ) s
( /* $Header: scan.h,v 1.3 92/12/14 11:32:01 bischoff Exp $ */) s
( ) s
( extern void scanSetup\(\);) s
( extern char *stringLookup\(\);) s
( extern char *copyLexemeOfSTRING\(\);) s
( extern void eatComment\(\);) s
( ) s
endpage
%%Page: 3 3
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.h Page 1) s
( ) s
( ) s
( /* $Header: sem.h,v 1.3 92/12/14 11:32:04 bischoff Exp $ */) s
( ) s
( #define FIRSTREGNUM 0) s
( ) s
( extern struct sym *newStgSym\(\);) s
( extern struct sym *newFuncSym\(\);) s
( extern struct sym *concatLocs\(\);) s
( extern struct sym *cdrParamList\(\);) s
( extern struct sym *stgRefLookup\(\);) s
( extern struct sym *funcInvocLookup\(\);) s
( extern struct env *newEnv\(\);) s
( extern struct dim *adjustDimList\(\);) s
( extern struct dim *cdrDimList\(\);) s
( extern struct dim *consDimList\(\);) s
( extern enum symType unrOpTypeCheck\(\);) s
( extern enum symType binOpTypeCheck\(\);) s
( extern enum symType assignmentTypeCheck\(\);) s
( extern int whileStmtCheck\(\);) s
( extern void semSetup\(\);) s
( extern void paramMatchCheck\(\);) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.h Page 1) s
( ) s
( ) s
( /* $Header: code.h,v 1.3 92/12/14 11:32:08 bischoff Exp $ */) s
( ) s
( #include <stdio.h>) s
( #include "y.tab.h") s
( ) s
( extern FILE *tempOut;) s
( #define tempOutID "g.c") s
( ) s
( extern labelType newLabelNum\(\);) s
( extern labelType newReturnLabelNum\(\);) s
( extern long stgSize\(\);) s
( extern void cgHeader\(\);) s
( extern void cgTrailer\(\);) s
( extern void cgFuncAddress\(\);) s
( extern void cgFuncCall\(\);) s
( extern void cgFuncTrailer\(\);) s
( extern void cgBlockEnter\(\);) s
( extern void cgBlockExit\(\);) s
( extern void cgBinArithExpr\(\);) s
( extern void cgRelExpr\(\);) s
( extern void cgBinLogExpr\(\);) s
( extern void cgLogNegExpr\(\);) s
( extern void cgUnrArithExpr\(\);) s
( extern void cgEmptyIndexSeq\(\);) s
( extern void cgConstSimpleExpr\(\);) s
( extern void cgIndexSeq\(\);) s
( extern void cgAssign\(\);) s
( extern void cgPush\(\);) s
( extern void cgCondDeref\(\);) s
( extern void cgOutputNoArg\(\);) s
( extern void cgOutputOneArg\(\);) s
( extern void cgCast\(\);) s
( extern void cgInput\(\);) s
( extern void cgIfThen\(\);) s
( extern void cgIfThenElse\(\);) s
( extern void cgThen\(\);) s
( extern void cgElse\(\);) s
( extern void cgWhileStatement\(\);) s
( extern void cgWdecision\(\);) s
( extern void cgWhile\(\);) s
( extern void cgReturnStmt\(\);) s
( extern void cgExitStmt\(\);) s
( extern void cgParamMatchCheck\(\);) s
( ) s
endpage
%%Page: 4 4
startpage
( ) s
( ) s
( Dec 14 11:32 1992  util.h Page 1) s
( ) s
( ) s
( /* $Header: util.h,v 1.3 92/12/14 11:32:11 bischoff Exp $ */) s
( ) s
( extern void yyerror\(\);) s
( extern void fatal\(\);) s
( extern void internal\(\);) s
( extern void handleOverflow\(\);) s
( extern FILE *safeOpen\(\);) s
( extern void printStringArray\(\);) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.L Page 1) s
( ) s
( ) s
( %{) s
( /* $Header: gppl.L,v 1.3 92/12/14 11:32:15 bischoff Exp $ */) s
( ) s
( #include "glob.h") s
( #include "scan.h") s
( #include "y.tab.h") s
( ) s
( %}) s
( ) s
( IDENT \([a-zA-Z_][a-zA-Z0-9_]*\)) s
( ) s
( %%) s
( int            return\(INT\);        @{ @INT.line@     = yylineno; @}) s
( float          return\(FLOAT\);      @{ @FLOAT.line@   = yylineno; @}) s
( bool           return\(BOOL\);       @{ @BOOL.line@    = yylineno; @}) s
( void           return\(VOID\);       @{ @VOID.line@    = yylineno; @}) s
( var            return\(VAR\);) s
( if             return\(IF\);         @{ @IF.line@      = yylineno; @}) s
( then           return\(THEN\);) s
( else           return\(ELSE\);) s
( while          return\(WHILE\);      @{ @WHILE.line@   = yylineno; @}) s
( return         return\(RETURN\);     @{ @RETURN.line@  = yylineno; @}) s
( exit           return\(EXIT\);       @{ @EXIT.line@    = yylineno; @}) s
( input          return\(INPUT\);) s
( output         return\(OUTPUT\);) s
( \\"             {char *strDum;) s
(                 strDum = copyLexemeOfSTRING\(\);) s
(                 return \(STRING\);) s
(                                    @{ @STRING.str@   = strDum;   @}) s
(                }) s
( \\/\\*           eatComment\(\);) s
( [ \\n\\t\\f]*     ;) s
( [0-9]+\\.[0-9]+ return\(FCONST\);     @{ sscanf\(yytext,"%f",) s
(                                              &\(@FCONST.val@.f\)) s
(                                             \);) s
(                                    @}) s
( [0-9]+         return\(ICONST\);     @{ sscanf\(yytext,"%d",) s
(                                              &\(@ICONST.val@.i\)) s
(                                             \);) s
(                                    @}) s
( EOF            return\(EOFCONST\);) s
( TRUE           return\(BCONST\);     @{ @BCONST.val@.b = 1;        @}) s
( FALSE          return\(BCONST\);     @{ @BCONST.val@.b = 0;        @}) s
( \\\(             return\('\('\);        @{ @'\('.line@     = yylineno; @}) s
( \\[             return\('['\);        @{ @'['.line@     = yylineno; @}) s
( [,]            return\(','\);        @{ @','.line@     = yylineno; @}) s
( [{]            return\('{'\);) s
( [}]            return\('}'\);) s
( [\)]            return\('\)'\);) s
( [;]            return\(';'\);) s
( [\\]]           return\(']'\);) s
( &&             return\(AND\);        @{ @AND.line@     = yylineno; @}) s
( \\|\\|           return\(OR\);         @{ @OR.line@      = yylineno; @}) s
( !              return\(NOT\);        @{ @NOT.line@     = yylineno; @}) s
( [*]            return\('*'\);        @{ @'*'.line@     = yylineno; @}) s
( [+]            return\('+'\);        @{ @'+'.line@     = yylineno; @}) s
endpage
%%Page: 5 5
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.L Page 2) s
( ) s
( ) s
( [/]            return\('/'\);        @{ @'/'.line@     = yylineno; @}) s
( [\\-]           return\('-'\);        @{ @'-'.line@     = yylineno; @}) s
( =              return\(GETS\);       @{ @GETS.line@    = yylineno; @}) s
( ==             return\(EQ\);         @{ @EQ.line@      = yylineno; @}) s
( !=             return\(NEQ\);        @{ @NEQ.line@     = yylineno; @}) s
( \\<             return\(LT\);         @{ @LT.line@      = yylineno; @}) s
( \\>             return\(GT\);         @{ @GT.line@      = yylineno; @}) s
( \\<=            return\(LEQ\);        @{ @LEQ.line@     = yylineno; @}) s
( \\>=            return\(GEQ\);        @{ @GEQ.line@     = yylineno; @}) s
( {IDENT}        {) s
(                 return\(ID\);) s
(                 @{ @ID.str@ = stringLookup\(yytext,yyleng,1\);) s
(                    @ID.line@ = yylineno;) s
(                 @}) s
(                }) s
( .              {fprintf\(stderr,"line %d: illegal character\\n",yylineno\);) s
(                 handleSemError\(\);) s
(                }) s
( %%) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 1) s
( ) s
( ) s
(  /* $Header: gppl.Y,v 1.3 92/12/14 11:32:17 bischoff Exp $ */) s
( ) s
( /* a compiler for a general purpose programming language */) s
( ) s
( %{) s
( #include "glob.h") s
( #include "y.tab.h") s
( #include "scan.h") s
( #include "sem.h") s
( #include "code.h") s
( #include "util.h") s
( %}) s
( ) s
( ) s
( %start prog) s
( ) s
( %token ID ICONST FCONST BCONST EOFCONST) s
( %token INT FLOAT BOOL VOID) s
( %token VAR) s
( %token IF THEN ELSE WHILE) s
( %token EQ LT GT GEQ LEQ NEQ) s
( %token AND OR NOT) s
( %token INPUT OUTPUT STRING) s
( %token RETURN EXIT) s
( ) s
( %right GETS) s
( %left OR) s
( %left AND) s
( %nonassoc EQ NEQ) s
( %nonassoc LT LEQ GT GEQ) s
( %left '+' '-') s
( %left '*' '/') s
( %right NOT) s
( ) s
endpage
%%Page: 6 6
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 2) s
( ) s
( ) s
( @traversal t) s
( ) s
( @attributes {struct env *env;) s
(              regNumType maxRegNum;) s
(             }) s
(             execElem statement) s
(             returnStatement exitStatement) s
(             ifStatement whileStatement) s
( ) s
( @attributes {struct env *env;) s
(              regNumType regNum;) s
(              regNumType maxRegNum;) s
(              struct sym *formParamList;) s
(              struct sym *func;) s
(              lineNumType line;) s
(             }) s
(             actParamList) s
( ) s
( @attributes {struct env *env;) s
(              struct sym *varLoc,*funcLoc;) s
(              regNumType maxRegNum;) s
(             }) s
(             block blockElemList) s
( ) s
( @attributes {struct sym *loc;) s
(              enum stgClass class;) s
(             }) s
(             stgDecl) s
( ) s
( @attributes {struct sym *loc;) s
(              struct sym *funcSym;) s
(             }) s
(             paramDeclList) s
( ) s
( @attributes {struct sym *loc;) s
(             }) s
(             paramDecl) s
( ) s
( @attributes {struct env *env;) s
(              struct sym *loc;) s
(             }) s
(             funcDecl) s
( ) s
( @attributes {enum symType type;) s
(              lineNumType line;) s
(             }) s
(             typeSpec) s
( ) s
( @attributes {enum symType type;) s
(              struct sym *loc;) s
(              enum stgClass class;) s
(             }) s
(             stgDecl2 stgDecl2List) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 3) s
( ) s
( ) s
( @attributes {struct dim *dimList;) s
(             }) s
(             dimSeq) s
( ) s
( @attributes {struct env *env;) s
(              enum symType type;) s
(              regNumType regNum;) s
(              regNumType maxRegNum;) s
(             }) s
(             funcInvoc assignExpr) s
( ) s
( @attributes {struct env *env;) s
(              enum symType type;) s
(              regNumType regNum;) s
(              regNumType maxRegNum;) s
(              struct sym *formalMatch;) s
(              enum pred isStgRef;) s
(             }) s
(             expr simpleExpr) s
( ) s
( @attributes {struct env *env;) s
(              regNumType regNum;) s
(              regNumType maxRegNum;) s
(              struct dim *dimList;) s
(              struct sym *sym;) s
(              lineNumType line;) s
(             }) s
(             indexSeq) s
( ) s
( @attributes {struct env *env;) s
(              enum symType type;) s
(              regNumType regNum;) s
(              regNumType maxRegNum;) s
(              struct sym *formalMatch;) s
(             }) s
(             stgRef) s
( ) s
( @attributes {char *str;) s
(              lineNumType line;) s
(              struct sym *sym;) s
(             }) s
(             ID) s
( ) s
( @attributes {char *str;) s
(             }) s
(             STRING) s
( ) s
( @attributes {lineNumType line;) s
(             }) s
(             AND OR NOT) s
(             GETS) s
(             GT LT EQ NEQ GEQ LEQ) s
(             '*' '+' '/' '-' '\(' ',' '[') s
(             FOR IF WHILE DO) s
(             INT FLOAT BOOL VOID) s
(             RETURN EXIT) s
endpage
%%Page: 7 7
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 4) s
( ) s
( ) s
( ) s
( @attributes {labelType label;) s
(              regNumType decisionRegNum;) s
(             }) s
(             then wDecision) s
( ) s
( @attributes {labelType label;) s
(             }) s
(             else while) s
( ) s
( @attributes {union num val;) s
(             }) s
(             ICONST FCONST BCONST) s
( ) s
( @attributes {long val;) s
(             }) s
(             iConstExpr) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 5) s
( ) s
( ) s
( @macro constSimpleExpr\(SYM,TYPE,\)) s
(    @i @simpleExpr.type@ = TYPE;) s
(    @i @simpleExpr.maxRegNum@ = @simpleExpr.regNum@;) s
(    @i @simpleExpr.isStgRef@ = FALSE;) s
(    @t cgConstSimpleExpr\(@simpleExpr.regNum@,TYPE,@SYM.val@\);) s
( @end) s
( ) s
( ) s
( @macro unrOpExprdefs\(op,\)) s
(   @i @expr.type@ = unrOpTypeCheck\(@expr.1.type@,op,@op.line@\);) s
(   @i @expr.1.env@ = @expr.env@;) s
(   @i @expr.1.regNum@ = @expr.regNum@;) s
(   @i @expr.maxRegNum@ = @expr.1.maxRegNum@;) s
(   @i @expr.1.formalMatch@ = lambdaSym;) s
(   @i @expr.isStgRef@ = FALSE;) s
( @end) s
( ) s
( ) s
( @macro binOpExprdefs\(op,\)) s
(   @i @expr.type@ = binOpTypeCheck\(@expr.1.type@,@expr.2.type@,op,@op.line@\);) s
(   @i @expr.1.env@ = @expr.env@;) s
(   @i @expr.2.env@ = @expr.env@;) s
(   @i @expr.1.regNum@ = @expr.regNum@;) s
(   @i @expr.2.regNum@ = @expr.regNum@ + 1;) s
(   @i @expr.maxRegNum@ = max\(@expr.1.maxRegNum@,@expr.2.maxRegNum@\);) s
(   @i @expr.1.formalMatch@ = lambdaSym;) s
(   @i @expr.2.formalMatch@ = lambdaSym;) s
(   @i @expr.isStgRef@ = FALSE;) s
( @end) s
( ) s
( @macro binArithExpr\(op,\)) s
(    @t cgBinArithExpr\(@expr.1.regNum@,op,@expr.type@\);) s
( @end) s
( ) s
( @macro relExpr\(op,\)) s
(   @t cgRelExpr\(@expr.1.regNum@,op,@expr.1.type@\);) s
( @end) s
( ) s
( @macro binLogExpr\(op,\)) s
(   @t cgBinLogExpr\(@expr.1.regNum@,op\);) s
( @end) s
( ) s
endpage
%%Page: 8 8
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 6) s
( ) s
( ) s
( ) s
( %%) s
( prog    ) s
(         :       block   ) s
(                 @{ @i @block.env@ = newEnv\(lambdaEnv,) s
(                                            lambdaSym,) s
(                                            @block.varLoc@,) s
(                                            @block.funcLoc@,) s
(                                            @block.maxRegNum@) s
(                                           \);) s
(                 @}) s
(         ;) s
( ) s
( block   ) s
(         :       '{'     blockElemList   '}') s
(                 @{ @i @blockElemList.env@ = @block.env@;) s
(                    @i @block.maxRegNum@ = @blockElemList.maxRegNum@;) s
(                    @i @block.varLoc@ = @blockElemList.varLoc@;) s
(                    @i @block.funcLoc@ = @blockElemList.funcLoc@;) s
(                    @t cgBlockExit\(@block.env@\);) s
(                 @}) s
(         ;) s
( ) s
( blockElemList) s
(         :) s
(                 @{ @i @blockElemList.varLoc@ = lambdaSym;) s
(                    @i @blockElemList.funcLoc@ = lambdaSym;) s
(                    @i @blockElemList.maxRegNum@ = FIRSTREGNUM - 1;) s
(                    @t cgBlockEnter\(@blockElemList.env@\);) s
(                 @}) s
(         |       blockElemList   execElem        ) s
(                 @{ @i @blockElemList.1.env@ = @blockElemList.env@;) s
(                    @i @blockElemList.maxRegNum@ =) s
(                          max\(@blockElemList.1.maxRegNum@,) s
(                              @execElem.maxRegNum@) s
(                             \);) s
(                    @i @blockElemList.varLoc@ = @blockElemList.1.varLoc@;) s
(                    @i @blockElemList.funcLoc@ = @blockElemList.1.funcLoc@;) s
(                    @i @execElem.env@ = @blockElemList.env@;) s
(                 @}) s
(         |       blockElemList   stgDecl ) s
(                 @{ @i @blockElemList.1.env@ = @blockElemList.env@;) s
(                    @i @blockElemList.maxRegNum@ = @blockElemList.1.maxRegNum@;) s
(                    @i @blockElemList.varLoc@ =) s
(                         concatLocs\(@blockElemList.1.varLoc@,@stgDecl.loc@\);) s
(                    @i @blockElemList.funcLoc@ = @blockElemList.1.funcLoc@;) s
(                    @i @stgDecl.class@ = VARIABLEC;) s
(                 @}) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 7) s
( ) s
( ) s
(         |       blockElemList   funcDecl        ) s
(                 @{ @i @blockElemList.1.env@ = @blockElemList.env@;) s
(                    @i @blockElemList.maxRegNum@ = @blockElemList.1.maxRegNum@;) s
(                    @i @blockElemList.varLoc@ = @blockElemList.1.varLoc@;) s
(                    @i @blockElemList.funcLoc@ =) s
(                         concatLocs\(@blockElemList.1.funcLoc@,@funcDecl.loc@\);) s
(                    @i @funcDecl.env@ = @blockElemList.env@;) s
(                 @}) s
(         ;) s
( ) s
( execElem        ) s
(         :       statement) s
(                 @{ @i @statement.env@ = @execElem.env@;) s
(                    @i @execElem.maxRegNum@ = @statement.maxRegNum@;) s
(                 @}) s
(         |       block   ) s
(                 @{ @i @block.env@ = newEnv\(@execElem.env@,) s
(                                            lambdaSym,) s
(                                            @block.varLoc@,) s
(                                            @block.funcLoc@,) s
(                                            @block.maxRegNum@) s
(                                           \);) s
(                    @i @execElem.maxRegNum@ = FIRSTREGNUM - 1;) s
(                 @}) s
(         ;) s
( ) s
( statement) s
(         :       ';'     ) s
(                 @{ @i @statement.maxRegNum@ = FIRSTREGNUM - 1;) s
(                 @}) s
(         |       expr    ';'     ) s
(                 @{ @i @expr.env@ = @statement.env@;) s
(                    @i @expr.regNum@ = FIRSTREGNUM;) s
(                    @i @statement.maxRegNum@ = @expr.maxRegNum@;) s
(                    @i @expr.formalMatch@ = lambdaSym;) s
(                 @}) s
(         |       ifStatement) s
(                 @{ @i @ifStatement.env@ = @statement.env@;) s
(                    @i @statement.maxRegNum@ = @ifStatement.maxRegNum@;) s
(                 @}) s
(         |       whileStatement) s
(                 @{ @i @whileStatement.env@ = @statement.env@;) s
(                    @i @statement.maxRegNum@ = @whileStatement.maxRegNum@;) s
(                 @}) s
(         |       returnStatement) s
(                 @{ @i @returnStatement.env@ = @statement.env@;) s
(                    @i @statement.maxRegNum@ = @returnStatement.maxRegNum@;) s
(                 @}) s
(         |       exitStatement) s
(                 @{ @i @exitStatement.env@ = @statement.env@;) s
(                    @i @statement.maxRegNum@ = @exitStatement.maxRegNum@;) s
(                 @}) s
(         ;) s
( ) s
endpage
%%Page: 9 9
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 8) s
( ) s
( ) s
( expr    ) s
(         :       assignExpr) s
(                 @{ @i @expr.type@ = @assignExpr.type@;) s
(                    @i @assignExpr.env@ = @expr.env@;) s
(                    @i @assignExpr.regNum@ = @expr.regNum@;) s
(                    @i @expr.maxRegNum@ = @assignExpr.maxRegNum@;) s
(                    @i @expr.isStgRef@ = FALSE;) s
(                 @}) s
(         |       simpleExpr) s
(                 @{ @i @expr.type@ = @simpleExpr.type@;) s
(                    @i @simpleExpr.env@ = @expr.env@;) s
(                    @i @simpleExpr.regNum@ = @expr.regNum@;) s
(                    @i @expr.maxRegNum@ = @simpleExpr.maxRegNum@;) s
(                    @i @simpleExpr.formalMatch@ = @expr.formalMatch@;) s
(                    @i @expr.isStgRef@ = @simpleExpr.isStgRef@;) s
(                 @}) s
(         |       '\('     expr    '\)') s
(                 @{ @i @expr.type@ = @expr.1.type@;) s
(                    @i @expr.1.env@ = @expr.env@;) s
(                    @i @expr.1.regNum@ = @expr.regNum@;) s
(                    @i @expr.maxRegNum@ = @expr.1.maxRegNum@;) s
(                    @i @expr.1.formalMatch@ = @expr.formalMatch@;) s
(                    @i @expr.isStgRef@ = @expr.1.isStgRef@;) s
(                 @}) s
(         |       '-'     expr            ) s
(                 @{ unrOpExprdefs\('-',\)) s
(                    @t cgUnrArithExpr\(@expr.regNum@,'-',@expr.type@\);) s
(                 @}) s
(         |       '+'     expr    ) s
(                 @{ unrOpExprdefs\('+',\)) s
(                    @t cgUnrArithExpr\(@expr.regNum@,'+',@expr.type@\);) s
(                 @}) s
(         |       NOT     expr            ) s
(                 @{ unrOpExprdefs\(NOT,\)) s
(                    @t cgLogNegExpr\(@expr.regNum@\);) s
(                 @}) s
(         |       expr    '*'     expr) s
(                 @{ binOpExprdefs\('*',\)) s
(                    binArithExpr\('*',\)) s
(                 @}) s
(         |       expr    '/'     expr) s
(                 @{ binOpExprdefs\('/',\)) s
(                    binArithExpr\('/',\)) s
(                 @}) s
(         |       expr    '+'     expr) s
(                 @{ binOpExprdefs\('+',\)) s
(                    binArithExpr\('+',\)) s
(                 @}) s
(         |       expr    '-'     expr) s
(                 @{ binOpExprdefs\('-',\)) s
(                    binArithExpr\('-',\)) s
(                 @}) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 9) s
( ) s
( ) s
(         |       expr    EQ      expr) s
(                 @{ binOpExprdefs\(EQ,\)) s
(                    relExpr\(EQ,\)) s
(                 @}) s
(         |       expr    NEQ     expr) s
(                 @{ binOpExprdefs\(NEQ,\)) s
(                    relExpr\(NEQ,\)) s
(                 @}) s
(         |       expr    LT      expr) s
(                 @{ binOpExprdefs\(LT,\)) s
(                    relExpr\(LT,\)) s
(                 @}) s
(         |       expr    GT      expr) s
(                 @{ binOpExprdefs\(GT,\)) s
(                    relExpr\(GT,\)) s
(                 @}) s
(         |       expr    LEQ     expr) s
(                 @{ binOpExprdefs\(LEQ,\)) s
(                    relExpr\(LEQ,\)) s
(                 @}) s
(         |       expr    GEQ     expr) s
(                 @{ binOpExprdefs\(GEQ,\)) s
(                    relExpr\(GEQ,\)) s
(                 @}) s
(         |       expr    AND     expr) s
(                 @{ binOpExprdefs\(AND,\)) s
(                    binLogExpr\(AND,\)) s
(                 @}) s
(         |       expr    OR      expr) s
(                 @{ binOpExprdefs\(OR,\)) s
(                    binLogExpr\(OR,\)) s
(                 @}) s
(         ;) s
( ) s
( assignExpr      ) s
(         :       stgRef  GETS    expr) s
(                 @{ @i @assignExpr.type@ = assignmentTypeCheck\(@stgRef.type@,) s
(                                                               @expr.type@,) s
(                                                               @GETS.line@) s
(                                                              \);) s
(                    @i @stgRef.env@ = @assignExpr.env@;) s
(                    @i @expr.env@ = @assignExpr.env@;) s
(                    @i @expr.regNum@ = @assignExpr.regNum@ + 1;) s
(                    @i @stgRef.regNum@ = @assignExpr.regNum@;) s
(                    @i @assignExpr.maxRegNum@ =) s
(                          max\(@stgRef.maxRegNum@,@expr.maxRegNum@\);) s
(                    @i @stgRef.formalMatch@ = lambdaSym;) s
(                    @i @expr.formalMatch@ = lambdaSym;) s
(                    @t cgAssign\(@stgRef.regNum@,@assignExpr.type@\);) s
(                 @}) s
(         ;) s
( ) s
endpage
%%Page: 10 10
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 10) s
( ) s
( ) s
( simpleExpr      ) s
(         :       stgRef) s
(                 @{ @i @simpleExpr.type@ = @stgRef.type@;) s
(                    @i @stgRef.env@ = @simpleExpr.env@;) s
(                    @i @stgRef.regNum@ = @simpleExpr.regNum@;) s
(                    @i @simpleExpr.maxRegNum@ = @stgRef.maxRegNum@;) s
(                    @i @stgRef.formalMatch@ = @simpleExpr.formalMatch@;) s
(                    @i @simpleExpr.isStgRef@ = TRUE;) s
(                    @t cgCondDeref\(@simpleExpr.formalMatch@,@simpleExpr.regNum@,) s
(                                   @simpleExpr.type@) s
(                                  \);) s
(                 @}) s
(         |       funcInvoc) s
(                 @{ @i @simpleExpr.type@ = @funcInvoc.type@;) s
(                    @i @funcInvoc.env@ = @simpleExpr.env@;) s
(                    @i @funcInvoc.regNum@ = @simpleExpr.regNum@;) s
(                    @i @simpleExpr.maxRegNum@ = @funcInvoc.maxRegNum@;) s
(                    @i @simpleExpr.isStgRef@ = FALSE;) s
(                 @}) s
(         |       ICONST) s
(                 @{ constSimpleExpr\(ICONST,INTT,\)   @}) s
(         |       FCONST) s
(                 @{ constSimpleExpr\(FCONST,FLOATT,\) @}) s
(         |       BCONST) s
(                 @{ constSimpleExpr\(BCONST,BOOLT,\)  @}) s
(         |       EOFCONST) s
(                 @{ @i @simpleExpr.type@ = INTT;) s
(                    @i @simpleExpr.maxRegNum@ = @simpleExpr.regNum@;) s
(                    @i @simpleExpr.isStgRef@ = FALSE;) s
(                    @t cgEOF\(@simpleExpr.regNum@\);) s
(                 @}) s
(         ;) s
( ) s
( iConstExpr      ) s
(         :       ICONST) s
(                 @{ @i @iConstExpr.val@ = @ICONST.val@.i;) s
(                 @}) s
(         |       '-'     iConstExpr) s
(                 @{ @i @iConstExpr.val@ = - @iConstExpr.1.val@ ;) s
(                 @}) s
(         |       '+'     iConstExpr) s
(                 @{ @i @iConstExpr.val@ =   @iConstExpr.1.val@ ;) s
(                 @}) s
(         |       '\('     iConstExpr      '\)') s
(                 @{ @i @iConstExpr.val@ =   @iConstExpr.1.val@ ;) s
(                 @}) s
(         |       iConstExpr      '*'     iConstExpr) s
(                 @{ @i @iConstExpr.val@ = @iConstExpr.1.val@ *) s
(                                            @iConstExpr.2.val@ ;) s
(                 @}) s
(         |       iConstExpr      '+'     iConstExpr) s
(                 @{ @i @iConstExpr.val@ = @iConstExpr.1.val@ +) s
(                                            @iConstExpr.2.val@ ;) s
(                 @}) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 11) s
( ) s
( ) s
(         |       iConstExpr      '/'     iConstExpr) s
(                 @{ @i @iConstExpr.val@ = @iConstExpr.1.val@ /) s
(                                            @iConstExpr.2.val@ ;) s
(                 @}) s
(         |       iConstExpr      '-'     iConstExpr) s
(                 @{ @i @iConstExpr.val@ = @iConstExpr.1.val@ -) s
(                                            @iConstExpr.2.val@ ;) s
(                 @}) s
(         ;) s
( ) s
( stgRef  ) s
(         :       ID      indexSeq) s
(                 @{ @i @ID.sym@ =) s
(                         stgRefLookup\(@stgRef.env@,@ID.str@,@ID.line@\);) s
(                    @i @indexSeq.env@ = @stgRef.env@;) s
(                    @i @indexSeq.regNum@ = @stgRef.regNum@;) s
(                    @i @stgRef.type@ = @ID.sym@->type;) s
(                    @i @indexSeq.dimList@ =) s
(                          adjustDimList\(@stgRef.formalMatch@,@ID.sym@,@ID.line@\);) s
(                    @i @stgRef.maxRegNum@ = @indexSeq.maxRegNum@;) s
(                    @i @indexSeq.sym@ = @ID.sym@;) s
(                    @i @indexSeq.line@ = @ID.line@;) s
(                 @}) s
(         ;) s
( ) s
( indexSeq) s
(         :       ) s
(                 @{ @i @indexSeq.maxRegNum@ = @indexSeq.regNum@;) s
(                    @t cgEmptyIndexSeq\(@indexSeq.env@,@indexSeq.sym@,) s
(                          @indexSeq.line@,@indexSeq.regNum@,@indexSeq.dimList@) s
(                                      \);) s
(                 @}) s
(         |       indexSeq        '['     expr    ']') s
(                 @{ @i @indexSeq.1.env@ = @indexSeq.env@;) s
(                    @i @expr.env@ = @indexSeq.env@;) s
(                    @i @indexSeq.1.regNum@ = @indexSeq.regNum@;) s
(                    @i @expr.regNum@ = @indexSeq.regNum@ + 1;) s
(                    @i @indexSeq.maxRegNum@ = max\(@indexSeq.1.maxRegNum@,) s
(                                                @expr.maxRegNum@) s
(                                               \);) s
(                    @i @indexSeq.1.dimList@ = cdrDimList\(@indexSeq.dimList@,) s
(                                                         @indexSeq.sym@,) s
(                                                         @indexSeq.line@) s
(                                                        \);) s
(                    @i @indexSeq.1.sym@ = @indexSeq.sym@;) s
(                    @i @indexSeq.1.line@ = @indexSeq.line@;) s
(                    @i @expr.formalMatch@ = lambdaSym;) s
(                    @t cgIndexSeq\(@indexSeq.sym@,@indexSeq.regNum@,) s
(                                  @indexSeq.dimList@) s
(                                 \);) s
(                 @}) s
(         ;) s
( ) s
endpage
%%Page: 11 11
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 12) s
( ) s
( ) s
( funcInvoc) s
(         :       ID      '\('     '\)') s
(                 @{ @i @funcInvoc.type@ = @ID.sym@->type;) s
(                    @i @ID.sym@ =) s
(                         funcInvocLookup\(@funcInvoc.env@,@ID.str@,@ID.line@\);) s
(                    @i @funcInvoc.maxRegNum@ = @funcInvoc.regNum@;) s
(                    @t cgFuncCall\(@funcInvoc.env@,@ID.sym@,) s
(                                  @funcInvoc.regNum@,TRUE,@ID.line@) s
(                                 \);) s
(                 @}) s
(         |       ID      '\('     actParamList    '\)') s
(                 @{ @i @actParamList.env@ = @funcInvoc.env@;) s
(                    @i @funcInvoc.type@ = @ID.sym@->type;) s
(                    @i @ID.sym@ =) s
(                         funcInvocLookup\(@funcInvoc.env@,@ID.str@,@ID.line@\);) s
(                    @i @actParamList.regNum@ = @funcInvoc.regNum@;) s
(                    @i @funcInvoc.maxRegNum@ = @actParamList.maxRegNum@;) s
(                    @i @actParamList.formParamList@ = @ID.sym@->paramLoc;) s
(                    @i @actParamList.func@ = @ID.sym@;) s
(                    @i @actParamList.line@ = @ID.line@;) s
(                    @t cgFuncCall\(@funcInvoc.env@,@ID.sym@,) s
(                                  @funcInvoc.regNum@,FALSE,@ID.line@) s
(                                 \);) s
(                 @}) s
(         |       typeSpec        '\('     expr    '\)') s
(                 @{ @i @expr.env@ = @funcInvoc.env@;) s
(                    @i @funcInvoc.type@ = @typeSpec.type@;) s
(                    @i @expr.regNum@ = @funcInvoc.regNum@;) s
(                    @i @funcInvoc.maxRegNum@ = @expr.maxRegNum@;) s
(                    @i @expr.formalMatch@ = lambdaSym;) s
(                    @t cgCast\(@expr.regNum@,@typeSpec.type@,@expr.type@\);) s
(                 @}) s
(         |       INPUT   '\('     STRING  ','     stgRef  '\)') s
(                 @{ @i @stgRef.env@ = @funcInvoc.env@;) s
(                    @i @funcInvoc.type@ = INTT;) s
(                    @i @stgRef.regNum@ = @funcInvoc.regNum@;) s
(                    @i @funcInvoc.maxRegNum@ = @stgRef.maxRegNum@;) s
(                    @i @stgRef.formalMatch@ = lambdaSym;) s
(                    @t cgInput\(@STRING.str@,@stgRef.regNum@,) s
(                               @stgRef.type@,@'\('.line@) s
(                              \);) s
(                 @}) s
(         |       OUTPUT  '\('     STRING  '\)') s
(                 @{ @i @funcInvoc.type@ = INTT;) s
(                    @i @funcInvoc.maxRegNum@ = @funcInvoc.regNum@;) s
(                    @t cgOutputNoArg\(@STRING.str@,@funcInvoc.regNum@\);) s
(                 @}) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 13) s
( ) s
( ) s
(         |       OUTPUT  '\('     STRING  ','     expr    '\)') s
(                 @{ @i @expr.env@ = @funcInvoc.env@;) s
(                    @i @funcInvoc.type@ = INTT;) s
(                    @i @expr.regNum@ = @funcInvoc.regNum@;) s
(                    @i @funcInvoc.maxRegNum@ = @expr.maxRegNum@;) s
(                    @i @expr.formalMatch@ = lambdaSym;) s
(                    @t cgOutputOneArg\(@STRING.str@,@expr.regNum@,@expr.type@\);) s
(                 @}) s
(         ;) s
( ) s
( actParamList) s
(         :       expr) s
(                 @{ @i @expr.regNum@ = @actParamList.regNum@;) s
(                    @i @actParamList.maxRegNum@ = @expr.maxRegNum@;) s
(                    @i @expr.env@ = @actParamList.env@;) s
(                    @i @expr.formalMatch@ = @actParamList.formParamList@;) s
(                    @t paramMatchCheck\(@actParamList.formParamList@,) s
(                                       @expr.type@,) s
(                                       @expr.isStgRef@,TRUE,) s
(                                       @actParamList.func@,@actParamList.line@) s
(                                      \);) s
(                       cgPush\(@actParamList.regNum@\);) s
(                 @}) s
(         |       actParamList    ','     expr    ) s
(                 @{ @i @actParamList.1.env@ = @actParamList.env@;) s
(                    @i @expr.env@ = @actParamList.env@;) s
(                    @i @actParamList.1.regNum@ = @actParamList.regNum@;) s
(                    @i @expr.regNum@ = @actParamList.regNum@;) s
(                    @i @actParamList.maxRegNum@ = max\(@actParamList.1.maxRegNum@,) s
(                                                      @expr.maxRegNum@) s
(                                                     \);) s
(                    @i @actParamList.1.formParamList@ =) s
(                         cdrParamList\(@actParamList.formParamList@,) s
(                                      @actParamList.func@,) s
(                                      @actParamList.line@) s
(                                     \);) s
(                    @i @actParamList.1.func@ = @actParamList.func@;) s
(                    @i @actParamList.1.line@ = @actParamList.line@;) s
(                    @i @expr.formalMatch@ = @actParamList.formParamList@;) s
(                    @t paramMatchCheck\(@actParamList.formParamList@,) s
(                                       @expr.type@,) s
(                                       @expr.isStgRef@,FALSE,) s
(                                       @actParamList.func@,@actParamList.line@) s
(                                      \);) s
(                       cgPush\(@actParamList.regNum@\);) s
(                 @}) s
(         ;) s
( ) s
endpage
%%Page: 12 12
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 14) s
( ) s
( ) s
( funcDecl) s
(         :       typeSpec        ID      '\('     paramDeclList   '\)'     block) s
(                 @{ @i @block.env@ = newEnv\(@funcDecl.env@,) s
(                                            @ID.sym@,) s
(                                            @block.varLoc@,) s
(                                            @block.funcLoc@,) s
(                                            @block.maxRegNum@) s
(                                           \);) s
(                    @i @funcDecl.loc@ = @ID.sym@;) s
(                    @i @ID.sym@ = newFuncSym\(@ID.str@,@ID.line@,) s
(                                             @typeSpec.type@,) s
(                                             newLabelNum\(\),) s
(                                             @paramDeclList.loc@) s
(                                            \);) s
(                    @i @paramDeclList.funcSym@ = @ID.sym@;) s
(                    @t cgFuncTrailer\(@ID.sym@\);) s
(                 @}) s
(         ;) s
( ) s
( paramDeclList) s
(         :) s
(                 @{ @i @paramDeclList.loc@ = lambdaSym;) s
(                    @t cgFuncAddress\(@paramDeclList.funcSym@\);) s
(                 @}) s
(         |       paramDeclList   paramDecl) s
(                 @{ @i @paramDeclList.loc@ =) s
(                         concatLocs\(@paramDecl.loc@,@paramDeclList.1.loc@\);) s
(                    @i @paramDeclList.1.funcSym@ = @paramDeclList.funcSym@;) s
(                 @}) s
(         ;       ) s
( ) s
( paramDecl       ) s
(         :               stgDecl         ) s
(                 @{ @i @paramDecl.loc@ = @stgDecl.loc@;) s
(                    @i @stgDecl.class@ = VALPARAMC;) s
(                 @}) s
(         |       VAR     stgDecl ) s
(                 @{ @i @paramDecl.loc@ = @stgDecl.loc@;) s
(                    @i @stgDecl.class@ = REFPARAMC;) s
(                 @}) s
(         ;) s
( ) s
( stgDecl ) s
(         :               typeSpec        stgDecl2List    ';') s
(                 @{ @i @stgDecl.loc@ = @stgDecl2List.loc@;) s
(                    @i @stgDecl2List.type@ = @typeSpec.type@;) s
(                    @i @stgDecl2List.class@ = @stgDecl.class@;) s
(                 @}) s
(         ;) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 15) s
( ) s
( ) s
( typeSpec) s
(         :       INT) s
(                 @{ @i @typeSpec.type@ = INTT;) s
(                    @i @typeSpec.line@ = @INT.line@;) s
(                 @}) s
(         |       FLOAT) s
(                 @{ @i @typeSpec.type@ = FLOATT;) s
(                    @i @typeSpec.line@ = @FLOAT.line@;) s
(                 @}) s
(         |       BOOL) s
(                 @{ @i @typeSpec.type@ = BOOLT;) s
(                    @i @typeSpec.line@ = @BOOL.line@;) s
(                 @}) s
(         |       VOID) s
(                 @{ @i @typeSpec.type@ = VOIDT;) s
(                    @i @typeSpec.line@ = @VOID.line@;) s
(                 @}) s
(         ;) s
( ) s
( stgDecl2List) s
(         :       stgDecl2        ) s
(                 @{ @i @stgDecl2List.loc@ = @stgDecl2.loc@;) s
(                    @i @stgDecl2.type@ = @stgDecl2List.type@;) s
(                    @i @stgDecl2.class@ = @stgDecl2List.class@;) s
(                 @}) s
(         |       stgDecl2List    ','     stgDecl2) s
(                 @{ @i @stgDecl2List.loc@ = concatLocs\(@stgDecl2.loc@,) s
(                                                       @stgDecl2List.1.loc@) s
(                                                      \);) s
(                    @i @stgDecl2List.1.type@ = @stgDecl2List.type@;) s
(                    @i @stgDecl2List.1.class@ = @stgDecl2List.class@;) s
(                    @i @stgDecl2.type@ = @stgDecl2List.type@;) s
(                    @i @stgDecl2.class@ = @stgDecl2List.class@;) s
(                 @}) s
(         ;) s
( ) s
( stgDecl2        ) s
(         :       ID      dimSeq) s
(                 @{ @i @stgDecl2.loc@ = @ID.sym@;) s
(                    @i @ID.sym@ = newStgSym\(@ID.str@,@ID.line@,) s
(                                            @stgDecl2.type@,) s
(                                            @stgDecl2.class@,) s
(                                            @dimSeq.dimList@) s
(                                           \);) s
(                 @}) s
(         ;) s
( ) s
endpage
%%Page: 13 13
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 16) s
( ) s
( ) s
( dimSeq  :       ) s
(                 @{ @i @dimSeq.dimList@ = lambdaDim;) s
(                 @}) s
(         |       dimSeq  '['     iConstExpr      ']') s
(                 @{ @i @dimSeq.dimList@ =) s
(                          consDimList\(@iConstExpr.val@,@dimSeq.1.dimList@,) s
(                                      @'['.line@) s
(                                     \);) s
(                 @}) s
(         ;) s
( ) s
( ifStatement) s
(         :       IF      expr    then    execElem        ) s
(                 @{ @i @execElem.env@ = @ifStatement.env@;) s
(                    @i @expr.env@ = @ifStatement.env@;) s
(                    @i @expr.regNum@ = FIRSTREGNUM;) s
(                    @i @ifStatement.maxRegNum@ = max\(@expr.maxRegNum@,) s
(                                                     @execElem.maxRegNum@) s
(                                                    \);) s
(                    @i @expr.formalMatch@ = lambdaSym;) s
(                    @i @then.label@ = newLabelNum\(\);) s
(                    @i @then.decisionRegNum@ = @expr.regNum@;) s
(                    @t cgIfThen\(@expr.type@,@IF.line@,@then.label@\);) s
(                 @}) s
( ) s
(         |       IF      expr    then    execElem        else    execElem) s
(                 @{ @i @expr.env@ = @ifStatement.env@;) s
(                    @i @execElem.env@ = @ifStatement.env@;) s
(                    @i @execElem.1.env@ = @ifStatement.env@;) s
(                    @i @expr.regNum@ = FIRSTREGNUM;) s
(                    @i @ifStatement.maxRegNum@ =) s
(                          max\(@expr.maxRegNum@,) s
(                              max\(@execElem.maxRegNum@,) s
(                                  @execElem.1.maxRegNum@) s
(                                 \)) s
(                             \);) s
(                    @i @expr.formalMatch@ = lambdaSym;) s
(                    @i @then.label@ = newLabelNum\(\);) s
(                    @i @then.decisionRegNum@ = @expr.regNum@;) s
(                    @i @else.label@ = @then.label@;) s
(                    @t cgIfThenElse\(@expr.type@,@IF.line@,@then.label@\);) s
(                 @}) s
(         ;) s
( ) s
( then    ) s
(         :       THEN) s
(                 @{ @t cgThen\(@then.decisionRegNum@,@then.label@\);) s
(                 @}) s
(         ;) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 17) s
( ) s
( ) s
( else    ) s
(         :       ELSE) s
(                 @{ @t cgElse\(@else.label@\);) s
(                 @}) s
(         ;) s
( ) s
( whileStatement) s
(         :       while   '\('     expr    '\)'     wDecision       execElem) s
(                 @{ @i @expr.env@ = @whileStatement.env@;) s
(                    @i @execElem.env@ = @whileStatement.env@;) s
(                    @i @expr.regNum@ = FIRSTREGNUM;) s
(                    @i @whileStatement.maxRegNum@ = max\(@expr.maxRegNum@,) s
(                                                        @execElem.maxRegNum@) s
(                                                       \);) s
(                    @i @expr.formalMatch@ = lambdaSym;) s
(                    @i @while.label@ = newLabelNum\(\);) s
(                    @i @wDecision.label@ = @while.label@;) s
(                    @i @wDecision.decisionRegNum@ = @expr.regNum@;) s
(                    @t cgWhileStatement\(@expr.type@,@'\('.line@,@while.label@\);) s
(                 @}) s
(         ;) s
( ) s
( while   ) s
(         :       WHILE) s
(                 @{ @t cgWhile\(@while.label@\);) s
(                 @}) s
(         ;) s
( ) s
( wDecision) s
(         :) s
(                 @{ @t cgWdecision\(@wDecision.decisionRegNum@,@wDecision.label@\);) s
(                 @}) s
(         ;) s
( ) s
( returnStatement) s
(         :       RETURN  expr    ';') s
(                 @{ @i @expr.env@ = @returnStatement.env@;) s
(                    @i @expr.regNum@ = FIRSTREGNUM;) s
(                    @i @returnStatement.maxRegNum@ = @expr.maxRegNum@;) s
(                    @i @expr.formalMatch@ = lambdaSym;) s
(                    @t cgReturnStmt\(@returnStatement.env@,@expr.regNum@,) s
(                                    @expr.type@,@RETURN.line@) s
(                                   \);) s
(                 @}) s
(         |       RETURN  ';') s
(                 @{ @i @returnStatement.maxRegNum@ = FIRSTREGNUM - 1;) s
(                    @t cgReturnStmt\(@returnStatement.env@,DONTCARE,) s
(                                    VOIDT,@RETURN.line@) s
(                                   \);) s
(                 @}) s
endpage
%%Page: 14 14
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 18) s
( ) s
( ) s
( exitStatement) s
(         :       EXIT    expr    ';') s
(                 @{ @i @expr.env@ = @exitStatement.env@;) s
(                    @i @expr.regNum@ = FIRSTREGNUM;) s
(                    @i @exitStatement.maxRegNum@ = @expr.maxRegNum@;) s
(                    @i @expr.formalMatch@ = lambdaSym;) s
(                    @t cgExitStmt\(@expr.regNum@,@expr.type@,@EXIT.line@\);) s
(                 @}) s
(         ;) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  gppl.Y Page 19) s
( ) s
( ) s
( ) s
( %%) s
( #include <stdio.h>) s
( ) s
( void yyyCheckForResizes\(\);) s
( ) s
( ) s
( ) s
( main\(argc,argv\)) s
(   int argc;) s
(   char *argv[];) s
(   {int parseStatus;) s
( ) s
(    yyyCheckForResizes\(argc,argv\);) s
(    scanSetup\(\);) s
(    semSetup\(\);) s
(    tempOut = safeOpen\(tempOutID,"w"\);) s
(    cgHeader\(\);) s
(    parseStatus = yyparse\(\);) s
(    cgTrailer\(\);) s
(    fclose\(tempOut\);) s
(    return\(parseStatus || \(doCodeGen == FALSE\)\);) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 15 15
startpage
( ) s
( ) s
( Dec 14 11:32 1992  util.c Page 1) s
( ) s
( ) s
( /* $Header: util.c,v 1.3 92/12/14 11:32:23 bischoff Exp $ */) s
( ) s
( #include "glob.h") s
( ) s
( extern int yylineno;) s
( ) s
( void yyerror\(cp\)) s
(   char *cp;) s
(   {fprintf\(stderr,"Syntax error near line %d: %s\\n",yylineno,cp\);) s
(    yyyerror\(\);) s
(   }) s
( ) s
( ) s
( ) s
( void fatal\(cp\)) s
(   char *cp;) s
(   {fprintf\(stderr,"Fatal error: %s\\n",cp\);) s
(    exit\(-1\);) s
(   }) s
( ) s
( ) s
( ) s
( void internal\(s\)) s
(   char *s;) s
(   {fprintf\(stderr,"gppl internal error: %s\\n",s\);) s
(   }) s
( ) s
( ) s
( ) s
( void handleOverflow\(cp\)) s
(   char *cp;) s
(   {fatal\(cp\);) s
(   }) s
( ) s
( ) s
( ) s
( FILE *safeOpen\(name,mode\)) s
(   char *name,*mode;) s
(   {FILE *dum;) s
(    if \(\(dum = fopen\(name,mode\)\)) s
(        ==) s
(        \(\(FILE *\)NULL\)) s
(       \)) s
(       {fprintf\(stderr,"fatal error opening %s.\\n",name\);) s
(        exit\(-1\);) s
(       }) s
(       else) s
(       return dum;) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  util.c Page 2) s
( ) s
( ) s
( void printStringArray\(arr,sizeofArr,fp\)) s
(   char **arr;) s
(   int sizeofArr;) s
(   FILE *fp;) s
(   {long i;) s
(    for \(i=0;i<\(sizeofArr/sizeof\(char *\)\);i++\)) s
(        fprintf\(fp,arr[i]\);) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 16 16
startpage
( ) s
( ) s
( Dec 14 11:32 1992  scan.c Page 1) s
( ) s
( ) s
( /* $Header: scan.c,v 1.3 92/12/14 11:32:27 bischoff Exp $ */) s
( ) s
( #include <stdio.h>) s
( #include <limits.h>) s
( #include "glob.h") s
( #include "util.h") s
( ) s
( extern int yylineno;) s
( #define DFAACCEPT 0) s
( ) s
( ) s
( ) s
( void eatComment\(\)) s
(   {char c;) s
(    int state = 1;) s
(    while \(state != DFAACCEPT\)) s
(      {c = yyinput\(\);) s
(       switch \(state\)) s
(         {case 1: switch\(c\)) s
(                    {case '*' : state = 2; break;) s
(                     default : ;) s
(                    }) s
(                  break;) s
(          case 2: switch\(c\)) s
(                    {case '*' : break;) s
(                     case '/' : state = DFAACCEPT;) s
(                                break;) s
(                     default  : state = 1;) s
(                    }) s
(                  break;) s
(          default : ;) s
(         }) s
(      }  /* while */) s
(   }) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  scan.c Page 2) s
( ) s
( ) s
( ) s
( #define strBufSize 512) s
( ) s
( char *copyLexemeOfSTRING\(\)) s
(   {char c;) s
(    char *cp,*afterBuf,*temp;) s
(    char buf[strBufSize];) s
(    int state = 1;) s
( ) s
(    cp = buf;) s
(    *cp++ = '\\"';) s
(    afterBuf = buf + strBufSize;) s
(    while \(state != DFAACCEPT\)) s
(      {*cp++ = c = yyinput\(\);) s
(       if \(cp == afterBuf\) fatal\("string too long\\n"\);) s
(       switch \(state\)) s
(         {case 1: switch\(c\)) s
(                    {case '\\\\' : state = 2; break;) s
(                     case '\\"' : state = DFAACCEPT; break;) s
(                     default : ;) s
(                    }) s
(                  break;) s
(          case 2: state = 1;) s
(                  break;) s
(          default : ;) s
(         }) s
(      }  /* while */) s
(    if \(\(temp = \(char *\)malloc\(1 + cp - buf\)\)) s
(        ==) s
(        \(\(char *\)NULL\)) s
(       \)) s
(       fatal\("malloc error in string allocation\\n"\);) s
(    *cp = '\\0';) s
(    strcpy\(temp,buf\);) s
(    return temp;) s
(   }) s
( ) s
( ) s
( ) s
( /* The size of the array of pointers to permanent null-terminated copies) s
(  * of lexemes of identifiers.) s
(  */) s
( int maxNstrings = 509;) s
( ) s
( ) s
( /* stringTable[i] is either \(char *\)NULL or a) s
(  * permanent null-terminated copy of the lexeme of an identifier.) s
(  */) s
( static char **stringTable;) s
( ) s
( ) s
( ) s
endpage
%%Page: 17 17
startpage
( ) s
( ) s
( Dec 14 11:32 1992  scan.c Page 3) s
( ) s
( ) s
( /*  generates and returns a pointer to a permanent null-terminated copy) s
(  *  of the first len characters of the string cp.) s
(  */) s
( static char *allocString\(cp,len\)) s
(   char *cp;) s
(   int len;) s
(   {char *ncp, *str_save;) s
(    if \(\(ncp = \(\(char *\) malloc\(len+1\)\)\)) s
(        ==) s
(        \(\(char *\) NULL\)) s
(       \)) s
(       fatal\("internal malloc error in allocString"\);) s
(    str_save = ncp;) s
(    while \(len--\)) s
(          *ncp++ = *cp++;) s
(    *ncp = '\\0';) s
(    return\(str_save\);) s
(   }) s
( ) s
( ) s
( ) s
( /*  compute a hash value for a string */) s
( static long stringHash\(cp,len\)) s
(   char *cp;) s
(   int len;) s
(   {int hashval;) s
(    switch \(hashval = len\)) s
(      {default: hashval += cp[len - 2] * 512;) s
(       case 3:  hashval += cp[len - 1] * 64;) s
(       case 2:  hashval += cp[1] * 8;) s
(       case 1:  hashval += cp[0]; break;) s
(       case 0:  fatal\("internal error: can't seek the empty string.\\n"\);) s
(      }) s
(    return\(hashval\);) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  scan.c Page 4) s
( ) s
( ) s
( /* Search the string table for a string matching the first len characters of) s
(  * cp.  If it is absent and insertion is requested, try to insert it, returning) s
(  * a pointer to a permanent null-terminated copy if successful, null pointer) s
(  * if unsuccessful \(due to a full table\).  If absent and insertion not) s
(  * requested, return null pointer.  If present, return pointer to the copy.) s
(  */) s
( char *stringLookup\(cp,len,insertIfAbsent\)) s
(   char *cp;) s
(   int len;) s
(   int insertIfAbsent;) s
(   {int i,try;) s
(    char **dum;) s
(    try = stringHash\(cp,len\) % maxNstrings;) s
(    for \(i=0; i<maxNstrings; i++\)) s
(        {dum = stringTable + try;) s
(         try = \(try + 1\) % maxNstrings;) s
(         if \(*dum == \(char *\)NULL\)) s
(            {if \(insertIfAbsent\) *dum = allocString\(cp,len\);) s
(             return\(*dum\);) s
(            }) s
(         if \(strlen\(*dum\) != len\) continue; /* don't match proper prefixes */) s
(         if \(!strncmp\(*dum,cp,len\)\) return\(*dum\);) s
(        }) s
(    handleOverflow\("out of room in string table"\);) s
(   }) s
( ) s
( ) s
( ) s
( void scanSetup\(\)) s
(   {int i;) s
( ) s
(    if \(\(stringTable = \(char **\) malloc\(maxNstrings * sizeof\(char *\)\)\)) s
(        !=) s
(        \(\(char **\) NULL\)) s
(       \)) s
(       for \(i=0; i<maxNstrings; i++\) stringTable[i] = \(char *\)NULL;) s
(       else) s
(       fatal\("malloc error in string table allocation\\n"\);) s
(   }) s
( ) s
( ) s
endpage
%%Page: 18 18
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 1) s
( ) s
( ) s
( /* $Header: sem.c,v 1.3 92/12/14 11:32:32 bischoff Exp $ */) s
( ) s
( #include "glob.h") s
( #include "y.tab.h") s
( #include "util.h") s
( ) s
( static int symSpaceSize = 1000;) s
(        struct sym *symSpace;) s
( static struct sym *symStock,*afterSymSpace;) s
( ) s
( ) s
( static int envSpaceSize = 1000;) s
(        struct env *envSpace;) s
( static struct env *envStock,*afterEnvSpace;) s
( ) s
( static int dimListSpaceSize = 1000;) s
(        struct dim *dimListSpace;) s
( static struct dim *dimListStock,*afterDimListSpace;) s
( ) s
( ) s
( ) s
( void handleSemError\(\)) s
(   {doCodeGen = FALSE;) s
(   }) s
( ) s
( ) s
( ) s
( void semSetup\(\)) s
(   {spaceSetup\("symbol",struct sym,symSpace,) s
(               symSpaceSize,3,afterSymSpace,symStock) s
(              \)) s
( ) s
(    spaceSetup\("environment",struct env,envSpace,) s
(               envSpaceSize,2,afterEnvSpace,envStock) s
(              \)) s
( ) s
(    spaceSetup\("dimension list",struct dim,dimListSpace,) s
(               dimListSpaceSize,2,afterDimListSpace,dimListStock) s
(              \)) s
( ) s
(    lambdaSym->next = lambdaSym;) s
(    lambdaSym->dimList = lambdaDim;) s
(    lambdaSym->paramLoc = lambdaSym;) s
( ) s
(    lambdaEnv->level = -1;) s
(    lambdaEnv->varLoc = lambdaSym;) s
(    lambdaEnv->funcLoc = lambdaSym;) s
(    lambdaEnv->outerEnv = lambdaEnv;) s
( ) s
(    lambdaDim->next = lambdaDim;) s
(   }) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 2) s
( ) s
( ) s
( struct dim *consDimList\(size,dimList,line\)) s
(   long size;) s
(   struct dim *dimList;) s
(   lineNumType line;) s
(   {struct dim *dum;) s
(    if \(size < 1\)) s
(       {fprintf\(stderr,) s
(          "nonpositive dimension in array declaration near line %d.\\n",line) s
(               \);) s
(        handleSemError\(\);) s
(       }) s
(    if \(\(dum = dimListStock++\) == afterDimListSpace\)) s
(       handleOverflow\("out of space for dimension lists\\n"\);) s
(    dum->size = size;) s
(    dum->next = dimList;) s
(    return dum;) s
(   }) s
( ) s
( ) s
( ) s
( static enum pred nameConflict\(sym1,sym2\)) s
(   struct sym *sym1,*sym2;) s
(   {if \(sym1->id == sym2->id\)) s
(       {fprintf\(stderr,) s
(                "symbol %s multiply defined: lines %d and %d.\\n",) s
(                sym1->id,sym1->line,sym2->line) s
(               \);) s
(        handleSemError\(\);) s
(        return TRUE;) s
(       }) s
(       else) s
(       return FALSE;) s
(   }) s
( ) s
( ) s
( ) s
( static void *symDupCheck\(loc1,loc2\)) s
(   struct sym *loc1,*loc2;) s
(   {struct sym *dum;) s
(    while \(loc1 != lambdaSym\)) s
(      {dum = loc2;) s
(       while \(dum != lambdaSym\)) s
(         {if \(nameConflict\(loc1,dum\)\) break;) s
(          dum = dum->next;) s
(         }) s
(       loc1 = loc1->next;) s
(      }) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 19 19
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 3) s
( ) s
( ) s
( /* returns the concatenation of two sequences of symbols,) s
(  * issuing an error message when there is a symbol E1 in) s
(  * one sequence and a symbol E2 in the other sequence) s
(  * such that E1 and E2 have the same identifier.) s
(  * Tacks rightLoc onto the end of leftLoc and returns leftLoc.) s
(  */) s
( struct sym *concatLocs\(leftLoc,rightLoc\)) s
(   struct sym *leftLoc,*rightLoc;) s
(   {struct sym **prevLeftP;) s
( ) s
(    symDupCheck\(rightLoc,leftLoc\);) s
(    prevLeftP = &leftLoc;) s
(    while \(*prevLeftP != lambdaSym\) prevLeftP = &\(\(*prevLeftP\)->next\);) s
(    *prevLeftP = rightLoc;) s
(    return leftLoc;) s
(   }) s
( ) s
( ) s
( ) s
( struct dim *cdrDimList\(dimList,sym,line\)) s
(   struct dim *dimList;) s
(   struct sym *sym;) s
(   lineNumType line;) s
(   {if \(dimList == lambdaDim\)) s
(       {if \(sym != lambdaSym\)) s
(           fprintf\(stderr,"extra index in line %d\\'s reference to %s.\\n",) s
(                   line,sym->id) s
(                  \);) s
(        handleSemError\(\);) s
(        return lambdaDim;) s
(       }) s
(       else) s
(       return dimList->next;) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 4) s
( ) s
( ) s
( struct dim *adjustDimList\(formalSym,actualSym,line\)) s
(   struct sym *formalSym,*actualSym;) s
(   lineNumType line;) s
(   {struct dim *formDL,*actDL;) s
(    char *msg;) s
( ) s
(    if \(formalSym == lambdaSym\) return actualSym->dimList;) s
(    if \(actualSym == lambdaSym\) return lambdaDim;) s
(    if \(formalSym->type != actualSym->type\)) s
(       {msg = "type mismatch.\\n"; goto errD;}) s
(    formDL = formalSym->dimList;) s
(    actDL = actualSym->dimList;) s
(    while \(formDL != lambdaDim\)) s
(      {if \(\(actDL == lambdaDim\) ||) s
(           \(formDL->scale != actDL->scale\) ||) s
(           \(formDL->size > actDL->size\)) s
(          \)) s
(          {msg = "incompatible dimensions.\\n"; goto errD;}) s
(       formDL = formDL->next;) s
(       actDL = actDL->next;) s
(      }) s
(    return actDL;) s
( errD:) s
(    fprintf\(stderr,) s
(       "actual parameter %s matched to formal parameter %s\\n  at line %d: %s",) s
(            actualSym->id,formalSym->id,line,msg) s
(           \);) s
(    handleSemError\(\);) s
(    while \(formDL != lambdaDim\) {formDL = formDL->next; actDL = actDL->next;}) s
(    return actDL;) s
(   }) s
( ) s
( ) s
( ) s
( struct sym *cdrParamList\(loc,func,line\)) s
(   struct sym *loc;) s
(   struct sym *func;) s
(   lineNumType line;) s
(   {if \(\(loc == lambdaSym\) || \(loc->next == lambdaSym\)\)) s
(       {if \(func != lambdaSym\)) s
(           fprintf\(stderr,"extra actual parameter in call to %s near line %d.\\n",) s
(                   func->id,line) s
(                  \);) s
(        handleSemError\(\);) s
(       }) s
(   if \(loc == lambdaSym\)) s
(      return lambdaSym;) s
(      else) s
(      return loc->next;) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 20 20
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 5) s
( ) s
( ) s
( void paramMatchCheck\(formParamList,exprType,isStgRef,isFirstExpr,func,line\)) s
(   struct sym *formParamList;) s
(   enum symType exprType;) s
(   enum pred isStgRef,isFirstExpr;) s
(   struct sym *func;) s
(   lineNumType line;) s
( ) s
(   {enum pred mismatch = FALSE;) s
(    struct sym *symDum;) s
( ) s
(    if \(\(func == lambdaSym\) || \(formParamList == lambdaSym\)\) return;) s
(    if \(isFirstExpr\)) s
(       {symDum = formParamList;) s
(        symDum = symDum->next;) s
(        while \(symDum != lambdaSym\)) s
(          {fprintf\(stderr,"missing actual parameter in line %d's call to %s.\\n",) s
(                          line,func->id) s
(                  \);) s
(           handleSemError\(\);) s
(           mismatch = TRUE;) s
(           symDum = symDum->next;) s
(          }) s
(       }) s
(    if \(mismatch\) return;) s
(    if \(\(formParamList->class == REFPARAMC\) && !isStgRef\)) s
(       {fprintf\(stderr,) s
(        "actual parameter in call to %s near line %d is not a reference,\\n\\) s
(    but matched to formal reference parameter %s.\\n",) s
(        func->id,line,formParamList->id) s
(               \);) s
(        handleSemError\(\);) s
(       }) s
(    if \(formParamList->type != exprType\)) s
(       {fprintf\(stderr,) s
(        "parameter type mismatch in call to %s near line %d: \\n\\) s
(     formal parameter %s.\\n",) s
(        func->id,line,formParamList->id) s
(               \);) s
(        handleSemError\(\);) s
(       }) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 6) s
( ) s
( ) s
( static long scaleCalc\(dimList,type\)) s
(   struct dim *dimList;) s
(   enum symType type;) s
(   {long prevScale,prevSize,sizeOfEach;) s
( ) s
(    sizeOfEach = stgSize\(type,1L\);) s
(    prevScale = 1;) s
(    prevSize = 1;) s
(    while \(dimList != lambdaDim\)) s
(      {dimList->scale = prevScale * prevSize;) s
(       prevScale = dimList->scale;) s
(       prevSize = dimList->size;) s
(       dimList->scale *= sizeOfEach;) s
(       dimList = dimList->next;) s
(      }) s
(    return \(prevScale * prevSize * sizeOfEach\);) s
(   }) s
( ) s
( ) s
( ) s
( struct sym *newStgSym\(lexeme,line,type,class,dimList\)) s
(   char *lexeme;) s
(   lineNumType line;) s
(   enum symType type;) s
(   enum stgClass class;) s
(   struct dim *dimList;) s
( ) s
(   {struct sym *dum;) s
( ) s
(    if \(type == VOIDT\)) s
(       {fprintf\(stderr,"line %d: declared storage of type void for %s.\\n",) s
(                line,lexeme) s
(               \);) s
(        handleSemError\(\);) s
(        type = INTT;) s
(       }) s
( ) s
(    if \(\(dum = symStock++\) == afterSymSpace\)) s
(       handleOverflow\("out of space in symbol table\\n"\);) s
(    dum->id = lexeme;) s
(    dum->line = line;) s
(    dum->type = type;) s
(    dum->class = class;) s
(    dum->size = scaleCalc\(dimList,dum->type\);) s
(    if \(\(class == VALPARAMC\) && \(dimList != lambdaDim\)\)) s
(       {fprintf\(stderr,"array %s declared as value parameter at line %d.\\n",) s
(                lexeme,line) s
(               \);) s
(        handleSemError\(\);) s
(       }) s
(    if \(class == REFPARAMC\) dum->size = stgSize\(type,1L\);) s
(    dum->dimList = dimList;) s
(    dum->next = lambdaSym;) s
(    return dum;) s
(   }) s
endpage
%%Page: 21 21
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 7) s
( ) s
( ) s
( static long assignAddresses\(loc\)) s
(   struct sym *loc;) s
(   {long size = 0;) s
( ) s
(    while \(loc != lambdaSym\)) s
(      {loc->addr = size;) s
(       size += loc->size,) s
(       loc = loc->next;) s
(      }) s
(    return size;) s
(   }) s
( ) s
( ) s
( ) s
( static void *assignLevel\(loc,level\)) s
(   struct sym *loc;) s
(   levelType level;) s
(   {while \(loc != lambdaSym\)) s
(      {loc->level = level;) s
(       loc = loc->next;) s
(      }) s
(   }) s
( ) s
( ) s
( ) s
( struct sym *newFuncSym\(lexeme,line,type,label,paramLoc\)) s
(   char *lexeme;) s
(   lineNumType line;) s
(   enum symType type;) s
(   labelType label;) s
(   struct sym *paramLoc;) s
(   {struct sym *dum;) s
( ) s
(    if \(\(dum = symStock++\) == afterSymSpace\)) s
(       handleOverflow\("out of space in symbol table\\n"\);) s
(    dum->id = lexeme;) s
(    dum->line = line;) s
(    dum->type = type;) s
(    dum->paramsSize = assignAddresses\(paramLoc\);) s
(    dum->label = label;) s
(    dum->paramLoc = paramLoc;) s
(    dum->next = lambdaSym;) s
(    return dum;) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 8) s
( ) s
( ) s
( struct env *newEnv\(outerEnv,funcSym,varLoc,funcLoc,maxRegNum\)) s
(   struct env *outerEnv;) s
(   struct sym *funcSym;) s
(   struct sym *varLoc,*funcLoc;) s
(   regNumType maxRegNum;) s
(   {struct env *innerEnv;) s
( ) s
(    if \(\(innerEnv = envStock++\) == afterEnvSpace\)) s
(       handleOverflow\("out of space in environment table\\n"\);) s
(    symDupCheck\(funcSym->paramLoc,varLoc\);) s
(    symDupCheck\(varLoc,funcLoc\);) s
(    symDupCheck\(funcSym->paramLoc,funcLoc\);) s
(    innerEnv->funcSym = funcSym;) s
(    innerEnv->level = outerEnv->level + 1;) s
(    assignLevel\(funcSym->paramLoc,innerEnv->level\);) s
(    assignLevel\(varLoc,innerEnv->level\);) s
(    assignLevel\(funcLoc,innerEnv->level\);) s
(    innerEnv->funcSym->paramLoc = funcSym->paramLoc;) s
(    innerEnv->varLoc =   varLoc;) s
(    innerEnv->funcLoc =  funcLoc;) s
(    innerEnv->nRegs = maxRegNum + 1;) s
(    innerEnv->exitLabel = newLabelNum\(\);) s
(    innerEnv->varsSize = assignAddresses\(varLoc\);) s
(    innerEnv->outerEnv = outerEnv;) s
(    return innerEnv;) s
(   }) s
( ) s
( ) s
( ) s
( struct sym *stgRefLookup\(env,str,line\)) s
(   struct env *env;) s
(   char *str;) s
(   lineNumType line;) s
(   {struct sym *dumSym;) s
( ) s
(    while \(env != lambdaEnv\)) s
(      {dumSym = env->funcSym->paramLoc;) s
(       while \(\(dumSym != lambdaSym\) && \(dumSym->id != str\)\)) s
(         dumSym = dumSym->next;) s
(       if \(dumSym != lambdaSym\) return dumSym;) s
( ) s
(       dumSym = env->varLoc;) s
(       while \(\(dumSym != lambdaSym\) && \(dumSym->id != str\)\)) s
(         dumSym = dumSym->next;) s
(       if \(dumSym != lambdaSym\) return dumSym;) s
( ) s
(       env = env->outerEnv;) s
(      }) s
(    fprintf\(stderr,"undeclared storage identifier %s at line %d.\\n",) s
(                   str,line) s
(           \);) s
(    handleSemError\(\);) s
(    return lambdaSym;) s
(   }) s
( ) s
( ) s
endpage
%%Page: 22 22
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 9) s
( ) s
( ) s
( ) s
( struct sym *funcInvocLookup\(env,str,line\)) s
(   struct env *env;) s
(   char *str;) s
(   lineNumType line;) s
(   {struct sym *dumSym;) s
( ) s
(    while \(env != lambdaEnv\)) s
(      {dumSym = env->funcLoc;) s
(       while \(\(dumSym != lambdaSym\) && \(dumSym->id != str\)\)) s
(         dumSym = dumSym->next;) s
(       if \(dumSym != lambdaSym\) return dumSym;) s
( ) s
(       env = env->outerEnv;) s
(      }) s
(    fprintf\(stderr,"undeclared function identifier %s at line %d.\\n",) s
(                   str,line) s
(           \);) s
(    handleSemError\(\);) s
(    return lambdaSym;) s
(   }) s
( ) s
( ) s
( ) s
( static enum mapType inTypeOf\(op\)) s
(   int op;) s
(   {switch \(op\)) s
(      {) s
(       case '*':) s
(       case '+':) s
(       case '-':) s
(       case '/':) s
(       case LT:) s
(       case GT:) s
(       case EQ:) s
(       case LEQ:) s
(       case GEQ:) s
(       case NEQ: return ARITHM;) s
(       case NOT:) s
(       case AND:) s
(       case OR: return LOGM;) s
(       default: fprintf\(stderr,"unknown unary operator\\n"\); exit\(-1\);) s
(      }) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 10) s
( ) s
( ) s
( static enum mapType outTypeOf\(op\)) s
(   int op;) s
(   {switch \(op\)) s
(      {) s
(       case '*':) s
(       case '+':) s
(       case '-':) s
(       case '/': return ARITHM;) s
(       case LT:) s
(       case GT:) s
(       case EQ:) s
(       case LEQ:) s
(       case GEQ:) s
(       case NEQ:) s
(       case AND:) s
(       case OR:) s
(       case NOT: return LOGM;) s
(       default: fprintf\(stderr,"unknown binary operator\\n"\); exit\(-1\);) s
(      }) s
(   }) s
( ) s
( ) s
( ) s
( enum symType binOpTypeCheck\(type1,type2,op,line\)) s
(   enum symType type1,type2;) s
(   int op;) s
(   lineNumType line;) s
(   {if \(\(type1 == ERRT\) || \(type2 == ERRT\)\) return ERRT;) s
(    if \() s
(        \(type1 != type2\)) s
(        ||) s
(        \(type1 == VOIDT\)) s
(        ||) s
(        \(\(inTypeOf\(op\) == ARITHM\) != \(\(type1 == INTT\) || \(type1 == FLOATT\)\)\)) s
(       \)) s
(       {fprintf\(stderr,"binary operator type mismatch at line %d.\\n",line\);) s
(        handleSemError\(\);) s
(        return ERRT;) s
(       }) s
(    return \(outTypeOf\(op\) == ARITHM\)?type1:BOOLT;) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 23 23
startpage
( ) s
( ) s
( Dec 14 11:32 1992  sem.c Page 11) s
( ) s
( ) s
( enum symType unrOpTypeCheck\(type,op,line\)) s
(   enum symType type;) s
(   int op;) s
(   lineNumType line;) s
(   {if \(type == ERRT\) return ERRT;) s
(    if \() s
(        \(type == VOIDT\)) s
(        ||) s
(        \(\(inTypeOf\(op\) == ARITHM\) != \(\(type == INTT\) || \(type == FLOATT\)\)\)) s
(       \)) s
(       {fprintf\(stderr,"unary operator type mismatch at line %d.\\n",line\);) s
(        handleSemError\(\);) s
(        return ERRT;) s
(       }) s
(    return \(outTypeOf\(op\) == ARITHM\)?type:BOOLT;) s
(   }) s
( ) s
( ) s
( ) s
( enum symType assignmentTypeCheck\(type1,type2,line\)) s
(   enum symType type1,type2;) s
(   lineNumType line;) s
(   {if \(\(type1 == ERRT\) || \(type2 == ERRT\)\) return ERRT;) s
(    if \(type1 != type2\)) s
(       {fprintf\(stderr,) s
(                "type mismatch in assignment at line %d.\\n",line) s
(               \);) s
(        handleSemError\(\);) s
(        return ERRT;) s
(       }) s
(    return type1;) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 1) s
( ) s
( ) s
( /* $Header: code.c,v 1.3 92/12/14 11:32:35 bischoff Exp $ */) s
( ) s
( #include "glob.h") s
( #include "y.tab.h") s
( #include "util.h") s
( ) s
( #define ALIGNSIZE   4) s
( #define STACKSIZE1 1000000L) s
( #define STACKSIZE  \(ceiling\(STACKSIZE1,ALIGNSIZE\)\)) s
( ) s
( #define nFREGS 3) s
( #define RETREGADDR1   -2    /* relative to the callee's fp */) s
( #define RETREGADDR2   -4    /* relative to sp upon return  */) s
( ) s
( /* RA, VA, PA are for calculations of frame-pointer-relative addresses */) s
( #define RA\(regNum\)       \(-\(nFREGS + \(regNum\)\)\)) s
( #define VA\(variableAddr\) \(-\(nFREGS + dumEnv->nRegs + \(variableAddr\)\)\)) s
( #define PA\(paramAddr\)    \(\(paramAddr\) + 1 + 1\)) s
( ) s
( ) s
( enum pred doCodeGen = TRUE;) s
( ) s
( FILE *tempOut;) s
( ) s
( ) s
( ) s
( long stgSize\(type,howMany\)) s
(   enum symType type;) s
(   long howMany;) s
(   {return\(howMany\);) s
(   }) s
( ) s
( ) s
( ) s
( static labelType labelSeq = 0;) s
( static labelType returnLabelSeq = 0;) s
( ) s
( ) s
( ) s
( labelType newLabelNum\(\)) s
(   {return \(labelSeq++\);) s
(   }) s
( ) s
( ) s
( ) s
( labelType newReturnLabelNum\(\)) s
(   {return \(returnLabelSeq++\);) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 24 24
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 2) s
( ) s
( ) s
( char *cHeaderCode[] =) s
( {) s
( "\\n",) s
( "#include <stdio.h>\\n",) s
( "\\n",) s
( "union stackItem {\\n",) s
( "   int i; \\n",) s
( "   float f;\\n",) s
( "   int b; \\n",) s
( "   int *ip;\\n",) s
( "   float *fp;\\n",) s
( "   int *bp; \\n",) s
( "   union stackItem *up;\\n",) s
( "  };\\n",) s
( "\\n",) s
( "\\n",) s
( "main\(\)\\n",) s
( "{\\n",) s
( " register union stackItem *sp,*fp;\\n",) s
( "\\n",) s
( " if \(\(sp = \(union stackItem *\)malloc\(STACKSIZE * sizeof\(union stackItem\)\)\)\\n",) s
( "     ==\\n",) s
( "     \(\(union stackItem *\)NULL\)\\n",) s
( "    \)\\n",) s
( "    fprintf\(stderr,\\"malloc error in stack allocation\\\\n\\"\);\\n",) s
( " sp = sp + STACKSIZE;\\n",) s
( "\\n",) s
( };) s
( ) s
( ) s
( ) s
( void cgHeader\(\)) s
(   {if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"#define STACKSIZE %d\\n",STACKSIZE\);) s
(    printStringArray\(cHeaderCode,sizeof\(cHeaderCode\),tempOut\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgTrailer\(\)) s
(   {long i;) s
( ) s
(    if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"\\n\\texit\(0\);\\n"\);) s
(    fprintf\(tempOut,"rts:\\n"\);) s
(    fprintf\(tempOut,"  switch \(\(*\(sp++\)\).i\)  \\n    {\\n"\);) s
(    for \(i=0; i<returnLabelSeq; i++\)) s
(        fprintf\(tempOut,"     case %4d: goto r%d;\\n",i,i\);) s
(    fprintf\(tempOut,"    } /* rts switch */ \\n"\);) s
(    fprintf\(tempOut,"IOBtrap:\\n"\);) s
(    fprintf\(tempOut,"\\tfprintf\(stderr,\\"array index out of bounds.\\\\n\\"\);\\n"\);) s
(    fprintf\(tempOut,"\\texit\(-1\);\\n"\);) s
(    fprintf\(tempOut,"} /* main */ \\n"\);) s
(   }) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 3) s
( ) s
( ) s
( ) s
( void cgFuncCall\(env,funcSym,regNum,isEmptyActList,line\)) s
(   struct env *env;) s
(   struct sym *funcSym;) s
(   regNumType regNum;) s
(   enum pred isEmptyActList;) s
(   lineNumType line;) s
(   {int retLabel;) s
(    int staticDist,i;) s
(    struct sym *dum;) s
( ) s
(    if \(\(doCodeGen == FALSE\) || \(funcSym == lambdaSym\)\) return;) s
(    if \(isEmptyActList\)) s
(       {dum = funcSym->paramLoc;) s
(        while \(dum != lambdaSym\)) s
(          {fprintf\(stderr,"missing actual parameter in line %d's call to %s.\\n",) s
(                          line,funcSym->id) s
(                  \);) s
(           handleSemError\(\);) s
(           dum = dum->next;) s
(          }) s
(       }) s
(    staticDist = env->level - funcSym->level;) s
(    retLabel = newReturnLabelNum\(\);) s
(    fprintf\(tempOut,"\\t\(*--sp\).i = %d;\\n",retLabel\);) s
(    fprintf\(tempOut,"\\t\(*--sp\).up = fp;\\n"\);) s
(    for \(i=0; i<staticDist; i++\)) s
(        fprintf\(tempOut,"\\t*sp = *\(*sp\).up;\\n"\);) s
(    fprintf\(tempOut,"\\tgoto f%d;\\n",funcSym->label\);) s
(    fprintf\(tempOut,"r%d:\\n",retLabel\);) s
(    if \(funcSym->type != VOIDT\)) s
(       fprintf\(tempOut,"\\tfp[%d] = sp[%d];\\n",RA\(regNum\),RETREGADDR2\);) s
(    fprintf\(tempOut,"\\tsp += %d;\\n",funcSym->paramsSize\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgBlockEnter\(env\)) s
(   struct env *env;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    if \(env != lambdaEnv\)) s
(       {if \(env->funcSym == lambdaSym\)) s
(           fprintf\(tempOut,"\\t\(*--sp\).up = fp;\\n"\);) s
(        fprintf\(tempOut,"\\t\(*--sp\).up = fp;\\n"\);) s
(        fprintf\(tempOut,"\\tfp = sp + 1;\\n"\);) s
(        fprintf\(tempOut,"\\tsp -= %d;\\n",) s
(                1 + env->nRegs + env->varsSize) s
(               \);) s
(       }) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 25 25
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 4) s
( ) s
( ) s
( void cgBlockExit\(env\)) s
(   struct env *env;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    if \(env == lambdaEnv\) return;) s
(    fprintf\(tempOut,"BE%d:\\tsp = fp;\\n",env->exitLabel\);) s
(    fprintf\(tempOut,"\\tfp = \(*\(sp++ - 1\)\).up;\\n"\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgFuncAddress\(sym\)) s
(   struct sym *sym;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    if \(sym != lambdaSym\)) s
(       {fprintf\(tempOut,"\\tgoto j%d;\\n",sym->label\);) s
(        fprintf\(tempOut,"f%d:\\t\\t\\t\\t\\t\\t/* %s */\\n",sym->label,sym->id\);) s
(       }) s
(   }) s
( ) s
( ) s
( ) s
( void cgFuncTrailer\(sym\)) s
(   struct sym *sym;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"\\tgoto rts;\\n",sym->label\);) s
(    fprintf\(tempOut,"j%d:\\n",sym->label\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgBinArithExpr\(destReg,op,type\)) s
(   int destReg;) s
(   int op;) s
(   enum symType type;) s
(   {char *typeExt;) s
( ) s
(    if \(doCodeGen == FALSE\) return;) s
(    switch\(type\)) s
(      {case INTT:    typeExt = "i";  break;) s
(       case FLOATT:  typeExt = "f";  break;) s
(      }) s
(    fprintf\(tempOut,"\\tfp[%d].%s %c= fp[%d].%s;\\n",) s
(            RA\(destReg\),) s
(            typeExt,) s
(            op,) s
(            RA\(destReg + 1\),) s
(            typeExt) s
(           \);) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 5) s
( ) s
( ) s
( void cgRelExpr\(destReg,op,type\)) s
(   int destReg;) s
(   int op;) s
(   enum symType type;) s
(   {char *typeExt,*opStr;) s
(    labelType label;) s
( ) s
(    if \(doCodeGen == FALSE\) return;) s
(    switch\(type\)) s
(      {case INTT:    typeExt = "i";  break;) s
(       case FLOATT:  typeExt = "f";  break;) s
(      }) s
(    switch \(op\)) s
(      {case EQ:  opStr = "=="; break;) s
(       case LEQ: opStr = "<="; break;) s
(       case GEQ: opStr = ">="; break;) s
(       case NEQ: opStr = "!="; break;) s
(       case LT:  opStr = "<"; break;) s
(       case GT:  opStr = ">"; break;) s
(      }) s
(    label = newLabelNum\(\);) s
(    fprintf\(tempOut,"\\tif \(fp[%d].%s %s fp[%d].%s\) goto b%d;\\n",) s
(            RA\(destReg\),typeExt,opStr,) s
(            RA\(destReg + 1\),typeExt,label) s
(           \);) s
(    fprintf\(tempOut,"\\tfp[%d].i = 0;\\n",RA\(destReg\)\);) s
(    fprintf\(tempOut,"\\tgoto B%d;\\n",label\);) s
(    fprintf\(tempOut,"b%d:\\tfp[%d].i = 1;\\n",label,RA\(destReg\)\);) s
(    fprintf\(tempOut,"B%d:\\n",label\);) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 26 26
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 6) s
( ) s
( ) s
( void cgBinLogExpr\(destReg,op\)) s
(   int destReg;) s
(   int op;) s
(   {labelType label;) s
(    char unrOp,rslt1,rslt2;) s
( ) s
(    if \(doCodeGen == FALSE\) return;) s
(    label = newLabelNum\(\);) s
(    switch\(op\)) s
(      {case AND: unrOp = '!'; rslt1 = '1'; rslt2 = '0'; break;) s
(       case OR : unrOp = ' '; rslt1 = '0'; rslt2 = '1'; break;) s
(      }) s
(    fprintf\(tempOut,"\\tif \(%c\(fp[%d].i\)\) goto b%d;\\n",) s
(            unrOp,RA\(destReg\),label) s
(           \);) s
(    fprintf\(tempOut,"\\tif \(%c\(fp[%d].i\)\) goto b%d;\\n",) s
(            unrOp,RA\(destReg + 1\),label) s
(           \);) s
(    fprintf\(tempOut,"\\tfp[%d].i = %c;\\n",RA\(destReg\),rslt1\);) s
(    fprintf\(tempOut,"\\tgoto B%d;\\n",label\);) s
(    fprintf\(tempOut,"b%d:\\tfp[%d].i = %c;\\n",label,RA\(destReg\),rslt2\);) s
(    fprintf\(tempOut,"B%d:\\n",label\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgUnrArithExpr\(destReg,op,type\)) s
(   int destReg;) s
(   int op;) s
(   enum symType type;) s
(   {char *typeExt;) s
( ) s
(    if \(doCodeGen == FALSE\) return;) s
(    if \(op == '+'\) return;) s
(    switch\(type\)) s
(      {case INTT:    typeExt = "i";  break;) s
(       case FLOATT:  typeExt = "f";  break;) s
(      }) s
(    fprintf\(tempOut,"\\tfp[%d].%s = -fp[%d].%s;\\n",) s
(            RA\(destReg\),typeExt,RA\(destReg\),typeExt) s
(           \);) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 7) s
( ) s
( ) s
( void cgLogNegExpr\(regNum\)) s
(   int regNum;) s
(   {labelType label;) s
( ) s
(    if \(doCodeGen == FALSE\) return;) s
(    label = newLabelNum\(\);) s
(    fprintf\(tempOut,"\\tif \(\(fp[%d].i\) == 0\) goto b%d;\\n",) s
(            RA\(regNum\),label) s
(           \);) s
(    fprintf\(tempOut,"\\tfp[%d].i = 0;\\n",RA\(regNum\)\);) s
(    fprintf\(tempOut,"\\tgoto B%d;\\n",label\);) s
(    fprintf\(tempOut,"b%d:\\tfp[%d].i = 1;\\n",label,RA\(regNum\)\);) s
(    fprintf\(tempOut,"B%d:\\n",label\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgEmptyIndexSeq\(env,sym,line,regNum,dimList\)) s
(   struct env *env;) s
(   struct sym *sym;) s
(   lineNumType line;) s
(   int regNum;) s
(   struct dim *dimList;) s
(   {long addr;) s
(    int staticDist,i;) s
(    struct env *dumEnv;) s
( ) s
(    if \(doCodeGen == FALSE\) return;) s
(    if \(sym == lambdaSym\) return;) s
(    staticDist = env->level - sym->level;) s
(    while \(dimList != lambdaDim\)) s
(       {fprintf\(stderr,) s
(                "missing index for line %d\\'s reference to array %s.\\n",) s
(                line,sym->id) s
(               \);) s
(        dimList = dimList->next;) s
(        handleSemError\(\);) s
(       }) s
(    fprintf\(tempOut,"\\tfp[%d].up = fp;\\n",RA\(regNum\)\);) s
(    dumEnv = env;) s
(    for \(i=0; i<staticDist; i++\)) s
(        {dumEnv = dumEnv->outerEnv;) s
(         fprintf\(tempOut,"\\tfp[%d] = *\(fp[%d].up\);\\n",RA\(regNum\),RA\(regNum\)\);) s
(        }) s
(    addr = \(sym->class == VARIABLEC\)?\(VA\(sym->addr\)\):\(PA\(sym->addr\)\);) s
(    fprintf\(tempOut,"\\tfp[%d].up += %d;\\n",RA\(regNum\),addr\);) s
(    if \(sym->class == REFPARAMC\)) s
(       fprintf\(tempOut,"\\tfp[%d] = *\(fp[%d].up\);\\n",) s
(                       RA\(regNum\),RA\(regNum\)) s
(              \);) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 27 27
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 8) s
( ) s
( ) s
( void cgIndexSeq\(sym,regNum,dimList\)) s
(   struct sym *sym;) s
(   int regNum;) s
(   struct dim *dimList;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    if \(sym == lambdaSym\) return;) s
(    fprintf\(tempOut,"\\tif \(fp[%d].i < 0\) goto IOBtrap;\\n",) s
(            RA\(regNum + 1\)) s
(           \);) s
(    fprintf\(tempOut,"\\tif \(fp[%d].i > %d\) goto IOBtrap;\\n",) s
(            RA\(regNum + 1\),) s
(            dimList->size - 1) s
(           \);) s
(    fprintf\(tempOut,"\\tfp[%d].i *= %d;\\n",RA\(regNum + 1\),dimList->scale\);) s
(    fprintf\(tempOut,"\\tfp[%d].up -= fp[%d].i;\\n",) s
(            RA\(regNum\),RA\(regNum + 1\)) s
(           \);) s
(   }) s
( ) s
( ) s
( ) s
( void cgConstSimpleExpr\(regNum,type,value\)) s
(   int regNum;) s
(   enum symType type;) s
(   union num value;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    switch\(type\)) s
(      {case INTT:) s
(         fprintf\(tempOut,"\\tfp[%d].i = %d;\\n",RA\(regNum\),value.i\);) s
(         break;) s
(       case FLOATT:) s
(         fprintf\(tempOut,"\\tfp[%d].f = %f;\\n",RA\(regNum\),value.f\);) s
(         break;) s
(       case BOOLT:) s
(         fprintf\(tempOut,"\\tfp[%d].b = %d;\\n",RA\(regNum\),value.b\);) s
(         break;) s
(      }) s
(   }) s
( ) s
( ) s
( ) s
( void cgEOF\(regNum\)) s
(   int regNum;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"\\tfp[%d].i = EOF;\\n",RA\(regNum\)\);) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 9) s
( ) s
( ) s
( void cgAssign\(regNum,type\)) s
(   int regNum;) s
(   enum symType type;) s
(   {char *typeExt;) s
( ) s
(    if \(doCodeGen == FALSE\) return;) s
(    switch\(type\)) s
(      {case INTT:    typeExt = "i";  break;) s
(       case FLOATT:  typeExt = "f";  break;) s
(       case BOOLT:   typeExt = "b";  break;) s
(      }) s
(    fprintf\(tempOut,"\\t*\(fp[%d].%sp\) = fp[%d].%s;\\n",) s
(            RA\(regNum\),typeExt,RA\(regNum + 1\),typeExt) s
(           \);) s
(    fprintf\(tempOut,"\\tfp[%d].%s = fp[%d].%s;\\n",) s
(            RA\(regNum\),typeExt,RA\(regNum + 1\),typeExt) s
(           \);) s
(   }) s
( ) s
( ) s
( ) s
( void cgPush\(regNum\)) s
(   int regNum;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"\\t*--sp = fp[%d];\\n",RA\(regNum\)\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgCondDeref\(formal,regNum,type\)) s
(   struct sym *formal;) s
(   int regNum;) s
(   enum symType type;) s
(   {char *typeExt;) s
( ) s
(    if \(doCodeGen == FALSE\) return;) s
(    if \(\(formal != lambdaSym\) && \(formal->class == REFPARAMC\)\) return;) s
(    switch\(type\)) s
(      {case INTT:    typeExt = "i";  break;) s
(       case FLOATT:  typeExt = "f";  break;) s
(       case BOOLT:   typeExt = "b";  break;) s
(      }) s
(    fprintf\(tempOut,"\\tfp[%d].%s = *\(fp[%d].%sp\);\\n",) s
(            RA\(regNum\),typeExt,) s
(            RA\(regNum\),typeExt) s
(           \);) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 28 28
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 10) s
( ) s
( ) s
( void cgCast\(regNum,newType,oldType\)) s
(   int regNum;) s
(   enum symType newType,oldType;) s
(   {char *ext1,*ext2,*cCast;) s
( ) s
(    if \(doCodeGen == FALSE\) return;) s
(    switch\(newType\)) s
(      {case INTT:    ext1 = "i"; cCast = "\(int\)"; break;) s
(       case FLOATT:  ext1 = "f"; cCast = "\(float\)"; break;) s
(       case BOOLT:   ext1 = "b"; cCast = "\(int\)"; break;) s
(      }) s
(    switch\(oldType\)) s
(      {case INTT:    ext2 = "i";  break;) s
(       case FLOATT:  ext2 = "f";  break;) s
(       case BOOLT:   ext2 = "b";  break;) s
(      }) s
(    fprintf\(tempOut,"\\tfp[%d].%s = %sfp[%d].%s;\\n",) s
(            RA\(regNum\),ext1,cCast,RA\(regNum\),ext2) s
(           \);) s
(   }) s
( ) s
( ) s
( ) s
( void cgOutputNoArg\(str,regNum\)) s
(   char *str;) s
(   regNumType regNum;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"\\tfp[%d].i = printf\(%s\);\\n",RA\(regNum\),str\);) s
(     /*  fprintf\(tempOut,"\\tfflush\(stdout\);\\n"\); */) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 11) s
( ) s
( ) s
( void cgOutputOneArg\(str,regNum,type\)) s
(   char *str;) s
(   int regNum;) s
(   enum symType type;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    switch\(type\)) s
(      {case INTT:) s
(         fprintf\(tempOut,"\\tfp[%d].i = printf\(%s,fp[%d].i\);\\n",) s
(                 RA\(regNum\),str,RA\(regNum\)\);) s
(         break;) s
(       case FLOATT:) s
(         fprintf\(tempOut,) s
(                 "\\tfp[%d].i = printf\(%s,fp[%d].f\);\\n",) s
(                 RA\(regNum\),str,RA\(regNum\)) s
(                \);) s
(         break;) s
(       case BOOLT:) s
(         fprintf\(tempOut,) s
(           "\\tfp[%d].i = printf\(%s,\(*\(fp[%d].b\)?\\"true\\":\\"false\\"\)\);\\n",) s
(                 RA\(regNum\),str,RA\(regNum\)) s
(                \);) s
(         break;) s
(      }) s
(    /*  fprintf\(tempOut,"\\tfflush\(stdout\);\\n"\); */) s
(   }) s
( ) s
( ) s
( ) s
( void cgInput\(str,regNum,type,line\)) s
(   char *str;) s
(   int regNum;) s
(   enum symType type;) s
(   lineNumType line;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"\\tfp[%d].i = ",RA\(regNum\)\);) s
(    switch\(type\)) s
(      {case INTT:) s
(         fprintf\(tempOut,"scanf\(%s,fp[%d].ip\);\\n",) s
(                 str,RA\(regNum\)\);) s
(         break;) s
(       case FLOATT:) s
(         fprintf\(tempOut,"scanf\(%s,fp[%d].fp\);\\n",) s
(                 str,RA\(regNum\)\);) s
(         break;) s
(       case BOOLT:) s
(         fprintf\(stderr,"attempted input of boolean near line %d.\\n",line\);) s
(         handleSemError\(\);) s
(         break;) s
(      }) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 29 29
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 12) s
( ) s
( ) s
( static void condCheck\(type,line\)) s
(   enum symType type;) s
(   lineNumType line;) s
(   {if \(type != BOOLT\)) s
(       {fprintf\(stderr,) s
(    "non-boolean expression as condition in control statement near line %d.\\n",) s
(                line) s
(               \);) s
(        handleSemError\(\);) s
(       }) s
(   }) s
( ) s
( ) s
( ) s
( void cgIfThen\(type,line,label\)) s
(   enum symType type;) s
(   lineNumType line;) s
(   labelType label;) s
(   {condCheck\(type,line\);) s
(    if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"e%d:\\n",label\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgIfThenElse\(type,line,label\)) s
(   enum symType type;) s
(   lineNumType line;) s
(   labelType label;) s
(   {condCheck\(type,line\);) s
(    if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"i%d:\\n",label\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgThen\(regNum,label\)) s
(   int regNum;) s
(   labelType label;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"\\tif \(!\(fp[%d].i\)\) goto e%d;\\n",RA\(regNum\),label\);) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 13) s
( ) s
( ) s
( void cgElse\(label\)) s
(   labelType label;) s
(   {if \(doCodeGen == FALSE\) return;) s
(         fprintf\(tempOut,"kl%d:\\tgoto i%d;\\n",label,label\);) s
(         fprintf\(tempOut,"e%d:\\n",label\);) s
(    /* labels prefixed by kl are kludges to silence the C compiler's) s
(     *   "statement not reached" warnings when the then clause ends) s
(     *   with a return statement.) s
(     */) s
(   }) s
( ) s
( ) s
( ) s
( void cgWdecision\(regNum,label\)) s
(   int regNum;) s
(   labelType label;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"\\tif \(!\(fp[%d].i\)\) goto W%d;\\n",RA\(regNum\),label\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgWhileStatement\(type,line,label\)) s
(   enum symType type;) s
(   lineNumType line;) s
(   labelType label;) s
(   {condCheck\(type,line\);) s
(    if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"\\tgoto w%d;\\n",label\);) s
(    fprintf\(tempOut,"W%d:\\n",label\);) s
(   }) s
( ) s
( ) s
( ) s
( void cgWhile\(label\)) s
(   labelType label;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    fprintf\(tempOut,"w%d:\\n",label\);) s
(   }) s
( ) s
( ) s
( ) s
endpage
%%Page: 30 30
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 14) s
( ) s
( ) s
( void cgReturnStmt\(env,regNum,type,line\)) s
(   struct env *env;) s
(   regNumType regNum;) s
(   enum symType type;) s
(   lineNumType line;) s
( ) s
(   {if \(doCodeGen == FALSE\) goto err;) s
(    if \(type != VOIDT\)) s
(       fprintf\(tempOut,"\\tfp[%d] = fp[%d];\\n",RETREGADDR1,RA\(regNum\)\);) s
(    while \(env->funcSym == lambdaSym\)) s
(      {fprintf\(tempOut,"\\tsp = fp;\\n"\);) s
(       fprintf\(tempOut,"\\tfp = \(*fp\).up;\\n"\);) s
(       if \(type != VOIDT\)) s
(          fprintf\(tempOut,"\\tfp[%d] = sp[%d];\\n",RETREGADDR1,RETREGADDR1\);) s
(       if \(\(env = env->outerEnv\) == lambdaEnv\)) s
(          {fprintf\(stderr,"line %d: return from no function.\\n",line\);) s
(           goto err;) s
(          }) s
(      }) s
(    if \(env->funcSym->type != VOIDT\)) s
(       {if \(type == VOIDT\)) s
(           {fprintf\(stderr,) s
(            "line %d: missing object of return in non-void function %s.\\n",) s
(                    line,env->funcSym->id) s
(                   \);) s
(            goto err;) s
(           }) s
(        if \(env->funcSym->type != type\)) s
(           {fprintf\(stderr,) s
(            "line %d: mismatched type of object returned from function %s.\\n",) s
(                   line,env->funcSym->id) s
(                  \);) s
(            goto err;) s
(           }) s
(       }) s
(       else) s
(       {if \(type != VOIDT\)) s
(           {fprintf\(stderr,"line %d: object returned by void function %s.\\n",) s
(                    line,env->funcSym->id) s
(                   \);) s
(            goto err;) s
(           }) s
(       }) s
(    fprintf\(tempOut,"\\tgoto BE%d;\\n",env->exitLabel\);) s
(    return;) s
( err:) s
(    handleSemError\(\);) s
(    return;) s
(   }) s
( ) s
( ) s
( ) s
endpage
startpage
( ) s
( ) s
( Dec 14 11:32 1992  code.c Page 15) s
( ) s
( ) s
( void cgExitStmt\(regNum,type,line\)) s
(   regNumType regNum;) s
(   enum symType type;) s
(   lineNumType line;) s
(   {if \(doCodeGen == FALSE\) return;) s
(    if \(type != INTT\)) s
(       {fprintf\(stderr,"line %d: non-integer object of exit statement.\\n",) s
(                line) s
(               \);) s
(        handleSemError\(\);) s
(        return;) s
(       }) s
(    fprintf\(tempOut,"\\texit\(fp[%d].i\);\\n",RA\(regNum\)\);) s
(   }) s
( ) s
( ) s
( ) s
endpage

%%Trailer
cleanup
docsave restore end
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gppl.ps`; if test $1 -ne 564
then
	echo ERROR: oxDistG1.04/gppl/gppl.ps checksum is $1 should be 564
fi
set `wc -lwc <oxDistG1.04/gppl/gppl.ps`
if test $1$2$3 != 723926864357136
then
	echo ERROR: wc results of oxDistG1.04/gppl/gppl.ps are $* should be 7239 26864 357136
fi

chmod 755 oxDistG1.04/gppl/gppl.ps

if test -f oxDistG1.04/gppl/y.tab.h.bak
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/y.tab.h.bak\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/y.tab.h.bak
	if test -f oxDistG1.04/gppl/y.tab.h.bak
	then
		echo Error: could not remove oxDistG1.04/gppl/y.tab.h.bak, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/y.tab.h.bak
>oxDistG1.04/gppl/y.tab.h.bak
set `sum $sumopt <oxDistG1.04/gppl/y.tab.h.bak`; if test $1 -ne 0
then
	echo ERROR: oxDistG1.04/gppl/y.tab.h.bak checksum is $1 should be 0
fi
set `wc -lwc <oxDistG1.04/gppl/y.tab.h.bak`
if test $1$2$3 != 000
then
	echo ERROR: wc results of oxDistG1.04/gppl/y.tab.h.bak are $* should be 0 0 0
fi

chmod 755 oxDistG1.04/gppl/y.tab.h.bak

echo mkdir - oxDistG1.04/gppl/gct
mkdir oxDistG1.04/gppl/gct

echo mkdir - oxDistG1.04/gppl/gct/semErrEGs
mkdir oxDistG1.04/gppl/gct/semErrEGs

if test -f oxDistG1.04/gppl/gct/semErrEGs/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t1
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t1
cat >oxDistG1.04/gppl/gct/semErrEGs/t1 <<'@EOF'
              {int a[0];  
               float r,s[-5 * -4 * -1];
              }
/*
nonpositive dimension in array declaration near line 1.
nonpositive dimension in array declaration near line 2.
 */

@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t1`; if test $1 -ne 42414
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t1 checksum is $1 should be 42414
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t1`
if test $1$2$3 != 827203
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t1 are $* should be 8 27 203
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t1

if test -f oxDistG1.04/gppl/gct/semErrEGs/t2
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t2
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t2
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t2
cat >oxDistG1.04/gppl/gct/semErrEGs/t2 <<'@EOF'
              {void a[10];  
              }
/*
line 1: declared storage of type void for a.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t2`; if test $1 -ne 61371
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t2 checksum is $1 should be 61371
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t2`
if test $1$2$3 != 51497
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t2 are $* should be 5 14 97
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t2

if test -f oxDistG1.04/gppl/gct/semErrEGs/t3
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t3
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t3
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t3
cat >oxDistG1.04/gppl/gct/semErrEGs/t3 <<'@EOF'
              {int in;  
               void in(var float r;) { input("%f\n",r); }
              }
/*
symbol in multiply defined: lines 1 and 2.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t3`; if test $1 -ne 45390
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t3 checksum is $1 should be 45390
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t3`
if test $1$2$3 != 620149
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t3 are $* should be 6 20 149
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t3

if test -f oxDistG1.04/gppl/gct/semErrEGs/t4
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t4\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t4
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t4
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t4, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t4
cat >oxDistG1.04/gppl/gct/semErrEGs/t4 <<'@EOF'
              {bool greater; int i; float r,s;
               i = 1; 
               r = 2.0; 
               greater = (i > r); 
              }
/*
binary operator type mismatch at line 4.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t4`; if test $1 -ne 36744
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t4 checksum is $1 should be 36744
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t4`
if test $1$2$3 != 827194
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t4 are $* should be 8 27 194
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t4

if test -f oxDistG1.04/gppl/gct/semErrEGs/t5
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t5\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t5
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t5
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t5, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t5
cat >oxDistG1.04/gppl/gct/semErrEGs/t5 <<'@EOF'
              {int i; bool p;
               p = !i; 
              }
/*
unary operator type mismatch at line 2.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t5`; if test $1 -ne 28347
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t5 checksum is $1 should be 28347
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t5`
if test $1$2$3 != 617117
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t5 are $* should be 6 17 117
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t5

if test -f oxDistG1.04/gppl/gct/semErrEGs/t6
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t6\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t6
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t6
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t6, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t6
cat >oxDistG1.04/gppl/gct/semErrEGs/t6 <<'@EOF'
              {int i; bool p;
               p = i; 
              }
/*
type mismatch in assignment at line 2.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t6`; if test $1 -ne 57713
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t6 checksum is $1 should be 57713
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t6`
if test $1$2$3 != 617115
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t6 are $* should be 6 17 115
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t6

if test -f oxDistG1.04/gppl/gct/semErrEGs/t7
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t7\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t7
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t7
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t7, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t7
cat >oxDistG1.04/gppl/gct/semErrEGs/t7 <<'@EOF'
              {int i[5][5];  
               output("%d\n",i[3][4][1]); 
              }
/*
extra index in line 2's reference to i.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t7`; if test $1 -ne 9556
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t7 checksum is $1 should be 9556
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t7`
if test $1$2$3 != 614136
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t7 are $* should be 6 14 136
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t7

if test -f oxDistG1.04/gppl/gct/semErrEGs/t8
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t8\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t8
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t8
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t8, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t8
cat >oxDistG1.04/gppl/gct/semErrEGs/t8 <<'@EOF'
              {int i[5][5];  
               output("%d\n",i[3]); 
              }
/*
missing index for line 2's reference to array i.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t8`; if test $1 -ne 61019
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t8 checksum is $1 should be 61019
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t8`
if test $1$2$3 != 615139
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t8 are $* should be 6 15 139
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t8

if test -f oxDistG1.04/gppl/gct/semErrEGs/t9
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t9\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t9
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t9
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t9, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t9
cat >oxDistG1.04/gppl/gct/semErrEGs/t9 <<'@EOF'
              {int j;
               j = 5; 
               square(j+1); 
               void square(var int i;){i = i * i;}  
              }
/* 
actual parameter in call to square near line 3 is not a reference,
   but matched to formal reference parameter i.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t9`; if test $1 -ne 27783
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t9 checksum is $1 should be 27783
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t9`
if test $1$2$3 != 937266
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t9 are $* should be 9 37 266
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t9

if test -f oxDistG1.04/gppl/gct/semErrEGs/t10
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t10\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t10
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t10
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t10, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t10
cat >oxDistG1.04/gppl/gct/semErrEGs/t10 <<'@EOF'
               {void qsort(int a[1000];int left,right;){  } 
               }
/* 
array a declared as value parameter at line 1.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t10`; if test $1 -ne 25665
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t10 checksum is $1 should be 25665
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t10`
if test $1$2$3 != 517133
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t10 are $* should be 5 17 133
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t10

if test -f oxDistG1.04/gppl/gct/semErrEGs/t12
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t12\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t12
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t12
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t12, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t12
cat >oxDistG1.04/gppl/gct/semErrEGs/t12 <<'@EOF'
              {bool p;
               input("%d\n",p); 
              }
/*
attempted input of boolean near line 2.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t12`; if test $1 -ne 43659
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t12 checksum is $1 should be 43659
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t12`
if test $1$2$3 != 613119
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t12 are $* should be 6 13 119
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t12

if test -f oxDistG1.04/gppl/gct/semErrEGs/t13
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t13\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t13
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t13
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t13, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t13
cat >oxDistG1.04/gppl/gct/semErrEGs/t13 <<'@EOF'
              {int i;
               i = 100; 
               while (i) {output("%d\n",i); i = i - 1;}
              }
/*
non-boolean expression as condition in control statement near line 3.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t13`; if test $1 -ne 54111
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t13 checksum is $1 should be 54111
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t13`
if test $1$2$3 != 726196
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t13 are $* should be 7 26 196
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t13

if test -f oxDistG1.04/gppl/gct/semErrEGs/t14
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t14\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t14
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t14
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t14, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t14
cat >oxDistG1.04/gppl/gct/semErrEGs/t14 <<'@EOF'
              {return; 
              }
/*
line 1: return from no function.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t14`; if test $1 -ne 47925
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t14 checksum is $1 should be 47925
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t14`
if test $1$2$3 != 51080
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t14 are $* should be 5 10 80
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t14

if test -f oxDistG1.04/gppl/gct/semErrEGs/t15
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t15\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t15
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t15
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t15, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t15
cat >oxDistG1.04/gppl/gct/semErrEGs/t15 <<'@EOF'
              {int fun(){return;}
              }
/*
line 1: missing object of return in non-void function fun.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t15`; if test $1 -ne 14118
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t15 checksum is $1 should be 14118
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t15`
if test $1$2$3 != 515116
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t15 are $* should be 5 15 116
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t15

if test -f oxDistG1.04/gppl/gct/semErrEGs/t16
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t16\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t16
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t16
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t16, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t16
cat >oxDistG1.04/gppl/gct/semErrEGs/t16 <<'@EOF'
              {int fun() {return 1.0;}
              }
/*
line 1: mismatched type of object returned from function fun.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t16`; if test $1 -ne 54831
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t16 checksum is $1 should be 54831
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t16`
if test $1$2$3 != 517124
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t16 are $* should be 5 17 124
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t16

if test -f oxDistG1.04/gppl/gct/semErrEGs/t17
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t17\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t17
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t17
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t17, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t17
cat >oxDistG1.04/gppl/gct/semErrEGs/t17 <<'@EOF'
              {void fun() {return 1.0;}
              }
/*
line 1: object returned by void function fun.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t17`; if test $1 -ne 42758
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t17 checksum is $1 should be 42758
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t17`
if test $1$2$3 != 515109
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t17 are $* should be 5 15 109
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t17

if test -f oxDistG1.04/gppl/gct/semErrEGs/t18
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t18\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t18
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t18
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t18, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t18
cat >oxDistG1.04/gppl/gct/semErrEGs/t18 <<'@EOF'
              {bool condCheck() { ... } 
               exit condCheck(); 
              } 
/*
line 1: illegal character
line 1: illegal character
line 1: illegal character
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t18`; if test $1 -ne 32205
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t18 checksum is $1 should be 32205
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t18`
if test $1$2$3 != 822177
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t18 are $* should be 8 22 177
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t18

if test -f oxDistG1.04/gppl/gct/semErrEGs/t19
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t19\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t19
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t19
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t19, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t19
cat >oxDistG1.04/gppl/gct/semErrEGs/t19 <<'@EOF'
               {void qsort(int a[1000];int left,right;){ ... }  
               }
/*
line 1: illegal character
line 1: illegal character
line 1: illegal character
array a declared as value parameter at line 1.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t19`; if test $1 -ne 58615
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t19 checksum is $1 should be 58615
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t19`
if test $1$2$3 != 830214
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t19 are $* should be 8 30 214
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t19

if test -f oxDistG1.04/gppl/gct/semErrEGs/t20
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t20\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t20
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t20
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t20, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t20
cat >oxDistG1.04/gppl/gct/semErrEGs/t20 <<'@EOF'
{
 fun(4,x);
}
/*
undeclared function identifier fun at line 2.
undeclared storage identifier x at line 2.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t20`; if test $1 -ne 37033
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t20 checksum is $1 should be 37033
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t20`
if test $1$2$3 != 719111
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t20 are $* should be 7 19 111
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t20

if test -f oxDistG1.04/gppl/gct/semErrEGs/t21
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t21\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t21
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t21
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t21, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t21
cat >oxDistG1.04/gppl/gct/semErrEGs/t21 <<'@EOF'
              {bool condCheck() { } 
               exit condCheck(); 
              } 
/*
line 2: non-integer object of exit statement.
 */
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t21`; if test $1 -ne 9844
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t21 checksum is $1 should be 9844
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t21`
if test $1$2$3 != 616141
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t21 are $* should be 6 16 141
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t21

if test -f oxDistG1.04/gppl/gct/semErrEGs/t24
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/semErrEGs/t24\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/semErrEGs/t24
	if test -f oxDistG1.04/gppl/gct/semErrEGs/t24
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/semErrEGs/t24, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/semErrEGs/t24
cat >oxDistG1.04/gppl/gct/semErrEGs/t24 <<'@EOF'
              
{
              {int a[0];  
               float r,s[-5 * -4 * -1];
              }

               {void qsort(int a[1000];int left,right;){  } 
               }

              {bool p;
               input("%d\n",p); 
              }

              {int i;
               i = 100; 
               while (i) {output("%d\n",i); i = i - 1;}
              }

              {return; 
              }

              {int fun(){return;}
              }

              {int fun() {return 1.0;}
              }

              {void fun() {return 1.0;}
              }

              {bool condCheck() { ... } 
               exit condCheck(); 
              } 

               {void qsort(int a[1000];int left,right;){ ... }  
               }

              {void a[10];  
              }

              {bool condCheck() { } 
               exit condCheck(); 
              } 

              {int in;  
               void in(var float r;) { input("%f\n",r); }
              }

              {bool greater; int i; float r,s;
               i = 1; 
               r = 2.0; 
               greater = (i > r); 
              }

              {int i; bool p;
               p = !i; 
              }

              {int i; bool p;
               p = i; 
              }

              {int i[5][5];  
               output("%d\n",i[3][4][1]); 
              }

              {int i[5][5];  
               output("%d\n",i[3]); 
              }

              {int j;
               j = 5; 
               square(j+1); 
               void square(var int i;){i = i * i;}  
              }

{
 fun(4,x);
}

}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/semErrEGs/t24`; if test $1 -ne 65425
then
	echo ERROR: oxDistG1.04/gppl/gct/semErrEGs/t24 checksum is $1 should be 65425
fi
set `wc -lwc <oxDistG1.04/gppl/gct/semErrEGs/t24`
if test $1$2$3 != 811451613
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/semErrEGs/t24 are $* should be 81 145 1613
fi

chmod 755 oxDistG1.04/gppl/gct/semErrEGs/t24

chmod 755 oxDistG1.04/gppl/gct/semErrEGs

if test -f oxDistG1.04/gppl/gct/README
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/README
	if test -f oxDistG1.04/gppl/gct/README
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/README
cat >oxDistG1.04/gppl/gct/README <<'@EOF'
This directory has some GPPL demonstration programs, each in its
own directory.  Each directory except `semErrEGs' has its own
Makefile and a subdirectory `gct' which contains test inputs.
Typing `make` in one of the following directories produces a
program `gc' that reads from standard input and writes to
standard output.

     * fact: recursive factorial function.

     * fib:  recursive Fibonacci function.

     * hs:  heapsort

     * math:  some math routines such as square root and
     exponentiation.

     * mod:  modulo function.

     * primes:  prime number generator.

     * prmfact:  function to compute prime factorizations of
     integers.

     * qsort:  quicksort.

     * selSort:  selection sort.

     * 711sol2:  Solves the problem of finding four numbers a, b,
     c, d such that:

           a <= b <= c <= d
           a * b * c * d = 7.11
           a + b + c + d = 7.11

The directory `semErrEGs' contains programs that violate GPPL
semantics.
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/README`; if test $1 -ne 17922
then
	echo ERROR: oxDistG1.04/gppl/gct/README checksum is $1 should be 17922
fi
set `wc -lwc <oxDistG1.04/gppl/gct/README`
if test $1$2$3 != 36148979
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/README are $* should be 36 148 979
fi

chmod 755 oxDistG1.04/gppl/gct/README

echo mkdir - oxDistG1.04/gppl/gct/fact
mkdir oxDistG1.04/gppl/gct/fact

if test -f oxDistG1.04/gppl/gct/fact/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/fact/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/fact/Makefile
	if test -f oxDistG1.04/gppl/gct/fact/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/fact/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/fact/Makefile
cat >oxDistG1.04/gppl/gct/fact/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/fact/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/fact/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/fact/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/fact/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/fact/Makefile

if test -f oxDistG1.04/gppl/gct/fact/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/fact/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/fact/gc.g
	if test -f oxDistG1.04/gppl/gct/fact/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/fact/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/fact/gc.g
cat >oxDistG1.04/gppl/gct/fact/gc.g <<'@EOF'
/* GPPL program for factorial function */

/* stores in an array the factorials of the first ten integers,
     then prints them.
 */

{
int i,f[10]; 

i = 0; 
while (i<10) 
  {f[i] = fact(i); 
   i = i + 1; 
  }


int fact(int i;)
  {if (i == 0) 
      then return 1; 
      else return i*fact(i-1);
  }


i = 0; 
while (i<10) 
  {output("%d  ",i); 
   output("%d\n",f[i]); 
   i = i + 1; 
  }


}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/fact/gc.g`; if test $1 -ne 8743
then
	echo ERROR: oxDistG1.04/gppl/gct/fact/gc.g checksum is $1 should be 8743
fi
set `wc -lwc <oxDistG1.04/gppl/gct/fact/gc.g`
if test $1$2$3 != 3269399
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/fact/gc.g are $* should be 32 69 399
fi

chmod 755 oxDistG1.04/gppl/gct/fact/gc.g

echo mkdir - oxDistG1.04/gppl/gct/fact/gct
mkdir oxDistG1.04/gppl/gct/fact/gct

if test -f oxDistG1.04/gppl/gct/fact/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/fact/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/fact/gct/t1
	if test -f oxDistG1.04/gppl/gct/fact/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/fact/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/fact/gct/t1
>oxDistG1.04/gppl/gct/fact/gct/t1
set `sum $sumopt <oxDistG1.04/gppl/gct/fact/gct/t1`; if test $1 -ne 0
then
	echo ERROR: oxDistG1.04/gppl/gct/fact/gct/t1 checksum is $1 should be 0
fi
set `wc -lwc <oxDistG1.04/gppl/gct/fact/gct/t1`
if test $1$2$3 != 000
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/fact/gct/t1 are $* should be 0 0 0
fi

chmod 755 oxDistG1.04/gppl/gct/fact/gct/t1

chmod 755 oxDistG1.04/gppl/gct/fact/gct

chmod 755 oxDistG1.04/gppl/gct/fact

echo mkdir - oxDistG1.04/gppl/gct/fib
mkdir oxDistG1.04/gppl/gct/fib

if test -f oxDistG1.04/gppl/gct/fib/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/fib/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/fib/Makefile
	if test -f oxDistG1.04/gppl/gct/fib/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/fib/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/fib/Makefile
cat >oxDistG1.04/gppl/gct/fib/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/fib/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/fib/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/fib/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/fib/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/fib/Makefile

if test -f oxDistG1.04/gppl/gct/fib/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/fib/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/fib/gc.g
	if test -f oxDistG1.04/gppl/gct/fib/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/fib/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/fib/gc.g
cat >oxDistG1.04/gppl/gct/fib/gc.g <<'@EOF'
/* GPPL program for Fibonacci function */

{
int i;

i = 0; 
while (i<24) 
  {output("%d  ",i); 
   output("%d\n",fib(i)); 
   i = i + 1; 
  }


int fib(int i;)
  {if (i == 0) 
      then return 0;
   if (i == 1) 
      then return 1; 
   return (fib(i-2) + fib(i-1));
  }
}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/fib/gc.g`; if test $1 -ne 42203
then
	echo ERROR: oxDistG1.04/gppl/gct/fib/gc.g checksum is $1 should be 42203
fi
set `wc -lwc <oxDistG1.04/gppl/gct/fib/gc.g`
if test $1$2$3 != 2147275
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/fib/gc.g are $* should be 21 47 275
fi

chmod 755 oxDistG1.04/gppl/gct/fib/gc.g

echo mkdir - oxDistG1.04/gppl/gct/fib/gct
mkdir oxDistG1.04/gppl/gct/fib/gct

if test -f oxDistG1.04/gppl/gct/fib/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/fib/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/fib/gct/t1
	if test -f oxDistG1.04/gppl/gct/fib/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/fib/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/fib/gct/t1
>oxDistG1.04/gppl/gct/fib/gct/t1
set `sum $sumopt <oxDistG1.04/gppl/gct/fib/gct/t1`; if test $1 -ne 0
then
	echo ERROR: oxDistG1.04/gppl/gct/fib/gct/t1 checksum is $1 should be 0
fi
set `wc -lwc <oxDistG1.04/gppl/gct/fib/gct/t1`
if test $1$2$3 != 000
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/fib/gct/t1 are $* should be 0 0 0
fi

chmod 755 oxDistG1.04/gppl/gct/fib/gct/t1

chmod 755 oxDistG1.04/gppl/gct/fib/gct

chmod 755 oxDistG1.04/gppl/gct/fib

echo mkdir - oxDistG1.04/gppl/gct/hs
mkdir oxDistG1.04/gppl/gct/hs

if test -f oxDistG1.04/gppl/gct/hs/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/hs/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/hs/Makefile
	if test -f oxDistG1.04/gppl/gct/hs/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/hs/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/hs/Makefile
cat >oxDistG1.04/gppl/gct/hs/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/hs/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/hs/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/hs/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/hs/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/hs/Makefile

if test -f oxDistG1.04/gppl/gct/hs/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/hs/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/hs/gc.g
	if test -f oxDistG1.04/gppl/gct/hs/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/hs/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/hs/gc.g
cat >oxDistG1.04/gppl/gct/hs/gc.g <<'@EOF'
{ 
int arr[10000];
int size;
int k;

size = 1000;
k = 8;   
genData(arr,size);
printData(arr,size); 
sort(arr,size,k);
printData(arr,size); 


void genData(var int a[10000]; int size;)
  {int i;
   a[0] = 29;  
   i = 1;
   while (i < size) 
     {a[i] = mod((i*i + a[i-1]),size);
      i = i + 1;
     } 

   int mod (int i,m;) 
     {int dum;  
      return i-((i/m)*m);
     } 
  } 



void sort(var int arr[10000]; int size,k;)
  {int i;
   int heapArr[10000 + 1]; 
   int heapK;
   int heapLast;

   MakeNull();
   i=0; while (i < size) {insert(arr[i]); i = i + 1; }
   i=0; while (i < size) {arr[i]=DeleteMin(); i = i + 1; }

   void MakeNull()
     {heapLast=0;
      heapK=k;
     }

   void insert(int value;)
     {int node;
      heapLast=heapLast+1;
      node=heapLast;
      heapArr[node]=value;
      adjusti(node);

      void adjusti(int node;)
        {bool done;
         int parent;
         int temp;

         done=FALSE;
         while (!done) 
           {parent = ((node + heapK - 2) / heapK); 
            if (parent != 0) then
               {if (heapArr[parent] > heapArr[node]) then
                   {temp = heapArr[parent];
                    heapArr[parent] = heapArr[node];
                    heapArr[node] = temp;
                    node = parent;
                   } 
                else done = TRUE;
               } 
               else done = TRUE;
           } 
         } 
     }

   int DeleteMin()
     {int min;
      if (heapLast != 0) then
        {min=heapArr[1];
         heapArr[1] = heapArr[heapLast];
         heapLast = heapLast-1;
         adjustd(1);
        } 
        else output("error--attempted deletion from empty heap\n");
      return min;

      void adjustd(int node;)
         {int iMinChild; 
          int TempForSwap;

          iMinChild=IndMinChild(node);
          if ! (((heapK * (node - 1)) + 2) > heapLast) then
             if (heapArr[node] > heapArr[iMinChild]) then
                {TempForSwap = heapArr[node];
                 heapArr[node] = heapArr[iMinChild];
                 heapArr[iMinChild] = TempForSwap;
                 adjustd(iMinChild);
                } 

          int IndMinChild(int root;)
            {int j,leastyet,shLast; 

             j = (heapK * (root - 1)) + 2;
             leastyet = j;
             shLast = (heapK * root) + 1;
             if (heapLast < shLast) then shLast = heapLast;
             j = j + 1;
             while (j <= shLast) 
               {if (heapArr[leastyet] > heapArr[j]) then leastyet = j;
                j = j + 1;
               }
             return leastyet;
            } /* IndMinChild */
         } /* adjustd */ 
     } /* DeletMin */ 
  } /* sort */ 



void printData(var int a[10000]; int size;)
  {int i;

   i = 0;
   while (i < size) 
     {output("%d   ",i); output("%d\n",a[i]);  
      i = i + 1;
     } 
  } 

}

@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/hs/gc.g`; if test $1 -ne 35883
then
	echo ERROR: oxDistG1.04/gppl/gct/hs/gc.g checksum is $1 should be 35883
fi
set `wc -lwc <oxDistG1.04/gppl/gct/hs/gc.g`
if test $1$2$3 != 1303282874
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/hs/gc.g are $* should be 130 328 2874
fi

chmod 755 oxDistG1.04/gppl/gct/hs/gc.g

echo mkdir - oxDistG1.04/gppl/gct/hs/gct
mkdir oxDistG1.04/gppl/gct/hs/gct

if test -f oxDistG1.04/gppl/gct/hs/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/hs/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/hs/gct/t1
	if test -f oxDistG1.04/gppl/gct/hs/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/hs/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/hs/gct/t1
>oxDistG1.04/gppl/gct/hs/gct/t1
set `sum $sumopt <oxDistG1.04/gppl/gct/hs/gct/t1`; if test $1 -ne 0
then
	echo ERROR: oxDistG1.04/gppl/gct/hs/gct/t1 checksum is $1 should be 0
fi
set `wc -lwc <oxDistG1.04/gppl/gct/hs/gct/t1`
if test $1$2$3 != 000
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/hs/gct/t1 are $* should be 0 0 0
fi

chmod 755 oxDistG1.04/gppl/gct/hs/gct/t1

chmod 755 oxDistG1.04/gppl/gct/hs/gct

chmod 755 oxDistG1.04/gppl/gct/hs

echo mkdir - oxDistG1.04/gppl/gct/math
mkdir oxDistG1.04/gppl/gct/math

if test -f oxDistG1.04/gppl/gct/math/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/math/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/math/Makefile
	if test -f oxDistG1.04/gppl/gct/math/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/math/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/math/Makefile
cat >oxDistG1.04/gppl/gct/math/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/math/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/math/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/math/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/math/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/math/Makefile

if test -f oxDistG1.04/gppl/gct/math/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/math/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/math/gc.g
	if test -f oxDistG1.04/gppl/gct/math/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/math/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/math/gc.g
cat >oxDistG1.04/gppl/gct/math/gc.g <<'@EOF'
{
 int i;
 float temp;
 
 i = 0;
 while (i < 50)
   {
    output("%f  ",float(i));
    output("%e  ",exp(float(i)) );
    temp = sqrt(float(i)); 
    output("%f  ",temp);
    output("%f     ",temp*temp);
    temp = cbrt(float(i));
    output("%f  ",temp);
    output("%f\n",temp*temp*temp);
    i =  i + 1;
   }

  
 float abs(float r;)
   {if (r >= 0.0) then return r; else return -r;
   }


 float dist(float r,s;)
   {return abs(r-s);
   }


/* Kurt's square root program.  
   March 16, 1990. 
   uses Sister Paulina's algorithm.   
   operates in base 10, so probably has some round-off errors not present 
	in a base 2 version.  
   uses a slow sequential search in the for loop--could replace this with a 
	binary search.  
   adapted to gppl December 15, 1991. 
*/  
 float sqrt(float in;)
  {float twiceA,cand,prevCand,sum,prevSum,remainder;  
   float powerOfTen; 
   float out; 
   int i;
 
   if (in < 0.0) then {output("attempted square root of negative\n");exit(-1);}
   if (in < 0.000001) then return 0.0;
   if (in >= 100.0) then return(sqrt(in / 100.0) * 10.0);  
   if (in < 1.0) then return(sqrt(in * 100.0) / 10.0);  
   remainder = in; 
   twiceA = 0.0; 
   powerOfTen = 1.0; 
   out = 0.0; 
   i = 0; 
   while (i < 10) 
       {cand = 0.0; 
	sum = 0.0; 
        while (remainder > sum)  
              {prevSum = sum; 
               prevCand = cand; 
               cand =  cand + powerOfTen; 
	       sum = (twiceA + cand) * cand;  
	      } 
        remainder = remainder - prevSum; 
        powerOfTen = powerOfTen / 10.0; 
        twiceA = twiceA + (2.0 * prevCand); 
        out = out + prevCand; 
        i = i + 1;
       }  
   return(out); 
  } 


     
/* Kurt's cube root program.  
   March 16, 1990. 
   operates in base 10, so probably has some round-off errors not present 
	in a base 2 version.  
   could be modified for increased precision and speed by rewriting for 
	base 2 and using C's bit manipulation instructions.  
*/  
float cbrt(float in;) 
  {float cand,prevCand,sum,prevSum,remainder;  
   float powerOfTen; 
   float out; 
   int i; 

   if ((in > -0.000001) && (in < 0.000001)) then return(0.0); 
   if (in <  0.0) then return(-cbrt(-in)); 
   if (in >= 1000.0) then return(cbrt(in / 1000.0) * 10.0);  
   if (in < 1.0) then return(cbrt(in * 1000.0) / 10.0);  
   remainder = in; 
   powerOfTen = 1.0; 
   out = 0.0; 
   i = 0; 
   while(i < 12)  
       {cand = 0.0; 
	sum = 0.0; 
        while (remainder > sum)  
              {prevSum = sum; 
               prevCand = cand; 
               cand = cand + powerOfTen; 
	       sum =((3.0 * out * cand) * (out + cand)) + (cand * cand * cand);
	      } 
        remainder = remainder - prevSum; 
        powerOfTen = powerOfTen / 10.0; 
        out = out + prevCand; 
        i = i + 1;
       }  
   return(out); 
  } 



 float exp(float in;)
   {float i,fact,out,prod,e;
   
    e = 2.7182818285; 
    out = 1.0;  
    prod = 1.0;
    fact = 1.0; 
    i = 1.0;
    if (in > 1.0) then return (e * exp(in-1.0));
    if (in < 0.0) then return (1.0/exp(in));
    while (prod/fact > 0.000000001)
      {prod = prod * in;
       fact = fact * i;
       out = out + (prod/fact); 
       i = i + 1.0;
      }
    return out;
   }



/* stub: do not use */
 float log(float in;)
   {float i,fact,out,prod,e;
   
    e = 2.7182818285; 
    out = 1.0;  
    prod = 1.0;
    fact = 1.0; 
    i = 1.0;
    if (in > 0.0000000001) then 
       {output("attempted log of small or negative number\n");
        exit(-1);
       }
    if (in > e) then return (1.0 + log(in/e));
    while (prod/fact > 0.000000001)
      {prod = prod * in;
       fact = fact * i;
       out = out + (prod/fact); 
       i = i + 1.0;
      }
    return out;
   }


}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/math/gc.g`; if test $1 -ne 13841
then
	echo ERROR: oxDistG1.04/gppl/gct/math/gc.g checksum is $1 should be 13841
fi
set `wc -lwc <oxDistG1.04/gppl/gct/math/gc.g`
if test $1$2$3 != 1595443740
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/math/gc.g are $* should be 159 544 3740
fi

chmod 755 oxDistG1.04/gppl/gct/math/gc.g

echo mkdir - oxDistG1.04/gppl/gct/math/gct
mkdir oxDistG1.04/gppl/gct/math/gct

if test -f oxDistG1.04/gppl/gct/math/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/math/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/math/gct/t1
	if test -f oxDistG1.04/gppl/gct/math/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/math/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/math/gct/t1
>oxDistG1.04/gppl/gct/math/gct/t1
set `sum $sumopt <oxDistG1.04/gppl/gct/math/gct/t1`; if test $1 -ne 0
then
	echo ERROR: oxDistG1.04/gppl/gct/math/gct/t1 checksum is $1 should be 0
fi
set `wc -lwc <oxDistG1.04/gppl/gct/math/gct/t1`
if test $1$2$3 != 000
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/math/gct/t1 are $* should be 0 0 0
fi

chmod 755 oxDistG1.04/gppl/gct/math/gct/t1

chmod 755 oxDistG1.04/gppl/gct/math/gct

chmod 755 oxDistG1.04/gppl/gct/math

echo mkdir - oxDistG1.04/gppl/gct/mod
mkdir oxDistG1.04/gppl/gct/mod

if test -f oxDistG1.04/gppl/gct/mod/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/mod/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/mod/Makefile
	if test -f oxDistG1.04/gppl/gct/mod/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/mod/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/mod/Makefile
cat >oxDistG1.04/gppl/gct/mod/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/mod/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/mod/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/mod/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/mod/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/mod/Makefile

if test -f oxDistG1.04/gppl/gct/mod/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/mod/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/mod/gc.g
	if test -f oxDistG1.04/gppl/gct/mod/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/mod/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/mod/gc.g
cat >oxDistG1.04/gppl/gct/mod/gc.g <<'@EOF'
{ 
int a[20][20],i,j; 

i = 1;
while (i < 20)
  {j = 0;
   while (j < 20)
     {a[i][j] = mod(j,i);
      j = j + 1;
     }
   i = i + 1;
  }


i = 1;
while (i < 20)
  {j = 0;
   while (j < 20)
     {output("%d mod ",j);
      output("%d == ",i);
      output("%d\n",a[i][j]);
      j = j + 1;
     }
   output("\n");
   i = i + 1;
  }


int mod (int i,m;) 
  {int dum;  
   if (m == 0) then 
      {output("attempted modulo 0 operation\n");
       exit(-1);
      }
   return i-((i/m)*m);
  } 

}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/mod/gc.g`; if test $1 -ne 21369
then
	echo ERROR: oxDistG1.04/gppl/gct/mod/gc.g checksum is $1 should be 21369
fi
set `wc -lwc <oxDistG1.04/gppl/gct/mod/gc.g`
if test $1$2$3 != 3887498
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/mod/gc.g are $* should be 38 87 498
fi

chmod 755 oxDistG1.04/gppl/gct/mod/gc.g

echo mkdir - oxDistG1.04/gppl/gct/mod/gct
mkdir oxDistG1.04/gppl/gct/mod/gct

if test -f oxDistG1.04/gppl/gct/mod/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/mod/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/mod/gct/t1
	if test -f oxDistG1.04/gppl/gct/mod/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/mod/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/mod/gct/t1
>oxDistG1.04/gppl/gct/mod/gct/t1
set `sum $sumopt <oxDistG1.04/gppl/gct/mod/gct/t1`; if test $1 -ne 0
then
	echo ERROR: oxDistG1.04/gppl/gct/mod/gct/t1 checksum is $1 should be 0
fi
set `wc -lwc <oxDistG1.04/gppl/gct/mod/gct/t1`
if test $1$2$3 != 000
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/mod/gct/t1 are $* should be 0 0 0
fi

chmod 755 oxDistG1.04/gppl/gct/mod/gct/t1

chmod 755 oxDistG1.04/gppl/gct/mod/gct

chmod 755 oxDistG1.04/gppl/gct/mod

echo mkdir - oxDistG1.04/gppl/gct/primes
mkdir oxDistG1.04/gppl/gct/primes

if test -f oxDistG1.04/gppl/gct/primes/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/primes/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/primes/Makefile
	if test -f oxDistG1.04/gppl/gct/primes/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/primes/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/primes/Makefile
cat >oxDistG1.04/gppl/gct/primes/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/primes/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/primes/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/primes/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/primes/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/primes/Makefile

if test -f oxDistG1.04/gppl/gct/primes/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/primes/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/primes/gc.g
	if test -f oxDistG1.04/gppl/gct/primes/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/primes/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/primes/gc.g
cat >oxDistG1.04/gppl/gct/primes/gc.g <<'@EOF'
/* GPPL program to find prime numbers */

/* reads a number from standard input, prints all primes less than that number.
 */

{int n;
 bool a[100001];
 
 input("%d",n);  
 if (n >= 100001) then
    {output("\n  too many\n");
     exit(-1);
    }
    else if (n < 0) then
    {output("\n  must be positive\n");
     exit(-1);
    }
 calcPrimes(n,a); 
 printPrimes(n,a); 


 void calcPrimes(int size; var bool a[100001];) 
   {int i;

    a[0] = FALSE; 
    a[1] = FALSE; 
    i = 2; while (i < size) {a[i] = TRUE; i = i + 1;}
   
    i = 2;
    while (i < size)
      {int j;
    
       if a[i] then
          {j = 2 * i;
           while (j < size)
             {a[j] = FALSE;
              j = j + i;
             } 
          }
       i = i + 1;
      }
   }



 void printPrimes(int size; var bool a[100001];) 
   {int i;

    i = 2; 
    while (i < size) 
      {if a[i] then output("%d\n",i); 
       i = i + 1;
      }
   }
}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/primes/gc.g`; if test $1 -ne 55987
then
	echo ERROR: oxDistG1.04/gppl/gct/primes/gc.g checksum is $1 should be 55987
fi
set `wc -lwc <oxDistG1.04/gppl/gct/primes/gc.g`
if test $1$2$3 != 55146934
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/primes/gc.g are $* should be 55 146 934
fi

chmod 755 oxDistG1.04/gppl/gct/primes/gc.g

echo mkdir - oxDistG1.04/gppl/gct/primes/gct
mkdir oxDistG1.04/gppl/gct/primes/gct

if test -f oxDistG1.04/gppl/gct/primes/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/primes/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/primes/gct/t1
	if test -f oxDistG1.04/gppl/gct/primes/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/primes/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/primes/gct/t1
cat >oxDistG1.04/gppl/gct/primes/gct/t1 <<'@EOF'
2000
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/primes/gct/t1`; if test $1 -ne 8247
then
	echo ERROR: oxDistG1.04/gppl/gct/primes/gct/t1 checksum is $1 should be 8247
fi
set `wc -lwc <oxDistG1.04/gppl/gct/primes/gct/t1`
if test $1$2$3 != 115
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/primes/gct/t1 are $* should be 1 1 5
fi

chmod 755 oxDistG1.04/gppl/gct/primes/gct/t1

if test -f oxDistG1.04/gppl/gct/primes/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/primes/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/primes/gct/t2
	if test -f oxDistG1.04/gppl/gct/primes/gct/t2
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/primes/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/primes/gct/t2
cat >oxDistG1.04/gppl/gct/primes/gct/t2 <<'@EOF'
2400
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/primes/gct/t2`; if test $1 -ne 41015
then
	echo ERROR: oxDistG1.04/gppl/gct/primes/gct/t2 checksum is $1 should be 41015
fi
set `wc -lwc <oxDistG1.04/gppl/gct/primes/gct/t2`
if test $1$2$3 != 115
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/primes/gct/t2 are $* should be 1 1 5
fi

chmod 755 oxDistG1.04/gppl/gct/primes/gct/t2

chmod 755 oxDistG1.04/gppl/gct/primes/gct

chmod 755 oxDistG1.04/gppl/gct/primes

echo mkdir - oxDistG1.04/gppl/gct/prmfact
mkdir oxDistG1.04/gppl/gct/prmfact

if test -f oxDistG1.04/gppl/gct/prmfact/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/prmfact/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/prmfact/Makefile
	if test -f oxDistG1.04/gppl/gct/prmfact/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/prmfact/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/prmfact/Makefile
cat >oxDistG1.04/gppl/gct/prmfact/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/prmfact/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/prmfact/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/prmfact/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/prmfact/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/prmfact/Makefile

if test -f oxDistG1.04/gppl/gct/prmfact/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/prmfact/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/prmfact/gc.g
	if test -f oxDistG1.04/gppl/gct/prmfact/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/prmfact/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/prmfact/gc.g
cat >oxDistG1.04/gppl/gct/prmfact/gc.g <<'@EOF'
{int n;
 int stat;

 stat = input("%d\n",n);
 while ((stat != EOF) && (stat != 0))
   {primeFactor(n);
    stat = input("%d\n",n);
   }


 void primeFactor(int in;)
   {int i,limit;
    bool a[100001];
   
    if (in < 0) then
       {output("%d == -1 ",in);
        in = -in; 
       }
       else output(" %d ==  1 ",in);
    if (in >= 100001) then
       {output("\n  absolute value too big\n");
        exit(-1);
       }
    calcPrimes(in + 1,a); 
    limit = in;
    i = 2; 
    while (i <= limit) 
      {while (a[i] && (((in/i)*i) == in))
          {output("* %d ",i); 
           in = in/i;
           if (in == 1) then
              {output("\n");
               return;
              }
          }
       i = i + 1;
      }
   }  



 void calcPrimes(int size; var bool a[100001];) 
   {int i;

    a[0] = FALSE; 
    a[1] = FALSE; 
    i = 2; while (i < size) {a[i] = TRUE; i = i + 1;}
   
    i = 2;
    while (i < size)
      {int j;
    
       if a[i] then
          {j = 2 * i;
           while (j < size)
             {a[j] = FALSE;
              j = j + i;
             } 
          }
       i = i + 1;
      }
   }
 
}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/prmfact/gc.g`; if test $1 -ne 35020
then
	echo ERROR: oxDistG1.04/gppl/gct/prmfact/gc.g checksum is $1 should be 35020
fi
set `wc -lwc <oxDistG1.04/gppl/gct/prmfact/gc.g`
if test $1$2$3 != 641671139
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/prmfact/gc.g are $* should be 64 167 1139
fi

chmod 755 oxDistG1.04/gppl/gct/prmfact/gc.g

echo mkdir - oxDistG1.04/gppl/gct/prmfact/gct
mkdir oxDistG1.04/gppl/gct/prmfact/gct

if test -f oxDistG1.04/gppl/gct/prmfact/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/prmfact/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/prmfact/gct/t1
	if test -f oxDistG1.04/gppl/gct/prmfact/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/prmfact/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/prmfact/gct/t1
cat >oxDistG1.04/gppl/gct/prmfact/gct/t1 <<'@EOF'
568
4893
-245
993
8412
482
5656
9345
45
88
72 
144
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/prmfact/gct/t1`; if test $1 -ne 19078
then
	echo ERROR: oxDistG1.04/gppl/gct/prmfact/gct/t1 checksum is $1 should be 19078
fi
set `wc -lwc <oxDistG1.04/gppl/gct/prmfact/gct/t1`
if test $1$2$3 != 121251
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/prmfact/gct/t1 are $* should be 12 12 51
fi

chmod 755 oxDistG1.04/gppl/gct/prmfact/gct/t1

if test -f oxDistG1.04/gppl/gct/prmfact/gct/t2
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/prmfact/gct/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/prmfact/gct/t2
	if test -f oxDistG1.04/gppl/gct/prmfact/gct/t2
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/prmfact/gct/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/prmfact/gct/t2
cat >oxDistG1.04/gppl/gct/prmfact/gct/t2 <<'@EOF'
29
10
14
3
19
4
9
13
14
14
15
19
8
4
9
5
14
18
19
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/prmfact/gct/t2`; if test $1 -ne 51837
then
	echo ERROR: oxDistG1.04/gppl/gct/prmfact/gct/t2 checksum is $1 should be 51837
fi
set `wc -lwc <oxDistG1.04/gppl/gct/prmfact/gct/t2`
if test $1$2$3 != 191950
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/prmfact/gct/t2 are $* should be 19 19 50
fi

chmod 755 oxDistG1.04/gppl/gct/prmfact/gct/t2

if test -f oxDistG1.04/gppl/gct/prmfact/gct/t3
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/prmfact/gct/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/prmfact/gct/t3
	if test -f oxDistG1.04/gppl/gct/prmfact/gct/t3
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/prmfact/gct/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/prmfact/gct/t3
cat >oxDistG1.04/gppl/gct/prmfact/gct/t3 <<'@EOF'
29
30
34
43
9
34
20
19
33
14
14
35
29
48
44
19
25
14
38
49
49
40
24
3
29
4
30
9
43
34
34
45
19
8
14
39
35
4
48
19
19
14
13
49
24
40
49
3
4
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/prmfact/gct/t3`; if test $1 -ne 25175
then
	echo ERROR: oxDistG1.04/gppl/gct/prmfact/gct/t3 checksum is $1 should be 25175
fi
set `wc -lwc <oxDistG1.04/gppl/gct/prmfact/gct/t3`
if test $1$2$3 != 4949139
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/prmfact/gct/t3 are $* should be 49 49 139
fi

chmod 755 oxDistG1.04/gppl/gct/prmfact/gct/t3

if test -f oxDistG1.04/gppl/gct/prmfact/gct/t4
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/prmfact/gct/t4\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/prmfact/gct/t4
	if test -f oxDistG1.04/gppl/gct/prmfact/gct/t4
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/prmfact/gct/t4, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/prmfact/gct/t4
cat >oxDistG1.04/gppl/gct/prmfact/gct/t4 <<'@EOF'
29
30
34
43
59
84
120
169
33
114
14
135
79
48
44
69
125
14
138
99
99
140
24
153
129
154
30
159
143
184
84
45
69
158
114
139
35
4
48
169
169
50
14
63
199
24
140
149
53
54
154
155
59
68
184
9
145
194
158
39
39
160
4
173
69
94
50
139
163
124
24
65
49
178
54
79
55
184
68
109
109
70
194
83
139
164
160
129
73
194
94
175
39
88
124
149
165
174
178
179
179
180
184
193
9
34
70
119
183
64
164
85
29
198
194
19
75
164
88
49
49
90
174
103
79
104
180
109
93
134
34
195
19
108
64
89
185
154
198
119
119
164
13
149
174
90
99
3
4
104
105
9
18
134
159
95
144
108
189
189
110
154
123
19
44
89
113
74
174
15
199
128
4
29
5
134
18
59
59
20
144
33
89
114
110
79
23
144
44
125
189
38
74
99
115
124
128
129
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/prmfact/gct/t4`; if test $1 -ne 18214
then
	echo ERROR: oxDistG1.04/gppl/gct/prmfact/gct/t4 checksum is $1 should be 18214
fi
set `wc -lwc <oxDistG1.04/gppl/gct/prmfact/gct/t4`
if test $1$2$3 != 198198686
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/prmfact/gct/t4 are $* should be 198 198 686
fi

chmod 755 oxDistG1.04/gppl/gct/prmfact/gct/t4

chmod 755 oxDistG1.04/gppl/gct/prmfact/gct

chmod 755 oxDistG1.04/gppl/gct/prmfact

echo mkdir - oxDistG1.04/gppl/gct/qsort
mkdir oxDistG1.04/gppl/gct/qsort

if test -f oxDistG1.04/gppl/gct/qsort/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/qsort/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/qsort/Makefile
	if test -f oxDistG1.04/gppl/gct/qsort/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/qsort/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/qsort/Makefile
cat >oxDistG1.04/gppl/gct/qsort/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/qsort/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/qsort/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/qsort/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/qsort/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/qsort/Makefile

if test -f oxDistG1.04/gppl/gct/qsort/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/qsort/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/qsort/gc.g
	if test -f oxDistG1.04/gppl/gct/qsort/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/qsort/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/qsort/gc.g
cat >oxDistG1.04/gppl/gct/qsort/gc.g <<'@EOF'
/* quicksort--based on K&R's example in "The C Programming Language" */ 

/* reads some integers from standard input, quicksorts them and 
     prints them to standard output 
 */ 

{
int b[10000]; 
int inSize;

qsort (b,0,(inSize = getData(b)) - 1); 
printData(b,inSize);  



int getData(var int a[10000];)
  {int i,inStatus;

   i = 0;   
   inStatus = input("%d\n",a[i]); 
   while (inStatus != EOF && inStatus != 0)  
     {i = i + 1;
      inStatus = input("%d\n",a[i]); 
     } 
   return i; 
  } 



void printData(var int a[10000]; int size;)
  {int i;

   i = 0;
   while (i < size) 
     {output("%d\n",a[i]);  
      i = i + 1;
     } 
  } 



void qsort(var int v[10000]; int left,right;) 
  {int i,last;

   if (left >= right) 
      then 
      return;
   swap(v,left,(left+right)/2); 
   last = left;
   i = left + 1;
   while (i <=  right) 
     {if (v[i] < v[left]) 
         then 
         {last = last + 1;
          swap (v,last,i); 
         }
      i = i + 1;
     }
   swap(v,left,last); 
   qsort(v,left,last-1);
   qsort(v,last+1,right);
  }



void swap(var int v[10000]; int i,j;)
  {int temp;
   
   temp = v[i];
   v[i] = v[j];
   v[j] = temp;
  }


}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/qsort/gc.g`; if test $1 -ne 14634
then
	echo ERROR: oxDistG1.04/gppl/gct/qsort/gc.g checksum is $1 should be 14634
fi
set `wc -lwc <oxDistG1.04/gppl/gct/qsort/gc.g`
if test $1$2$3 != 751631183
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/qsort/gc.g are $* should be 75 163 1183
fi

chmod 755 oxDistG1.04/gppl/gct/qsort/gc.g

echo mkdir - oxDistG1.04/gppl/gct/qsort/gct
mkdir oxDistG1.04/gppl/gct/qsort/gct

if test -f oxDistG1.04/gppl/gct/qsort/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/qsort/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/qsort/gct/t1
	if test -f oxDistG1.04/gppl/gct/qsort/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/qsort/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/qsort/gct/t1
cat >oxDistG1.04/gppl/gct/qsort/gct/t1 <<'@EOF'
29
30
34
43
59
84
120
169
233
314
414
535
679
848
44
269
525
814
138
499
899
340
824
353
929
554
230
959
743
584
484
445
469
558
714
939
235
604
48
569
169
850
614
463
399
424
540
749
53
454
954
555
259
68
984
9
145
394
758
239
839
560
404
373
469
694
50
539
163
924
824
865
49
378
854
479
255
184
268
509
909
470
194
83
139
364
760
329
73
994
94
375
839
488
324
349
565
974
578
379
379
580
984
593
409
434
670
119
783
664
764
85
629
398
394
619
75
764
688
849
249
890
774
903
279
904
780
909
293
934
834
995
419
108
64
289
785
554
598
919
519
400
564
13
749
774
90
699
603
804
304
105
209
618
334
359
695
344
308
589
189
110
354
923
819
44
600
489
713
274
174
415
999
928
204
829
805
134
818
859
259
20
144
633
489
714
310
279
623
344
444
925
789
38
674
699
115
924
128
729
729
130
934
143
759
784
220
69
333
14
114
635
579
948
744
969
625
714
238
199
599
440
724
453
629
254
330
859
843
284
184
545
369
658
414
639
335
504
148
269
869
950
514
563
99
124
640
649
153
154
654
655
159
168
684
709
245
294
858
939
539
660
304
473
169
394
150
439
263
624
524
965
949
478
554
179
355
84
368
209
609
570
94
183
839
64
860
229
173
694
794
475
739
588
24
49
665
874
678
79
79
680
884
693
109
134
770
19
883
364
464
185
529
498
94
319
175
664
788
549
949
990
674
3
979
604
880
809
393
634
534
95
319
208
764
989
885
454
698
619
219
500
464
113
449
474
190
599
703
504
4
205
109
718
34
59
795
244
408
289
889
210
254
23
519
744
700
389
813
974
874
515
899
28
904
529
905
34
918
559
959
120
44
733
189
414
410
179
723
44
144
25
689
138
374
399
215
824
228
429
429
230
834
243
459
484
320
969
433
714
814
735
479
48
444
669
725
614
338
899
299
540
624
553
329
954
430
759
943
984
884
645
269
758
114
339
435
404
248
969
569
50
414
663
799
824
740
549
253
854
354
755
59
268
384
409
345
194
958
639
239
760
204
573
869
94
250
339
363
324
224
65
849
578
254
879
455
984
468
909
309
670
994
283
539
764
960
129
273
394
494
575
639
688
724
749
765
774
778
779
779
780
784
793
809
834
870
919
983
64
164
285
429
598
794
19
275
564
888
249
649
90
574
103
679
304
980
709
493
334
234
195
219
308
464
689
985
354
798
319
919
600
364
213
149
174
290
499
803
204
704
305
9
818
734
759
895
144
508
989
589
310
154
123
219
444
800
289
913
674
574
615
799
128
604
229
5
934
18
259
659
220
944
833
889
114
510
79
823
744
844
125
589
238
74
99
315
724
328
129
129
330
734
343
159
184
420
869
533
414
514
835
379
148
144
369
825
514
438
599
999
640
524
653
29
654
530
659
43
684
584
745
169
858
814
39
535
304
348
669
269
150
314
763
499
524
840
449
353
554
54
855
959
368
84
109
445
94
58
339
939
860
104
673
569
794
350
239
463
24
924
165
749
678
954
579
555
884
568
609
9
770
894
383
239
464
60
29
373
94
194
675
539
788
424
449
865
674
878
479
479
880
684
893
509
534
970
819
83
764
864
385
329
698
494
719
375
464
988
949
349
190
474
203
379
4
80
609
593
34
934
295
119
408
164
389
85
254
898
19
619
700
264
313
849
874
390
399
903
904
404
405
909
918
434
459
995
44
608
689
289
410
54
223
919
144
900
189
13
374
274
715
699
228
304
929
105
834
118
959
359
320
844
933
589
814
610
979
923
444
544
225
489
338
774
799
415
624
428
829
829
430
634
443
859
884
520
769
633
114
214
935
279
248
844
69
925
414
538
299
699
740
424
753
729
354
630
559
143
384
284
845
69
958
514
739
635
204
448
369
969
250
214
863
199
224
940
349
453
254
754
955
859
468
784
809
545
994
158
39
639
960
4
773
269
494
450
139
563
724
624
265
649
778
654
279
655
784
668
309
709
870
794
483
939
164
160
929
473
794
894
775
439
888
124
149
965
574
978
179
179
980
584
993
209
234
70
719
183
464
564
485
229
798
194
419
475
364
88
649
49
290
374
303
79
704
180
509
693
734
634
395
19
508
864
89
185
154
998
719
319
800
164
413
549
574
490
299
3
604
104
505
809
18
134
159
95
944
708
389
989
510
954
323
619
844
0
89
113
74
974
815
599
328
4
629
205
734
218
659
59
420
744
33
289
514
710
879
23
144
244
325
389
438
474
499
515
524
528
529
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/qsort/gct/t1`; if test $1 -ne 9506
then
	echo ERROR: oxDistG1.04/gppl/gct/qsort/gct/t1 checksum is $1 should be 9506
fi
set `wc -lwc <oxDistG1.04/gppl/gct/qsort/gct/t1`
if test $1$2$3 != 100010003887
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/qsort/gct/t1 are $* should be 1000 1000 3887
fi

chmod 755 oxDistG1.04/gppl/gct/qsort/gct/t1

chmod 755 oxDistG1.04/gppl/gct/qsort/gct

chmod 755 oxDistG1.04/gppl/gct/qsort

echo mkdir - oxDistG1.04/gppl/gct/selSort
mkdir oxDistG1.04/gppl/gct/selSort

if test -f oxDistG1.04/gppl/gct/selSort/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/selSort/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/selSort/Makefile
	if test -f oxDistG1.04/gppl/gct/selSort/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/selSort/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/selSort/Makefile
cat >oxDistG1.04/gppl/gct/selSort/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/selSort/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/selSort/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/selSort/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/selSort/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/selSort/Makefile

if test -f oxDistG1.04/gppl/gct/selSort/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/selSort/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/selSort/gc.g
	if test -f oxDistG1.04/gppl/gct/selSort/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/selSort/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/selSort/gc.g
cat >oxDistG1.04/gppl/gct/selSort/gc.g <<'@EOF'
/* GPPL selection sort program */

/* generates some data, prints it, sorts it, prints it */

{ 
int b[1000]; 

genData(b,100); 
printData(b,100); 
selSort (100,b) ; 
printData(b,100);  



int mod (int i,m;) 
  {int dum;  
   return i-((i/m)*m);
  } 



void genData(var int a[1000];int size;)
  {int i;
   a[0] = 29;  
   i = 1;
   while (i < size) 
     {a[i] = mod((i*i + a[i-1]),size);
      i = i + 1;
     } 
  } 



void printData(var int a[1000];int size;)
  {int i;
   i = 0;
   while (i < size) 
     {output("%d   ",i);  
      output("%d\n",a[i]);  
      i = i + 1;
     } 
  } 



void selSort(int size; var int a[1000];)
  {int i,j,temp,min;  

   i = 0; 
   while (i < size) 
     {
      min = i;
      j = i + 1; 
      while (j < size)
        {
         if (a[j] < a[min]) then min = j;  
         j = j + 1;
        }
      temp = a[i]; 
      a[i] = a[min];
      a[min] = temp;  
      i = i + 1;
     } 
  }
}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/selSort/gc.g`; if test $1 -ne 57241
then
	echo ERROR: oxDistG1.04/gppl/gct/selSort/gc.g checksum is $1 should be 57241
fi
set `wc -lwc <oxDistG1.04/gppl/gct/selSort/gc.g`
if test $1$2$3 != 65148936
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/selSort/gc.g are $* should be 65 148 936
fi

chmod 755 oxDistG1.04/gppl/gct/selSort/gc.g

echo mkdir - oxDistG1.04/gppl/gct/selSort/gct
mkdir oxDistG1.04/gppl/gct/selSort/gct

if test -f oxDistG1.04/gppl/gct/selSort/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/selSort/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/selSort/gct/t1
	if test -f oxDistG1.04/gppl/gct/selSort/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/selSort/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/selSort/gct/t1
>oxDistG1.04/gppl/gct/selSort/gct/t1
set `sum $sumopt <oxDistG1.04/gppl/gct/selSort/gct/t1`; if test $1 -ne 0
then
	echo ERROR: oxDistG1.04/gppl/gct/selSort/gct/t1 checksum is $1 should be 0
fi
set `wc -lwc <oxDistG1.04/gppl/gct/selSort/gct/t1`
if test $1$2$3 != 000
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/selSort/gct/t1 are $* should be 0 0 0
fi

chmod 755 oxDistG1.04/gppl/gct/selSort/gct/t1

chmod 755 oxDistG1.04/gppl/gct/selSort/gct

chmod 755 oxDistG1.04/gppl/gct/selSort

echo mkdir - oxDistG1.04/gppl/gct/subArrSort
mkdir oxDistG1.04/gppl/gct/subArrSort

if test -f oxDistG1.04/gppl/gct/subArrSort/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/subArrSort/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/subArrSort/Makefile
	if test -f oxDistG1.04/gppl/gct/subArrSort/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/subArrSort/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/subArrSort/Makefile
cat >oxDistG1.04/gppl/gct/subArrSort/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/subArrSort/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/subArrSort/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/subArrSort/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/subArrSort/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/subArrSort/Makefile

if test -f oxDistG1.04/gppl/gct/subArrSort/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/subArrSort/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/subArrSort/gc.g
	if test -f oxDistG1.04/gppl/gct/subArrSort/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/subArrSort/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/subArrSort/gc.g
cat >oxDistG1.04/gppl/gct/subArrSort/gc.g <<'@EOF'
{
int a[4][6][14],b[4][6][14]; 
int prev;

prev = 29;
genData3D(a); 
copyData(a,b);
sort(b);
printData(a,b);


void genData3D(var int a[4][6][14];)
  {int i;

   i = 0; 
   while (i < 4)
     {
      genData2D(a[i]);
      i = i + 1;
     }
  }



void genData2D(var int a[6][14];)
  {int i;

   i = 0;
   while (i < 6) 
     {
      genData1D(a[i]); 
      i = i + 1;
     }
  } 



void genData1D(var int a[14];)
  {int i;

   i = 0; 
   while (i < 14)
     {
      a[i] = prev = mod((i*i + prev),217);
      i = i + 1;
     } 
  }



void printData(var int a[4][6][14],b[4][6][14];)
  {int i,j,k;
  i = 0;
   while (i < 4) 
     {j = 0;
      while (j < 6)
        {k = 0; 
         while (k < 14)
           {output("%3d   ",i);  
            output("%3d   ",j);  
            output("%3d   ",k);  
            output("       %3d  ",a[i][j][k]);  
            output("%3d\n",b[i][j][k]);  
            if k == 13 then output("\n");
            k = k + 1;
           } 
         j = j + 1;
        }
      i = i + 1;
     }
  } 



void copyData(var int a[4][6][14],b[4][6][14];)
  {int i,j,k;
  i = 0;
   while (i < 4) 
     {j = 0;
      while (j < 6)
        {k = 0; 
         while (k < 14)
           {  
            b[i][j][k] = a[i][j][k];  
            k = k + 1;
           } 
         j = j + 1;
        }
      i = i + 1;
     }
  } 



void sort(var int a[4][6][14];)
  {int i,j;
  i = 0;
   while (i < 4) 
     {j = 0;
      while (j < 6)
        {qsort(a[i][j],0,13); 
         j = j + 1;
        }
      i = i + 1;
     }
  } 



void qsort(var int v[14]; int left,right;) 
  {int i,last;

   if (left >= right) 
      then 
      return;
   swap(v,left,(left+right)/2); 
   last = left;
   i = left + 1;
   while (i <=  right) 
     {if (v[i] < v[left]) 
         then 
         {last = last + 1;
          swap (v,last,i); 
         }
      i = i + 1;
     }
   swap(v,left,last); 
   qsort(v,left,last-1);
   qsort(v,last+1,right);
  }



void swap(var int v[14]; int i,j;)
  {int temp;
   
   temp = v[i];
   v[i] = v[j];
   v[j] = temp;
  }



int mod (int i,m;) 
  {int dum;  
   return i-((i/m)*m);
  } 

}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/subArrSort/gc.g`; if test $1 -ne 32838
then
	echo ERROR: oxDistG1.04/gppl/gct/subArrSort/gc.g checksum is $1 should be 32838
fi
set `wc -lwc <oxDistG1.04/gppl/gct/subArrSort/gc.g`
if test $1$2$3 != 1493082132
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/subArrSort/gc.g are $* should be 149 308 2132
fi

chmod 755 oxDistG1.04/gppl/gct/subArrSort/gc.g

echo mkdir - oxDistG1.04/gppl/gct/subArrSort/gct
mkdir oxDistG1.04/gppl/gct/subArrSort/gct

if test -f oxDistG1.04/gppl/gct/subArrSort/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/subArrSort/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/subArrSort/gct/t1
	if test -f oxDistG1.04/gppl/gct/subArrSort/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/subArrSort/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/subArrSort/gct/t1
>oxDistG1.04/gppl/gct/subArrSort/gct/t1
set `sum $sumopt <oxDistG1.04/gppl/gct/subArrSort/gct/t1`; if test $1 -ne 0
then
	echo ERROR: oxDistG1.04/gppl/gct/subArrSort/gct/t1 checksum is $1 should be 0
fi
set `wc -lwc <oxDistG1.04/gppl/gct/subArrSort/gct/t1`
if test $1$2$3 != 000
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/subArrSort/gct/t1 are $* should be 0 0 0
fi

chmod 755 oxDistG1.04/gppl/gct/subArrSort/gct/t1

chmod 755 oxDistG1.04/gppl/gct/subArrSort/gct

chmod 755 oxDistG1.04/gppl/gct/subArrSort

echo mkdir - oxDistG1.04/gppl/gct/711sol2
mkdir oxDistG1.04/gppl/gct/711sol2

if test -f oxDistG1.04/gppl/gct/711sol2/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/711sol2/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/711sol2/Makefile
	if test -f oxDistG1.04/gppl/gct/711sol2/Makefile
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/711sol2/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/711sol2/Makefile
cat >oxDistG1.04/gppl/gct/711sol2/Makefile <<'@EOF'
gc: g.c
	cc -o gc g.c; 

g.c: gc.g ../../gc
	../../gc <gc.g

clean:
	rm gc g.c
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/711sol2/Makefile`; if test $1 -ne 20908
then
	echo ERROR: oxDistG1.04/gppl/gct/711sol2/Makefile checksum is $1 should be 20908
fi
set `wc -lwc <oxDistG1.04/gppl/gct/711sol2/Makefile`
if test $1$2$3 != 81579
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/711sol2/Makefile are $* should be 8 15 79
fi

chmod 755 oxDistG1.04/gppl/gct/711sol2/Makefile

if test -f oxDistG1.04/gppl/gct/711sol2/gc.g
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/711sol2/gc.g\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/711sol2/gc.g
	if test -f oxDistG1.04/gppl/gct/711sol2/gc.g
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/711sol2/gc.g, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/711sol2/gc.g
cat >oxDistG1.04/gppl/gct/711sol2/gc.g <<'@EOF'
/* finds four numbers a,b,c,d such that a*b*c*d == a+b+c+d == 7.11 */
{
 int a,b,c,d; 
 int aLim,bLim,cLim;
 int Ascratch,Mscratch;  

 aLim = 711/4; 
 a = 1;
 while (a <= aLim) 
   {if (divides(a,2) || divides(a,3) || divides(a,5) || 
        divides(a,79) || (a == 1)
       ) then 
       {bLim = a + (711-a)/3;
        b = a;
        while(b <= bLim) 
          {if (divides(b,2) || divides(b,3) || 
               divides(b,5) || divides(b,79)
              )  
              then 
              {cLim = a + b + (711-a-b)/2;  
               Ascratch = 711 - a - b; 
               Mscratch = a * b; 
               c = b;
               while(c <= cLim) 
                 {if ((d = Ascratch - c) >= c) then   
                     {if (Mscratch*c*d == 711000000) 
                        then
                         {output("%4.2f ",float(a)/100.0);
                          output("%4.2f ",float(b)/100.0);
                          output("%4.2f ",float(c)/100.0);
                          output("%4.2f\n",float(d)/100.0);
                         }
                     }
                  c = c + 1;
                 } 
              } 
           b = b + 1;
          }
       }
    a = a + 1; 
   }



 bool divides2(int i,m;)
   {return ((i/m)*m == i);
   }



 bool divides(int i,m;)
   {return (mod(i,m) == 0);
   }



 int mod (int i,m;) 
   {int dum;  
    return i-((i/m)*m);
   } 
}
@EOF
set `sum $sumopt <oxDistG1.04/gppl/gct/711sol2/gc.g`; if test $1 -ne 54469
then
	echo ERROR: oxDistG1.04/gppl/gct/711sol2/gc.g checksum is $1 should be 54469
fi
set `wc -lwc <oxDistG1.04/gppl/gct/711sol2/gc.g`
if test $1$2$3 != 611591407
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/711sol2/gc.g are $* should be 61 159 1407
fi

chmod 755 oxDistG1.04/gppl/gct/711sol2/gc.g

echo mkdir - oxDistG1.04/gppl/gct/711sol2/gct
mkdir oxDistG1.04/gppl/gct/711sol2/gct

if test -f oxDistG1.04/gppl/gct/711sol2/gct/t1
then
	echo Ok to overwrite existing file oxDistG1.04/gppl/gct/711sol2/gct/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/gppl/gct/711sol2/gct/t1
	if test -f oxDistG1.04/gppl/gct/711sol2/gct/t1
	then
		echo Error: could not remove oxDistG1.04/gppl/gct/711sol2/gct/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/gppl/gct/711sol2/gct/t1
>oxDistG1.04/gppl/gct/711sol2/gct/t1
set `sum $sumopt <oxDistG1.04/gppl/gct/711sol2/gct/t1`; if test $1 -ne 0
then
	echo ERROR: oxDistG1.04/gppl/gct/711sol2/gct/t1 checksum is $1 should be 0
fi
set `wc -lwc <oxDistG1.04/gppl/gct/711sol2/gct/t1`
if test $1$2$3 != 000
then
	echo ERROR: wc results of oxDistG1.04/gppl/gct/711sol2/gct/t1 are $* should be 0 0 0
fi

chmod 755 oxDistG1.04/gppl/gct/711sol2/gct/t1

chmod 755 oxDistG1.04/gppl/gct/711sol2/gct

chmod 755 oxDistG1.04/gppl/gct/711sol2

chmod 755 oxDistG1.04/gppl/gct

chmod 755 oxDistG1.04/gppl

echo mkdir - oxDistG1.04/docs
mkdir oxDistG1.04/docs

if test -f oxDistG1.04/docs/oxTutor.dvi
then
	echo Ok to overwrite existing file oxDistG1.04/docs/oxTutor.dvi\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/docs/oxTutor.dvi
	if test -f oxDistG1.04/docs/oxTutor.dvi
	then
		echo Error: could not remove oxDistG1.04/docs/oxTutor.dvi, aborting
		exit 1
	fi
fi

rm -f /tmp/uud$$
(echo "begin 666 /tmp/uud$$\n#;VL*n#6%@x\n \nend" | uudecode) >/dev/null 2>&1
if [ X"`cat /tmp/uud$$ 2>&1`" = Xok ]
then
	unpacker=uudecode
else
	echo Compiling unpacker for non-ascii files
	pwd=`pwd`; cd /tmp
	cat >unpack$$.c <<'EOF'
#include <stdio.h>
#define C (*p++ - ' ' & 077)
main()
{
	int n;
	char buf[128], *p, a,b;

	scanf("begin %o ", &n);
	gets(buf);

	if (freopen(buf, "w", stdout) == NULL) {
		perror(buf);
		exit(1);
	}

	while (gets(p=buf) && (n=C)) {
		while (n>0) {
			a = C;
			if (n-- > 0) putchar(a << 2 | (b=C) >> 4);
			if (n-- > 0) putchar(b << 4 | (a=C) >> 2);
			if (n-- > 0) putchar(a << 6 | C);
		}
	}
	exit(0);
}
EOF
	cc -o unpack$$ unpack$$.c
	rm unpack$$.c
	cd $pwd
	unpacker=/tmp/unpack$$
fi
rm -f /tmp/uud$$

echo x - oxDistG1.04/docs/oxTutor.dvi '[non-ascii]'
$unpacker <<'@eof'
begin 755 oxDistG1.04/docs/oxTutor.dvi
M]P(!@Y+ '#L      ^@;(%1E6"!O=71P=70@,3DY,RXQ,2XP-3HQ-S4VBP  X
M  $                                               #_____H )RX
M  "-H/VU  "@ BT  (V@_??;(XV2 -L(./,\&O(B5@ 11ZX "@    9C;6)XX
M,3#G3W@ZCJ0.@ "-D7T7E/,K6*M1"P ,    #     5C;7(Q,M9!;I8#ZJA!X
MD*QR='1R:6)U=&4M1W)A;6UA<I-#;VUP:6QI;F>34WES=&5MCJ&-D@"D#85BX
M87-E9)8#ZJAO;I-9D?\%5F%C8RR33&5X+)-A;F230SJ.GQN  (V2 (V'U.=4X
MD?Y8$'5T;W)I86R1!I^\26Z1_W*P=')OD0"-3V1U8W1I;VZ.GQJ9FHV2 +^8X
MY_,B2_%@>0 *\S, "@    5C;7(Q,,U.;Y6R(7:396V38I!-WF5RE@.F9C4LX
MDS$Y.3..I V9FHV-C8V-D@"D:X&>JX)CCHZ.C8V-D@"A8-7S)"$B+)H "O,SX
M  H    &8VUS>3$PSPV.CHZ.D@"L5 K-,3DY,BR6 Z9F,3DY,Y-+=7)TDTTNX
MDT)I<V.0LB%H;PN.H8V2 *ACW?,HW^H\>  *\S, "@    9C;71T,3#38FESX
M8VAO9F9 8W,N:6%S=&%T92YE9'6.GR@55HV-D2>  .<QCI%%3LY);I'_<K!TX
M<F^1 (U/9'5C=&EO;HZ?&F(CC9$G@ #S,,+63J  #     P    &8VUB>#$RX
MVT]XE@2/T-9I<Y-A;I-A='1R:6)U=&4M9W)A;6UA<I-C;VUP:6QI;F>3<WESX
M=&5MDV)A<V5DDV]NDUF1_P5686-C+)8$N1I,97@LDV%N9)$$C]!#+HZD#H  X
MC9$G@ !/>(V-D03E%)_[I3+S#7Q[60< "     @    $8VUR.+@QCHZ1#HHLX
MUF=E;F5R86QI>F5SE@3E%'1H99-F=6YC=&EO;I-O9I-9D?\%5F%C8Y-I;I-TX
M:&63=Y6L<F&3>98$Y11T:&%TDV%T=')I8G5T99-G<F%M;6%R<XZAC9$G@ !GX
M96YE<F%L:7IEE@.[%V-O;I"L<G1E>'0M9G)E99-G<F%M;6%R<RZ1!2D%3W)DX
M:6YA<GF369'_!59A8V.386YDDTQE>)-S<)!3CF5C:0QC871I;VYSDV-A;HZAX
MC9$G@ !BD%..998"\/IA=6=M96Z:K')T9623=VET:)-D90QN:71I;VYSDV]FX
MDW-Y;IAT:&5S:7IE9)-A;F23:6YH97)I=&5DDV%T=')I8G5T97.3=W)I='1EX
M;HZAC9$G@ !I;I8$/U)#+T,K*Y-S>6Z0K')T87@ND08VW4:1_P56<F]MDW1HX
M97-EDW-PD%..96-I#&-A=&EO;G,LD014?$]XDV=E;F5R871E<Y-ADW!R;V=RX
M86V3=&AA=(ZAC9$G@ !B=6EL9'.6 [R=86YDDV1E8V]R871E<Y-A='1R:6)UX
M=&5DDW!A<G-EDW1R965S+I$%*8=/>)-A8V-E<'1SDV&3;6]S=)-G96YE<F%LX
MDV-L87-SCJ&-D2>  &]FE@3:ZV%T=')I8G5T99-G<F%M;6%R<RZ1" FI5&AEX
MDW5S97*38V%NDW-PD%..96-I9GF3<&%R<V4M=')E99-T<F&5K')VDV5R<V%LX
M<Y8$VNMF;W*396%S>8ZAC9$G@ !O<F1E<FEN9Y8%I$!O9I-S:61EDV4+96-TX
M<Y-S=6.0K')HDV%SDV-OD%..9&639V5N97)A=&EO;BZ1"F6H3WB3:&%N9&QEX
M<Y-T:&63=&5D:6]U<XZAC9$G@ !A;F26 XT797)R;W(M<')O;F639&5T86ELX
M<Y-O9I-W<FET:6YGDV-OD%..9&639F]RDW!A<G-E+71R9663;6%N86=E;65NX
MD*QR="R1 Y_.<V^3:71SDW5S98ZAC9$G@ !E87-E<Y8#6'QP<F]B;&5M<Y-OX
M9I-S96-U<FETFJQR>9-A;F23;6%I;IAT86EN86)I;&ETF'F387-S;YI3CF-IX
M871E9)-W:71HDW1H872387-PF&5C=)-O9HZAC9$G@ !T<F%N<VQA=&]RD0/JX
MJ&1E=I6L<F5L;W!M96Z3="Z.H8V1.1_T3WB6 JI+:7.389-9D?\%5F%C8R],X
M97@O0R]#*RN3<')E<')OD%..8V5S<V]R+)$"ZEYA;F23:7.39&5S:6=N9623X
M=&^38G)I;F>3871T<FEB=71ECJ&-D2>  &=R86UM87)SE@2,EW1ODW1H99-MX
M86EN<W1R96%MDV]FDU5N:7@M8F%S9623;&%N9W5A9V639&5VE:QR96QO<&UEX
M;I-T+I$''JY/>)$$C)=I;BV.H8V1)X  :&5R:71SE@3F*&%L;)-O9I-T:&63X
M9F%M:6QI87*3<WENFJQR=&%XDV%N9)-S96UA;IAT:6-SDV]FDUF1_P5686-CX
M+)8%)0A,97@LDV%N9)$$YBA#+T,K*RZ.H8V1)X  5&AI<Y8$I!YM86N:K')EX
M<Y-/>)-E87-I;'F386-C97-S:6)L99-T;Y-L86YG=6%G99-D97-I9VYE<G,LX
ME@32>V1E=IAE;&]PD%..97)S+)-A;F21!*0>97@MCJ&-D2>  '":4XYE<FEMX
M96Z0K')T97)SE@0%H'=H;Y-U<V63=&AO<V63=&^8;VQS+I$%B<A)=)-A;'-OX
MDW!R;Y"L<G9I9&5SDV&3<F5A9'F37&5S8V%PF&63:&%T8Y"L<F@BDVENCJ&-X
MD2>  &-A<V66 ^JH:723:7.39&5S:7)E9)-T;Y-R971U<FZ3=&^386Z3;W)DX
M:6YA<GF369'_!59A8V.3:6UP;&5M96Z0K')T871I;VXNCJ&-D3D?]%1H:7.6X
M ]-<<&%PD%..97*39VEVFJQR97.386Z3;YAVF&5R=FEE=Y-O9I-/>)-BF'F3X
M96UP:&%S:7II;F>397AA;7!L97,ND04Q'$ETDW%U:6.8:VQYCJ&-D2>  &9AX
M;6EL:6%R:7IE<Y8&&UQYD*QR;W63=VET:)-T:&633WB39F5A='5R97.3=&AAX
M=)-A<F63;6]S=)-I;6UE9&EA=&5L>9-U<V5F=6PNCJ&-D2>  $&1!826;6]RX
M998%A/]C;VUP;&5T99-R969E<F5N8V4LFP7KE71H99/S+IN[B$  #     P X
M   &8VUT:3$RV4]XE@6L855S97*34I;_9F9E9F5RDV5N8Y-ED06L84UA;G5AX
M;)$!/I/6+)AA8V-O;7!A;FEE<XZAC9$G@ !T:&66!<L\3WB396QE8W1R;VYIX
M8Y-D:7-T<FEB=71I;VXLD09#87=H:6.:K')HDV-A;I-BD%..99-O8G1A:6YEX
M9)-F<F5EDV*8>9-W<FET:6YGDW1OCJ&-D2>  /,QWX:U5  ,    #     9CX
M;71T,3+<;W@M<F5Q=65S=$!C<RYI87-T871E+F5D==8NCI$G@ "?"MW=B0  X
M9F8 F_]DGPL  (V-C9$-@Y"?_%[_\PC9DZ!2  <    '    !&-M<C>S,8Z.X
MD1(  _,92_%@>0 *    "@    5C;7(Q,,14:&66 Q9I;F%M99-<3W@BDV-OX
M;65SDV9R;VV386Z3871T96UP=)-T;Y-P<F]N;W5N8V6386Z386-R;VZ:N.-YX
M;9-F;W*37$%NDT&8='1R:6)U=&4MCI\,  "-1W)A;6UA<I8#555#;VUP:6QIX
M;F>34WES=&5M(HZ.GQX  (V2 .>0 M8QCHZ,BP    (                 X
M                                   JH )R  "-H/VU  "@ BT  (V@X
M_?8  (V1.1_TUD:;_P5686UI;&EA<FETD*QR>98#B7AW:71HDW1H99-U<V63X
M;V:369AA8V,LE@.<Z$QE>"R30RR6 XEX86YDDTUA:YJL<F63:7.3<W4.8VEEX
M;IATDW1ODW5N9&5R+8ZD#H  C9$G@ !S=&%N9)8#ZTIT:&ESDW1U=&]R:6%LX
MDV%N9)-T;Y-BFE..96=I;I-U<VEN9Y-/>"Z1!3K&4V]M99-P<FEO<I-E>'"8X
M;W-U<F63=&^3871T<FEB=71ECJ&-D2>  &=R86UM87)SE@0:3&ESDVAE;'!FX
M=6PND07'S5)E861E<G.3=VET:)-A;I-U<F=EDV9O<I-D971A:6QSDV%N9)-HX
M86YD<RUO;I-E>'"04XYE<FDMCJ&-D2>  &5N8V66 [T0<VAO=6QDDW5S99-TX
M:&63:6YD97B3;V:3=&AEDW)E9F5R96YC99-M86Z:K')U86R386YDDW-H;W5LX
M9)-H89AVF&6386-C97-SDW1OCJ&-D2>  &&6 P^3<WES=&5MDV]NDW=H:6.:X
MK')HDT]XDVESDVEN<W1A;&QE9"Z1!._95&AEDV5X86UP;&5SDVAE<F5I;I,HX
M:6Z3;6%CF&AI;F4M<F5A9&%B;&6.H8V1)X  9F]R;2F6 ^JH87)EDVEN8VQUX
M9&5DDW=I=&B3=&AEDT]XDV1I<W1R:6)U=&EO;BZ.GR@55HV-D2>  .<RCI%%X
M3LY#;VZ6_W*P=I-E<G1I;F>6"4I389-9D?Y8$&%C8R],97B3<')O9W)A;9-FX
M;W*3=7-ECI\6  "-D45.SG=I=&B1!I^\3WB.GQIB(XV1)X  UE!R;V)A8FQYX
ME@4(&W1H99-E87-I97-TDW>5K')ADWF6!0@;=&^39V5TDW-T87)T9623=VETX
M:)-/>)-I<Y-T;Y-C;VZ5K')VDV5R=)8%"!MA;I-E>&ES=&EN9XZAC9$G@ !9X
MD?\%5F%C8R],97B-C9$#PLZ?^Z4RN#*.CI$,1:#6<&%R<V5RE@/"SF]RDW1RX
M86YS;&%T;W(ND04KEU1H:7.38V%NDW5S=6%L;'F38I!3CF639&]N99-W:71HX
M;W5TDV.0K')H86YG:6YGCJ&-D2>  '1H998#G&I9D?\%5F%C8Y-A;F233&5XX
MDV-OFE..9&4ND04>RT]XDV-A;I-A;'-ODV*899-U<V5DDW=I=&B369'_!59AX
M8V,M;VYL>9-T<F%N<VQA=&]R<RR1 ZP0:2YE+BR.H8V1)X  =&AO<V66 ^JHX
M=VET:)-L97AI8V%LDV%N86QY>F5R<Y-H86YD+6-OD%..9&5DDVENDT.3*'-EX
M99-S96-T:6]NDSDN,RDNCI\BRJN-C9$G@ #S-QKR(E8 #F9F  H    &8VUBX
M>#$PXC(N,8Z133A 098%A1QP87)S97*3;V:387)I=&AM971I8Y-E>'!R97-SX
M:6]N<XZ?%D  C9$G@ #607.6 Q4589-R=6YN:6YGDV5X86UP;&4LD0,_S'>:X
MK')EDW-T87)TDW=I=&B389-9D?\%5F%C8R],97B3<&%R<V5RDV9O<I-I;IATX
M96=E<I-A<FET:&UE=&ECCJ&-D2>  &5X<')E<W-I;VYS+HZAC9$Y'_14:&66X
M WL"3&5XDPQL99-I<Y-N86UE9)/<<V-A;BYLUBR1 Y%686YDDW-PD%..96-IX
M#&5SDW1H99-T;VN0K')E;G.3;V:3=&AEDVQA;F=U86=EDV%SCJ&-D2>  &1IX
M9VETE@/JJ'-T<FEN9W,LDW!A<F5ND*QR=&AE<V5S+)-A;F239F]U<I-B:6YAX
M<GF3;W"04XYE<F%T;W)S.HZ?&0  C9$G@ #S']_J/'@ "@    H    &8VUTX
M=#$PRB5[CJ0,  "-D2>  "-I;F-L=61ED04__2)Y+G1A8BYH(HZAC9$G@  EX
M?8Z?&   C9$G@  E)8ZAC9$G@ !;D04__5QN7'1<9ETKD2G_Z#N.H8V1)X  X
M6S M.5TKD3[_W')E='5R;BA)0T].4U0I.XZAC9$G@ !;*"DJ+RM<+5V1+S_EX
M<F5T=7)N*'EY=&5X=%LP72D[CJ&-D2>  "4ECI\;@ "-D3D?]-94:&66!=9!X
M69'_!59A8V.3#&QEDRAN86UE9)/<9W)A;2YYUBF3<W"04XYE8VD,97.3=&AEX
MDW-Y;I"L<G1A>"Z1"ONL5&AEDV=R86UM87*3:7..GPZ  (V1)X  9&ES86V5X
MK')B:6=U871E9)L#ZJABDWF8=7-EF&]FF'1H99C<)6QE9G28UG)E<V5R=I-EX
M9)AWDV]R9#J.D2>  )\2_:&)  !F9@";_V2?"P  C8V-D0V#D)_\7O^S,HZ.X
MD1(  \1/>)8"W,EI<Y-D97-I9VYE9)-T;Y-WFKCC;W)KDV%L<V^3=VET:)-9X
MD?\JJF%C8Y-A;F233&5XDW>8;W)KD?]QQV%L:6N897.386YDDT,K*RZ1!$F9X
M5&AR;W5G:&]U=)-T:&ESCJ&-<&%PFD<=97(LE@-4[%Q9D?\JJF%C8R(LDUQ,X
M97@B+)-A;F26 U327$,BD0-4T6-A;I-G96YE<F%L;'F38IAEDW1A:Y"XXV5NX
MDW1ODVUE86Z37%F1_RJJ86-CDV]RDT)I<V]N(BR1 U3L7$QE>)-O<HZAC49LX
M97@B+)8#555A;F237$.3;W*30RLK(BR3<F5S<)!''65C=&EVD+CC96QYD?\JX
MJBZ.CI\>  "-D@#GD +6,HZ.C(L    #                            X
M                       + : "<@  C:#]M0  H (M  "-H/WV  "-D2> X
M ,HE=&]K96Z1!3_]24-/3E-4CJ0,  "-D2>  "5L969TE@4__2<K)Y,G+2>.X
MH8V1)X  )6QE9G26!3_])RHGDR<O)XZI&   C9$G@  E)8ZAC9$G@ !E>'!RX
MEA3_]#J1)+_K97AP<I,G*B>1&C_Q97AP<HZAC9%1?^A\D22_ZV5X<'*1%/_TX
M)R\GD1H_\65X<'*.H8V147_H?)$DO^ME>'!RD13_]"<K)Y$:/_%E>'!RCJ&-X
MD5%_Z'R1)+_K97AP<I$4__0G+2>1&C_Q97AP<HZAC9%1?^A\D22_ZR<H)Y$:X
M/_%E>'!RD13_]"<I)XZAC9%1?^A\D22_ZTE#3TY35(ZAC9%1?^@[CJ&-D2> X
M "4ECJ&-D2>  &UA:6XH*8ZAC9$Q__I[<F5T=7)N*'EY<&%R<V4H*2D[CJ&-X
MD3'_^GV.GQN  (V1.1_TUE1H998$18!F;VQL;YJL<G=I;F>336%KF&63#&QEX
MDVESDW5S9623=&^38G5I;&2386YDDVUA:6Z8=&%I;I-T:&63<&%R<V5R+)$$X
M7#9W:&ECF&B.GPZ  (V1)X  :7.6 ^JH;F%M9623W&=CUCJ.GQD  (V1)X  X
MRF=C.I8%/_UY+G1A8BYODVQE>"YY>2YOCJ&-D5%_Z&-CE@4__2UODV=CDWDNX
M=&%B+F^3;&5X+GEY+F^3+6QYDRUL;(ZFC9$G@ !Y+G1A8BYCE@4__7DN=&%BX
M+F@ZDV=R86TN>8ZAC9%1?^AY86-CE@4__2UDDV=R86TN>8ZFC9$G@ !L97@NX
M>7DN8SJ1!3_]<V-A;BYLCJ&-D5%_Z&QE>)$%/_US8V%N+FR.IHV1)X  >2YTX
M86(N;SJ1!3_]>2YT86(N8XZAC9%1?^AC8Y8%/_TM8Y-Y+G1A8BYCCJ:-D2> X
M &QE>"YY>2YO.I8%/_UL97@N>7DN8Y-Y+G1A8BYHCJ&-D5%_Z&-CE@4__2UCX
MDVQE>"YY>2YCCI\BRJN-C9$G@ #B,BXRCI%-.$!!E@6%''!A<G-E<I-T:&%TX
MDV)U:6QD<Y-ADW!A<G-EDW1R966.GQ9  (V1)X  UE1H99L#IYQA8I!3CF^5X
MK')VDV68<&%R<V5RF&1OD%..97.8;F^8<V5M86Z3=&ECF&%N86QY<VES+I$%X
M(H=4D?\%5F^89V5TF')E861YF&9O<IA/>)AI;7!L96UE;BV.I Z  (V1)X  X
M=&%T:6]NE@1%@&]FDW-E;6%NE:QR=&EC<RR1!%PV=Y-EE@1%@&YE9623;65RX
M96QYDW)E<&QA8V63=&AEDV9O;&QOFJQR=VEN9Y-L:6YE<Y-I;I-T:&6336%KX
MF&6.H8V1)X  #&QE.HZ.GQX  (V2 .>0 C..CHR+    !               X
M                                    $SR@ G(  (V@_;4  * "+0  X
MC:#]]@  C9%!O_'*>2YT86(N8Y8%/_UY+G1A8BYH.I-G<F%M+GF.I P  (V1X
M:[_9>6%C8Y8%/_TM9)-G<F%M+GF.J1@  (V10;_Q;&5X+GEY+F,ZD04__7-CX
M86XN;(ZAC9%KO]EL97B1!3_]<V-A;BYLCI\5?QB-D2>  -9W:71HD0/JJ'1HX
M97-E.HZ?$U]2C9%!O_'*;WAO=70N>98%/_UO>&]U="YL.I-G<F%M+GF3<V-AX
M;BYLCJ&-D6N_V6]XE@4__6=R86TN>9-S8V%N+FR.IHV10;_Q>2YT86(N8Y8%X
M/_UY+G1A8BYH.I-O>&]U="YYCJ&-D6N_V7EA8V.6!3_]+623;WAO=70N>8ZFX
MC9%!O_%L97@N>7DN8SJ1!3_];WAO=70N;(ZAC9%KO]EL97B1!3_];WAO=70NX
M;(ZD%=]2C9$G@ #65&AED0/JJ&-O;6UA;F0ZCJ&-D49@ =QO>)8&+,UG<F%MX
M+GF3<V-A;BYLCJ&-D2>  -9T<F%N<V9O<FUSE@0L\MQG<F%M+GF3UBAC86QLX
M9623=&AED]E9+0QL99$ Y;#6*9-I;I"L<G1OD]QO>&]U="YYUBR1!#V%86YDX
MDW1R86YS9F]R;7.3W'-C86XN;(ZD#H  C9$G@ #6*&-A;&QE9)8%\-]T:&63X
MV4PM#&QED0#EL-8IDVEND*QR=&^3W&]X;W5T+FS6+I$+2X14:&5S99-/>)-OX
M=71P=71SDW)E<&QA8V63W&=R86TN>9/686YDCJ&-D2>  -QS8V%N+FR6 ^JHX
MUFENDW1H99-R96UA:6YI;F>3<W1E<'.3;V:3<&%R<V5RDV-O;G-T<G5C=&EOX
M;BZ.H8V1.1_T5&AEE@.J7W5S97(M;V)S97)VFJQR96238I!3CF5H89AV:6]RX
M<Y-O9I-T:&63;W)I9VEN86R3<')O9W)A;9-A;F23=&AEDV]N99-P<F5P<F\MX
MCJ&-D2>  &-E<W-E9)8#<<!BFJQR>9-/>)-A<F63=&AEDW-A;64ND040DU1HX
M99-D:0ME<F5N8V63:7.3=&AA=)-T:&63=IAE<G-I;VZ3;6%D99-U<VEN9Y-/X
M>(ZAC9$G@ !A;F26 _)*=&AEDVYE=Y--86N:K')EDPQL99-B=6EL9'.389-DX
M=6UMF'F3*&%T=')I8G5T92UL97-S*9-P87)S99-T<F5E+)$#]#)W:&EL99-TX
M:&6.H8V1)X  ;W)I9VEN86R6!+=Z8G5I;&1SDVYODW!A<G-EDW1R964ND0>?X
M5U1H99-O<FEG:6YA;)-C;Y!3CF1EDVENDW1H99-E>&%M<&QEDVQA8Y"L<FMSX
MDUF1_P5686-CCJ&-D2>  &%C=&EO;G,LD07Z86)U=)8%D-5H8623:7238V]NX
MFJQR=&%I;F5DDW-U8YAHDV%C=&EO;G,LD07Z871H96ERDV4+96-T<Y-WF&]UX
M;&23:&&8=IAEDV*04XYE96Z.H8V1)X  =6YD:7-T=7)BFE..9626 ^JH8I"LX
M<GF3=&AEDT]XDW!R97!R;YAC97-S:6YG+HZAC9$Y'_1(89JL<G9I;F>6!(!5X
M;6^04XYD:0QE9)-O=7*336%KF&63#&QE+)$$I<%WF&6387)EDW)E861YDW1OX
MDV%U9VUE;IATDW1H99-9+0QL99-A;F2.H8V1)X  3"T,;&66 ^JH=VET:)-/X
M>)-C;VYS=')U8W1S+HZ?)Z%]C8V1)X  YS..D45.SD%D9&EN9Y8&G[Q/>"UGX
M96YE<F%T9623<V5M86Z1_W*P=&EC<XZ?&F(CC9$G@ #65&AI<Y8$2A1S96-TX
M:6]NDVEND*QR=')OFE..9'5C97.3=&AEDV9O<FV386YDDVUE86YI;F>3;V:3X
M3W@M<W"896-I#&.38V]N<W1R=6-T<RR1!&'P8I"L<GF.H8V1)X  =Y6L<F&3X
M>98#ZJAO9I-C;VZ5K')VDV5R=&EN9Y8#ZJAO=7*3<&%R<V4M=')E92UB=6ELX
M9&EN9Y-P87)S97*3:6Z0K')T;Y-ADV-A;&-U;&%T;W(NCJ&-D3D?]$5A8YJLX
M<FB6 P!*<&%R<V63=')E99-H87.3;&5AF':897.3;&%BD%..96QE9)-BF'F3X
M=&AED]Q)0T].4U21 P .UG1O:YAE;BZ1!.K!3&5TDW5SDV5N9&^8=Y-T:&ESX
MCJ&-D2>  '1O:YJL<F5NE@3=>W=I=&B386Z3871T<FEB=71ED]QS=')I;F?6X
M.I$''H5ADV.8:&%R86-T97*3<)!3CF]I;IAT97*3=&AA=)-F;W*396%CF&B3X
MW$E#3TY35(ZAC9$G@ #6;F^:4XYD998$%VII<Y-T;Y-PF&]I;IJL<G23=&^3X
M89-C;W"8>9-O9I-T:&63;&5X96UEDV-O<G)E<W":4XYO;F1I;F>3=&^3=&AEX
MDVYOF&1E+I$%OR54:&ESDVESCJ&-D2>  &1O;F66 ^JH8I"L<GF3<&QA8VENX
M9Y-T:&63V6%T=')I8G5T99$$,S5D99;_9F9C;&%RDV%T:6]ND0#EL-8ZCHZ?X
M'@  C9( YY "-(Z.C(L    %                                    X
M               7?J "<@  C:#]M0  H (M  "-H/WV  "-D49@ =Q 871TX
M<FEB=71E<Y8&+,U[8VAA<I,J<W1R:6YG.WV324-/3E-4CI\8@ "-D2>  -9BX
MFE..969O<F66 Z]X=&AEDPQR<W23W"4ED]9M87)KDVENDW1H99-9+0QL92Z1X
M!24E5&AEDV%BF&^5K')VDV4M;65NDW1I;VYE9)8#KWAS=&]R86=EDVQOF&-AX
M=&EO;HZD#H  C9$G@ !C<F5A=&5DE@2F=V9O<I-E86.0K')HD]Q)0T].4U21X
M!*9&UFYOD%..9&63:7.38V%L;&5DDV%ND]EA='1R:6)U=&61!-_5:6YS=&%NX
M8Y'_9F9ED06,)]8H8V]N8VES96QY.I$&L'UA;HZAC9$G@ #9:6YS=&%N8Y'_X
M9F9ED0#EL-8I+I$%..!)=)8#ZJAI<Y-A;I-I;G-T86YC99-O9I-T:&63W'-TX
M<FEN9Y/6871T<FEB=71EDV]FD]Q)0T].4U36+HZAC9$Y'_17D?\%5F66!9_RX
M<W5P<&QYDV&30Y-M86-R;Y,H;F%M9623W&QE>&5M9=8IDW1H87238V]N<W1RX
M=6-T<Y-ADV-O<)"L<GF3;V:3=&AECJ&-D2>  &QE>&5M92Z1!\5Z1I'_!59OX
M<I8$Q#%B<F5V:72:K')YDV]FDW1H99-E>&%M<&QE+)$$^I/<;&5X96UED]9UX
M;G-A9F5L>9-N96=L96-T<Y-T;Y-CF&AE8YAKDV9O<HZAC9$G@ !R971U<FZ6X
M ^JH;V:3W$Y53$R3UF*0K')YD]QM86QL;V/6+I$%..!(97)EDVESDW1H99-MX
M;Y!3CF1I#&5DDTPM#&QE.HZ?&0  C9$G@ #*)7N.I P  (V1)X  (VEN8VQUX
M9&61!3_](GDN=&%B+F@BCJ&-D2>  "-I;F-L=61ED04__3QS=')I;F<N:#Z.X
MJ1@  (V1)X  (V1E9FEN998%/_UL97AE;663<W1R8W!Y*"AC:&%RDRHI;6%LX
M;&]C*'EY;&5N9RLQ*2QY>71E>'0ICJ&-D2>  "5]CJ:-D2>  "4ECJ&-D2> X
M %N1!3_]7&Y<=%QF72N1*?_H.XZAC9$G@ !;,"TY72N1/O_<<F5T=7)N*$E#X
M3TY35"D[E@4__4![DT!)0T].4U0N<W1R:6YG0),]DVQE>&5M93N30'V.H8V1X
M)X  (B@BD4Z_TW)E='5R;B@G*"<I.XZAC9$G@  B*2*13K_3<F5T=7)N*"<IX
M)RD[CJ&-D2>  "(J(I%.O]-R971U<FXH)RHG*3N.H8V1)X  (B\BD4Z_TW)EX
M='5R;B@G+R<I.XZAC9$G@  B*R*13K_3<F5T=7)N*"<K)RD[CJ&-D2>  "(MX
M(I%.O]-R971U<FXH)RTG*3N.H8V1)X  )26.GQN  (V1.1_TUE21_P56;Y8#X
MJQ)T:&63<FEG:)JL<G23;V:3=&AEDVQE>&EC86R3<G5L99-F;W*3W$E#3TY3X
M5-8LDW1H97)EDVESDV*04XYE=)AWF&5E;I/<0/,M(2(LF@ ,    "@    9CX
M;7-Y,3#89I/686YDD]Q V&>3UF%NCJ0.@ "-D2>  -EA='1R:6)U=&61 Z:OX
M9&4,;FET:6]ND00W=]9T:&%TE@-1QV-A=7-E<Y-T:&63W'-T<FEN9Y/6871TX
M<FEB=71EDVEN<W1A;F-EDVENDV5A8Y"L<FB3W$E#3TY35(ZAC9$G@ #6;F^:X
M4XYD998#ZJAT;Y-G972389-PF&]I;IJL<G1E<I-T;Y-ADV-O<)AYDV]FDW1HX
M99-C;VYS=&%NF'0G<Y-L97AE;64NCJ&-D3D?]$YO=&EC998#ZJAT:&%TDW>:X
MK')EDVAAF':899-R97!L86-E9)-T:&63<VEN9VQEDVQE>&EC86R3<G5L93J.X
MI!B  (V11F !W%LH*2HO*UPM79$WDS5R971U<FXH>7ET97AT6S!=*3N.H8V1X
M)X  UG=I=&B6 U#I<VEXDW)U;&5SDW1H872387)EDW1O9V5T:&5RDV5Q=6EVX
MD?]8Y&%L96Z:K')TDW1ODW1H8723<VEN9VQEDW)U;&4ND04%H$]XDW>8;W5LX
M9)-H89AVF&6.I Z  (V1)X  8I!3CF5E;I8%*9MU;F%B;&63=&^39&5T97)MX
M:6YEDV9R;VV3=&AEDV]BD0"G'&IE8W23;V:3=&AEDW-I;F=L99/<<F5T=7)NX
MD]9S=&%T96UE;I"L<G2.H8V1)X  *&YA;65L>98"S_;<>7ET97AT6S!=UBF3X
M=&AEDW-PD%..96-I#&.3=&]KFJQR96Z3=&AA=)-WF&]U;&238I!3CF63W')EX
M='5R;M9E9"Z1!-JE0GF3<F5P;&%C:6YGCJ&-D2>  '1H998$F;AR=6QE+)$$X
MQ7QWFJQR99-M86N899-T:&63W')E='5R;M9E9)-T;VN896YSDV5X<&QI8VETX
M+)$$Q7QA;F2389AVF&]I9)-ADW>887)N:6YGDV9R;VV.H8V1)X  3W@NCJ&-X
MD3D?]$5A8Y"L<FB6 VS?<&%R<V4M=')E99-N;YI3CF1EDVQA8IAE;&5DDV*0X
MK')YD]QE>'!RD]9I<Y-T:&63<F^8;W23;V:389-S=6)T<F5EDV-O<G)E<W"8X
M;VYD+8ZAC9$G@ !I;F>6 ^JH=&^389-S=6*04XYE>'!R97-S:6]N+I$%..!0X
M;&%C:6YGDW1H99-A='1R:6)U=&639&5C;&%R871I;VXZCHZ?'@  C9( YY "X
M-8Z.C(L    &                                                X
M   ?*J "<@  C:#]M0  H (M  "-H/WV  "-D49@ =Q 871T<FEB=71E<Y8&X
M+,U[;&]N9Y-V86P[?9-E>'!RCI\8@ "-D2>  -9I;I8%;O-T:&6362T,;&63X
M8V%U<V5SDW1H99-/>"UG96YE<F%T9623=')A;G-L871O<I-T;Y-A;&QOD%..X
M8V%T99-S<&%C99,H86Z3870MCJ0.@ "-D2>  '1R:6)U=&66!%'R:6YS=&%NX
M8V4IDV9O<I-AD]QL;VYGD]9N86UE9)/<=F%LD]9E86.0K')HDW1I;663:723X
M8W)E871E<Y-ADVYOFE..9&63;&%BF&5L962.H8V1)X  8I"L<GF1 ^JHW&5XX
M<'+6+HZAC9$Y'_14:&6;!=K1V6*6_V9F;Y-D>9$&Z%/6*'1H99AP87)TF&*0X
M4XYE=)6L<G>3965NF&-U<FQYF&)R86-E<RF8;V:886Z8871T<FEB=71EF&1EX
M8VQA<F%T:6]NCJ&-D2>  ')E<V5MD*QR8FQE<Y8#W %T:&%TDV]FDV&30Y-SX
M=')U8W1U<F639&5C;&%R871I;VXLD0/>[V5X8V5P=)-T:&%TDV-U<FQYDV)RX
M86-E<Y-C86YN;W2.H8V1)X  8I!3CF61 ^JH;F5S=&5D+HV-G_NE,K@SCHZ.X
MH8V1.1_TUE1H998%3X-D90QN:71I;VYSDV9O<I-T:&63W'9A;)/6871T<FEBX
M=71EDV]FD]QE>'!RD]9A<F63<V5E;I-I;I-T:&63V6%T=')I8G5T98ZAC9$GX
M@ !REO]F9F5F97*396YCDV61!(^T<V638W1I;VYSD05-)M8H8V^04XYD998$X
M3TEF<F%G;65NFJQR='.39&5L:6UI=&5DDV*8>9/<0-AFD]9A;F23W$#89]8IX
MDVENDW1H99-M;Y!3CF1I#&5DCJ&-D2>  %DM#&QE+I$%"?)%86.0K')HE@-=X
MWV]FDW1H99-A='1R:6)U=&639&4,;FET:6]N<Y-S=&%R='.3=VET:)-T:&63X
MV6EM<&QI8VET+6UOD?]F9F1ED0.QSF%N;G5N+8ZAC9$G@ !C:6%T;W*1!7/OX
MW$!IUBR;!#CL=VAO<V66!"E$;65A;FEN9Y-I<Y-E>'!L86EN9623:6Z3<V5CX
M=&EO;I,T+C$ND07TM4ENDW1H:7.397AA;7!L92R896%CD*QR:(ZAC9$G@ !AX
M='1R:6)U=&66 ^JH<F5F97)E;F-EDW-E8W1I;VZ38V]ND*QR=&%I;G.397AAX
M8W1L>9-O;F63871T<FEB=71EDV1E#&YI=&EO;BZ.D2>  * !27='B0  9F8 X
MF_]DGPL  (V-C9$-@Y"?_%[_LS..CI$2  /$09JXXW1T<FEB=71E<Y8#X71CX
M86Z38I!''663;V:386Z8>9-#DV9U;F1A;65NF'1A;)-O<I-D97)I=IAE9)-TX
MF'EPFD<=92Z1!A8C5&AEDT]XDV-OF&1EDVENDW-E8W1I;VZ3.(Z?#   C75SX
M97.6 U5586Z3871T<FEB=71EDW1H8723:7.389-#DW-T<G5C='5R92Z.CI\>X
M  "-D@#GD +6-HZ.C(L    '                                    X
M               G9* "<@  C:#]M0  H (M  "-H/WV  "-D2>  ,HE=&]KX
M96Z1!3_]24-/3E-4CJ0,  "-D2>  "5L969TE@4__2<K)Y,G+2>.H8V1)X  X
M)6QE9G26!3_])RHGDR<O)XZI&   C9$G@ ! 871T<FEB=71E<Y8%/_U[8VAAX
M<I,J<W1R:6YG.Y-]DTE#3TY35(ZAC9$G@ ! 871T<FEB=71E<Y8%/_U[;&]NX
M9Y-V86P[?9$??^YE>'!RCJ:-D2>  "4ECJ&-D2>  &5X<'*6%/_T.I$DO^MEX
M>'!RDR<J)Y$:/_%E>'!RCJ&-D7M_T$![E@4__4!IDT!E>'!R+C N=F%L0),]X
MDT!E>'!R+C$N=F%L0),JDT!E>'!R+C(N=F%L0#N1"G_Z0'V.IHV147_H?)$DX
MO^ME>'!RD13_]"<O)Y$:/_%E>'!RCJ&-D7M_T$![E@4__4!IDT!E>'!R+C NX
M=F%L0),]DT!E>'!R+C$N=F%L0),ODT!E>'!R+C(N=F%L0#N1"G_Z0'V.IHV1X
M47_H?)$DO^ME>'!RD13_]"<K)Y$:/_%E>'!RCJ&-D7M_T$![E@4__4!IDT!EX
M>'!R+G9A;$"3/9- 97AP<BXQ+G9A;$"3*Y- 97AP<BXR+G9A;$ [D13_]$!]X
MCJ:-D5%_Z'R1)+_K97AP<I$4__0G+2>1&C_Q97AP<HZAC9%[?]! >Y8%/_U X
M:9- 97AP<BXP+G9A;$"3/9- 97AP<BXQ+G9A;$"3+9- 97AP<BXR+G9A;$ [X
MD0I_^D!]CJ:-D5%_Z'R1)+_K)R@GD1H_\65X<'*1%/_T)RDGCJ&-D7M_T$![X
ME@4__4!IDT!E>'!R+C N=F%L0),]DT!E>'!R+C$N=F%L0#N163_-0'V.IHV1X
M47_H?)$DO^M)0T].4U2.H8V1>W_00'N6!3_]0&F30&5X<'(N=F%L0),]DV%TX
M;VDH0$E#3TY35"YS=')I;F= *3N1-'_B0'V.H8V147_H.XZAC9$G@  E)8ZAX
MC9$G@ !M86EN*"F.H8V1,?_Z>W)E='5R;BAY>7!A<G-E*"DI.XZAC9$Q__I]X
MCI\9YF:-D3D?]-94:&66 IQP9W)A;6UA<I-S>6V0K')BD%..;VR3W&5X<'*3X
MUFAA<Y-T:')E99/99W*6_V9F86UM87(M<WEM8I-O;)$#  %ODV.38W5R<I-EX
M;F.397.1 YI-UBAN86UE;'F.J0Z  (V1)X  W&5X<'(N,-8LE@/JJ-QE>'!RX
M+C'6+)-A;F23W&5X<'(N,M8IDVENDW1H99-G<F%M;6%RDW)U;&4ZCJ073,V-X
MD49@ =QE>'!REABS-#J1*SF;97AP<I,G*B>1'N !97AP<HZAC9$G@ #606Z;X
M ^G!V6%T=')I8G5T99$$,F%OEO]F9F.38W5R<I-E;F.399$$SW'6*&-O;F-IX
M<V5L>3J1!3AM86Z8V6^38Y-C=7)RDV5N8Y-ED0#EL-8IF&ESF&&89W)A;6UAX
M<BUS>6V0K')BE5..;VR8;Y-C+8ZFC9$G@ !C=7)R96YC998%"[IT;V=E=&AEX
M<I-W:71HDV%NDV%T=')I8G5T99-O9I-T:&63<WEMD*QR8I!3CF]L+I$(G!=!X
M;I/9871T<FEB=71ED04\ZG*6_V9F969E<I-E;F.398ZFC9$G@ #6=&%KD*QRX
M97.6 ^JH=&AEDV9O<FTZCJ:FC9$Y'_3<0-EG<I;_9F9A;6UA<G-Y;6*3;VS<X
M+M9;V6EN=&639V5RW"[67=EA='1R:6)U=&5N86UEW$".IJ:-D2>  -9W:&5RX
M998%+(;9871T<FEB=71E;F%M99$&$C;687!PFE..96%R<Y-A<Y-A;I-I9&5NX
MD*QR=&D,97*3:6Z3=&AEDV*8;YAD>9-O9I-T:&63871T<FEB=71ECHZ?'@  X
MC9( YY "-XZ.C(L    (                                        X
M           L+* "<@  C:#]M0  H (M  "-H/WV  "-D2>  -9D96-L87)AX
M=&EO;I8$V)1F;W*3V6=REO]F9F%M;6%R<WEM8I-O;-8ND0@"I$EFE@38E&ENX
MD*QR=&5G97*3:7.3V6[6+)$%% ]T:&63<F5F97)E;F-EDVESDW1ODW1H99/9X
M;M9T:(ZD#H  C9$G@ !OD%..8V-U<G)E;F-EE@-.)&]FD]EG<I;_9F9A;6UAX
M<G-Y;6*3;VR1!(RWUF-O=6Z0K')T:6YGE@-.)&9R;VV3=&AEDVQE9G23;V:3X
M=&AEDW)U;&63*'1H99-L969T;6]S=(ZAC9$G@ !OE5..8V-U<G)E;F-EFP39X
MQV*396EN9YAT:&68,'1H*2Z1" 8]5&AEF'-Q=6%R99AB<F%CE:QR:Y-E='.8X
M86*04XYODW:399AD96YO=&68=&AA=)C9:6YT99'_9F9G97*.H8V1)X  UF%NX
M9)8#ZJAT:&63<V5C;VYDD]PND04XX-9A<F63;W!T:6]N86R3*'1H99-D969AX
M=6QTDW:1_UCD86QU99-F;W*3V6EN=&61_V9F9V5RD04U4]9BD%..96EN9Y,PX
M*2Z.H8V1.1_TV4&0LS)T=')I8G5T99$$.:ED90QN:71I;VYSD03OB]9A<F66X
M _&N8F%S:6-A;&QYDT.38V^04XYD99-F<F%G;65NFJQR='.38V]NF'1A:6YIX
M;F>3871T<FEB=71ECJ&-D2>  ')E9F5R96YC97,ND07.HTENE@0<E&=E;F5RX
M86PLD00I#F%NDV%T=')I8G5T99-D90QN:71I;VZ3<V5C=&EO;I-C;VZ:K')TX
M86EN<Y-Z97)ODW1ODVUA;IAYCJ&-D2>  &%T=')I8G5T998$,%]D90QN:71IX
M;VYS+I$&"@5%86.:K')HDV%T=')I8G5T99-D90QN:71I;VZ3:7.386YN;W5NX
M8V5DDV*8>9-ADVUOD%..9&6386XMCJ&-D2>  &Z:K')U;F-I871O<BR6 ^JHX
M86YDDW1E<FUI;F%T96238IAYD]Q V&>3UF]RDV*8>9-T:&63;F5X=)-M;Y!3X
MCF1EDV%N;IAU;F-I871O<BZ.GR@+QXV-D2>  .<TCI%%3LY/<F1E<I8&G[QOX
M9I-!D?]RL'1T<FEB=71E+4EN<W1A;F-EDT5VD?[E8&%L=6%T:6]NCI\:8B.-X
MD2>  -9!FJQR='1R:6)U=&66!"4X9W)A;6UA<G.3<W"04XYE8VEF>9-S96UAX
M;IAT:6-SDVENDV&3V61EEO]F9F-L87*3871I=F61!0KHUF]RD00E.-EF=6YCX
M=&EO;F%LD05CR]8H<F%T:&5RCJ&-D2>  '1H86Z6 X_]<V5Q=65NFJQR=&EAX
M;)-O<I-I;7"04XYE<F%T:7:892F3<W28>6QE+I$%&J=7:&5NDV&3<&%R<V63X
M=')E99-I<Y-C<F5A=&5D+)$#HA]T:&63=')E92=SCJ&-D2>  &%T=')I8G5TX
M998#$+-I;G-T86YC97.387)EDV5VD?]8Y&%L=6%T9623:6Z386Z3;W)D97*3X
M8V]N<W1R86EN9623*&)U=)-N;W239G5L;'F39&5T97(MCJ&-D2>  &UI;F5DX
M*98#'QQBD*QR>9-T:&63871T<FEB=71EDV=R86UM87(ND03U!TETDVESDV-LX
M96%RDW1H8723:6Z3=&AEDV5X86UP;&63;V:3<V5C=&EO;I,S+(ZAC9$G@ !AX
M;&R6 W_FW'9A;)/6:6YS=&%N8V5SDVENDW1H99-L96%FDVYOFE..9&5SDVV0X
MK')U<W238IAEDV5VD?]8Y&%L=6%T96238IAE9F]R99-T:&63W'9A;)/6:6YSX
M=&%N8V6.H8V1)X  ;V:6 ^JH=&AEDW)OFE..;W23;F^89&4NCJ&-D3D?]$]XX
ME@5*>2AR871H97*3=&AA;I-T:&638V]M<&EL97*39&5S:6=N97(IDV=E;F5RX
M871E<Y-C;Y!3CF1EDW1H87238V%U<V5SDVEN+8ZAC9$G@ !S=&%N8V5SE@/JX
MJ'1ODV*04XYEDV5VD?]8Y&%L=6%T9623:6Z389-C;W)R96-TDV]R9&5R+HZ?X
M(L$<C8V1)X  XC0N,8Z133A 1&5PD'7"96YD96YC>98%A1QR96QA=&EO;G.3X
M:6Z3=&AEDUDM#&QECI\3P "-D2>  -94:&5R998%L\-I<Y-ADV-O;G-T<F%IX
M;IJL<G239F]RDV5A8YAHDV=R86UM87*3<G5L99-I;I-T:&6362T,;&4ZD0C+X
M%F&3V61E<)'_9F9E;F1E;F-YCJ0,  "-D2>  '*1_V9F96QA=&EO;I$$T%C6X
M;VZ6 ^JH=&AEDV%T=')I8G5T99-OD%..8V-U<G)E;F-E<Y-I;I-T:&%TDW)UX
M;&4ND04XX$:1_P56;W*3=&AEDW)U;&4ZCI\5R'V-D2>  ,IE>'!REA3_]#J1X
M)+_K97AP<I,G*B>1&C_Q97AP<HZAC9%[?]! >Y8%/_U :9- 97AP<BXP+G9AX
M;$"3/9- 97AP<BXQ+G9A;$"3*I- 97AP<BXR+G9A;$ [CJ&-D7M_T$!]CI\8X
M2'V-D2>  -9T:&5R998#ZJAI<Y-T:&638V]N<W1R86END*QR=)-T:&%TDVENX
M<W1A;F-E<Y-C;W)R97-PD%..;VYD:6YGDW1OD]QE>'!R+C$N=F%LD]9A;F2.X
MI Z  (V1)X  W&5X<'(N,BYV86R6!7*BUFENDW-I8FQI;F>3<&%R<V4M=')EX
M99-N;YI3CF1E<Y-MD*QR=7-TDV*899-E=I'_6.1A;'5A=&5DDV*8969O<F63X
M=&AEDV]N98ZAC9$G@ !C;W)R97-PFE..;VYD:6YGE@/JJ'1OD]QE>'!R+C NX
M=F%LD]9I;I-T:&5I<I-P87)E;I"L<G23;F^89&4NCJ&-D3D?]$5A8YJL<FB6X
M [$V<G5L92=SDV1E<)!3CF5N9&5N8WF3<F5L871I;VZ3:7.39&5T97)M:6YEX
M9)-BF'F3:71SDVEN9&EV:61U86R3871T<FEB=71ECJ&-D2>  &1E#&YI=&EOX
M;G,ND0?,1E1H97)EE@3&=6%R99-S97::K')E<F%LDVUOD%..9&5SDV9O<I-CX
M;VUMF'5N:6-A=&EN9Y-D97"04XYE;F1E;F-YDVEN9F]R+8ZAC9$G@ !M871IX
M;VZ6! H_=&^33W@ND067I51H99/9:6UP;&EC:721!% ^;6^1_V9F9&61!._OX
MUFES+)L$$B5F;W*3;6]S=)-/>)-T<F%N<VQA=&]R<RR8=&AEDV]N;'F3<W5CX
MD*QR:(ZAC9$G@ !M;YI3CF1EE@/JJ&YE961E9"Z1!3C@5&AED]EE>'!L:6-IX
M=)$$,S5M;Y'_9F9D99$$T%C6:7.39&5S8W)I8IAE9)-B<FEE#7F3:6Z3<V5CX
M=&EO;I,Y+C<NCJ&-D3D?]%1H998$!?5I;7!L:6-I="UM;Y!3CF1EDV%N;I"LX
M<G5N8VEA=&]RD]Q :9/6*'-E99-T:&6397AA;7!L99-I;I-S96-T:6]NDS,IX
MDW-I9VYA;'..H8V1)X  =&^6!$^53WB3=&AEDV*04XYE9VEN;FEN9Y-O9I-AX
M;I-A='1R:6)U=&639&4,;FET:6]N+I$&9Z9&D?\%5G5R=&AE<BR1!&C0:723X
M:6YF;W)M<Y-/>)-T:&%TCHZ?'@  C9( YY ".(Z.C(L    )            X
M                                       Q]J "<@  C:#]M0  H (MX
M  "-H/WV  "-D2>  -9A;I8$C)!I;G-T86YC99-C;W)R97-PD%..;VYD:6YGX
MDW1ODW1H99-D90QN:71I;VXG<Y/9;&5F=&UO<W21!;#4UF%T=')I8G5T99-RX
M969E<F5N8V63:7..I Z  (V1)X  =&^6 TT[8II3CF6397:1_UCD86QU871EX
M9)/9869T97*1!)?FUG1H;W-EDV-O<G)E<W"8;VYD:6YGDW1ODV]T:&5RDV%TX
M=')I8G5T99-R969E<F5N8V5SDVENDW1H98ZAC9$G@ !D90QN:71I;VXND08QX
MNE1H:7.6!#V;:7.3=&^3<V&0K')YDW1H8723=&AEDV^:4XYC8W5R<F5N8V63X
M8V]R<F5S<)AO;F1I;F>3=&^3=&AEDVQE9G1M;W-TCJ&-D2>  ')E9F5R96YCX
M998$AYO99&5PD?]F9F5N9'.1!,-X;VZ1!6U+UG1H99-OFE..8V-U<G)E;F-EX
M<Y-C;W)R97-PF&]N9&EN9Y-T;Y-T:&63;W1H97*3<F5F97)E;F-E<XZAC9$GX
M@ !I;I8#ZJAT:&639&4,;FET:6]N+HZ?(LJKC8V1)X  XC0N,HZ133A 1&5PX
MD'7"96YD96YC>98%A1QR96QA=&EO;G.3:6Z3=&AEDTPM#&QECI\60 "-D2> X
M -9.;W1EE@6O#71H8723=&AEDVUOFE..9&6386YND*QR=6YC:6%T;W*3W$!IX
MD]9D;YAE<Y-N;W2387!PF&5A<I-I;I-T:&633"T,;&63;V:3=&AECJ&-D2> X
M &5X86UP;&66!3'#:6Z3<V5C=&EO;I,S+IL)#C%-;Y!3CF1EDV%N;I"L<G5NX
M8VEA=&]R<Y-A<F63;F]TDW5S9623:6Z33"T,;&5S+IA!;I-A="V.H8V1)X  X
M=')I8G5T998%17]R969E<F5N8V63<V5C=&EO;I-I;I-A;I-,+0QL99-I<Y-EX
M>&5C=71E9)-A<Y-ADW=H;VQEDW=H96YE=I"L<F5RDW1H98ZAC9$G@ !C;W)RX
M97-PD%..;VYD:6YGE@.0[VQE>&EC86R3<G5L99-I<Y-M871CFJQR:&5D+I$%X
M&OA);I-T:&6397AA;7!L92R1 Z+A=&AI<Y-I<Y-D;VYEDW=H96YE=IAE<HZAX
MC9$G@ !T:&66!1SJ3&5X+6=E;F5R871E9)-S8V%N;F5RDVUA=&.0K')H97.3X
M89-D:6=I=)-S=')I;F<ND0C/I45X96-U=&EN9Y-A;I-A='1R:6)U=&6.H8V1X
M)X  <F5F97)E;F-EE@3=!7-E8W1I;VZ3;6&:K')YDVENF':8;VQVF&63=&AEX
MDV5VD?]8Y&%L=6%T:6]NDV]FDW-E=IAE<F%LDV%T=')I8G5T99-I;G-T86YCX
M97,NCJ&-D2>  $%NE@,&^6%T=')I8G5T99-R969E<F5N8V63<V5C=&EO;I-IX
M;I-T:&633"T,;&63;9JL<G5S=)-C;VZ8=&%I;I-E>&%C=&QYDV]N99-A='1RX
M:6)U=&6.H8V1)X  <F5F97)E;F-EE@01^F9O<I-E86.0K')HDV%T=')I8G5TX
M99-OD%..8V-U<G)E;F-EDV1E#&YE9)-T:&5R99,H:6Z3=&AEDW!R979I;W5SX
MDV5X86TMCJ&-D2>  '!L92R6 ^JH=&AA=)-F;W*3W$E#3TY35"YS=')I;F?6X
M*2Z.GR@55HV-D2>  .<UCI%%3LY5<VEN9Y8&G[QG;&]B86R3=I'^Y6!A<FEAX
M8FQE<XZ?&F(CC9$G@ #609JL<G1T<FEB=71EE@0-W7)E9F5R96YC99-S96-TX
M:6]N<Y-C86Z38V]NF'1A:6Z386Z8>9-#DV-OD%..9&4LD006JFEN8VQU9&ENX
M9Y-R969E<F5N8V5SDW1OCJ&-D2>  &=L;V)A;)$#ZJAVD?]8Y&%R:6%B;&5SX
M+HZAC9$Y'_1);I8"H2%O=7*3<G5N;FEN9Y-E>&%M<&QE+)$"XPEWFJQR99-HX
M89AVF&5N)W23>9AE=)-S:&^8=VZ3:&^8=Y-T;Y-P<FENF'23=&AEDVUA:6Z3X
M<F5S=6QTCJ&-D2>  &]FE@0U*'1H99-S96UA;IJL<G1I8Y-A;F%L>7-I<Y,HX
M:2YE+BR1!$?)=&AEDW:1_UCD86QU99-O9I-T:&6397AP<F5S<VEO;BDND088X
M851H99-A<'!R;V%CF&B3:7..H8V1)X  =&^6!,M'8V]PD*QR>9-T:&63W'9AX
M;)/6871T<FEB=71EDVEN<W1A;F-EDV]FDW1H99-R;YI3CF]TDVYOF&1EDVENX
MD*QR=&^389-G;&]B86R3=I'_6.1A<FEA8FQE+(ZAC9$G@ !T:&5NE@24H'!RX
M:6Z:K')TDVETDV%F=&5RDW1E<FUI;F%T:6]NDV]FD]QY>7!A<G-E*"G6+I$'X
M-L=7D?\%5F63:6Z8=')OD%..9'5C99-ADW5N:7%U99-S=&%R=(ZAC9$G@ !PX
M<F^:4XYD=6-T:6]NE@/X7F9O<I-T:&ESDW!U<G"8;W-E+I$%8@%4:&633"T,X
M;&63;F5E9)-N;W238IAEDV.:K')H86YG960ND05B 4AE<F63:7.3<VAOF'=NX
MCJ&-D2>  '1H998#ZJAN97>362T,;&4LDW=I=&B38YJL<FAA;F=E9)-O<I-AX
M9&1E9)-L:6YE<Y-M87)KF&5DDV*8>9-E;7!TF'F30Y-C;VUM96Z8=',ZCHZ?X
M'@  C9( YY ".8Z.C(L    *                                    X
M               \\: "<@  C:#]M0  H (M  "-H/WV  "-D2>  ,HE=&]KX
M96Z1!3_]24-/3E-4CJ0,  "-D2>  "5L969TE@4__2<K)Y,G+2>.H8V1)X  X
M)6QE9G26!3_])RHGDR<O)XZI&   C9$G@  E>Y(!17]&+RJ1!3_]*B^.H8V1X
M)X  ;&]N9Y8%/_UG;&]B5F%L.Y(!"[]G+RJ3*B^.H8V1)X  )7V2 45_1B\JX
MD04__2HOCJ:-D2>  $!A='1R:6)U=&5SE@4__7MC:&%RDRIS=')I;F<[?9-)X
M0T].4U2.H8V1)X  0&%T=')I8G5T97.6!3_]>VQO;F>3=F%L.WV1&C_Q<Y-EX
M>'!RD@"=?Z8O*I,J+XZAC9$G@  E)8ZAC9$G@ !SEB2_ZSJ397AP<I( YO]\X
M+RJ1!3_]*B^.H8V1>W_00'N6!3_]0&F39VQO8E9A;),]DT!S+G9A;$"3/9- X
M97AP<BYV86Q .Y$??^Y ?9$/O_<O*I,J+XZAC9%1?^@[D@$@OULO*I$%/_TJX
M+XZFC9$G@ !E>'!REA3_]#J1)+_K97AP<I,G*B>1&C_Q97AP<HZAC9%[?]! X
M>Y8%/_U :9- 97AP<BXP+G9A;$"3/9- 97AP<BXQ+G9A;$"3*I- 97AP<BXRX
M+G9A;$ [D0I_^D!]CJ:-D5%_Z'R1)+_K97AP<I$4__0G+R>1&C_Q97AP<HZAX
MC9%[?]! >Y8%/_U :9- 97AP<BXP+G9A;$"3/9- 97AP<BXQ+G9A;$"3+Y- X
M97AP<BXR+G9A;$ [D0I_^D!]CJ:-D5%_Z'R1)+_K97AP<I$4__0G*R>1&C_QX
M97AP<HZAC9%[?]! >Y8%/_U :9- 97AP<BYV86Q DSV30&5X<'(N,2YV86Q X
MDRN30&5X<'(N,BYV86Q .Y$4__1 ?8ZFC9%1?^A\D22_ZV5X<'*1%/_T)RTGX
MD1H_\65X<'*.H8V1>W_00'N6!3_]0&F30&5X<'(N,"YV86Q DSV30&5X<'(NX
M,2YV86Q DRV30&5X<'(N,BYV86Q .Y$*?_I ?8ZFC9%1?^A\D22_ZR<H)Y$:X
M/_%E>'!RD13_]"<I)XZAC9%[?]! >Y8%/_U :9- 97AP<BXP+G9A;$"3/9- X
M97AP<BXQ+G9A;$ [D5D_S4!]CJ:-D5%_Z'R1)+_K24-/3E-4CJ&-D7M_T$![X
ME@4__4!IDT!E>'!R+G9A;$"3/9-A=&]I*$!)0T].4U0N<W1R:6YG0"D[D31_X
MXD!]CJ&-D5%_Z#N.H8V1)X  )26.H8V1)X  ;6%I;B@ICJ&-D3'_^GMY>7!AX
M<G-E*"D[D@$+OV<O*I$%/_TJ+XZAC9$W/_=P<FEN=&8H(B5D7&XB+&=L;V)6X
M86PI.Y( QW^.+RJ1!3_]*B^.H8V1,?_Z?8Z?&X  C9$Y'_3657"04XYO;I8%X
M)Y]C;VUP;&5T:6]NDV]FDW1H99-C86QLDW1OD]QY>7!A<G-EUBR1!7;==&AEX
MDW1R964G<Y-A='1R:6)U=&63:6YS=&%N8V5SCJ0.@ "-D2>  &AAE:QR=I-EX
ME@.0JF%L;)-BD%..965NDV5VF_]8Y&%L=6%T960ND04:X51H99-E=IAA;'5AX
M=&EO;I-O9I/<0',N=F%L0)/696Z:K')T86EL<Y-A;I-A<W-I9VYM96Z8=)-TX
M;XZAC9$G@ #<9VQO8E9A;-8ND04XX%1H998#ZJAP<FENFJQR=&EN9Y-O9I/<X
M9VQO8E9A;)/6:7.3=&AEDVQA<W23=&AI;F>39&]N99-BF'F3=&AEDV-A;&-UX
M;&%T;W(NCHZ?'@  C9( Y* $,3".CHR+    "P                      X
M                            12*@ G(  (V@_;4  * "+0  C:#]^   X
MC8V1)X  YS:.D45.SE"6_W*P87)S92UT<F5ED0:?O'1R89-VDV5R<V%L<XZ?X
M&F(CC9$G@ #609$$8J-P87)S998$8L)T<F5EDVESDVV5K')U8Y-HE@1BPFUOX
M<F63=7-E9G5LDVEFDVETDV-A;I-BD%..99-T<F&5K')VDV5R<V5D+)$$@,AAX
M;F26!&+":6:3:71SDV%T=')I8G5T98ZD#H  C9$G@ !I;G-T86YC97.6 _PLX
M8V%NDV*04XYEDV%C8V5S<V5DDV1U<FEN9Y-T<F&5K')VDV5R<V%L<RZ1!6UMX
M4W5CDVB; _PL=')ADW:397)S86QSF&%R99AP87)T:6-U;&%R;'F.H8V1)X  X
M=7-E9G5LE@4:M69O<I-C;YI3CF1EDV=E;F5R871I;VXND0C)!D]XDV-A;I-BX
MF&63:6YS=')U8W1E9)-T;Y-G96YE<F%T99-ADW1R86YS;&%T;W*.H8V1)X  X
M=&AA=)8$+CUPD%..97)F;W)M<Y-VF_]8Y&%R:6]U<Y-K:6YD<Y-O9I-T<F&5X
MK')VDV5R<V%L<Y8$+CUA9G1E<I-E=IAA;'5A=&EO;I-O9I-A;&R3;V:3=&AEX
MDW1R964G<XZAC9$G@ !A='1R:6)U=&61 ^JH:6YS=&%N8V5S+HZ?(LJKC8V1X
M)X  XC8N,8Z133A 07!P;&EC871I;VXZD0=<)71R86YS;&%T:6]NE@6%''1OX
MDW!R90QXCI\60 "-D2>  -94:&66!$D[9F]L;&^0K')W:6YGDUDM#&QEDW-PX
MD%..96-I#&5SDV%NDV5X<')E<W-I;VZ3<&%R<V5RDW1H8723=')A;G-L871EX
M<Y-I='.3*&EN#'@ICJ&-D2>  &EN<'5TE@.\7'1ODW!R90QXDV9O<FTND04IX
M<51H99-,+0QL99-I<Y-T:&63<V%M99-A<Y-T:&%TDV]FDW1H99-P<F5V:6]UX
M<Y-E>&%M<&QE+HZ.GQX  (V2 .2@!#$QCHZ,BP    P                 X
M                                 $J?H )R  "-H/VU  "@ BT  (V@X
M_?8  (V1)X  RB5T;VME;I$%/_U)0T].4U2.I P  (V1)X  )6QE9G26!3_]X
M)RLGDR<M)XZAC9$G@  E;&5F=)8%/_TG*B>3)R\GCJD8  "-D2>  $!T<F%VX
M97)S86R6!3_]0'!R96]R9&5RDWEO=7)4<F%VCJ&-D2>  $!T<F%V97)S86R6X
M!3_]0'!R96]R9&5RDWEO=7)S5&]OCJ:-D2>  $!A='1R:6)U=&5SE@4__7MCX
M:&%RDRIS=')I;F<[?9-)0T].4U2.H8V1)X  0&%T=')I8G5T97.6!3_]>VQOX
M;F>3=F%L.WV1&C_Q<Y-E>'!RCJ&-D2>  "4ECJ&-D2>  '.6)+_K.I-E>'!RX
MCJ&-D7M_T$![E@4__4!IDT!S+G9A;$"3/9- 97AP<BYV86Q .XZAC9( BS_'X
M0'EO=7)S5&]OD04__7!R:6YT9B@B7&XE9%QN(BQ <RYV86Q *3N.H8V1>W_0X
M0'V.H8V147_H.XZAC9$G@ !E>'!REA3_]#J1)+_K97AP<I,G*B>1&C_Q97APX
M<HZAC9%[?]! >Y8%/_U :9- 97AP<BXP+G9A;$"3/9- 97AP<BXQ+G9A;$"3X
M*I- 97AP<BXR+G9A;$ [CJ&-D@"+/\= >6]U<E1R87:6!3_]<')I;G1F*"*3X
M*I,B*3N.H8V1>W_00'V.H8V147_H?)$DO^ME>'!RD13_]"<O)Y$:/_%E>'!RX
MCJ&-D7M_T$![E@4__4!IDT!E>'!R+C N=F%L0),]DT!E>'!R+C$N=F%L0),OX
MDT!E>'!R+C(N=F%L0#N.H8V2 (L_QT!Y;W5R5')A=I8%/_UP<FEN=&8H(I,OX
MDR(I.XZAC9%[?]! ?8ZAC9%1?^A\D22_ZV5X<'*1%/_T)RLGD1H_\65X<'*.X
MH8V1>W_00'N6!3_]0&F30&5X<'(N=F%L0),]DT!E>'!R+C$N=F%L0),KDT!EX
M>'!R+C(N=F%L0#N.H8V2 (L_QT!Y;W5R5')A=I8%/_UP<FEN=&8H(I,KDR(IX
M.XZAC9%[?]! ?8ZAC9%1?^A\D22_ZV5X<'*1%/_T)RTGD1H_\65X<'*.H8V1X
M>W_00'N6!3_]0&F30&5X<'(N,"YV86Q DSV30&5X<'(N,2YV86Q DRV30&5XX
M<'(N,BYV86Q .XZAC9( BS_'0'EO=7)4<F%VE@4__7!R:6YT9B@BDRV3(BD[X
MCJ&-D7M_T$!]CJ&-D5%_Z'R1)+_K)R@GD1H_\65X<'*1%/_T)RDGCJ&-D7M_X
MT$![E@4__4!IDT!E>'!R+C N=F%L0),]DT!E>'!R+C$N=F%L0#N.H8V1>W_0X
M0'V.H8V147_H?)$DO^M)0T].4U2.H8V1>W_00'N6!3_]0&F30&5X<'(N=F%LX
M0),]DV%T;VDH0$E#3TY35"YS=')I;F= *3N.H8V2 (L_QT!Y;W5R5')A=I8%X
M/_UP<FEN=&8H(I,E<Y,B+$!)0T].4U0N<W1R:6YG0"D[CJ&-D7M_T$!]CJ&-X
MD5%_Z#N.H8V1)X  )26.H8V1)X  ;6%I;B@ICJ&-D3'_^GMR971U<FXH>7EPX
M87)S92@I*3N.H8V1,?_Z?8Z.GQX  (V2 .2@!-8Q,HZ.C(L    -        X
M                                          !-S: "<@  C:#]M0  X
MH (M  "-H/WV  "-D2>  -94:&61 ^JH;&EN98ZD&(  C9%&8 '<0'1R879EX
M<G-A;)8&+,U <')E;W)D97*3>6]U<E1R87:.H8V1)X  UF1E8VQA<F5SE@/QX
MXF&3;&5F="UT;RUR:6=HFJQR=)-P<F5O<F1E<I-T<F&8=IAE<G-A;)-N86UEX
M9)/<>6]U<E1R87;6+I$%3HU3=7!PD%..;W-EDW1H8723:6Z.I Z  (V1)X  X
M;W5RE@-!R65X86UP;&4LD0-CCW1H99/<>6]U<E1R87:3UG1R896L<G:397)SX
M86R6 T'):&%SDW)E86.:K')H962389-N;Y!3CF1EDV%TDW=H:6.8:)-ADV=RX
M86UM87*.H8V1)X  <G5L998"N+SS++?A9Z, #     P    &8VUM:3$RUU*;X
M M(&UFESDV%P<&QI960ND032YTEFDW1H99-A='1R:6)U=&63<F5F97)E;F-EX
MDW-E8W1I;VZ3;V:3UU*8UF-O;I"L<G1A:6YSDW1H99/9='*1_V9F879E<G-AX
M;"V.H8V1)X  ;6^1_V9F9&61!%$B86YN=6YC:6%T;W*6! LWW$!Y;W5R5')AX
M=I/6*'=H:6.:K')HDW>887.39VEVF&5NDVUE86YI;F>38IAYDVET<Y/<0'1RX
M879E<G-A;(ZAC9$G@ #69&5C;&%R871I;VXI+)$#-:YT:&5NE@,(;W1H99/<X
M<')I;G1FD]9S=&%T;65NFJQR=)-F;VQL;YAW:6YGD]Q >6]U<E1R87:3UFESX
MDV5X96-U=&5D+)$#-:YA;F2.H8V1)X  =&AEFP-]MG1R896L<G:397)S86R8X
M:7.88V]NDW1I;I-U96289F]RF'1H99AS=6)T<F5EF')OE5..;W1E9)AA=)ATX
M:&68;F^39&68:6Z8<75E<W1I;VXND044CU5S+8ZAC9$G@ !I;F>6 ]]'W$!PX
M;W-T;W)D97*3UFEN<W1E8623;V:3W$!P<F5O<F1E<I/6=YJL<F]U;&238V%UX
M<V6389-T<F&8=IAE<G-A;)-T:&%TDV5X96-U=&5SCJ&-D2>  '1H998%M5C<X
M<')I;G1FD]EA9G1E<I$'  /68V]M<&QE=&EN9Y-T:&63=')AE:QR=I-E<G-AX
M;)8%M5AO9I-T:&%TDW-U8G1R964LD08H!')E<W5L=&EN9Y-I;I-ACJ&-D2> X
M '"04XYO<W0,>)$#ZJAT<F%N<VQA=&EO;BZ.H8V1.1_T09$#O5]T<F&5K')VX
MDV5R<V%LE@.]:W1H872386-C97-S97.3=&AED]QV86R3UFEN<W1A;F-EDVENX
MDW1H99-R;YI3CF]TDVYOF&1EDVESDV%NDV%L=&5R;F$MCJ&-D2>  '1I=I"LX
M<F66 ^JH=&^3=7-I;F>3=&AEDV=L;V)A;)-VD?]8Y&%R:6%B;&63W&=L;V)6X
M86R3UF]FDW-E8W1I;VZ3-2Z1!3C@4&QA8VEN9Y-T:&63;&EN93J.I!B  (V1X
M1F !W$!T<F%V97)S86R6!BS-0'!R96]R9&5RDWEO=7)S5&]OCJ&-D2>  -9IX
M;I8#ZJAT:&639&5C;&%R871I;VYSDW-E8W1I;VXLDV%N9)-T:&63;&EN93J.X
MH8V11F !W$!Y;W5R<U1O;Y$&+,UP<FEN=&8H(B5D7&XB+$!S+G9A;$ I.XZAX
MC9$G@ #6:6Z6!'F6=&AEDV%T=')I8G5T99-R969E<F5N8V63<V5C=&EO;I-FX
M;W*3=&AEDW-T87)TDW!R;Y!3CF1U8W1I;VZ386-C;VUP;&ES:&5SDW1H98ZDX
M#H  C9$G@ !S86UEE@/JJ'1H:6YGDV%SDW1H99-U<V63;V:3W&=L;V)686S6X
M+HZAC9$Y'_1/;F6;!"L;=')AE:QR=I-E<G-A;)AI<YAD;VYEF&9O<IAE86.3X
M:)AT<F&3=I-E<G-A;)AD96-L87)A=&EO;BR1!#LW=&AEF'1R89-VDV5R<V%LX
M<YABD%..96EN9XZAC9$G@ !D;VYEE@-SIV]N99-A9G1E<I-A;F]T:&5R+)$#X
MBW1I;I-T:&63;W)D97*3:6Z3=VAI8Y"L<FB3=&AEDV1E8VQA<F%T:6]N<Y-AX
M<'"04XYE87(ND041-4ENDW1H98ZAC9$G@ !E>&%M<&QE+)L#EV5T:&66 X*4X
M9&5C;&%R871I;VZ3;V:3W'EO=7)S5&]OD]9A<'"04XYE87)SDV%F=&5RDW1HX
M8723;V:3W'EO=7)4<F%VUBR8<V^3=&AECJ&-D2>  ':1_UCD86QU998#ZJAOX
M9I-T:&6397AP<F5S<VEO;I-I<Y-P<FENFJQR=&5DDV%F=&5RDW1H99-P<F5OX
M<F1E<I-T<F%N<VQA=&EO;I-I<Y-P<FENF'1E9"Z.GR@55HV-D2>  .<WCI%%X
M3LY);FAE<FET9626!I^\=G,ND0C4^E-Y;IO_<K!T:&5S:7IE9)-!F'1T<FEBX
M=71E<XZ?&F(CC9$G@ #62726 Z@H:7.3=7-E9G5LDW1ODW1H:6YKDV]FDW1HX
M99-L97AI8V%LDW)U;&5SDRAI+F4N+)$#M75T:&63<G5L97.3:6Z3=&AEDTPMX
M#&QE*9-A<Y-V:7)T=6%LCJ&-D2>  &=R86UM87*6 MS3<G5L97.3*'!R;Y!3X
MCF1U8W1I;VYS*9-W:&]S99-R:6=HFJQR="UH86YDDW-I9&5SDV%R99-T:&63X
M96UP=)AYDW-T<FEN9Y-A;F2.H8V1)X  =VAO<V66!4#U;&5F="UH86YDDW-IX
M9&5S+)L%EHAW:&EL99-A8W1U86R369'_!59A8V.3=&]KD*QR96YS+)AA<F63X
M=FER='5A;)-N;VZ0K')T97)M:6YA;',NCJ&-D2>  %1H:7.6!3##9V5N97)IX
M8Y-C;VYC97!TDV]FD]ER=6QED086<]9I<Y-C;VYS:7-T96Z0K')TDW=I=&B3X
M=7-U86R38V]N8V5P='.3;V:3V6%T=')I8G5T98ZAC9$G@ !G<I'_9F9A;6UAX
M<I$!2JO6+)8#ZJAA;F23;&5A9'.3=&^3=&AEDV9O;&QOD*QR=VEN9Y-D90QNX
M:71I;VYS.HZAC9$Y'_1!;I8#ZJAA='1R:6)U=&63;Y!3CF-C=7)R96YC99/7X
M;Y/6:6Z389-R=6QED]=2D00#\M9I<Y/9<WEN=&AE<VEZ99'_9F9DD04I.]9IX
M9I-A;F23;VYL>9-I9HZ.GQX  (V2 .2@!#$SCHZ,BP    X             X
M                                     %+ H )R  "-H/VU  "@ BT X
M (V@_?8  (V-C8V1./_OV ^.CHZ11-_LUV^6 ^M0UFESDV]NDW1H99-,2%.3X
M;V:3UU*;! 2:UF%N9)-T:&63871T<FEB=71EDW)E9F5R96YC99-S96-T:6]NX
MDV]FD]=2F-9C;VZ0K')T86EN<XZD#H  C9%$W^QAE@/JJ&1E#&YI=&EO;I-OX
M9I/7;]8LDV]RCJD8@ "-C8V-D3C_[]@/CHZ.D43?[-=OE@/3<=9I<Y-O;I-TX
M:&634DA3D0/3:V]FD]=2FP/LN]9A;F23=&AEDV%T=')I8G5T99-R969E<F5NX
M8V63<V5C=&EO;I-O9I/74IC68V]ND*QR=&%I;G..H8V11-_L;F^6 ^JH9&4,X
M;FET:6]NDV]FD]=OUBZ.IHV1.1_T06Z6 ^JH871T<FEB=71EDV^04XYC8W5RX
M<F5N8V63UV^3UFENDV&3<G5L99/74I$$ _+6:7.3V6EN:&5R:71ED?]F9F21X
M!2D[UFEFDV%N9)-O;FQYDVEFCJ:-C8V-D3C_[]@/CHZ.D43?[-=OE@,B/-9IX
M<Y-O;I-T:&63;&5F="UH86YDDW-I9&63*$Q(4RF1 R();V:3UU*1 SN&UF%NX
M9)-T:&63871T<FEB=71EDW)E9F5R96YC99-S96-T:6]NCJ&-D43?[&]FE@/JX
MJ-=2D00#\M9C;VZ0K')T86EN<Y-N;Y-D90QN:71I;VZ3;V:3UV_6+)-O<HZFX
MC8V-C9$X_^_8#XZ.CI%$W^S7;Y8%DX?6:7.3;VZ3=&AEDW)I9VB0K')T+6AAX
M;F23<VED99,H4DA3*9$%DQIO9I/74I$%K-'686YDDW1H99-A='1R:6)U=&63X
M<F5F97)E;F-ECJ&-D43?['-E8W1I;VZ6 ^JH;V:3UU*1! /RUF-O;I"L<G1AX
M:6YSDV&39&4,;FET:6]NDV]FD]=OUBZ.IHV1.1_T3WB6!!,P:7-S=65SDV%NX
MDV5R<F]RDVUE<W-A9V63:6:3:723#&YD<Y-A;I-A='1R:6)U=&63=&AA=)-HX
M87.38I!3CF]T:)-S>6Z0K')T:&4MCJ&-D2>  '-I>F5DE@/F46%N9)-I;FAEX
M<FET9623;Y!3CF-C=7)R96YC97.3:6Z3=&AEDV=R86UM87(ND04W;D%NDV%TX
M=')I8G5T99-I<Y/9<WEN=&AE<VEZ99'_9F9DCJ&-D2>  -9I9I8"VR-A;F23X
M;VYL>9-I9I-I=)-H87.38723;&5A<W23;VYEDV^:4XYC8W5R<F5N8V4LD0,1X
M<6%N9)-I='.397:0K')E<GF3;YAC8W5R<F5N8V63:7.3<WEND*QR=&AE+8ZAX
MC9$G@ !S:7IE9"Z1!94I06Z6! EK871T<FEB=71EDVESD]EI;FAE<FET99'_X
M9F9DD05'_M9I9I-A;F23;VYL>9-I9I-I=)-H87.38723;&5A<W23;VYEDV^0X
M4XYC8W5R<F5N8V4LCJ&-D2>  &%N9)8%:H9I='.397::K')E<GF3;Y!3CF-CX
M=7)R96YC99-I<Y-I;FAE<FET960ND0FX>DETDV9O;&QOF'=SDV9R;VV3=&AEX
MDV%BD%..;YAVF&63=&AA=)-T:&6.H8V1)X  9W)A;6UA<B=SE@1\EW-T87)TX
MDW-Y;9JL<F*04XYO;)-C86Z3:&&8=IAEDV]N;'F3<WENF'1H97-I>F5DDV%TX
M=')I8G5T97,ND0;NKE)E9F5R<FEN9Y-T;XZAC9$G@ !R971U<FYE9)8$A.9TX
M;VN:K')E;G.387.3<G5L97.396UP:&%S:7IE<Y-T:&6397%U86R3<W1A='5SX
MDV]FDW1O:YAE;G.386YDDVYO;IAT97(MCJ&-D2>  &UI;F%L<RR1 \%7:6YAX
M<VV5K')U8Y-HE@.W F%SDV5A8YJL<FB3:VEN9)-O9I-S>6V88I!3CF]LDRAEX
M>&-E<'23=&AEDW-T87)TDW-Y;9ABD%..;VPIDV-A;I-H89AVF&6.H8V1)X  X
M8I!3CF]T:)8#R,!S>6Z:K')T:&5S:7IE9)-A;F23:6YH97)I=&5DDV%T=')IX
M8G5T97,ND04MDT5A8YAHDW-Y;9ABD%..;VR3:&%SDV&39&ES=&EN8W23;F%MX
M98ZAC9$G@ !S<&%C92R1 ]8Q<V^6 ]$4<V%M92UN86UE9)-A='1R:6)U=&5SX
MDV]FDV1I"V5R96Z:K')TDW-Y;9ABD%..;VQSDV%R99-D:7-T:6YC=)-A='1RX
M:6)U=&5S+(ZAC9$G@ !A;F26 ^JH8V%NDV1I"V5RDV%SDW1ODW=H971H97*3X
M=&AE>9-A<F63:6YH97)I=&5DDV]RDW-Y;I"L<G1H97-I>F5D+HZAC9$Y'_1&X
MD?\%5F]RE@.]"V5A8Y"L<FB3<&%R<V4M=')E99-N;YI3CF1EDV5X8V5P=)-TX
M:&63<F^8;W23;F^89&4LD0/&*G25K')WDV^6 [T+<G5L97.3;V:3=&AEDT]XX
MDVEN<'5TCJ&-D2>  '-PD%..96-I#&-A=&EO;I8%,N]A<F63;V:3<&%R=&ECX
M=6QA<I-I;I"L<G1E<F5S="Z1"1&V5&AED]EH;VUED05@\W)U;&61!AB?UFESX
MDW1H99-R=6QEDV%P<&QI962.H8V1)X  8726!4.D=&AEDVYOFE..9&4LE@69X
MXVDN92XLDW1H998%0Z1R=6QEDW=H;W-EDTQ(4Y$%0TMI<Y-T:&63;&%BF&5LX
MDV]FDW1H99-G:7:0K')E;I-N;YAD92R1!9GC86YDCJ&-D2>  '=H;W-EE@2$X
MM%)(4Y$$A(QS>6V0K')BFE..;VQSDV%R99-T:&63;&%BF&5L<Y-O9I-T:&63X
M8Y"L<FAI;&1R96Z3;V:3=&AEDVYOF&1E+I$'!P14:&63V7"6_V9F87*396YTX
MCJ&-D2>  ')U;&61!9#/UFESE@2K'W1H99-R=6QEDV%P<&QI96238723=&AEX
MDVYOD%..9&4G<Y-P87)E;I"L<G0ND0=Z1%1H99-A='1R:6)U=&639&4,;FETX
M:6]NDV]FDV&.H8V1)X  <WENFJQR=&AE<VEZ9626!#+=871T<FEB=71EDVENX
M<W1A;F-EDV]FDV&39VEVF&5NDVYOFE..9&63:7.387-S;YAC:6%T9623=VETX
M:)-T:&63;F^89&4G<XZAC9$G@ !H;VUEE@3!C7)U;&63*&DN92XLD03W1VETX
MDV%P<)!3CF5A<G.3:6Z3=&AEDV%T=')I8G5T99-R969E<F5N8V63<V5C=&EOX
M;I-F;W*3=&AA=)-R=6QE*2R.H8V1)X  86YDE@0#QV1E#&YI=&EO;G.3;V:3X
M:6YH97)I=&5DDV%T=')I8G5T99-I;G-T86YC97.387)EDW-I;6EL87)L>9-AX
M<W-OD%..8VEA=&5DDW=I=&B.H8V1)X  =&AEE@/JJ'!A<F5ND*QR=)-R=6QEX
M+HZAC9$Y'_1);I8$6U1ADVQE9V%LDVEN<'5TDW-PD%..96-I#&-A=&EO;BR1X
M!'=_96%CFJQR:)-A='1R:6)U=&63;V:389-S>6V88II3CF]LDV%P<)AE87)IX
M;F>3:6Z388ZAC9$G@ !R=6QEE@0"U6ESDV5I=&AE<I-S>6Z0K')T:&5S:7IEX
M9)-O<I-I;FAE<FET960LFP0(X&)U=)-N;W238I!3CF]T:"R8<V^3=&AEDV1EX
M#&YI=&EO;G.3;V:386QLCJ&-D2>  &%T=')I8G5T97.6 ^JH7 QTDW1O9V5TX
M:&5R(I-C;VUP;&5T96QYDV%N9)-W:71H;W5TDV-O;I"L<G1R861I8W1I;VXNX
MCHZ?'@  C9( Y* $,32.CHR+    #P                              X
M                    7&>@ G(  (V@_;4  * "+0  C:#]^   C8V1)X  X
MYSB.D45.SE5S:6YGE@:?O&EN:&5R:71E9)-A='1R:6)U=&5SCI\:8B.-D2> X
M -94:&ESE@1Z1'-E8W1I;VZ39VEVD*QR97.386Z397AA;7!L99-I;F1I8V%TX
M:6YGDW1H99-U<V63;V:3:6YH97)I=&5DDV%T=')I8G5T97.39F]RCJ0.@ "-X
MD2>  '-E;6%NFJQR=&ECE@2F &%N86QY<VESDVENF':8;VQV:6YGDW)I9VB8X
M=)-C;VZ8=&5X="Z1!VKH5&AEDV5X86UP;&6386QS;Y-G:7:897.389-BD%..X
M971T97*.H8V1)X  :61E898#ZJAO9I-H;Y"L<G>33WB38V^:4XYD99-I<Y-UX
M<V5DDW1O9V5T:&5RDW=I=&B30Y-C;YAD92Z.H8V1.1_T26Z6 QN[;6%NFJQRX
M>9-L86YG=6%G97,LD0-%'69O<I-I;G-T86YC99-0F&%S8V%L+)$#11UE86.8X
M:)-VD?]8Y&%R:6%B;&639&5C;&%R871I;VZ3:7.397-S96XMCJ&-D2>  '1IX
M86QL>98#RM!ADVQI<W23;V:3:61E;IJL<G1I#&5R<Y-F;VQL;YAWF&5DDV*8X
M>9-ADW28>7":4XYEDW-PF&5C:0QE<BZ1!2Y#2&5R99-WFJQR99-S:&^8=Y-AX
MDW-I;7!L98ZAC9$G@ !L86YG=6%G998$;.AW:&]S99-E=IJL<F5R>9-S96Z8X
M=&5N8V638V]N<VES='.3;V:3<W5CF&B389-VD?]8Y&%R:6%B;&639&5C;&%RX
M871I;VXND0:_GT]U<HZAC9$G@ !T<F%N<VQA=&]RE@1XCW!A<G-E<Y-T:&63X
M:6YP=70LD02<"7)E8V]R9&EN9Y-I;I-ADW-Y;9JL<F*04XYO;)-O8I$ IQQJX
M96-TDW1H99-I9&5NF'1I#&5RDV%N9(ZAC9$G@ !TFJQR>7"04XYEE@0TG&]FX
MDV5A8YAHDW:1_UCD87)I86)L99-D96-L87)E9"Z1!A:\5&AE;I-T:&63<WEMX
MF&*04XYO;)-O8I$ IQQJ96-T<Y-A<F63<')I;IAT96239'5R:6YGCJ&-D2> X
M &&6 ^JH<)!3CF]S=&]R9&5RDW1R896L<G:397)S86PNCJ0,  "-D3D?]$AEX
M<F66 ^JH:7.3=&AEDTPM#&QE.HZ?%@  C9$G@ #*)7N.H8V1)X  (VEN8VQUX
M9&61!3_](GDN=&%B+F@BCJ&-D2>  "-I;F-L=61ED04__3QS=')I;F<N:#Z.X
MJ1@  (V1)X  (V1E9FEN998%/_UL97AE;663<W1R8W!Y*"AC:&%RDRHI;6%LX
M;&]C*'EY;&5N9RLQ*2QY>71E>'0ICJ&-D2>  "5]CJ:-D2>  "4ECJ&-D2> X
M %N1!3_]7&Y<=%QF72N1*?_H.XZAC9$G@ !R96%LD4E_UG)E='5R;BA214%,X
M*3N.H8V1)X  :6YT96=E<I$YO]]R971U<FXH24Y4*3N.H8V1)X  8F]O;&5AX
M;I$YO]]R971U<FXH0D]/3"D[CJ&-D2>  %MA+7I!+5I=*Y$O/^5R971U<FXHX
M241%3E0I.Y$*?_I >Y8%/_U 241%3E0N<W1R:6YG0),]DVQE>&5M93N30'V.X
MH8V1)X  (BPBD4Z_TW)E='5R;B@G+"<I.XZAC9$G@  B.R*13K_3<F5T=7)NX
M*"<[)RD[CJ&-D2>  "(Z(I%.O]-R971U<FXH)SHG*3N.H8V1)X  +I%9/\U[X
M9G!R:6YT9BAS=&1E<G(L(FEL;&5G86R6!3_]8VAA<F%C=&5R7&XB*3N397AIX
M="@M,2D[?8ZAC9$G@  E)8ZD&(  C9$Y'_365&AEE@.3<F1E#&YI=&EO;G.3X
M:6Z3<V5C=&EO;I,WDW1O9V5T:&5RDW=I=&B3=&AEDV9O;&QOD*QR=VEN9Y-9X
M+0QL99-I;7!L>9-T:&%T.HZAC8V-C9$X_^_8#XZ.CI%$W^S<<W1R:6YGE@/JX
MJ-9I<Y-ADW-Y;I"L<G1H97-I>F5DDV%T=')I8G5T99-O9I/<241%3E36+HZAX
MC8V-C9$X_^_8#XZ.CI%$W^S<<WEME@/JJ-9I<Y-A;I-I;FAE<FET9623871TX
M<FEB=71EDV]FD]Q)1$5.5-8NCJ&-C8V-D3C_[]@/CHZ.D43?[-QT36%R:Y8#X
MZJC6:7.386Z3:6YH97)I=&5DDV%T=')I8G5T99-O9I/<=F%R3&ES=-8NCJ&-X
MC8V-D3C_[]@/CHZ.D43?[-QV87)$96-LE@/JJ-9H87.3;F^3871T<FEB=71EX
M<RZ.CI\>  "-D@#DH 0Q-8Z.C(L    0                            X
M                      !GQZ "<@  C:#]M0  H (M  "-H/WV  "-D2> X
M ,HE=&]K96Z6!3_]4D5!3)-)3E230D]/3)-)1$5.5(ZI&   C9$G@  E>XZDX
M#   C9$G@  C:6YC;'5D99$%/_T\<W1D;&EB+F@^CJ&-D2>  '-T<G5C=)8%X
M/_US>6V3>V-H87*3*G-T<BPJ='EP94UA<FL[?3N.IHV1)X  <W1R=6-TE@4_X
M_7-Y;9,J86QL;V-3>6TH8W L="F.H8V1,?_Z8VAA<I$%/_TJ8W L*G0[CJ&-X
MD3'_^GMS=')U8W26!3_]<WEMDRIP4WEM.XZAC9$W/_=P4WEME@4__3V3*'-TX
M<G5C=)-S>6V3*BF3;6%L;&]C*'-I>F5O9I,H<W1R=6-TDW-Y;2DI.XZAC9$WX
M/_=P4WEM+3YS='*6!3_]/9-C<#N3<%-Y;2T^='EP94UA<FN3/9-T.XZAC9$WX
M/_=R971U<FZ1!3_]<%-Y;3N.H8V1,?_Z?8ZAC9$G@  E?8ZFC9$G@ ! 871TX
M<FEB=71E<Y8%/_U[8VAA<I,J<W1R:6YG.Y-S=')U8W23<WEMDRIS>6T[DWV3X
M241%3E2.H8V1)X  0&%T=')I8G5T97.6!3_]>V-H87*3*G1-87)K.Y%CO\=]X
MDW9A<DQI<W2.H8V1)X  0'1R879E<G-A;)8%/_U <&]S=&]R9&5RDVUY5),OX
M*I-M>9-4<F%V97)S86R3*B^.IHV1)X  )26.H8V1)X  =F%R1&5C;)$4__0ZX
MD2G_Z'9A<DQI<W26!3_])SHGDU)%04R3)SLGCJ&-D@"0?\1 >Y8%/_U :9- X
M=F%R3&ES="YT36%R:T"3/9,B<F5A;"([D13_]$!]CJ:-D6$_WWR1*?_H=F%RX
M3&ES=)8%/_TG.B>324Y4DR<[)XZAC9( D'_$0'N6!3_]0&F30'9A<DQI<W0NX
M=$UA<FM DSV3(FEN=&5G97(B.Y- ?8ZFC9%A/]]\D2G_Z'9A<DQI<W26!3_]X
M)SHGDT)/3TR3)SLGCJ&-D@"0?\1 >Y8%/_U :9- =F%R3&ES="YT36%R:T"3X
M/9,B8F]O;&5A;B([DT!]CJ&-D6$_WSN.IHV1)X  =F%R3&ES=)$4__0ZD2G_X
MZ$E$14Y4CJ&-D@"0?\1 >Y8%/_U :9- 241%3E0N<WEM0),]CJ&-D@"Z?ZQAX
M;&QO8U-Y;2A 241%3E0N<W1R:6YG0"Q =F%R3&ES="YT36%R:T I.XZAC9( X
MH#^[0&UY5)8%/_UP<FEN=&8H(B5S.I,E<SM<;B(L0$E$14Y4+G-Y;4 M/G1YX
M<&5-87)K+(ZAC9(!'C]S0$E$14Y4+G-Y;4 M/G-T<BD[CJ&-D@"0?\1 ?8ZAX
MC9%A/]]\D2G_Z'9A<DQI<W26!3_])RPGDTE$14Y4CJ&-D@"0?\1 >Y8%/_U X
M:9- =F%R3&ES="XQ+G1-87)K0),]DT!V87),:7-T+G1-87)K0#N.H8V2 * _X
MNT!IE@4__4!)1$5.5"YS>6U DSV.H8V2 +I_K&%L;&]C4WEM*$!)1$5.5"YSX
M=')I;F= +$!V87),:7-T+G1-87)K0"D[CJ&-D@"@/[M ;7E4E@4__7!R:6YTX
M9B@B)7,ZDR5S.UQN(BQ 241%3E0N<WEM0"T^='EP94UA<FLLCJ&-D@$>/W- X
M241%3E0N<WEM0"T^<W1R*3N.H8V2 )!_Q$!]CJ&-D6$_WSN.CI\>  "-D@#DX
MH 36,3:.CHR+    $0                                          X
M        ;M&@ G(  (V@_;4  * "+0  C:#]]@  C9$G@ #*)26.I P  (V1X
M)X  ;6%I;B@ICJ&-D3'_^GMR971U<FXH>7EP87)S92@I*3N1!3_]?8Z?*!56X
MC8V1)X  YSF.D45.SD]VD?]RL&5R=FEE=Y8&G[QO9I-O=&AE<I-F96%T=7)EX
M<XZ?&F(CC9$G@ #65&AI<Y8% 7ES96-T:6]NDV)R:64->9-D97-C<FEBD%..X
M97.3<V]M99-/>)-F96%T=7)E<Y-T:&%TDV%R99-P<F^0K')V:61E9)-F;W*3X
M8V]N+8ZD#H  C9$G@ !VD*QR96YI96YC998$S%=O<I-F;W*3861VD?]8Y&%NX
M8V5DDV]RDW-PD%..96-I86QI>F5DDW5S92Z1!]WM1&5T86EL96239&5S8W)IX
M<'1I;VYSDV]FDW1H97-ECJ&-D2>  &9E871U<F5SE@/JJ&%P<)!3CF5A<I-IX
M;I-T:&63V4]XE@0S-55S97*34I;_9F9E9F5RDV5N8Y-ED00S-4UA;G5A;)$!X
M/I/6+HZI(LJKC8V1)X  XCDN,8Z133A 36%C<F^1!84<9F%C:6QI=)"*/7F.X
MGQ9  (V1)X  UD]X)W.6!$H7:6YP=723<W":4XYE8VD,8V%T:6]NDVUAD*QRX
M>9-BF&63<W5CD*QR:)-T:&%TDW1H99-S86UEDV]RDW-I;6EL87*3=&5X=)-AX
M<'"896%R<XZAC9$G@ !I;I8%O@!M;W)EDW1H86Z3;VYEDW!L86-EDVENDV%TX
M=')I8G5T99-R969E<F5N8V63<V5C=&EO;G,ND0JRZ4]XDVAA<Y-ADVUA8W)OX
MCJ&-D2>  '-U8G-T:71U=&EO;I8#ZJAF96%T=7)EDW1H87238V%NDV*:4XYEX
MDW5S9623=&^39&5C<F5A<V63=I6L<F5R8IAO<VETDWF6 ^JH:6Z3<W5CD*QRX
M:)-C87-E<RZ.IHV-D2>  .(Y+C*.D4TX0$%U=&]M871I8Y8%A1QG96YE<F%TX
M:6]NDV]FDV-O<)"*/7F3<G5L97..GQ9  (V1)X  UD]F=&5NE@,IZF&362T,X
M;&63:&%SDV%T=')I8G5T99-D90QN:71I;VYSDW1H87239G5N8W1I;VZ3;VYLX
M>9-T;Y-C;W"0K')YDV%NDVEN<W1A;F-ECJ&-D2>  &*:4XYE;&]N9VEN9Y8#X
MQ&=T;Y-O;F63;F^89&63=&^389-L:6N0K')E+6YA;65DDVEN<W1A;F-EDV*8X
M96QO;F=I;F>3=&^3=&AEDVYOF&1E)W.3<&%R+8ZAC9$G@ !E;IJL<G26!!S>X
M;W*38YAH:6QD+I$%SX-,87)G99-A='1R:6)U=&639W)A;6UA<G.3=&5N9)-TX
M;Y-H89AVF&63;6%NF'F3<W5CF&B39&4,;FET:6]N<RR.H8V1)X  =VAI8Y"LX
M<FB6!+6987)EDW-O;65T:6UE<Y-C86QL9623V6.1_V9F;W!YD03MOG)U;&5SX
MD0#]W=8ND0>9LE1H99-S:71U871I;VZ3:7.38V]N<W!I8W5O=7.3=VAE;HZAX
MC9$G@ !C;VZ:K')T97AT=6%LE@,''6EN9F]R;6%T:6]NDVESDVUOF':89623X
M;&5A9G>887)DDW9I89-I;FAE<FET9623871T<FEB=71E<RZ1!.T'3WB3<WENX
MF'1A>(ZAC9$G@ !P<F^5K')V:61E<YL#\<1WDV&3>7.8;V:8<W"04XYE8VEFX
M>6EN9YAT:&%TF&&88V]PDWF8<G5L99AI<YAG;&]B86R8=&^8=&AEF&%T=')IX
M8G5T99AG<F%M+8ZAC9$G@ !M87(LE@/JJ&]BFJQR=FEA=&EN9Y-R97"04XYEX
M=&ET:6]NDV]FDV%T=')I8G5T99-D90QN:71I;VYSDVENDVUA;IAYDV=R86UMX
M87*3<G5L97,NCJ:-C9$G@ #B.2XSCI%-.$!5<VEN9Y8%A1Q/>)-W:71HDW-CX
M86YN97)SDVYO=)-B87-E9)-O;I-,97B.GQ9  (V1)X  UD)YE@/,H61E9F%UX
M;'0LD0/2HD]XDW!R;YJL<G9I9&5SDW!R97!R;Y!3CF-E<W-I;F>39F]RDTQEX
M>),,;&5SDV%U9VUE;IAT9623=VET:)-/>)-C;VXMCJ&-D2>  '-T<G5C=',NX
MD0402D)YE@-PYG5S:6YGDV&38V]M;6%N9)-L:6YEDV]P=&EO;BR1 XE 3WB3X
M8V%NDV*04XYEDVEN9F]R;65DDW1H8723=&AEDTPM#&QECJ&-D2>  &-O;I6LX
M<G1A:6YSFP5Y^D]X+6%U9VUE;I-T96280YAC;Y!3CF1EF')A=&AE<IAT:&%NX
MF'1H99AU<W5A;)A/>"UA=6=M96Z3=&5DF$QE>(ZAC9$G@ !C;Y!3CF1E+HZFX
MC8V1)X  XCDN-(Z133A 57-EE@6%'&]FDVV0BCUU;'1I<&QEDW-C86YN97)SX
MCI\60 "-D2>  -93;VUEE@1AQ'1R86YS;&%T;W)SDV-O;IJL<G1A:6Z3<V5VX
MF&5R86R3<V-A;FYE<G,ND0:>,U-U8YAHDV&3=')A;G-L871O<I-I<Y-D97-IX
M9VYE9)-S;XZAC9$G@ !T:&%TE@2N"6%TDV%NFJQR>9-M;VUE;IAT+)L$WN)IX
M=)-I<Y-U<VEN9Y-O;F63<V-A;FYE<I-O<I-A;F]T:&5R+)AA;F23<W=I=&.0X
MK')H97.3=&^388Z.GQX  (V2 .2@!#$WCHZ,BP   !(                 X
M                                 '0,H )R  "-H/VU  "@ BT  (V@X
M_?8  (V1)X  UF1I"V5R96Z:K')TE@0'*V]N99-W:&5NDW1H97)EDVESDV&3X
M8YAH86YG99-I;I-C;VZ8=&5X="Z1!8YJ06Z33WB3=')A;G-L871O<I-T:&%TX
MDW5S97..I Z  (V1)X  ;6]R998$:A]T:&%NDV]N99-S8V%N;F5RDV-A;I-BX
MD%..99-C;VYS=')U8W1E9)-BD*QR>9-S=6)M:71T:6YGDW1ODT]XDVUO<F63X
M=&AA;HZAC9$G@ !O;F61 ^JH3"T,;&4NCJDBRJN-C9$G@ #B.2XUCI%-.$!3X
M=')I<'!I;F>6!84<3WB38V]N<W1R=6-T<XZ?%D  C9$G@ #63V-C87-I;VYAX
M;&QYD?\%5BR1 P\"=&AEE@+8&$]XDW5S97*3;6&0K')YDV1E<VER99-C;W!IX
M97.3;V:3=&AEDUDM#&QEDV%N9)-,+0QL92AS*9-S=')I<'"04XYE9(ZAC9$GX
M@ !O9I8$#@Q/>"US<)!3CF5C:0QCDV-O;G-T<G5C=',ND06C#4)YDV&38V]MX
M;6%N9"UL:6YEDV]P=&EO;BR1!!;E=&AEDT]XDW5S97*38V%NDPQL=&5RCJ&-X
MD2>  &%L;)8#XDM/>"US<)!3CF5C:0QCDV-O;G-T<G5C='.39G)O;9-T:&63X
M:6YP=71S+)$#X_=T;Y-O8G1A:6Z3#&QE<Y-A8V-E<'1A8FQEDW1ODUF1_P56X
M86-CCJ&-D2>  &%N9)8$=*),97@ND0;6SE1H99-O<FEG:6YA;)-C;W!I97.3X
M;V:3=&AEDUDM#&QEDV%N9)-,+0QL92AS*9-A<F63=6YCD*QR:&%N9V5D+)$$X
MER%B=72.H8V1)X  3W@G<Y8$'&MO=71P=71SDV]ND]QO>&]U="HN*I/68V]NX
MD*QR=&%I;I-N96ET:&5RDT]XDV-O;G-T<G5C='.3;F]RDW1H99-U<W5A;)-/X
M>"V.H8V1)X  9V5N97)A=&5DE@/JJ'!A<G-E+71R964M;6%N86=E;65ND*QRX
M=)-C;Y!3CF1E+HZFC8V1)X  XCDN-HZ133A 06-C97-S:6YGE@6%'%F1_IZXX
M86-CDW!S975D;Y"*/7:1_Q1[87)I86)L97..GQ9  (V1)X  UD&:K')T=')IX
M8G5T998$6Q]D90QN:71I;VYSDW1H8723<F5F97*3=&^3=&AEDUF1_P5686-CX
MDW!S975D;YAVD?]8Y&%R:6%B;&5SD]PD)-8LE@1W/=PD,=8LD]PD,M8LDV5TX
M8RZ.H8V1)X  87)EE@/JJ'"04XYE<FUI='1E9)-I;I-VD?]8Y&%R:6]U<Y-FX
M;W)M<RR3:6YC;'5D:6YG.HZAH8V1.1_TW$!IFP8LS4#99W*6_V9F86UM87)SX
M>6UBDV]LW"[66]EI;G1EDV=E<MPNUEW9871T<FEB=71E;F%M9=Q D0/JJ#V8X
M)-=NUCN.H:&-D2>  '=H97)EE@-^<]PDUVZ3UF1E;F]T97.389-9D?\%5F%CX
M8Y-P<V5U9&^:K')VD?]8Y&%R:6%B;&4ND044SDETDVESDV%L<V^3<)!3CF]SX
M<VEB;&63=&^38V]PF'F3871T<FEB=71ECJ&-D2>  &EN<W1A;F-E<Y8#ZJAIX
M;IJL<G1ODW!S975D;YAVD?]8Y&%R:6%B;&5S+HZFC8V1)X  XCDN-XZ133A X
M17AP<F5S<VEN9Y8%A1QD97"0=<)E;F1E;F-I97.397AP;&EC:71L>8Z?%D  X
MC9$G@ #64W5P<)!3CF]S998"\,9T:&%TDWF:K')O=9-H89AVF&6389-#DV9UX
M;F-T:6]ND]QF=6Z3UFENDV&3;&EB<F%R>9'_!58LD0,BP&%N9)-T:&%TDWF8X
M;W63=YAA;IATDW1ODW5S98ZAC9$G@ !I=)8$+;9T;Y-D90QN99-A;I-A='1RX
M:6)U=&63;Y!3CF-C=7)R96YC92R;!#YZ<V&0K')YD]QS>6TN871T<F+6+)AIX
M;I-T97)M<Y-O9I-S;VUEDV]T:&5RCJ&-D2>  &^:4XYC8W5R<F5N8V66!;3$X
MW&]T:&5R<WEM+F]T:&5R071T<F+6+I$*ES-&D?\%5G5R=&AE<I-S=7!PF&]SX
M99-T:&%TDW1H99,,<G-TDV9O<FUA;(ZAC9$G@ !P87)A;65T97*6!1O#;V:3X
MW&9U;I/6:7.3;V:3=&AEDW-A;663=)"L<GEPD%..99-A<Y/<;W1H97)S>6TNX
M;W1H97)!='1R8M8LD05H"F%N9)-T:&%TCJ&-D2>  -QF=6[6)W.6 YTR<V5CX
M;VYDDV9O<FUA;)-P87)A;65T97*3:7.389-PD%..;VENFJQR=&5RDW1ODW-OX
M;65T:&EN9Y-O9I-T:&63<V%M99-TF'EPD%..99-A<XZAC9$G@ #<<WEM+F%TX
M=')BUBZ1!>*]09$$(SEC86QLE@0C1W1OD]QF=6Z3UF.:K')H86YG97.3=&AEX
MDV-O;IAT96Z8='.3;V:3=&AEDVQOD%..8V%T:6]NDVEN9&EC871E9)-BF'F.X
MH8V1)X  :71SE@/JJ'-E8V]N9)-A<F=U;65ND*QR="Z.H8V1.1_T2726 ^JHX
M=YJL<F]U;&1N)W23=YAO<FN3=&^3=W)I=&4ZCI\8@ "-D49@ =Q :98&+,UFX
M=6XH0&]T:&5R4WEM+F]T:&5R071T<F) +),F0'-Y;2YA='1R8D I.XZ.GQX X
M (V2 .2@!-8Q.(Z.C(L    3                                    X
M              !\-: "<@  C:#]M0  H (M  "-H/WV  "-D2>  -9S:6YCX
M998$JI5T:&63;6^:4XYD99-A;FZ0K')U8VEA=&]RD]Q :9/6*'-E99-S96-TX
M:6]NDS0N,2F3:6UP;&EE<Y-T:&%TDW1H99-OF&-C=7)R96YC98ZD#H  C9$GX
M@ !A<'":4XYE87)I;F>6 VJ%#')S=),HW&]T:&5R4WEM+F]T:&5R071T<F+6X
M*9-I<Y-T:&63;YAC8W5R<F5N8V638IAE:6YGDV1E#&YE9"R1 X0F86YDCJ&-X
MD2>  '1H8726 ^JH:7239&5PD%..96YD<Y-O;I/<<WEM+F%T=')BUBZ1!3C@X
M06-T=6%L;'F3>9JL<F]UDVENF'1E;F23=&AEDV]P<)!3CF]S:71E+HZAC9$YX
M'_1/;F66 PH7<V]L=71I;VZ3=Y"L<F]U;&238II3CF63=&^3;6^89&EF>9-TX
M:&639&4,;FET:6]NDV]FD]QF=6Z3UBAR97:0K')E<G-I;F>3=&AEDV]R9&5RX
MCJ&-D2>  &]FE@*P%&ET<Y-F;W)M86R3<&%R86UE=&5RDVQI<W0I+I$$T 1)X
M9I-YFJQR;W639&]N)W23=YAA;IATDW1ODV1I<W1U<F*3=&AEDVQI8G)A<GF1X
M_P56+)$"[OYH;YAWF&5VF&5R+(ZAC9$G@ !I=)8#ZJAWD*QR;W5L9)-BFE..X
M99-BF&5S=)-T;Y-U<V633W@G<Y/997AP;&EC:726!#,U;6^1_V9F9&6386YNX
M=6YC:6%T;W*1!353W$!EE@/JJ-9A<Y-F;VQL;Y"L<G=S.HZI&(  C9%&8 '<X
M0&66!BS-<WEM+F%T=')BDSJ3;W1H97)3>6TN;W1H97)!='1R8I,[CJ&-D5CFX
M:&9U;BA ;W1H97)3>6TN;W1H97)!='1R8D LD08LS29 <WEM+F%T=')B0"D[X
MCJ:-D2>  -9);I8$7&YT:&63#')S=)-L:6YEDV%BFE..;Y6L<G:392R1!'C@X
M3WB6!%QN:7.397AP;&EC:71L>9-G:7:0K')E;I-D97"896YD96YC>9-I;F9OX
M<FUA=&EO;I-U<VEN9XZAC9$G@ !AFP/JJ$UA:Y6L<F4M;&EKDV68<WENDW1AX
M>#J1!3C@:728:7.89&5C;&%R9628=&AA=)C<<WEM+F%T=')BF-9D97"04XYEX
M;F1SF&]NCJ&-D2>  -QO=&AE<E-Y;2YO=&AE<D%T=')BUBZ1"?5\57-EE@5^X
MW&]FDW1H99-E>'!L:6-I=)-M;Y!3CF1EDVUA:Y"L<F5SDW1H99-O<F1E<I-OX
M9I-T:&6.H8V1)X  ;Y!3CF-C=7)R96YC97.6 ^0O:6Z3=&AEDW-E8V]N9)-LX
M:6YE)W.38V%L;)-T;Y/<9G5ND]9I<G)E;&5VD?]8Y&%ND*QR=)-T;Y-/>"=SX
MDW5N9&5R<W1A;F1I;F>.H8V1)X  ;V:6 ^JH=&AEDV1E<)!3CF5N9&5N8VEEX
M<RZ.GR+*JXV-D2>  .(Y+CB.D4TX0$=E;F5R871I;F>6!84<04Y322])4T\OX
M0RLKDV]U='!U=(Z?%D  C9$G@ #60GF6 \R[9&5F875L="R1 ]*W=&AEDT.3X
M8V^04XYD99-G96YE<F%T96238IJL<GF33WB39F]L;&^8=W.3=')A9&ET:6]NX
M86R30Y-S>6Z8=&%X+I$%+N94:&5R98ZAC9$G@ !I<RR; ^JH:&^5K')WDV5VX
MDV5R+)AAF&-O;6UA;F0M;&EN99AO<'1I;VZ8=&^8<')OE5..9'5C99AC;Y-DX
M99AC;VUP871I8FQEF'=I=&B.H8V1)X  04Y322])4T\O0RLKFP/B.7-Y;I6LX
M<G1A>"Z1!3805&B3=7.8:728:7.896%S>9AT;YAM86N399A/>"=SF&-OD%..X
M9&689V5N97)A=&EO;IAC;VXMCJ&-D2>  &9O<FV6 ^JH=&^3=&AEDV5X<)!3X
MCF5C=&%T:6]N<Y-O9I-P<F%C=&EC86QL>9-A;I"L<GF30Y-O<I-#*RN38V]MX
M<&EL97(NCI\H%5:-C9$G@ #G,3".D4\^:$%CEO]RL&MN;Y-W;&5D9V5M96Z3X
M='..GQIB(XV1)X  UE1H:7.6!'0V:7.3=&^3=&AA;FN35)'_!59E<G)YDT1IX
M;F5E;BR;!):90V%R;VQY;I-':6*04XYE<G-O;BR836%R:W5SDTML:6YG<W"0X
M4XYO<BR82F]H;HZAC9$G@ !,979I;F4LE@.S9T-A<FQAFP.EETUA<F-E874LX
MDV%N9)A-:6.0K')H865LF%-E86=E<IAF;W*8=&AE:7*8:&5L<&9U;)AR979IX
M97=SF&]FF&5A<FQYCJ&-D2>  ':0K')E<G-I;VYSE@/JJ&]FDW1H:7.3<&%PX
MD%..97(NCHZ?'@  C9( Y* $,3F.CHSX  "$:@&#DL <.P     #Z )R   !X
MK8    < $_,\&O(B5@ 11ZX "@    9C;6)X,3#S-QKR(E8 #F9F  H    &X
M8VUB>#$P\S'?AK54  P    ,    !F-M='0Q,O,PPM9.H  ,    #     9CX
M;6)X,3+S+IN[B$  #     P    &8VUT:3$R\RTA(BR:  P    *    !F-MX
M<WDQ,/,LM^%GHP ,    #     9C;6UI,3+S*UBK40L #     P    %8VURX
M,3+S*-_J/'@ "O,S  H    &8VUT=#$P\R0A(BR:  KS,P *    !F-M<WDQX
M,/,B2_%@>0 *\S, "@    5C;7(Q,/,?W^H\>  *    "@    9C;71T,3#SX
M&4OQ8'D "@    H    %8VUR,3#S#7Q[60< "     @    $8VUR./,(V9.@X
:4@ '    !P    1C;7(W^0  BZD"W]_?W]\                         X
                                                             X
end
@eof
set `sum $sumopt <oxDistG1.04/docs/oxTutor.dvi`; if test $1 -ne 55964
then
	echo ERROR: oxDistG1.04/docs/oxTutor.dvi checksum is $1 should be 55964
fi
set `wc -lwc <oxDistG1.04/docs/oxTutor.dvi`
if test $1$2$3 != 455936116
then
	echo ERROR: wc results of oxDistG1.04/docs/oxTutor.dvi are $* should be 45 59 36116
fi

chmod 755 oxDistG1.04/docs/oxTutor.dvi

if test -f oxDistG1.04/docs/oxTutor.ps
then
	echo Ok to overwrite existing file oxDistG1.04/docs/oxTutor.ps\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/docs/oxTutor.ps
	if test -f oxDistG1.04/docs/oxTutor.ps
	then
		echo Error: could not remove oxDistG1.04/docs/oxTutor.ps, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/docs/oxTutor.ps
sed 's/^@//' >oxDistG1.04/docs/oxTutor.ps <<'@EOF'
%!PS-Adobe-2.0
%%Creator: dvips 5.519 Copyright 1986, 1993 Radical Eye Software
%%Title: gs.dvi
%%CreationDate: Fri Nov  5 17:57:05 1993
%%Pages: 19
%%PageOrder: Ascend
%%BoundingBox: 0 0 612 792
%%EndComments
%DVIPSCommandLine: dvips -o gs.ps gs.dvi
%DVIPSSource:  TeX output 1993.11.05:1756
%%BeginProcSet: tex.pro
/TeXDict 250 dict def TeXDict begin /N{def}def /B{bind def}N /S{exch}N
/X{S N}B /TR{translate}N /isls false N /vsize 11 72 mul N /hsize 8.5 72
mul N /landplus90{false}def /@rigin{isls{[0 landplus90{1 -1}{-1 1}
ifelse 0 0 0]concat}if 72 Resolution div 72 VResolution div neg scale
isls{landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div
hsize mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul
TR matrix currentmatrix dup dup 4 get round 4 exch put dup dup 5 get
round 5 exch put setmatrix}N /@landscape{/isls true N}B /@manualfeed{
statusdict /manualfeed true put}B /@copies{/#copies X}B /FMat[1 0 0 -1 0
0]N /FBB[0 0 0 0]N /nn 0 N /IE 0 N /ctr 0 N /df-tail{/nn 8 dict N nn
begin /FontType 3 N /FontMatrix fntrx N /FontBBox FBB N string /base X
array /BitMaps X /BuildChar{CharBuilder}N /Encoding IE N end dup{/foo
setfont}2 array copy cvx N load 0 nn put /ctr 0 N[}B /df{/sf 1 N /fntrx
FMat N df-tail}B /dfs{div /sf X /fntrx[sf 0 0 sf neg 0 0]N df-tail}B /E{
pop nn dup definefont setfont}B /ch-width{ch-data dup length 5 sub get}
B /ch-height{ch-data dup length 4 sub get}B /ch-xoff{128 ch-data dup
length 3 sub get sub}B /ch-yoff{ch-data dup length 2 sub get 127 sub}B
/ch-dx{ch-data dup length 1 sub get}B /ch-image{ch-data dup type
/stringtype ne{ctr get /ctr ctr 1 add N}if}B /id 0 N /rw 0 N /rc 0 N /gp
0 N /cp 0 N /G 0 N /sf 0 N /CharBuilder{save 3 1 roll S dup /base get 2
index get S /BitMaps get S get /ch-data X pop /ctr 0 N ch-dx 0 ch-xoff
ch-yoff ch-height sub ch-xoff ch-width add ch-yoff setcachedevice
ch-width ch-height true[1 0 0 -1 -.1 ch-xoff sub ch-yoff .1 add]{
ch-image}imagemask restore}B /D{/cc X dup type /stringtype ne{]}if nn
/base get cc ctr put nn /BitMaps get S ctr S sf 1 ne{dup dup length 1
sub dup 2 index S get sf div put}if put /ctr ctr 1 add N}B /I{cc 1 add D
}B /bop{userdict /bop-hook known{bop-hook}if /SI save N @rigin 0 0
moveto /V matrix currentmatrix dup 1 get dup mul exch 0 get dup mul add
@.99 lt{/QV}{/RV}ifelse load def pop pop}N /eop{SI restore showpage
userdict /eop-hook known{eop-hook}if}N /@start{userdict /start-hook
known{start-hook}if pop /VResolution X /Resolution X 1000 div /DVImag X
/IE 256 array N 0 1 255{IE S 1 string dup 0 3 index put cvn put}for
65781.76 div /vsize X 65781.76 div /hsize X}N /p{show}N /RMat[1 0 0 -1 0
0]N /BDot 260 string N /rulex 0 N /ruley 0 N /v{/ruley X /rulex X V}B /V
{}B /RV statusdict begin /product where{pop product dup length 7 ge{0 7
getinterval dup(Display)eq exch 0 4 getinterval(NeXT)eq or}{pop false}
ifelse}{false}ifelse end{{gsave TR -.1 -.1 TR 1 1 scale rulex ruley
false RMat{BDot}imagemask grestore}}{{gsave TR -.1 -.1 TR rulex ruley
scale 1 1 false RMat{BDot}imagemask grestore}}ifelse B /QV{gsave
transform round exch round exch itransform moveto rulex 0 rlineto 0
ruley neg rlineto rulex neg 0 rlineto fill grestore}B /a{moveto}B /delta
0 N /tail{dup /delta X 0 rmoveto}B /M{S p delta add tail}B /b{S p tail}
B /c{-4 M}B /d{-3 M}B /e{-2 M}B /f{-1 M}B /g{0 M}B /h{1 M}B /i{2 M}B /j{
3 M}B /k{4 M}B /w{0 rmoveto}B /l{p -4 w}B /m{p -3 w}B /n{p -2 w}B /o{p
-1 w}B /q{p 1 w}B /r{p 2 w}B /s{p 3 w}B /t{p 4 w}B /x{0 S rmoveto}B /y{
3 2 roll p a}B /bos{/SS save N}B /eos{SS restore}B end
%%EndProcSet
TeXDict begin 40258431 52099146 1000 300 300
(/home/grad2/bischoff/oxDevelop/getstart/gs.dvi) @start
/Fa 3 112 df<007FFFE0000007803C000007800E000007800700000F000780000F0003
80000F0003C0000F0003C0001E000780001E000780001E000780001E000F00003C001E00
003C003C00003C007000003C01C000007FFE00000078078000007801C000007801E00000
F000F00000F000F00000F000F00000F000F00001E001E00001E001E00001E001E00001E0
01E00003C003C00003C003C04003C003C04003C001C08007C001C080FFFC00E300000000
3C0022237EA125>82 D<3C07C04618604720308740388780388700388700380E00700E00
700E00700E00701C00E01C00E01C01C01C01C13801C23803823803823801847001883000
F018157E941D>110 D<003E0000C1800380C00700E00E00E01C00F03C00F03C00F07800
F07800F07800F0F001E0F001E0F001C0F003C0700380700700700600381C001C380007E0
0014157E9417>I E /Fb 3 104 df<03F0000FFC001FFE003FFF007FFF807FFF80FFFFC0
FFFFC0FFFFC0FFFFC0FFFFC0FFFFC0FFFFC0FFFFC07FFF807FFF803FFF001FFE000FFC00
03F00012147D9519>15 D<000F0038007000E001C001C001C001C001C001C001C001C001
C001C001C001C001C001C001C001C001C0038007001E00F0001E000700038001C001C001
C001C001C001C001C001C001C001C001C001C001C001C001C001C001C000E00070003800
0F10317CA419>102 D<F0001E000700038001C001C001C001C001C001C001C001C001C0
01C001C001C001C001C001C001C001C000E000700038000F0038007000E001C001C001C0
01C001C001C001C001C001C001C001C001C001C001C001C001C001C0038007001E00F000
10317CA419>I E /Fc 66 126 df<6030F078F078F078F078F078F078F078F078E038E0
38E0380D0C7C9916>34 D<0387000387000387000387000387000387007FFFC0FFFFE0FF
FFE0070E00070E00070E000F1E000E1C000E1C000E1C00FFFFE0FFFFE07FFFC01C38001C
38001C38001C38001C38001C380013197F9816>I<3801807C0380FE0780FE0700EE0700
EE0F00EE0E00EE1E00FE1C00FE3C007C380038380000780000700000F00000E00000E000
01E00001C00003C0000380000383800787C0070FE00F0EE00E0EE01E0EE01C0EE01C0EE0
3C0FE03807C018038013207F9C16>37 D<183C3E1E0E0E0E1E1C3C78F060070D799816>
39 D<00E001E007C007000F001E003C0038007800700070007000F000E000E000E000E0
00E000E000E000F000700070007000780038003C001E000F00070007C001E000E00B217A
9C16>I<E000F0007C001C001E000F000780038003C001C001C001C001E000E000E000E0
00E000E000E000E001E001C001C001C003C0038007800F001E001C007C00F000E0000B21
7C9C16>I<01C00001C00001C00001C00071C700F9CF807FFF001FFC0007F00007F0001F
FC007FFF00F9CF8071C70001C00001C00001C00001C00011127E9516>I<01C00001C000
01C00001C00001C00001C00001C00001C000FFFF80FFFF80FFFF8001C00001C00001C000
01C00001C00001C00001C00001C00011137E9516>I<387C7E7E3E0E1E3C7CF860070B79
8416>I<FFFF80FFFF80FFFF8011037E8D16>I<70F8F8F8700505788416>I<0001800003
80000780000700000F00000E00001E00001C00003C0000380000780000700000F00000E0
0001E00001C00001C00003C0000380000780000700000F00000E00001E00001C00003C00
00380000780000700000F00000E00000E0000011207E9C16>I<03E0000FF8001FFC001E
3C00380E00780F00700700700700E00380E00380E00380E00380E00380E00380E00380E0
0380F00780700700700700780F003C1E001E3C001FFC000FF80003E00011197E9816>I<
01800380078007801F807F80FF8073800380038003800380038003800380038003800380
03800380038003807FF87FFC7FF80E197C9816>I<07E0001FF8007FFE00783F00F00F00
F00780F00380F00380000380000380000780000700000F00001E00003C0000780000F000
03E0000780000F00001E03803C03807FFF80FFFF807FFF8011197E9816>I<03E0000FF8
003FFC007C1E00780F00F00700E00700E00780E00780E00380F00780F00780780F803FFF
803FFB800FE380000780000700300F00780E00781E00787C007FF8003FE0000F80001119
7E9816>57 D<70F8F8F870000000000000000070F8F8F8700512789116>I<387C7C7C38
0000000000000000387C7C7C3C1C3C38F8F0600618799116>I<000380000780001F8000
3E0000FC0003F00007E0001F80003E0000FC0000F00000FC00003E00001F800007E00003
F00000FC00003E00001F8000078000038011157E9616>I<7FFF00FFFF80FFFF80000000
000000000000000000000000FFFF80FFFF807FFF00110B7E9116>I<E00000F00000FC00
003E00001F800007E00003F00000FC00003E00001F80000780001F80003E0000FC0003F0
0007E0001F80003E0000FC0000F00000E0000011157E9616>I<00F80003FE000FFF001F
0F803E3F803C7F8078FFC071E7C0F1C3C0E3C3C0E381C0E381C0E381C0E381C0E381C0E3
C3C0F1C38071E78078FF003C7E003E3C001F03C00FFFC003FF0000FC0012197E9816>64
D<00E00001F00001F00001B00001B00003B80003B80003B800031800071C00071C00071C
00071C00071C000E0E000E0E000FFE000FFE001FFF001C07001C07001C07007F1FC0FF1F
E07F1FC013197F9816>I<7FF800FFFE007FFF001C0F001C07801C03801C03801C03801C
07801C07001FFF001FFE001FFE001C1F001C03801C03C01C01C01C01C01C01C01C01C01C
03C01C07807FFF80FFFF007FFC0012197F9816>I<01F18007FF800FFF801F0F803C0780
780780780380700380F00000E00000E00000E00000E00000E00000E00000E00000F00000
7003807803807803803C07801F0F000FFE0007FC0001F00011197E9816>I<7FF800FFFE
007FFF001C0F001C07801C03C01C01C01C01C01C01E01C00E01C00E01C00E01C00E01C00
E01C00E01C00E01C00E01C01C01C01C01C03C01C07801C0F807FFF00FFFE007FF8001319
809816>I<7FFFC0FFFFC07FFFC01C01C01C01C01C01C01C01C01C00001C00001C1C001C
1C001FFC001FFC001FFC001C1C001C1C001C00001C00E01C00E01C00E01C00E01C00E07F
FFE0FFFFE07FFFE013197F9816>I<FFFEFFFEFFFE038003800380038003800380038003
8003800380038003800380038003800380038003800380FFFEFFFEFFFE0F197D9816>73
D<FFC000FFC000FFC0001C00001C00001C00001C00001C00001C00001C00001C00001C00
001C00001C00001C00001C00001C00001C00401C00E01C00E01C00E01C00E0FFFFE0FFFF
E0FFFFE013197F9816>76 D<FC07E0FE0FE0FE0FE03A0B803B1B803B1B803B1B803B1B80
3B1B803BBB8039B38039B38039B38039B38039F38038E38038E380380380380380380380
380380380380FE0FE0FE0FE0FE0FE013197F9816>I<7E1FC0FF3FE07F1FC01D07001D87
001D87001D87001DC7001DC7001CC7001CC7001CE7001CE7001CE7001C67001C67001C77
001C77001C37001C37001C37001C17007F1F00FF9F007F0F0013197F9816>I<1FFC003F
FE007FFF00780F00F00780E00380E00380E00380E00380E00380E00380E00380E00380E0
0380E00380E00380E00380E00380E00380F00780F00780780F007FFF003FFE001FFC0011
197E9816>I<7FE000FFF8007FFC001C1E001C0F001C07001C07001C07001C07001C0F00
1C1E001FFC001FF8001FFC001C3E001C0E001C0E001C0E001C0E001C0E201C0E701C0E70
7F0FF0FF87E07F03C014197F9816>82 D<07E3001FFF007FFF00781F00F00F00E00700E0
0700E00000F000007800007F80001FF00007FC0000FE00000F00000780000380000380E0
0380E00380F00780F80F00FFFE00FFFC00C7F00011197E9816>I<7FFFE0FFFFE0FFFFE0
E0E0E0E0E0E0E0E0E0E0E0E000E00000E00000E00000E00000E00000E00000E00000E000
00E00000E00000E00000E00000E00000E00000E00007FC000FFE0007FC0013197F9816>
I<FE0FE0FF1FE0FE0FE03803801C07001C07001C07001C07000E0E000E0E000E0E000E0E
00060C00071C00071C00071C00071C0003180003B80003B80003B80001B00001F00001F0
0000E00013197F9816>86 D<7FFF80FFFF80FFFF80E00700E00F00E01E00E01C00003C00
00780000700000F00001E00001C00003C0000780000700000F00001E03801C03803C0380
780380700380FFFF80FFFF80FFFF8011197E9816>90 D<FFF0FFF0FFF0E000E000E000E0
00E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E0
00E000E000E000E000FFF0FFF0FFF00C20789C16>I<E00000E00000F000007000007800
003800003C00001C00001E00000E00000F000007000007800003800003C00001C00001C0
0001E00000E00000F000007000007800003800003C00001C00001E00000E00000F000007
0000078000038000018011207E9C16>I<FFF0FFF0FFF000700070007000700070007000
700070007000700070007000700070007000700070007000700070007000700070007000
700070FFF0FFF0FFF00C207F9C16>I<1FE0007FF8007FFC00783C00301E00000E00000E
0003FE001FFE007E0E00F00E00E00E00E00E00F01E00F83E007FFFE03FE7E00F83E01312
7E9116>97 D<7E0000FE00007E00000E00000E00000E00000E00000E3E000EFF800FFFC0
0F83E00F01E00E00F00E00F00E00700E00700E00700E00700E00F00F00E00F01E00F83C0
0FFFC00EFF00063C001419809816>I<03F80FFE1FFE3C1E780C7000F000E000E000E000
E000F000700778073E0F1FFE0FFC03F010127D9116>I<003F00007F00003F0000070000
070000070000070003C7000FF7003FFF003C1F00780F00F00700F00700E00700E00700E0
0700E00700F00700F00F00781F007C3F003FFFE01FF7F007C7E014197F9816>I<07E00F
F81FFC3C3E780E700FF007FFFFFFFFFFFFE000F000700778073E1F1FFE0FFC03F010127D
9116>I<001F00007F8000FF8001E78001C30001C00001C0007FFF00FFFF00FFFF0001C0
0001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C0003FFE
007FFF003FFE0011197F9816>I<03E3C00FFFE01FFFE01E3CC03C1E00380E00380E0038
0E003C1E001E3C001FFC001FF8003BE0003800003800001FFC001FFF003FFFC07803C0F0
01E0E000E0E000E0E000E0F001E07C07C03FFF800FFE0003F800131C7F9116>I<7E0000
FE00007E00000E00000E00000E00000E00000E3C000EFF000FFF800F87800F03800F0380
0E03800E03800E03800E03800E03800E03800E03800E03800E03807FC7F0FFE7F87FC7F0
1519809816>I<018003C003C0018000000000000000007FC07FC07FC001C001C001C001
C001C001C001C001C001C001C001C001C07FFFFFFF7FFF101A7D9916>I<7E0000FE0000
7E00000E00000E00000E00000E00000E7FE00E7FE00E7FE00E0F000E1E000E3C000E7800
0EF0000FF8000FF8000FBC000F1E000E0E000E0F000E07807F87F0FFCFF07F87F0141980
9816>107 D<FFC000FFC000FFC00001C00001C00001C00001C00001C00001C00001C000
01C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C000
FFFF80FFFF80FFFF8011197E9816>I<F9C380FFEFC0FFFFE03E7CE03C78E03870E03870
E03870E03870E03870E03870E03870E03870E03870E03870E0FE7CF8FE7CF8FE7CF81512
809116>I<7E3C00FEFF007FFF800F87800F03800F03800E03800E03800E03800E03800E
03800E03800E03800E03800E03807FC7F0FFE7F87FC7F01512809116>I<03E0000FF800
1FFC003C1E00780F00700700E00380E00380E00380E00380E00380F00780700700780F00
3C1E001FFC000FF80003E00011127E9116>I<7E3E00FEFF807FFFC00F83E00F01E00E00
F00E00F00E00700E00700E00700E00700E00F00F00E00F01E00F83C00FFFC00EFF000E3C
000E00000E00000E00000E00000E00000E00007FC000FFE0007FC000141B809116>I<FF
0FC0FF3FE0FF7FE007F04007E00007C00007800007800007000007000007000007000007
0000070000070000FFFC00FFFC00FFFC0013127F9116>114 D<0FEC3FFC7FFCF03CE01C
E01CF0007F801FF007FC003EE00EE00EF00EF81EFFFCFFF8C7E00F127D9116>I<030000
0700000700000700000700007FFF00FFFF00FFFF00070000070000070000070000070000
07000007000007010007038007038007078007878003FF0003FE0000F80011177F9616>
I<7E1F80FE3F807E1F800E03800E03800E03800E03800E03800E03800E03800E03800E03
800E03800E07800F0F800FFFF007FFF803E3F01512809116>I<7F1FC0FF1FE07F1FC01C
07001E0F000E0E000E0E000E0E00071C00071C00071C00071C0003B80003B80003B80001
F00001F00000E00013127F9116>I<7F1FC07F3FC07F1FC00F1C00073C0003B80003F000
01F00000E00001E00001F00003B800073C00071C000E0E007F1FC0FF3FE07F1FC013127F
9116>120 D<7F1FC0FF9FE07F1FC01C07000E07000E0E000E0E00070E00071C00071C00
039C00039C0003980001B80001B80000F00000F00000F00000E00000E00000E00001C000
79C0007BC0007F80003F00003C0000131B7F9116>I<3FFFC07FFFC07FFFC0700780700F
00701E00003C0000F80001F00003E00007C0000F00001E01C03C01C07801C0FFFFC0FFFF
C0FFFFC012127F9116>I<001F80007F8001FF8001E00001C00001C00001C00001C00001
C00001C00001C00001C00001C00003C0007F8000FF0000FF00007F800003C00001C00001
C00001C00001C00001C00001C00001C00001C00001C00001E00001FF80007F80001F8011
207E9C16>I<E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0
E0E00320779C16>I<FC0000FF0000FFC00003C00001C00001C00001C00001C00001C000
01C00001C00001C00001C00001E00000FF00007F80007F8000FF0001E00001C00001C000
01C00001C00001C00001C00001C00001C00001C00003C000FFC000FF0000FC000011207E
9C16>I E /Fd 50 122 df<0001FF0000001FFFC000007F80F00000FE00F80003FC01FC
0003F803FC0007F003FC0007F003FC0007F003FC0007F001F80007F000F00007F0000000
07F000000007F000000007F0000000FFFFFFFC00FFFFFFFC00FFFFFFFC0007F001FC0007
F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F0
01FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001
FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC007FFF1FFFC07FFF1FFF
C07FFF1FFFC0222A7FA926>12 D<00000600000000000F00000000000F00000000000F00
000000000F00000000000F00000000000F00000000000F00000000000F00000000000F00
000000000F00000000000F00000000000F00000000000F00000000000F00000000000F00
000000000F00000000000F00000000000F00000000000F00000000000F0000007FFFFFFF
FFE0FFFFFFFFFFF0FFFFFFFFFFF07FFFFFFFFFE000000F00000000000F00000000000F00
000000000F00000000000F00000000000F00000000000F00000000000F00000000000F00
000000000F00000000000F00000000000F00000000000F00000000000F00000000000F00
000000000F00000000000F00000000000F00000000000F00000000000F00000000000600
00002C2E7CA535>43 D<FFFF80FFFF80FFFF80FFFF80FFFF80FFFF8011067F9017>45
D<1C007F00FF80FF80FF80FF80FF807F001C0009097B8813>I<00000300000007800000
0F8000000F8000000F0000001F0000001F0000001E0000003E0000003E0000007C000000
7C00000078000000F8000000F8000000F0000001F0000001F0000003E0000003E0000003
C0000007C0000007C00000078000000F8000000F8000001F0000001F0000001E0000003E
0000003E0000003C0000007C0000007C000000F8000000F8000000F0000001F0000001F0
000001E0000003E0000003E0000007C0000007C00000078000000F8000000F8000000F00
00001F0000001F0000003E0000003E0000003C0000007C0000007C00000078000000F800
0000F8000000F000000060000000193C7CAC22>I<000E00001E00007E0007FE00FFFE00
FFFE00F8FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE00
00FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE00
00FE0000FE0000FE0000FE0000FE0000FE0000FE007FFFFE7FFFFE7FFFFE17277BA622>
49 D<00FF800003FFF0000FFFFC003F03FF007C00FF807C007FC0FE007FC0FF003FE0FF
003FE0FF003FE0FF001FE07E001FE03C003FE000003FE000003FC000003FC000007F8000
007F800000FF000001FE000001FC000003F0000007E000000FC000001F0000003E000000
7C00E0007800E000F000E001E001C0038001C0070001C00FFFFFC01FFFFFC03FFFFFC07F
FFFFC0FFFFFF80FFFFFF80FFFFFF801B277DA622>I<007F800003FFF00007FFFC001F81
FE001F00FF003F80FF003F807F803FC07F803F807F803F807F801F007F800000FF800000
FF000000FF000001FE000003F8000007F00000FFC00000FFF0000001FC000000FF000000
7F8000007FC000003FC000003FE000003FE000003FE03C003FE07E003FE0FF003FE0FF00
3FE0FF003FC0FF007FC0FE007F807C00FF803F01FF001FFFFC0007FFF00000FF80001B27
7DA622>I<00000E0000001E0000003E0000007E000000FE000000FE000001FE000003FE
0000077E00000E7E00000E7E00001C7E0000387E0000707E0000E07E0000E07E0001C07E
0003807E0007007E000E007E000E007E001C007E0038007E0070007E00E0007E00FFFFFF
F8FFFFFFF8FFFFFFF80000FE000000FE000000FE000000FE000000FE000000FE000000FE
000000FE00007FFFF8007FFFF8007FFFF81D277EA622>I<0C0003000F803F000FFFFE00
0FFFFE000FFFFC000FFFF8000FFFE0000FFFC0000FFE00000E0000000E0000000E000000
0E0000000E0000000E0000000E7FC0000FFFF8000F80FE000E007F000C003F8000003F80
00001FC000001FC000001FE000001FE018001FE07E001FE0FE001FE0FE001FE0FE001FE0
FE001FE0FE001FC078003FC078003F803C007F001F01FE000FFFFC0003FFF00000FF8000
1B277DA622>I<0007F000003FFC0000FFFF0001FC0F0007F01F800FE03F800FC03F801F
C03F803F803F803F801F007F8000007F0000007F0000007F000000FF000000FF0FC000FF
3FF800FF70FE00FFE03F00FFC03F80FF801FC0FF801FC0FF801FC0FF001FE0FF001FE0FF
001FE0FF001FE07F001FE07F001FE07F001FE07F001FE03F801FC03F801FC01F803F800F
C03F8007E0FF0003FFFC0000FFF000003FC0001B277DA622>I<380000003E0000003FFF
FFF03FFFFFF03FFFFFF07FFFFFE07FFFFFC07FFFFFC07FFFFF8070000F0070001E007000
3C00E0003800E0007800E000F0000001E0000003C0000003C0000007800000078000000F
0000001F0000001F0000001F0000003F0000003F0000003E0000007E0000007E0000007E
0000007E000000FE000000FE000000FE000000FE000000FE000000FE000000FE000000FE
000000FE0000003800001C297CA822>I<003FC00001FFF00003FFFC000FC07E000F003F
001F001F001E001F803E000F803E000F803F000F803F800F803FC01F803FF01F003FFC3F
001FFE7E001FFFF8000FFFE00007FFF80001FFFC0001FFFF0007FFFF801F8FFF803F03FF
C07E01FFC07C007FE0FC001FE0F8000FE0F80007E0F80003E0F80003E0F80003E0FC0003
C07C0007C07E0007803F000F801FC03F000FFFFC0003FFF800007FC0001B277DA622>I<
007F800001FFF00007FFF8000FE0FE001FC07E003F803F007F003F807F003F80FF001FC0
FF001FC0FF001FC0FF001FC0FF001FE0FF001FE0FF001FE0FF001FE07F003FE07F003FE0
7F003FE03F807FE01F80FFE00FE1DFE003FF9FE0007E1FE000001FE000001FC000001FC0
00001FC000003FC01F003F803F803F803F807F003F807F003F80FE003F01FC001E03F800
0FFFE00007FF800001FE00001B277DA622>I<1C007F00FF80FF80FF80FF80FF807F001C
000000000000000000000000000000000000001C007F00FF80FF80FF80FF80FF807F001C
00091B7B9A13>I<000003800000000007C00000000007C0000000000FE0000000000FE0
000000000FE0000000001FF0000000001FF0000000003FF8000000003FF8000000003FF8
0000000073FC0000000073FC00000000F3FE00000000E1FE00000000E1FE00000001C0FF
00000001C0FF00000003C0FF80000003807F80000007807FC0000007003FC0000007003F
C000000E003FE000000E001FE000001E001FF000001C000FF000001FFFFFF000003FFFFF
F800003FFFFFF80000780007FC0000700003FC0000700003FC0000E00001FE0000E00001
FE0001E00001FF0001C00000FF0001C00000FF00FFFE001FFFFEFFFE001FFFFEFFFE001F
FFFE2F297EA834>65 D<00003FF001800003FFFE0780000FFFFF8F80003FF007FF8000FF
8001FF8001FE00007F8007FC00003F8007F800001F800FF000000F801FE000000F803FE0
000007803FC0000007807FC0000003807FC0000003807FC000000380FF8000000000FF80
00000000FF8000000000FF8000000000FF8000000000FF8000000000FF8000000000FF80
00000000FF8000000000FF8000000000FF80000000007FC0000000007FC0000003807FC0
000003803FC0000003803FE0000003801FE0000007800FF00000070007F800000F0007FC
00001E0001FE00003C0000FF8000F800003FF007F000000FFFFFC0000003FFFF00000000
3FF8000029297CA832>67 D<FFFFFFF80000FFFFFFFF8000FFFFFFFFE00003FC001FF800
03FC0007FC0003FC0001FE0003FC0000FF0003FC00007F8003FC00003FC003FC00001FC0
03FC00001FE003FC00001FE003FC00000FF003FC00000FF003FC00000FF003FC00000FF0
03FC00000FF803FC00000FF803FC00000FF803FC00000FF803FC00000FF803FC00000FF8
03FC00000FF803FC00000FF803FC00000FF803FC00000FF803FC00000FF003FC00000FF0
03FC00000FF003FC00001FE003FC00001FE003FC00001FC003FC00003FC003FC00007F80
03FC00007F0003FC0001FE0003FC0003FC0003FC001FF800FFFFFFFFE000FFFFFFFF8000
FFFFFFFC00002D297DA835>I<FFFFFFFFE0FFFFFFFFE0FFFFFFFFE003FC001FE003FC00
07F003FC0001F003FC0001F003FC0000F003FC00007003FC00007003FC00007003FC01C0
7803FC01C03803FC01C03803FC01C03803FC03C00003FC03C00003FC0FC00003FFFFC000
03FFFFC00003FFFFC00003FC0FC00003FC03C00003FC03C00003FC01C00E03FC01C00E03
FC01C00E03FC01C01C03FC00001C03FC00001C03FC00001C03FC00003C03FC00003803FC
00007803FC0000F803FC0001F803FC0003F803FC001FF8FFFFFFFFF0FFFFFFFFF0FFFFFF
FFF027297DA82D>I<00007FE003000003FFFC0F00001FFFFF1F00007FF00FFF0000FF80
01FF0003FE0000FF0007FC00007F000FF800003F000FF000001F001FE000001F003FE000
000F003FC000000F007FC0000007007FC0000007007FC000000700FF8000000000FF8000
000000FF8000000000FF8000000000FF8000000000FF8000000000FF8000000000FF8000
000000FF8000000000FF8001FFFFF8FF8001FFFFF87FC001FFFFF87FC00000FF007FC000
00FF003FC00000FF003FE00000FF001FE00000FF000FF00000FF000FF80000FF0007FC00
00FF0003FE0001FF0000FF8001FF00007FF007FF00001FFFFFBF000003FFFE0F0000007F
F003002D297CA836>71 D<FFFFFCFFFFFCFFFFFC01FE0001FE0001FE0001FE0001FE0001
FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001
FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001
FE0001FE0001FE0001FE0001FE0001FE00FFFFFCFFFFFCFFFFFC16297EA81A>73
D<FFFFFC0000FFFFFC0000FFFFFC000003FC00000003FC00000003FC00000003FC000000
03FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003
FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC
00000003FC00000003FC00000003FC0001C003FC0001C003FC0001C003FC0001C003FC00
03C003FC00038003FC00038003FC00078003FC00078003FC000F8003FC000F8003FC001F
8003FC007F8003FC01FF00FFFFFFFF00FFFFFFFF00FFFFFFFF0022297DA829>76
D<FFFE0000001FFFC0FFFE0000001FFFC0FFFF0000003FFFC003FF0000003FF00003FF00
00003FF00003BF80000077F00003BF80000077F000039FC00000E7F000039FC00000E7F0
00038FE00001C7F000038FE00001C7F0000387F0000387F0000387F0000387F0000387F0
000387F0000383F8000707F0000383F8000707F0000381FC000E07F0000381FC000E07F0
000380FE001C07F0000380FE001C07F0000380FF003807F00003807F003807F00003807F
003807F00003803F807007F00003803F807007F00003801FC0E007F00003801FC0E007F0
0003800FE1C007F00003800FE1C007F00003800FE1C007F000038007F38007F000038007
F38007F000038003FF0007F000038003FF0007F000038001FE0007F000038001FE0007F0
00038000FC0007F000038000FC0007F000FFFE00FC01FFFFC0FFFE007801FFFFC0FFFE00
7801FFFFC03A297DA841>I<FFFC0000FFFEFFFE0000FFFEFFFF0000FFFE03FF80000380
03FFC000038003FFE000038003BFE0000380039FF0000380038FF80003800387FC000380
0387FE0003800383FE0003800381FF0003800380FF80038003807FC0038003807FE00380
03803FF0038003801FF0038003800FF80380038007FC0380038003FE0380038003FF0380
038001FF8380038000FF83800380007FC3800380003FE3800380001FF3800380001FFB80
0380000FFB8003800007FF8003800003FF8003800001FF8003800001FF8003800000FF80
038000007F80038000003F80038000001F80038000000F80FFFE00000F80FFFE00000780
FFFE000003802F297DA836>I<0000FFE000000007FFFC0000003FC07F8000007F001FC0
0001FC0007F00003F80003F80007F00001FC000FF00001FE001FE00000FF001FE00000FF
003FC000007F803FC000007F807FC000007FC07F8000003FC07F8000003FC07F8000003F
C0FF8000003FE0FF8000003FE0FF8000003FE0FF8000003FE0FF8000003FE0FF8000003F
E0FF8000003FE0FF8000003FE0FF8000003FE0FF8000003FE07F8000003FC07FC000007F
C07FC000007FC03FC000007F803FC000007F801FE00000FF001FE00000FF000FF00001FE
0007F00001FC0003F80003F80001FC0007F00000FF001FE000003FC07F8000000FFFFE00
000000FFE000002B297CA834>I<007F806003FFF0E00FFFFFE01F807FE03F001FE07E00
07E07E0003E07C0003E0FC0001E0FC0001E0FC0000E0FE0000E0FE0000E0FF000000FFC0
00007FFE00007FFFE0003FFFFC003FFFFF001FFFFF8007FFFFC003FFFFE000FFFFF00007
FFF000007FF000000FF8000007F8000003F8E00003F8E00001F8E00001F8E00001F8F000
01F8F00001F0F80003F0FC0003E0FF0007E0FFE01FC0FFFFFF00E0FFFE00C01FF0001D29
7CA826>83 D<FFFFF001FFFCFFFFF001FFFCFFFFF001FFFC03FC0000070003FC00000700
03FC0000070003FC0000070003FC0000070003FC0000070003FC0000070003FC00000700
03FC0000070003FC0000070003FC0000070003FC0000070003FC0000070003FC00000700
03FC0000070003FC0000070003FC0000070003FC0000070003FC0000070003FC00000700
03FC0000070003FC0000070003FC0000070003FC0000070003FC0000070003FC00000700
03FC0000070003FC00000F0001FC00000E0001FE00000E0000FE00001E0000FF00003C00
007F80007800003FC000F800001FF007E0000007FFFFC0000001FFFF000000001FF80000
2E297DA835>85 D<FFFFF0003FFF80FFFFF0003FFF80FFFFF0003FFF8003FF000001E000
01FF000003C00000FF8000038000007FC000078000007FE0000F0000003FE0000E000000
1FF0001E0000001FF8003C0000000FF8003800000007FC007800000007FE00F000000003
FE00E000000001FF01E000000001FF83C000000000FF8380000000007FC780000000007F
EF00000000003FEE00000000001FFE00000000000FFC00000000000FF8000000000007F8
000000000007F8000000000007F8000000000007F8000000000007F8000000000007F800
0000000007F8000000000007F8000000000007F8000000000007F8000000000007F80000
00000007F8000000000007F8000000000007F80000000001FFFFE000000001FFFFE00000
0001FFFFE0000031297FA834>89 D<01FF800007FFF0000F81FC001FC0FE001FC07F001F
C07F001FC03F800F803F8000003F8000003F8000003F80000FFF8000FFFF8007FC3F801F
E03F803F803F807F803F807F003F80FE003F80FE003F80FE003F80FE007F80FF007F807F
00FFC03F83DFFC0FFF0FFC01FC03FC1E1B7E9A21>97 D<FFE0000000FFE0000000FFE000
00000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000
000FE00000000FE00000000FE00000000FE00000000FE00000000FE1FE00000FE7FF8000
0FFE07E0000FF803F8000FF001FC000FE000FE000FE000FE000FE0007F000FE0007F000F
E0007F800FE0007F800FE0007F800FE0007F800FE0007F800FE0007F800FE0007F800FE0
007F800FE0007F800FE0007F000FE000FF000FE000FE000FF000FE000FF001FC000FF803
F8000F9E07E0000F0FFF80000E01FC0000212A7EA926>I<001FF80000FFFE0003F01F00
0FE03F801FC03F803F803F803F803F807F801F007F000000FF000000FF000000FF000000
FF000000FF000000FF000000FF000000FF000000FF0000007F0000007F8000003F8001C0
3FC001C01FC003C00FE0078003F01F0000FFFC00001FE0001A1B7E9A1F>I<00003FF800
00003FF80000003FF800000003F800000003F800000003F800000003F800000003F80000
0003F800000003F800000003F800000003F800000003F800000003F800000003F800001F
E3F80000FFFBF80003F03FF8000FE00FF8001FC007F8003F8003F8003F8003F8007F8003
F8007F0003F800FF0003F800FF0003F800FF0003F800FF0003F800FF0003F800FF0003F8
00FF0003F800FF0003F800FF0003F8007F0003F8007F0003F8003F8003F8003F8007F800
1FC00FF8000FE01FF80003F03FFF8000FFF3FF80003FC3FF80212A7EA926>I<003FE000
01FFF80003F07E000FE03F001FC01F803F800FC03F800FC07F000FC07F0007E0FF0007E0
FF0007E0FF0007E0FFFFFFE0FFFFFFE0FF000000FF000000FF000000FF0000007F000000
7F8000003F8000E03F8001E01FC001C00FE003C003F81F8000FFFE00001FF0001B1B7E9A
20>I<0007F0003FFC00FE3E01FC7F03F87F03F87F07F07F07F03E07F00007F00007F000
07F00007F00007F00007F000FFFFC0FFFFC0FFFFC007F00007F00007F00007F00007F000
07F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F000
07F00007F00007F00007F0007FFF807FFF807FFF80182A7EA915>I<00FF81F003FFE7FC
0FC1FE7C1F80FC7C3F80FE7C3F007E107F007F007F007F007F007F007F007F007F007F00
7F007F003F007E003F80FE001F80FC000FC1F8001FFFE00018FF8000380000003C000000
3C0000003E0000003FFFF8003FFFFF001FFFFFC00FFFFFE007FFFFF01FFFFFF07E0007F8
7C0001F8F80001F8F80000F8F80000F8F80000F8FC0001F87E0003F03F0007E00FC01F80
03FFFE00007FF0001E287E9A22>I<FFE0000000FFE0000000FFE00000000FE00000000F
E00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE0
0000000FE00000000FE00000000FE00000000FE07F00000FE1FFC0000FE787E0000FEE07
F0000FFC03F8000FF803F8000FF003F8000FF003F8000FF003F8000FE003F8000FE003F8
000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F800
0FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F800FFFE3FFF80FF
FE3FFF80FFFE3FFF80212A7DA926>I<07001FC01FE03FE03FE03FE01FE01FC007000000
000000000000000000000000FFE0FFE0FFE00FE00FE00FE00FE00FE00FE00FE00FE00FE0
0FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE0FFFEFFFEFFFE0F2B7DAA14>
I<FFE0FFE0FFE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00F
E00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00F
E00FE00FE00FE0FFFEFFFEFFFE0F2A7DA914>108 D<FFC07F800FF000FFC1FFE03FFC00
FFC783F0F07E000FCE03F9C07F000FDC01FB803F000FF801FF003F800FF001FE003F800F
F001FE003F800FF001FE003F800FE001FC003F800FE001FC003F800FE001FC003F800FE0
01FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001
FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC
003F800FE001FC003F80FFFE1FFFC3FFF8FFFE1FFFC3FFF8FFFE1FFFC3FFF8351B7D9A3A
>I<FFC07F0000FFC1FFC000FFC787E0000FCE07F0000FDC03F8000FF803F8000FF003F8
000FF003F8000FF003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F800
0FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000F
E003F8000FE003F8000FE003F800FFFE3FFF80FFFE3FFF80FFFE3FFF80211B7D9A26>I<
003FE00001FFFC0003F07E000FC01F801F800FC03F800FE03F0007E07F0007F07F0007F0
7F0007F0FF0007F8FF0007F8FF0007F8FF0007F8FF0007F8FF0007F8FF0007F8FF0007F8
7F0007F07F0007F03F800FE03F800FE01F800FC00FC01F8007F07F0001FFFC00003FE000
1D1B7E9A22>I<FFE1FE0000FFE7FF8000FFFE07E0000FF803F8000FF001FC000FE001FE
000FE000FE000FE000FF000FE000FF000FE0007F800FE0007F800FE0007F800FE0007F80
0FE0007F800FE0007F800FE0007F800FE0007F800FE0007F800FE000FF000FE000FF000F
E000FE000FF001FE000FF003FC000FF803F8000FFE0FE0000FEFFF80000FE1FC00000FE0
0000000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE000
00000FE0000000FFFE000000FFFE000000FFFE00000021277E9A26>I<FFC1F0FFC7FCFF
CE3E0FDC7F0FD87F0FF87F0FF07F0FF03E0FF0000FE0000FE0000FE0000FE0000FE0000F
E0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE000FFFF00FFFF00FF
FF00181B7E9A1C>114 D<03FE300FFFF03E03F07800F07000F0F00070F00070F80070FC
0000FFE000FFFE007FFFC03FFFE01FFFF007FFF800FFFC0003FC0000FCE0007CE0003CF0
003CF0003CF80078FC0078FF01F0F7FFC0C1FF00161B7E9A1B>I<007000007000007000
00700000F00000F00000F00001F00003F00003F00007F0001FFFF0FFFFF0FFFFF007F000
07F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F000
07F03807F03807F03807F03807F03807F03807F03803F87001F8F000FFE0001F8015267F
A51B>I<FFE03FF800FFE03FF800FFE03FF8000FE003F8000FE003F8000FE003F8000FE0
03F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003
F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE007F8
000FE007F8000FE00FF80007E01FF80003F03BFF8001FFF3FF80003FC3FF80211B7D9A26
>I<FFFE03FF80FFFE03FF80FFFE03FF8007F000700007F000700007F800F00003F800E0
0003FC01E00001FC01C00001FC01C00000FE03800000FE038000007F070000007F070000
007F8F0000003F8E0000003FDE0000001FDC0000001FDC0000000FF80000000FF8000000
0FF800000007F000000007F000000003E000000003E000000001C00000211B7F9A24>I<
FFFE7FFC0FFEFFFE7FFC0FFEFFFE7FFC0FFE0FE007E000E007F003F001C007F003F001C0
07F807F803C003F807F8038003F807F8038001FC0EFC070001FC0EFC070001FE1EFC0F00
00FE1C7E0E0000FE1C7E0E0000FF383F1E00007F383F1C00007F783F3C00003FF01FB800
003FF01FB800003FF01FF800001FE00FF000001FE00FF000000FC007E000000FC007E000
000FC007E00000078003C00000078003C0002F1B7F9A32>I<FFFC0FFF00FFFC0FFF00FF
FC0FFF0007F003C00003F807800001FC07800000FE0F000000FF1E0000007F3C0000003F
F80000001FF00000000FF00000000FF000000007F000000007F80000000FFC0000001FFE
0000001EFE0000003C7F000000783F800000F01FC00001E01FE00001C00FE00003C007F0
00FFF01FFF80FFF01FFF80FFF01FFF80211B7F9A24>I<FFFE03FF80FFFE03FF80FFFE03
FF8007F000700007F000700007F800F00003F800E00003FC01E00001FC01C00001FC01C0
0000FE03800000FE038000007F070000007F070000007F8F0000003F8E0000003FDE0000
001FDC0000001FDC0000000FF80000000FF80000000FF800000007F000000007F0000000
03E000000003E000000001C000000001C000000003800000000380000038078000007C07
000000FE0F000000FE0E000000FE1E000000FE3C0000007C780000003FE00000000FC000
000021277F9A24>I E /Fe 40 122 df<6060F0F0F8F868680808080808081010101020
20404080800D0C7F9C15>34 D<0006000000060000000600000006000000060000000600
0000060000000600000006000000060000000600000006000000060000FFFFFFE0FFFFFF
E00006000000060000000600000006000000060000000600000006000000060000000600
00000600000006000000060000000600001B1C7E9720>43 D<60F0F07010101010202040
80040C7C830C>I<FFE0FFE00B0280890E>I<60F0F06004047C830C>I<03E00C30100820
0C20066006600660067006780C3E083FB01FE007F007F818FC307E601E600FC007C003C0
03C003C00360026004300C1C1007E0101D7E9B15>56 D<00060000000600000006000000
0F0000000F0000000F00000017800000178000001780000023C0000023C0000023C00000
41E0000041E0000041E0000080F0000080F0000180F8000100780001FFF80003007C0002
003C0002003C0006003E0004001E0004001E000C001F001E001F00FF80FFF01C1D7F9C1F
>65 D<FFFFC00F00F00F00380F003C0F001C0F001E0F001E0F001E0F001E0F001C0F003C
0F00780F01F00FFFE00F00780F003C0F001E0F000E0F000F0F000F0F000F0F000F0F000F
0F001E0F001E0F003C0F0078FFFFE0181C7E9B1D>I<001F808000E06180018019800700
07800E0003801C0003801C00018038000180780000807800008070000080F0000000F000
0000F0000000F0000000F0000000F0000000F0000000F000000070000080780000807800
0080380000801C0001001C0001000E000200070004000180080000E03000001FC000191E
7E9C1E>I<FFFFF80F00780F00180F00080F00080F000C0F00040F00040F02040F02000F
02000F02000F06000FFE000F06000F02000F02000F02000F02000F00000F00000F00000F
00000F00000F00000F00000F8000FFF800161C7E9B1B>70 D<001F808000E06180018019
80070007800E0003801C0003801C00018038000180780000807800008070000080F00000
00F0000000F0000000F0000000F0000000F0000000F000FFF0F0000F8070000780780007
8078000780380007801C0007801C0007800E00078007000B800180118000E06080001F80
001C1E7E9C21>I<FFF8000F80000F00000F00000F00000F00000F00000F00000F00000F
00000F00000F00000F00000F00000F00000F00000F00000F00000F00080F00080F00080F
00180F00180F00100F00300F00700F01F0FFFFF0151C7E9B1A>76
D<003F800000E0E0000380380007001C000E000E001C0007003C00078038000380780003
C0780003C0700001C0F00001E0F00001E0F00001E0F00001E0F00001E0F00001E0F00001
E0F00001E0700001C0780003C0780003C0380003803C0007801C0007000E000E0007001C
000380380000E0E000003F80001B1E7E9C20>79 D<07E0801C1980300580700380600180
E00180E00080E00080E00080F00000F800007C00007FC0003FF8001FFE0007FF0000FF80
000F800007C00003C00001C08001C08001C08001C0C00180C00180E00300D00200CC0C00
83F800121E7E9C17>83 D<7FFFFFC0700F01C0600F00C0400F0040400F0040C00F002080
0F0020800F0020800F0020000F0000000F0000000F0000000F0000000F0000000F000000
0F0000000F0000000F0000000F0000000F0000000F0000000F0000000F0000000F000000
0F0000000F0000001F800003FFFC001B1C7F9B1E>I<FFF007FC0F8001E00780008007C0
018003C0010003E0020001F0020000F0040000F8040000780800007C1800003C1000001E
2000001F2000000F4000000FC00000078000000780000007800000078000000780000007
80000007800000078000000780000007800000078000007FF8001E1C809B1F>89
D<08081010202040404040808080808080B0B0F8F8787830300D0C7A9C15>92
D<1FC000307000783800781C00301C00001C00001C0001FC000F1C00381C00701C00601C
00E01C40E01C40E01C40603C40304E801F870012127E9115>97 D<FC00001C00001C0000
1C00001C00001C00001C00001C00001C00001C00001C00001C7C001D86001E03001C0180
1C01C01C00C01C00E01C00E01C00E01C00E01C00E01C00E01C00C01C01C01C01801E0300
19060010F800131D7F9C17>I<07E00C301878307870306000E000E000E000E000E000E0
0060007004300418080C3007C00E127E9112>I<003F0000070000070000070000070000
070000070000070000070000070000070003E7000C1700180F00300700700700600700E0
0700E00700E00700E00700E00700E00700600700700700300700180F000C370007C7E013
1D7E9C17>I<03E00C301818300C700E6006E006FFFEE000E000E000E000600070023002
18040C1803E00F127F9112>I<00F8018C071E061E0E0C0E000E000E000E000E000E00FF
E00E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E007FE00F
1D809C0D>I<00038003C4C00C38C01C3880181800381C00381C00381C00381C00181800
1C38000C300013C0001000003000001800001FF8001FFF001FFF803003806001C0C000C0
C000C0C000C06001803003001C0E0007F800121C7F9215>I<FC00001C00001C00001C00
001C00001C00001C00001C00001C00001C00001C00001C7C001C87001D03001E03801C03
801C03801C03801C03801C03801C03801C03801C03801C03801C03801C03801C03801C03
80FF9FF0141D7F9C17>I<18003C003C0018000000000000000000000000000000FC001C
001C001C001C001C001C001C001C001C001C001C001C001C001C001C001C00FF80091D7F
9C0C>I<FC00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00
001C3FC01C0F001C0C001C08001C10001C20001C40001CE0001DE0001E70001C78001C38
001C3C001C1C001C0E001C0F001C0F80FF9FE0131D7F9C16>107
D<FC001C001C001C001C001C001C001C001C001C001C001C001C001C001C001C001C001C
001C001C001C001C001C001C001C001C001C001C00FF80091D7F9C0C>I<FC7E07E0001C
838838001D019018001E01E01C001C01C01C001C01C01C001C01C01C001C01C01C001C01
C01C001C01C01C001C01C01C001C01C01C001C01C01C001C01C01C001C01C01C001C01C0
1C001C01C01C00FF8FF8FF8021127F9124>I<FC7C001C87001D03001E03801C03801C03
801C03801C03801C03801C03801C03801C03801C03801C03801C03801C03801C0380FF9F
F014127F9117>I<03F0000E1C00180600300300700380600180E001C0E001C0E001C0E0
01C0E001C0E001C06001807003803003001806000E1C0003F00012127F9115>I<FC7C00
1D86001E03001C01801C01C01C00C01C00E01C00E01C00E01C00E01C00E01C00E01C01C0
1C01C01C01801E03001D06001CF8001C00001C00001C00001C00001C00001C00001C0000
FF8000131A7F9117>I<FCE01D301E781E781C301C001C001C001C001C001C001C001C00
1C001C001C001C00FFC00D127F9110>114 D<1F9030704030C010C010E010F8007F803F
E00FF000F880388018C018C018E010D0608FC00D127F9110>I<04000400040004000C00
0C001C003C00FFE01C001C001C001C001C001C001C001C001C001C101C101C101C101C10
0C100E2003C00C1A7F9910>I<FC1F801C03801C03801C03801C03801C03801C03801C03
801C03801C03801C03801C03801C03801C03801C07800C07800E1B8003E3F014127F9117
>I<FF07E03C03801C01001C01000E02000E020007040007040007040003880003880003
D80001D00001D00000E00000E00000E00000400013127F9116>I<FF3FCFE03C0F03801C
0701801C0701001C0B01000E0B82000E0B82000E1182000711C4000711C4000720C40003
A0E80003A0E80003C0680001C0700001C0700001803000008020001B127F911E>I<7F8F
F00F03800F030007020003840001C80001D80000F00000700000780000F800009C00010E
00020E000607000403801E07C0FF0FF81512809116>I<FF07E03C03801C01001C01000E
02000E020007040007040007040003880003880003D80001D00001D00000E00000E00000
E000004000004000008000008000F08000F10000F300006600003C0000131A7F9116>I
E /Ff 3 52 df<0C001C00EC000C000C000C000C000C000C000C000C000C000C000C000C
000C000C000C00FFC00A137D9211>49 D<1F0060C06060F070F030603000700070006000
C001C00180020004000810101020207FE0FFE00C137E9211>I<0FC03070703870387038
0038003000E00FC0007000380018001C601CF01CF018E03860701FC00E137F9211>I
E /Fg 61 126 df<2008F01EF01EF01EF01EF01EF01EF01EF01E701C701C701C701C701C
600C0F0F7B9E1A>34 D<00600000E00000E00000E00000E00003FC000FFF001FFF803EE7
C078E1C0F0E1E0E0E0E0E0E1E0E0E1E0E0E0C0F0E00078E0003FE0001FF8000FFE0001FF
0000EF8000E3C000E1C060E1E0F0E0E0F0E0E0F0E0E0E0E1E0F0E1C078E3C03EEF801FFF
000FFE0003F80000E00000E00000E00000600013277DA21A>36 D<3C00C07E01E07E03E0
FF03E0E703C0E707C0E707C0E70780E70F80E70F80E71F00FF1F007E1E007E3E003C3E00
003C00007C00007C0000F80000F80000F00001F00001F00001E00003E00003E00003C1E0
07C3F007C3F00F87F80F87380F07381F07381F07381E07383E07F83E03F03C03F01801E0
15277EA21A>I<01E00003F00007F8000F3C000E1C000E1C000E1C000E1C000E3C000E39
FC0E79FC0FF1FC07E1E007C1C00781C00783C00F83801FC7803DC70079E700F0EF00E0FE
00E07E00E03C08E03C1CF07E1C78FF3C7FE7F83FC3F80F81F0161E7F9D1A>I<1C3C3E1E
0E0E0E0E1E1C3C38F8F0E0070F779D1A>I<0038007800F801E003C007800F001E001C00
3C0038007800700070007000F000E000E000E000E000E000E000E000E000F00070007000
7000780038003C001C001E000F00078003C001E000F8007800380D2878A21A>I<6000F0
0078003C001E000F00078003C001C001E000E000F0007000700070007800380038003800
380038003800380038007800700070007000F000E001E001C003C007800F001E003C0078
00F00060000D287CA21A>I<00E00000E00000E00000E00040E040F0E1E0F8E3E07EEFC0
1FFF0007FC0003F80007FC001FFF007EEFC0F8E3E0F0E1E040E04000E00000E00000E000
00E00013157D991A>I<0030000078000078000078000078000078000078000078000078
007FFFF0FFFFF8FFFFF87FFFF00078000078000078000078000078000078000078000078
0000300015167E991A>I<3C7E7F7F7F3F070F0E3EFCF8E0080D77851A>I<7FFFC0FFFFE0
FFFFE07FFFC013047D901A>I<78FCFCFCFC78060676851A>I<0000C00001E00003E00003
E00003C00007C00007C0000F80000F80001F00001F00001E00003E00003E00007C00007C
0000F80000F80001F00001F00001E00003E00003E00007C00007C0000F80000F80000F00
001F00001F00003E00003E00007C00007C0000780000F80000F80000F000006000001327
7DA21A>I<01F00007FC000FFE001F1F001C07003803803803807001C07001C07001C0E0
00E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0F001E07001C07001C078
03C03803803C07801C07001F1F000FFE0007FC0001F000131E7D9D1A>I<00C001C003C0
03C007C00FC07FC0FDC079C001C001C001C001C001C001C001C001C001C001C001C001C0
01C001C001C001C001C001C07FFF7FFF7FFF101E7B9D1A>I<07F8000FFE001FFF003C0F
807803C0F001C0E001E0F000E0F000E06000E00000E00000E00001E00001C00003C00007
80000F00000E00003E00007C0000F80001E00003C0000780000F00001E00E03C00E07FFF
E0FFFFE07FFFE0131E7D9D1A>I<78FCFCFCFC7800000000000000000078FCFCFCFC7806
1576941A>58 D<3C7E7E7E7E3C0000000000000000003C7C7E7E7E3E0E1E1C3CF8F0E007
1C77941A>I<7FFFF0FFFFF8FFFFF87FFFF00000000000000000000000007FFFF0FFFFF8
FFFFF87FFFF0150C7E941A>61 D<007E0001FF8003FFC007C3E00F00E01E0FF03C3FF038
7FF07879F870F0F8F0E078E1E078E1C038E1C038E1C038E1C038E1C038E1C038E1E078F0
E07070F0F07879E0387FE03C3FC01E0F000F003807C1F803FFF801FFE0007F80151E7E9D
1A>64 D<003800007C00007C00006C0000EE0000EE0000EE0000C60000C60001C70001C7
0001C70001C7000383800383800383800383800701C00701C007FFC007FFC00FFFE00E00
E00E00E00E00E00E00E01C00707F01FCFF83FE7F01FC171E7F9D1A>I<00FE3803FFB807
FFF80F83F81E00F81C00783C0078780038700038700038F00000E00000E00000E00000E0
0000E00000E00000E00000E00000F000007000387000387800383C00781C00701E00F00F
83E007FFC003FF8000FE00151E7E9D1A>67 D<7FFE00FFFF007FFF801C07C01C01E01C00
F01C00701C00781C00381C00381C003C1C001C1C001C1C001C1C001C1C001C1C001C1C00
1C1C001C1C003C1C00381C00381C00781C00701C00F01C01E01C07C07FFFC0FFFF007FFE
00161E7F9D1A>I<FFFFF8FFFFF8FFFFF81C00381C00381C00381C00381C00001C00001C
00001C0E001C0E001C0E001FFE001FFE001FFE001C0E001C0E001C0E001C00001C00001C
00001C001C1C001C1C001C1C001C1C001CFFFFFCFFFFFCFFFFFC161E7E9D1A>I<FFFF80
FFFF80FFFF8001C00001C00001C00001C00001C00001C00001C00001C00001C00001C000
01C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C000
01C00001C000FFFF80FFFF80FFFF80111E7C9D1A>73 D<7FE000FFF0007FE0000E00000E
00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E
00000E00000E00000E00000E00000E00000E001C0E001C0E001C0E001C0E001C7FFFFCFF
FFFC7FFFFC161E7F9D1A>76 D<7E003F00FF007F807F007F001D80DC001D80DC001D80DC
001DC1DC001DC1DC001CC19C001CC19C001CE39C001CE39C001C631C001C771C001C771C
001C361C001C361C001C3E1C001C1C1C001C1C1C001C001C001C001C001C001C001C001C
001C001C001C001C001C001C007F007F00FF80FF807F007F00191E809D1A>I<FE03FEFF
03FEFF03FE1D80701D80701DC0701CC0701CC0701CE0701CE0701C60701C70701C70701C
30701C38701C38701C18701C1C701C1C701C0C701C0E701C0E701C06701C06701C07701C
03701C0370FF81F0FF81F0FF80F0171E7F9D1A>I<0FFE003FFF807FFFC07C07C07001C0
F001E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0
E000E0E000E0E000E0E000E0E000E0E000E0F001E0F001E07001C07C07C07FFFC03FFF80
0FFE00131E7D9D1A>I<07F1C01FFDC03FFFC07C1FC07007C0F003C0E001C0E001C0E001
C0E00000F000007800003F00001FF8000FFE0001FF00000F800003C00001C00001E00000
E06000E0E000E0E000E0F001E0F003C0FE0780FFFF80FFFE00E3FC00131E7D9D1A>83
D<7FFFFEFFFFFEFFFFFEE0380EE0380EE0380EE0380E0038000038000038000038000038
000038000038000038000038000038000038000038000038000038000038000038000038
0000380000380000380003FF8003FF8003FF80171E7F9D1A>I<FF83FEFF83FEFF83FE1C
00701C00701C00701C00701C00701C00701C00701C00701C00701C00701C00701C00701C
00701C00701C00701C00701C00701C00701C00701C00701E00F00E00E00F01E007C7C003
FF8001FF00007C00171E7F9D1A>I<FF01FEFF01FEFF01FE1C00701C00701C00701E00F0
0E00E00E00E00E00E00701C00701C00701C00701C003838003838003838003838001C700
01C70001C70001C70000C60000EE0000EE0000EE00006C00007C00007C00003800171E7F
9D1A>I<FFF8FFF8FFF8E000E000E000E000E000E000E000E000E000E000E000E000E000
E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000
E000E000FFF8FFF8FFF80D2776A21A>91 D<600000F00000F80000F800007800007C0000
7C00003E00003E00001F00001F00000F00000F80000F800007C00007C00003E00003E000
01E00001F00001F00000F80000F800007C00007C00003E00003E00001E00001F00001F00
000F80000F800007C00007C00003C00003E00003E00001E00000C013277DA21A>I<FFF8
FFF8FFF80038003800380038003800380038003800380038003800380038003800380038
00380038003800380038003800380038003800380038003800380038003800380038FFF8
FFF8FFF80D277EA21A>I<1FF0003FFC007FFE00781F0030078000038000038000FF8007
FF801FFF803F83807C0380F00380E00380E00380E00380F007807C1F803FFFFC1FFDFC07
F0FC16157D941A>97 D<FE0000FE0000FE00000E00000E00000E00000E00000E00000E00
000E3F000EFFC00FFFE00FE1F00F80700F00780F00380E003C0E001C0E001C0E001C0E00
1C0E001C0F003C0F00380F00780F80F00FC3E00FFFC00EFF80067E00161E7F9D1A>I<01
FF8007FFC00FFFE01F01E03C00C0780000700000F00000E00000E00000E00000E00000E0
0000F000007000007800703C00701F01F00FFFE007FFC001FF0014157D941A>I<001FC0
001FC0001FC00001C00001C00001C00001C00001C00001C001F9C007FDC00FFFC01F0FC0
3C07C07803C07003C0F001C0E001C0E001C0E001C0E001C0E001C0F003C07003C07807C0
3807C03E1FC01FFFFC0FFDFC03F1FC161E7E9D1A>I<01FC0007FF000FFF801F07C03C01
E07800E07000F0F00070E00070FFFFF0FFFFF0FFFFF0E00000F000007000007800703C00
701F01F00FFFE007FFC001FF0014157D941A>I<000FF0001FF8003FF800787800F03000
E00000E00000E00000E0007FFFF0FFFFF0FFFFF000E00000E00000E00000E00000E00000
E00000E00000E00000E00000E00000E00000E00000E00000E00000E0003FFF807FFFC03F
FF80151E7F9D1A>I<01F8FC07FFFE0FFFFE1F0F8C1C03803C03C03801C03801C03801C0
3C03C01C03801F0F801FFF003FFE0039F8003800003C00001C00001FFF801FFFF03FFFF8
7C00FC70001CF0001EE0000EE0000EE0000EF0001E78003C3F01F81FFFF00FFFE001FF00
17217F941A>I<FE0000FE0000FE00000E00000E00000E00000E00000E00000E00000E3F
000EFF800FFFC00FE1E00F80E00F00E00F00E00E00E00E00E00E00E00E00E00E00E00E00
E00E00E00E00E00E00E00E00E00E00E0FFE3FEFFE7FEFFE3FE171E7F9D1A>I<00C00001
E00001E00000C0000000000000000000000000000000000000007FE0007FE0007FE00000
E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000
E00000E00000E0007FFF80FFFFC07FFF80121F7C9E1A>I<FE0000FE0000FE00000E0000
0E00000E00000E00000E00000E00000E0FFC0E1FFE0E0FFC0E03C00E07800E0F000E1E00
0E3C000E78000EFC000FFC000FDE000F8F000E07800E03C00E03C00E01E00E00F0FFE3FE
FFE3FFFFE3FE181E7F9D1A>107 D<FFE000FFE000FFE00000E00000E00000E00000E000
00E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E000
00E00000E00000E00000E00000E00000E00000E00000E000FFFFE0FFFFE0FFFFE0131E7D
9D1A>I<7DF1F000FFFBF8007FFFFC001F1F1C001E1E1C001E1E1C001C1C1C001C1C1C00
1C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C00
1C1C1C007F1F1F00FF9F9F807F1F1F00191580941A>I<FE3F00FEFF80FFFFC00FE1E00F
80E00F00E00F00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E
00E00E00E0FFE3FEFFE7FEFFE3FE17157F941A>I<01F00007FC001FFF003E0F803C0780
7803C07001C0E000E0E000E0E000E0E000E0E000E0E000E0F001E07001C07803C03C0780
3E0F801FFF0007FC0001F00013157D941A>I<FE3F00FEFFC0FFFFE00FE1F00F80700F00
780F00380E003C0E001C0E001C0E001C0E001C0E001C0F003C0F00380F00780F80F00FC3
E00FFFC00EFF800E7E000E00000E00000E00000E00000E00000E00000E00000E0000FFE0
00FFE000FFE00016207F941A>I<01F8E007FEE00FFFE01F0FE03C03E07801E07001E0F0
00E0E000E0E000E0E000E0E000E0E000E0F001E07001E07803E03C07E01E0FE00FFFE007
FCE003F8E00000E00000E00000E00000E00000E00000E00000E00000E0000FFE000FFE00
0FFE17207E941A>I<7F87F0FF9FFC7FBFFC03FC3C03F01803E00003E00003C00003C000
0380000380000380000380000380000380000380000380000380007FFF00FFFF007FFF00
16157E941A>I<0FFB803FFF807FFF80F80F80E00380E00380E00380F800007FC0003FFC
000FFF00007F800007C06001C0E001C0F001C0F003C0FC0F80FFFF00FFFE00E7F8001215
7C941A>I<00C00001C00001C00001C00001C00001C00001C0007FFFE0FFFFE0FFFFE001
C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C07001C07001
C07001C0F001E1E000FFE0007FC0003F00141C7F9B1A>I<FE0FE0FE0FE0FE0FE00E00E0
0E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E01E0
0E01E00F07E007FFFE03FFFE01FCFE17157F941A>I<7F83FCFFC7FE7F83FC0E00E00E00
E00E00E00701C00701C00701C003838003838003838001C70001C70001C70000EE0000EE
0000EE00007C00007C0000380017157F941A>I<7FC7F87FCFFC7FC7F80703C003838003
C70001EF0000FE00007C00007800003800007C0000EE0001EE0001C7000383800783C00F
01C07FC7FCFFC7FE7FC7FC17157F941A>120 D<7FC3FCFFC7FE7FC3FC0E00E00E00E007
00E00701C00781C00381C003838003C38001C38001C70000E70000E70000E60000660000
6E00003C00003C00003C0000380000380000380000700000700030700078E00071E0007F
C0003F80001E000017207F941A>I<0007E0001FE0003FE0007C0000F00000E00000E000
00E00000E00000E00000E00000E00000E00000E00000E00000E00001E00007C000FF8000
FF0000FF800007C00001E00000E00000E00000E00000E00000E00000E00000E00000E000
00E00000E00000E00000F000007C00003FE0001FE00007E013277DA21A>123
D<7C0000FF0000FF800007C00001E00000E00000E00000E00000E00000E00000E00000E0
0000E00000E00000E00000E00000F000007C00003FE0001FE0003FE0007C0000F00000E0
0000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00001E00007C0
00FF8000FF00007C000013277DA21A>125 D E /Fh 31 123 df<00000FE00000301800
00E01C0001C03C0001803C00038038000380000003800000070000000700000007000000
07000000070000000E000000FFFFE0000E00E0000E00E0000E01C0001C01C0001C01C000
1C01C0001C0380001C038000380380003803800038070000380700003807000070070800
700E1000700E1000700E1000700E2000E0062000E003C000E0000000E0000000C0000001
C0000001C0000071800000F1800000F3000000620000003C0000001E2D82A21B>12
D<FFF0FFF0FFE00C037C8B11>45 D<0000030000000300000007000000070000000F0000
000F0000001F0000002F0000002F0000004F0000004F8000008780000087800001078000
020780000207800004078000040780000807800008078000100780003007800020078000
7FFF80004007C0008007C0008003C0010003C0030003C0020003C0040003C0040003C00C
0003C03C0007C0FF003FFC1E237DA224>65 D<00FFFC00000F8000000F0000000F000000
1E0000001E0000001E0000001E0000003C0000003C0000003C0000003C00000078000000
780000007800000078000000F0000000F0000000F0000000F0000001E0000001E0000001
E0002001E0002003C0004003C0004003C0008003C0008007800180078001000780030007
800F000F803E00FFFFFE001B227DA11F>76 D<00FF800007FC000F80000F80000F800017
80000F80001780001780002F000013C0002F000013C0004F000013C0008F000023C0009E
000023C0011E000023C0011E000023C0021E000043C0043C000043C0043C000043C0083C
000041E0083C000081E01078000081E02078000081E02078000081E04078000101E040F0
000101E080F0000101E100F0000101E100F0000200F201E0000200F201E0000200F401E0
000200F801E0000400F803C0000400F003C0000400F003C0000C00E003C0001E00C007C0
00FFC0C07FFC002E227DA12C>I<0000FE0000078380000C00E0003800700070003800E0
003801C0001C0380001C0700001C0F00001E1E00001E1C00001E3C00001E3C00001E7800
001E7800001E7800001EF000003CF000003CF000003CF0000078F0000078E0000078E000
00F0E00000F0E00001E0E00001C0F00003C0F00007807000070078000E0038001C001C00
38000E00E0000703800001FC00001F2479A225>79 D<00FFFFC0000F0070000F003C000F
001C001E000E001E000E001E000F001E000F003C001E003C001E003C001E003C003C0078
003800780070007801E00078078000FFFC0000F00E0000F0070000F0038001E003C001E0
03C001E003C001E003C003C0078003C0078003C0078003C0078007800F0007800F010780
0F01078007020F800702FFF8038C000000F020237DA124>82 D<3FFE03FF03C0007803C0
006003C00020078000400780004007800040078000400F0000800F0000800F0000800F00
00801E0001001E0001001E0001001E0001003C0002003C0002003C0002003C0002007800
040078000400780004007800040070000800F0000800F000100070001000700020007000
40003000400038018000180200000E0C000003F00000202377A124>85
D<FFF001FF1F8000780F0000600F0000400F8000C0078000800780010007C0020003C006
0003C0040003E0080001E0100001E0200001F0600000F0400000F0800000F9000000FB00
00007A0000007C00000078000000780000007800000078000000F0000000F0000000F000
0000F0000001E0000001E0000001E0000001E0000003E000003FFC0000202276A124>89
D<00F8C00185C00705C00E03800E03801C03803C0380380700780700780700780700F00E
00F00E00F00E00F00E10F01C20701C20703C20305C40308C400F078014157B9419>97
D<03C03F8003800380038007000700070007000E000E000E000E001C001CF81D0C1E0E3C
0638073807380F700F700F700F700FE01EE01EE01EE03CE038E038607060E031C01F0010
237BA216>I<007E0001C1000301800703800E07801C07803C0000380000780000780000
780000F00000F00000F00000F00000F00100700100700200300C001830000FC00011157B
9416>I<00003C0003F80000380000380000380000700000700000700000700000E00000
E00000E00000E00001C000F9C00185C00705C00E03800E03801C03803C03803807007807
00780700780700F00E00F00E00F00E00F00E10F01C20701C20703C20305C40308C400F07
8016237BA219>I<00F803840E021C023C0238027804F018FFE0F000F000E000E000E000
E000E002E0026004701830600F800F157A9416>I<00003E0000470000CF00018F000186
000380000380000380000700000700000700000700000700000E0000FFF0000E00000E00
000E00001C00001C00001C00001C00001C00003800003800003800003800003800007000
00700000700000700000700000E00000E00000E00000E00000C00001C00001C000718000
F18000F300006200003C0000182D82A20F>I<001F180030B800E0B801C07001C0700380
700780700700E00F00E00F00E00F00E01E01C01E01C01E01C01E01C01E03800E03800E07
80060B8006170001E700000700000700000E00000E00000E00701C00F01800F0300060E0
003F8000151F7E9416>I<00F0000FE00000E00000E00000E00001C00001C00001C00001
C000038000038000038000038000070000071F0007218007C0C00F00E00F00E00E00E00E
00E01C01C01C01C01C01C01C01C0380380380380380380380704700708700E08700E1070
0610E006206003C016237DA219>I<00C001E001C001C000000000000000000000000000
0000001C002300430043008700870087000E000E001C001C001C00380038003840708070
807080710032001C000B217BA00F>I<01E01FC001C001C001C003800380038003800700
0700070007000E000E000E000E001C001C001C001C003800380038003800700070007000
7100E200E200E200E200640038000B237CA20C>108 D<1C0F80F8002610C10C00476066
060087807807008780780700870070070087007007000E00E00E000E00E00E000E00E00E
000E00E00E001C01C01C001C01C01C001C01C01C001C01C0382038038038403803807040
3803807080380380308070070031003003001E0023157B9428>I<1C0F002631C04740C0
8780E08780E08700E08700E00E01C00E01C00E01C00E01C01C03801C03801C03801C0704
380708380E08380E103806107006203003C016157B941B>I<007E0001C3000381800701
C00E01C01C01E03C01E03801E07801E07801E07801E0F003C0F003C0F00380F007807007
00700E00700C0030180018700007C00013157B9419>I<01C1F002621804741C08780C08
700E08700E08701E00E01E00E01E00E01E00E01E01C03C01C03C01C03C01C07803807003
807003C0E003C1C0072380071E000700000700000E00000E00000E00000E00001C00001C
00001C0000FFC000171F7F9419>I<1C1F002620804741C08783C08703C0870180870000
0E00000E00000E00000E00001C00001C00001C00001C0000380000380000380000380000
70000030000012157B9415>114 D<00FC000183000200800401800C03800C03000C0000
0F00000FF00007FC0003FE00003E00000F00000700700700F00600F00600E00400400800
2030001FC00011157D9414>I<00C001C001C001C001C003800380038003800700FFF807
0007000E000E000E000E001C001C001C001C003800380038003810702070207040708031
001E000D1F7C9E10>I<1E00602300E04380E04381C08381C08701C08701C00703800E03
800E03800E03801C07001C07001C07001C07081C0E10180E101C0E101C1E200C262007C3
C015157B941A>I<1E03802307C04387C04383C08381C08700C08700C00700800E00800E
00800E00801C01001C01001C01001C02001C02001C04001C08001C08000C300003C00012
157B9416>I<03C1E0046210083470103CF02038F0203860203800007000007000007000
00700000E00000E00000E00000E02061C040F1C040F1C080E2C100446200383C0014157D
9416>120 D<1E00302300704380704380E08380E08700E08700E00701C00E01C00E01C0
0E01C01C03801C03801C03801C03801C07001C07001C07001C0F000C3E0003CE00000E00
000E00001C00601C00F03800F03000E0600080C0004380003E0000141F7B9418>I<01E0
2003F06007F8C0041F800801000802000004000008000010000020000040000080000100
000200000400800801001003003F060061FC0040F80080700013157D9414>I
E /Fi 3 52 df<03000700FF000700070007000700070007000700070007000700070007
00070007000700070007007FF00C157E9412>49 D<0F8030E040708030C038E038403800
3800700070006000C00180030006000C08080810183FF07FF0FFF00D157E9412>I<0FE0
30306018701C701C001C00180038006007E000300018000C000E000EE00EE00EC00C4018
30300FE00F157F9412>I E /Fj 2 121 df<0007FC0000003FFF800000FC07E00003F001
F80007E000FC000FC0007E001F80003F001F80003F003F00001F803F00001F807F00001F
C07E00000FC07E00000FC0FE00000FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE0
FE00000FE0FE00000FE0FE00000FE0FE00000FE07E00000FC07F00001FC07F00001FC03F
00001F803F80003F801F80003F000FC0007E0007E000FC0003F001F80000FC07E000003F
FF80000007FC000023227DA12A>79 D<FFE07FC0FFE07FC00F801C0007C0380003E07000
03F0600001F8C00000F98000007F8000003F0000001F0000001F8000003FC0000037C000
0063E00000C1F00001C0F8000380FC0007007E000E003E00FF80FFE0FF80FFE01B167F95
1E>120 D E /Fk 14 118 df<78FCFCFCFC780606778518>46 D<00FC0003FE0007FF00
0F87801E03C03C3FC0387FC078FFE071E3E071C1E0F3C1E0E380E0E380E0E380E0E380E0
E380E0E380E0F3C1E071C1C071E3C078FF80387F003C3E001E00E00F83E007FFE003FF80
00FE00131C7E9B18>64 D<1FE0003FF8007FFC00783E00300F0000070000070001FF000F
FF003FFF007F0700780700F00700E00700E00700F00F00783F007FFFF03FFBF00FE1F014
147D9318>97 D<7E0000FE00007E00000E00000E00000E00000E00000E00000E3E000EFF
800FFFC00FE3E00F80F00F00700F00780E00380E00380E00380E00380E00380F00380F00
780F00700F80F00FC3E00FFFC00EFF80067E00151C809B18>I<01FE0007FF001FFF803F
07803C0300780000700000F00000E00000E00000E00000E00000F000007000007801C03C
01C03F07C01FFF8007FF0001FC0012147D9318>I<001F80003F80001F80000380000380
00038000038000038003F3800FFB801FFF803E1F80780F80700780F00780E00380E00380
E00380E00380E00380E00780F00780700780780F803E3F801FFFF00FFBF803E3F0151C7E
9B18>I<03F0000FFC001FFE003E1F00780780700380F003C0E001C0E001C0FFFFC0FFFF
C0FFFFC0F000007000007801C03C01C03F07C01FFF8007FF0001FC0012147D9318>I<00
1FC0007FE000FFE001F1E001C0C001C00001C00001C0007FFFC0FFFFC0FFFFC001C00001
C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001
C0007FFF007FFF007FFF00131C7F9B18>I<7E0000FE00007E00000E00000E00000E0000
0E00000E00000E3F000EFF800FFFC00FE1E00F80E00F00E00F00E00E00E00E00E00E00E0
0E00E00E00E00E00E00E00E00E00E00E00E00E00E07FC3FCFFE7FE7FC3FC171C809B18>
104 D<03800007C00007C00007C0000380000000000000000000000000007FC000FFC000
7FC00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C000
01C00001C00001C000FFFF00FFFF80FFFF00111D7C9C18>I<01F0000FFE001FFF003E0F
803803807001C07001C0E000E0E000E0E000E0E000E0E000E0F001E07001C07803C03C07
803E0F801FFF000FFE0001F00013147E9318>111 D<0FF7003FFF007FFF00F81F00E007
00E00700F007007C00007FF0001FFC0007FE00001F00600780E00380F00380F00780FC0F
00FFFF00FFFE00E7F80011147D9318>115 D<0180000380000380000380000380007FFF
C0FFFFC0FFFFC00380000380000380000380000380000380000380000380000380000380
400380E00380E00381E003C3C001FFC000FF80007E0013197F9818>I<7E07E0FE0FE07E
07E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E
00E00E01E00F07E007FFFC03FFFE01FCFC1714809318>I E /Fl
1 14 df<0001FE0000000FFFC000003E01F00000F0003C0001C0000E0003800007000700
0003800E000001C00C000000C01C000000E0380000007030000000303000000030700000
003860000000186000000018E00000001CC00000000CC00000000CC00000000CC0000000
0CC00000000CC00000000CC00000000CC00000000CC00000000CE00000001C6000000018
600000001870000000383000000030300000003038000000701C000000E00C000000C00E
000001C00700000380038000070001C0000E0000F0003C00003E01F000000FFFC0000001
FE0000262B7DA02D>13 D E /Fm 24 119 df<001F83E000F06E3001C078780380F87803
00F03007007000070070000700700007007000070070000700700007007000FFFFFF8007
007000070070000700700007007000070070000700700007007000070070000700700007
00700007007000070070000700700007007000070070000700700007007000070070007F
E3FF001D20809F1B>11 D<70F8FCFC74040404080810102040060E7C840D>44
D<70F8F8F87005057C840D>46 D<018003800F80F3800380038003800380038003800380
0380038003800380038003800380038003800380038003800380038003800380038007C0
FFFE0F1E7C9D17>49 D<03F0000C1C00100E00200700400780800780F007C0F803C0F803
C0F803C02007C00007C0000780000780000F00000E00001C0000380000700000600000C0
000180000300000600400C00401800401000803FFF807FFF80FFFF80121E7E9D17>I<03
F0000C1C00100E00200F00780F80780780780780380F80000F80000F00000F00000E0000
1C0000380003F000003C00000E00000F000007800007800007C02007C0F807C0F807C0F8
07C0F00780400780400F00200E001C3C0003F000121F7E9D17>I<1803001FFE001FFC00
1FF8001FE00010000010000010000010000010000010000011F000161C00180E00100700
1007800003800003800003C00003C00003C07003C0F003C0F003C0E00380400380400700
200600100E000C380003E000121F7E9D17>53 D<03F0000E18001C0C0038060038070070
0700700380F00380F00380F003C0F003C0F003C0F003C0F003C07007C07007C03807C018
0BC00E13C003E3C0000380000380000380000700300700780600780E00700C0020180010
70000FC000121F7E9D17>57 D<FFFFE0000F80380007801E0007801F0007800F0007800F
8007800F8007800F8007800F8007800F8007800F0007801F0007801E0007803C0007FFF0
0007803C0007801E0007800F0007800F8007800780078007C0078007C0078007C0078007
C0078007C00780078007800F8007800F0007801F000F803C00FFFFF0001A1F7E9E20>66
D<FFFC0FFC0FC003E0078001800780010007800200078004000780080007801000078020
000780400007808000078100000783000007878000078F80000793C0000791E00007A1E0
0007C0F0000780F0000780780007803C0007803C0007801E0007801E0007800F00078007
8007800780078007C00FC007E0FFFC3FFC1E1F7E9E23>75 D<FF80001FF80F80001F8007
80001F0005C0002F0005C0002F0005C0002F0004E0004F0004E0004F000470008F000470
008F000470008F000438010F000438010F000438010F00041C020F00041C020F00041C02
0F00040E040F00040E040F00040E040F000407080F000407080F000407080F000403900F
000403900F000401E00F000401E00F000401E00F000E00C00F001F00C01F80FFE0C1FFF8
251F7E9E2A>77 D<FF803FF807C007C007C0038005E0010005E0010004F0010004780100
04780100043C0100043C0100041E0100040F0100040F010004078100040781000403C100
0401E1000401E1000400F1000400F1000400790004003D0004003D0004001F0004001F00
04000F0004000700040007000E0003001F000300FFE001001D1F7E9E22>I<0E0000FE00
000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E3E000EC3
800F01C00F00E00E00E00E00700E00700E00780E00780E00780E00780E00780E00780E00
700E00700E00E00F00E00D01C00CC300083E0015207F9F19>98 D<03F80E0C1C1E381E38
0C70007000F000F000F000F000F000F00070007000380138011C020E0C03F010147E9314
>I<03F0000E1C001C0E00380700380700700700700380F00380F00380FFFF80F00000F0
0000F000007000007000003800801800800C010007060001F80011147F9314>101
D<0E0000FE00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00
000E3E000E43000E81800F01C00F01C00E01C00E01C00E01C00E01C00E01C00E01C00E01
C00E01C00E01C00E01C00E01C00E01C00E01C00E01C0FFE7FC16207F9F19>104
D<1C001E003E001E001C000000000000000000000000000E007E000E000E000E000E000E
000E000E000E000E000E000E000E000E000E000E000E000E00FFC00A1F809E0C>I<0E1F
01F000FE618618000E81C81C000F00F00E000F00F00E000E00E00E000E00E00E000E00E0
0E000E00E00E000E00E00E000E00E00E000E00E00E000E00E00E000E00E00E000E00E00E
000E00E00E000E00E00E000E00E00E000E00E00E00FFE7FE7FE023147F9326>109
D<01F800070E001C03803801C03801C07000E07000E0F000F0F000F0F000F0F000F0F000
F0F000F07000E07000E03801C03801C01C0380070E0001F80014147F9317>111
D<0E78FE8C0F1E0F1E0F0C0E000E000E000E000E000E000E000E000E000E000E000E000E
000E00FFE00F147F9312>114 D<1F9030704030C010C010C010E00078007F803FE00FF0
0070803880188018C018C018E030D0608F800D147E9312>I<020002000200060006000E
000E003E00FFF80E000E000E000E000E000E000E000E000E000E000E000E080E080E080E
080E080610031001E00D1C7F9B12>I<0E01C0FE1FC00E01C00E01C00E01C00E01C00E01
C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E03C00603C0030D
C001F1FC16147F9319>I<FF83F81E01E01C00C00E00800E00800E008007010007010003
820003820003820001C40001C40001EC0000E80000E80000700000700000700000200015
147F9318>I E /Fn 76 123 df<001F83E000706E3000C07C780180F8780380F0780700
70000700700007007000070070000700700007007000070070000700700007007000FFFF
FFC007007000070070000700700007007000070070000700700007007000070070000700
700007007000070070000700700007007000070070000700700007007000070070000700
7000070078007FE3FF801D2380A21C>11 D<001FC0000070200000C01000018038000380
780007007800070030000700000007000000070000000700000007000000070000000700
0000FFFFF800070078000700380007003800070038000700380007003800070038000700
380007003800070038000700380007003800070038000700380007003800070038000700
380007003800070038007FE1FF80192380A21B>I<001FD8000070380000C07800018078
000380780007003800070038000700380007003800070038000700380007003800070038
0007003800FFFFF800070038000700380007003800070038000700380007003800070038
000700380007003800070038000700380007003800070038000700380007003800070038
000700380007003800070038007FF3FF80192380A21B>I<000FC07F00007031C08000E0
0B004001801E00E003803E01E007003C01E007001C00C007001C000007001C000007001C
000007001C000007001C000007001C000007001C0000FFFFFFFFE007001C01E007001C00
E007001C00E007001C00E007001C00E007001C00E007001C00E007001C00E007001C00E0
07001C00E007001C00E007001C00E007001C00E007001C00E007001C00E007001C00E007
001C00E007001C00E007001C00E07FF1FFCFFE272380A229>I<7038F87CFC7EFC7E743A
04020402040204020804080410081008201040200F0F7EA218>34
D<70F8FCFC7404040404080810102040060F7CA20E>39 D<002000400080010003000600
04000C000C00180018003000300030007000600060006000E000E000E000E000E000E000
E000E000E000E000E000E000E000E0006000600060007000300030003000180018000C00
0C0004000600030001000080004000200B327CA413>I<800040002000100018000C0004
00060006000300030001800180018001C000C000C000C000E000E000E000E000E000E000
E000E000E000E000E000E000E000E000C000C000C001C001800180018003000300060006
0004000C00180010002000400080000B327DA413>I<0001800000018000000180000001
800000018000000180000001800000018000000180000001800000018000000180000001
8000000180000001800000018000FFFFFFFEFFFFFFFE0001800000018000000180000001
800000018000000180000001800000018000000180000001800000018000000180000001
80000001800000018000000180001F227D9C26>43 D<70F8FCFC74040404040808101020
40060F7C840E>I<FFE0FFE00B027F8B10>I<70F8F8F87005057C840E>I<000180000180
000380000300000300000700000600000600000E00000C00000C00001C00001800001800
00180000380000300000300000700000600000600000E00000C00000C00001C000018000
0180000380000300000300000700000600000600000E00000C00000C00000C00001C0000
180000180000380000300000300000700000600000600000E00000C00000C0000011317D
A418>I<01F000071C000C06001803003803803803807001C07001C07001C07001C0F001
E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001
E0F001E07001C07001C07001C07803C03803803803801C07000C0600071C0001F0001322
7EA018>I<008003800F80F3800380038003800380038003800380038003800380038003
8003800380038003800380038003800380038003800380038003800380038007C0FFFE0F
217CA018>I<03F0000C1C001007002007804003C04003C08003E0F003E0F801E0F801E0
F801E02003E00003E00003C00003C0000780000700000E00001C00001800003000006000
00C0000180000100000200200400200800201800603000403FFFC07FFFC0FFFFC013217E
A018>I<03F8000C1E001007002007804007C07807C07803C07807C03807C00007800007
80000700000F00000E0000380003F000001C00000F000007800007800003C00003C00003
E02003E07003E0F803E0F803E0F003C04003C0400780200780100F000C1C0003F0001322
7EA018>I<000200000600000E00000E00001E00001E00002E00004E00004E00008E0000
8E00010E00020E00020E00040E00040E00080E00100E00100E00200E00200E00400E0080
0E00FFFFF8000E00000E00000E00000E00000E00000E00000E00001F0001FFF015217FA0
18>I<1000801E07001FFF001FFE001FF80013E000100000100000100000100000100000
10000010F800130E001407001803801003800001C00001C00001E00001E00001E00001E0
7001E0F001E0F001E0E001C08001C04003C04003802007001006000C1C0003F00013227E
A018>I<007E0001C1000300800601C00E03C01C03C01801803800003800007800007000
00700000F0F800F30C00F40600F40300F80380F801C0F001C0F001E0F001E0F001E0F001
E0F001E07001E07001E07001E03801C03801C01803801C03000C0600070C0001F0001322
7EA018>I<4000006000007FFFE07FFFC07FFFC0400080C0010080010080020080020000
040000080000080000100000300000200000600000600000600000E00000C00000C00001
C00001C00001C00001C00003C00003C00003C00003C00003C00003C00003C00003C00001
800013237DA118>I<01F800060E000803001001802001802000C06000C06000C06000C0
7000C07801803E01003F02001FC4000FF80003F80003FC00067F00083F80100F803007C0
6001C06000E0C000E0C00060C00060C00060C000606000406000C03000801803000E0E00
03F00013227EA018>I<01F000060C000C0600180700380380700380700380F001C0F001
C0F001C0F001E0F001E0F001E0F001E0F001E07001E07003E03803E01805E00C05E00619
E003E1E00001C00001C00001C0000380000380300300780700780600700C002018001030
000FC00013227EA018>I<70F8F8F870000000000000000000000070F8F8F87005157C94
0E>I<70F8F8F870000000000000000000000070F8F8F87808080808101010204040051F
7C940E>I<0001800000018000000180000003C0000003C0000003C0000005E0000005E0
00000DF0000008F0000008F0000010F800001078000010780000203C0000203C0000203C
0000401E0000401E0000401E0000800F0000800F0000FFFF000100078001000780030007
C0020003C0020003C0040003E0040001E0040001E00C0000F00C0000F03E0001F8FF800F
FF20237EA225>65 D<FFFFF8000F800E0007800780078003C0078003E0078001E0078001
F0078001F0078001F0078001F0078001F0078001E0078003E0078007C007800F8007803E
0007FFFE0007800780078003C0078001E0078001F0078000F0078000F8078000F8078000
F8078000F8078000F8078000F8078001F0078001F0078003E0078007C00F800F00FFFFFC
001D227EA123>I<0007E0100038183000E0063001C00170038000F0070000F00E000070
1E0000701C0000303C0000303C0000307C0000107800001078000010F8000000F8000000
F8000000F8000000F8000000F8000000F8000000F800000078000000780000107C000010
3C0000103C0000101C0000201E0000200E000040070000400380008001C0010000E00200
00381C000007E0001C247DA223>I<FFFFF0000F801E0007800700078003C0078001C007
8000E0078000F007800078078000780780007C0780003C0780003C0780003C0780003E07
80003E0780003E0780003E0780003E0780003E0780003E0780003E0780003E0780003C07
80003C0780007C0780007807800078078000F0078000E0078001E0078003C0078007000F
801E00FFFFF8001F227EA125>I<FFFFFFC00F8007C0078001C0078000C0078000400780
004007800060078000200780002007800020078020200780200007802000078020000780
60000780E00007FFE0000780E00007806000078020000780200007802000078020080780
000807800008078000100780001007800010078000300780003007800070078000E00F80
03E0FFFFFFE01D227EA121>I<FFFFFFC00F8007C0078001C0078000C007800040078000
400780006007800020078000200780002007802020078020000780200007802000078060
000780E00007FFE0000780E0000780600007802000078020000780200007802000078000
0007800000078000000780000007800000078000000780000007800000078000000FC000
00FFFE00001B227EA120>I<0007F008003C0C1800E0021801C001B8038000F807000078
0F0000381E0000381E0000183C0000183C0000187C0000087800000878000008F8000000
F8000000F8000000F8000000F8000000F8000000F8000000F8001FFF780000F878000078
7C0000783C0000783C0000781E0000781E0000780F00007807000078038000B801C000B8
00E00318003C0C080007F00020247DA226>I<FFFC3FFF0FC003F0078001E0078001E007
8001E0078001E0078001E0078001E0078001E0078001E0078001E0078001E0078001E007
8001E0078001E0078001E007FFFFE0078001E0078001E0078001E0078001E0078001E007
8001E0078001E0078001E0078001E0078001E0078001E0078001E0078001E0078001E007
8001E00FC003F0FFFC3FFF20227EA125>I<FFFC0FC00780078007800780078007800780
078007800780078007800780078007800780078007800780078007800780078007800780
078007800780078007800FC0FFFC0E227EA112>I<03FFF0001F00000F00000F00000F00
000F00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F00
000F00000F00000F00000F00000F00000F00000F00000F00000F00700F00F80F00F80F00
F80E00F01E00401C0020380018700007C00014237EA119>I<FFFC03FF000FC000F80007
800060000780004000078000800007800100000780020000078004000007800800000780
10000007802000000780400000078080000007818000000783C000000787E000000789E0
00000788F000000790F0000007A078000007C03C000007803C000007801E000007800F00
0007800F00000780078000078007C000078003C000078001E000078001E000078000F000
078000F8000FC000FC00FFFC07FF8021227EA126>I<FFFE00000FC00000078000000780
000007800000078000000780000007800000078000000780000007800000078000000780
000007800000078000000780000007800000078000000780000007800000078000000780
000007800080078000800780008007800080078001800780018007800100078003000780
030007800F000F803F00FFFFFF0019227EA11E>I<FFC00003FF0FC00003F007C00003E0
05E00005E005E00005E004F00009E004F00009E004F00009E004780011E004780011E004
780011E0043C0021E0043C0021E0043C0021E0041E0041E0041E0041E0040F0081E0040F
0081E0040F0081E004078101E004078101E004078101E00403C201E00403C201E00401E4
01E00401E401E00401E401E00400F801E00400F801E00400F801E004007001E00E007001
E01F007003F0FFE0203FFF28227EA12D>I<FF8007FF07C000F807C0007005E0002004F0
002004F0002004780020047C0020043C0020041E0020041F0020040F0020040780200407
80200403C0200401E0200401E0200400F0200400F8200400782004003C2004003E200400
1E2004000F2004000F20040007A0040003E0040003E0040001E0040001E0040000E00E00
00601F000060FFE0002020227EA125>I<000FE00000783C0000E00E0003C00780078003
C00F0001E00E0000E01E0000F03C0000783C0000787C00007C7C00007C7800003C780000
3CF800003EF800003EF800003EF800003EF800003EF800003EF800003EF800003EF80000
3E7800003C7C00007C7C00007C3C0000783E0000F81E0000F00F0001E00F0001E0078003
C003C0078000E00E0000783C00000FE0001F247DA226>I<FFFFF0000F803C0007800F00
07800780078007C0078003C0078003E0078003E0078003E0078003E0078003E0078003E0
078003C0078007C00780078007800F0007803C0007FFF000078000000780000007800000
078000000780000007800000078000000780000007800000078000000780000007800000
07800000078000000FC00000FFFC00001B227EA121>I<FFFFE000000F803C000007800E
00000780078000078007C000078003C000078003E000078003E000078003E000078003E0
00078003E000078003C000078007C000078007800007800E000007803C000007FFE00000
0780700000078038000007801C000007801E000007800E000007800F000007800F000007
800F000007800F000007800F800007800F800007800F800007800F808007800FC0800780
07C0800FC003C100FFFC01E2000000007C0021237EA124>82 D<03F0200C0C6018026030
01E07000E0600060E00060E00060E00020E00020E00020F00000F000007800007F00003F
F0001FFE000FFF0003FF80003FC00007E00001E00000F00000F000007080007080007080
0070800070C00060C00060E000C0F000C0C80180C6070081FC0014247DA21B>I<7FFFFF
F87807807860078018400780084007800840078008C007800C8007800480078004800780
048007800400078000000780000007800000078000000780000007800000078000000780
000007800000078000000780000007800000078000000780000007800000078000000780
0000078000000780000007800000078000000FC00003FFFF001E227EA123>I<FFFC07FF
0FC000F80780007007800020078000200780002007800020078000200780002007800020
078000200780002007800020078000200780002007800020078000200780002007800020
078000200780002007800020078000200780002007800020078000200380004003C00040
03C0004001C0008000E000800060010000300600001C08000003F00020237EA125>I<FF
F03FFC03FE1F8007E000F80F0003C000700F0003C000200F0003C00020078001E0004007
8001E00040078001E0004003C002F0008003C002F0008003C002F0008001E00478010001
E00478010001E00478010000F0083C020000F0083C020000F0083C020000F8183E060000
78101E04000078101E0400007C101E0400003C200F0800003C200F0800003C200F080000
1E40079000001E40079000001E40079000000F8003E000000F8003E000000F8003E00000
070001C00000070001C00000070001C0000003000180000002000080002F237FA132>87
D<FFF0007FC01F80001F000F80000C00078000080007C000180003E000100001E0002000
01F000200000F000400000F800C000007C008000003C010000003E010000001E02000000
1F040000000F84000000078800000007D800000003D000000003E000000001E000000001
E000000001E000000001E000000001E000000001E000000001E000000001E000000001E0
00000001E000000001E000000001E000000003E00000003FFF000022227FA125>89
D<FEFEC0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0
C0C0C0C0C0C0C0C0C0C0C0C0FEFE07317BA40E>91 D<0804100820102010402040208040
804080408040B85CFC7EFC7E7C3E381C0F0F7AA218>I<FEFE0606060606060606060606
06060606060606060606060606060606060606060606060606060606060606060606FEFE
07317FA40E>I<0FE0001838003C0C003C0E0018070000070000070000070000FF0007C7
001E07003C0700780700700700F00708F00708F00708F00F087817083C23900FC1E01515
7E9418>97 D<0E0000FE00001E00000E00000E00000E00000E00000E00000E00000E0000
0E00000E00000E00000E00000E1F000E61C00E80600F00300E00380E003C0E001C0E001E
0E001E0E001E0E001E0E001E0E001E0E001E0E001C0E003C0E00380F00700C80600C41C0
083F0017237FA21B>I<01FE000703000C07801C0780380300780000700000F00000F000
00F00000F00000F00000F00000F000007000007800403800401C00800C010007060001F8
0012157E9416>I<0000E0000FE00001E00000E00000E00000E00000E00000E00000E000
00E00000E00000E00000E00000E001F8E00704E00C02E01C01E03800E07800E07000E0F0
00E0F000E0F000E0F000E0F000E0F000E0F000E07000E07800E03800E01801E00C02E007
0CF001F0FE17237EA21B>I<01FC000707000C03801C01C03801C07801E07000E0F000E0
FFFFE0F00000F00000F00000F00000F000007000007800203800201C00400E0080070300
00FC0013157F9416>I<003C00C6018F038F030F07000700070007000700070007000700
0700FFF80700070007000700070007000700070007000700070007000700070007000700
0700070007807FF8102380A20F>I<00007001F198071E180E0E181C07001C07003C0780
3C07803C07803C07801C07001C07000E0E000F1C0019F000100000100000180000180000
1FFE000FFFC00FFFE03800F0600030400018C00018C00018C000186000306000303800E0
0E038003FE0015217F9518>I<0E0000FE00001E00000E00000E00000E00000E00000E00
000E00000E00000E00000E00000E00000E00000E1F800E60C00E80E00F00700F00700E00
700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00
700E00700E0070FFE7FF18237FA21B>I<1C001E003E001E001C00000000000000000000
000000000000000E00FE001E000E000E000E000E000E000E000E000E000E000E000E000E
000E000E000E000E000E00FFC00A227FA10E>I<01C003E003E003E001C0000000000000
0000000000000000000001E00FE001E000E000E000E000E000E000E000E000E000E000E0
00E000E000E000E000E000E000E000E000E000E000E000E000E060E0F0C0F18061803E00
0B2C82A10F>I<0E0000FE00001E00000E00000E00000E00000E00000E00000E00000E00
000E00000E00000E00000E00000E03FC0E01F00E01C00E01800E02000E04000E08000E10
000E38000EF8000F1C000E1E000E0E000E07000E07800E03C00E01C00E01E00E00F00E00
F8FFE3FE17237FA21A>I<0E00FE001E000E000E000E000E000E000E000E000E000E000E
000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E
000E000E000E00FFE00B237FA20E>I<0E1FC07F00FE60E183801E807201C00F003C00E0
0F003C00E00E003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E
003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E00
3800E00E003800E0FFE3FF8FFE27157F942A>I<0E1F80FE60C01E80E00F00700F00700E
00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E
00700E00700E0070FFE7FF18157F941B>I<01FC000707000C01801800C03800E0700070
700070F00078F00078F00078F00078F00078F00078F000787000707800F03800E01C01C0
0E038007070001FC0015157F9418>I<0E1F00FE61C00E80600F00700E00380E003C0E00
1C0E001E0E001E0E001E0E001E0E001E0E001E0E001E0E003C0E003C0E00380F00700E80
E00E41C00E3F000E00000E00000E00000E00000E00000E00000E00000E00000E0000FFE0
00171F7F941B>I<01F8200704600E02601C01603801E07800E07800E0F000E0F000E0F0
00E0F000E0F000E0F000E0F000E07000E07800E03801E01C01E00C02E0070CE001F0E000
00E00000E00000E00000E00000E00000E00000E00000E00000E0000FFE171F7E941A>I<
0E3CFE461E8F0F0F0F060F000E000E000E000E000E000E000E000E000E000E000E000E00
0E000F00FFF010157F9413>I<0F8830786018C018C008C008E008F0007F803FE00FF001
F8003C801C800C800CC00CC008E018D0308FC00E157E9413>I<02000200020002000600
060006000E001E003E00FFF80E000E000E000E000E000E000E000E000E000E000E000E04
0E040E040E040E040E040708030801F00E1F7F9E13>I<0E0070FE07F01E00F00E00700E
00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E
00F00E00F006017003827800FC7F18157F941B>I<FFC1FE1E00780E00300E00200E0020
07004007004003808003808003808001C10001C10000E20000E20000E200007400007400
00380000380000380000100017157F941A>I<FF8FF8FF1E01E03C1C01C0180E01C0180E
01E0100E01E01007026020070270200702702003843040038438400384384001C8188001
C81C8001C81C8000F00D0000F00F0000F00F0000600600006006000060060020157F9423
>I<FF83FE1F01F00E00C007008003810003830001C20000E40000780000780000380000
3C00004E00008E000187000103800201C00401E00C00E03E01F0FF03FE17157F941A>I<
FFC1FE1E00780E00300E00200E002007004007004003808003808003808001C10001C100
00E20000E20000E200007400007400003800003800003800001000001000002000002000
002000004000F04000F08000F180004300003C0000171F7F941A>I<3FFFC03803803007
80200700600E00401C00403C0040380000700000E00001E00001C0000380400700400F00
400E00C01C0080380080780180700780FFFF8012157F9416>I E
/Fo 49 123 df<FFFFF0FFFFF0FFFFF0FFFFF0FFFFF0FFFFF0FFFFF014077F921B>45
D<1F003F807FC0FFE0FFE0FFE0FFE0FFE07FC03F801F000B0B7A8A17>I<000000380000
007C0000007C000000FC000000F8000000F8000001F8000001F0000001F0000003F00000
03E0000007E0000007C0000007C000000FC000000F8000000F8000001F8000001F000000
3F0000003E0000003E0000007E0000007C0000007C000000FC000000F8000001F8000001
F0000001F0000003F0000003E0000003E0000007E0000007C000000FC000000F8000000F
8000001F8000001F0000001F0000003F0000003E0000003E0000007E0000007C000000FC
000000F8000000F8000001F8000001F0000001F0000003F0000003E0000007E0000007C0
000007C000000FC000000F8000000F8000001F8000001F0000003F0000003E0000003E00
00007E0000007C0000007C000000FC000000F8000000F8000000700000001E487BB529>
I<000FFC0000007FFF800001FFFFE00003FC0FF00007F003F8000FE001FC000FE001FC00
1FC000FE003FC000FF003FC000FF003F80007F007F80007F807F80007F807F80007F807F
80007F80FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF80
007FC0FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF8000
7FC0FF80007FC0FF80007FC07F80007F807F80007F807F80007F807F80007F803F80007F
003FC000FF003FC000FF001FC000FE001FE001FE000FE001FC0007F807F80003FC0FF000
01FFFFE000007FFF8000000FFC0000222E7DAD29>I<0001E0000003E000000FE000007F
E0001FFFE000FFFFE000FFBFE000E03FE000003FE000003FE000003FE000003FE000003F
E000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003F
E000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003F
E000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003F
E000003FE000003FE000003FE0007FFFFFF07FFFFFF07FFFFFF01C2E7AAD29>I<003FF0
0001FFFE0007FFFF801FC07FE03F003FF07C001FF87F000FFCFF8007FEFFC007FEFFC003
FFFFC003FFFFC003FFFFC003FF7F8003FF3F0003FF000003FF000003FF000007FE000007
FE000007FC00000FF800001FF800001FF000003FE000007F8000007F000000FE000001FC
000003F0000007E000000FC007001F8007003E0007007C000F00F8000E01F0000E01E000
1E03FFFFFE07FFFFFE0FFFFFFE1FFFFFFE3FFFFFFE7FFFFFFCFFFFFFFCFFFFFFFCFFFFFF
FC202E7CAD29>I<000FFC0000007FFF800001F01FE00003C00FF00007800FF8000FE007
FC001FF007FE001FF807FE001FF807FE001FF807FE001FF807FE001FF807FE000FF007FE
0007E007FC0001800FFC0000000FF80000000FF80000001FF00000003FE00000007F8000
001FFE0000001FFC0000001FFF800000001FF00000000FF800000007FE00000003FF0000
0003FF00000001FF80000001FF800E0001FFC03F8001FFC07FC001FFC0FFE001FFC0FFE0
01FFC0FFE001FFC0FFE001FFC0FFE001FF80FFE003FF807FC003FF007F0007FE003F000F
FC001FE01FF80007FFFFE00001FFFF8000001FFC0000222E7DAD29>I<00000078000000
00F800000001F800000003F800000007F800000007F80000000FF80000001FF80000003F
F80000007FF800000077F8000000F7F8000001E7F8000003C7F800000787F800000707F8
00000F07F800001E07F800003C07F800007807F800007007F80000F007F80001E007F800
03C007F800078007F8000F0007F8000F0007F8001E0007F8003C0007F800780007F800F0
0007F800FFFFFFFFF0FFFFFFFFF0FFFFFFFFF000000FF80000000FF80000000FF8000000
0FF80000000FF80000000FF80000000FF80000000FF80000000FF800000FFFFFF0000FFF
FFF0000FFFFFF0242E7EAD29>I<0C0000380FC003F80FFFFFF80FFFFFF00FFFFFE00FFF
FFC00FFFFF800FFFFF000FFFFC000FFFF0000FFF00000F0000000F0000000F0000000F00
00000F0000000F0000000F0000000F1FF8000FFFFF000FFFFFC00FF01FE00F800FF00F00
07F80E0007FC000003FE000003FE000003FE000003FF000003FF1E0003FF7F8003FFFF80
03FFFFC003FFFFC003FFFFC003FFFF8003FEFF8003FE7F0007FC7C0007FC3C000FF81E00
1FF00FC07FE007FFFF8001FFFE00003FE000202E7CAD29>I<00007F80000007FFF00000
1FC07800007F001C0000FE001E0001FC007E0003F800FF0007F001FF000FF001FF001FE0
01FF001FE001FF003FE000FE003FE0007C007FC00000007FC00000007FC00000007FC000
0000FFC3FF8000FFC7FFE000FFCFBFF000FFDC03FC00FFF803FE00FFF001FF00FFF000FF
00FFE000FF80FFE000FF80FFE000FFC0FFC000FFC0FFC000FFC0FFC000FFC0FFC000FFC0
7FC000FFC07FC000FFC07FC000FFC07FC000FFC03FC000FFC03FC000FF801FE000FF801F
E000FF000FE001FF000FF001FE0007F803FC0001FC0FF80000FFFFE000003FFF80000007
FC0000222E7DAD29>I<38000000003E000000003FFFFFFFC03FFFFFFFC03FFFFFFFC03F
FFFFFF807FFFFFFF007FFFFFFE007FFFFFFC007FFFFFF8007FFFFFF800780001F0007000
03E000700007C000F0000F8000E0000F0000E0001F0000E0003E000000007C00000000F8
00000000F800000001F000000003F000000003F000000007E000000007E00000000FE000
00000FE00000000FE00000001FE00000001FC00000001FC00000003FC00000003FC00000
003FC00000003FC00000003FC00000007FC00000007FC00000007FC00000007FC0000000
7FC00000007FC00000007FC00000007FC00000007FC00000003F800000001F0000002230
7BAF29>I<0007FC0000003FFF800000F80FE00001E003F00003C001F80007C000FC000F
8000FC000F80007E001F80007E001F80007E001FC0007E001FE0007E001FF0007E001FF8
00FE001FFE00FC001FFF81FC000FFFE3F8000FFFFFF00007FFFFC00003FFFF800003FFFF
C00000FFFFF000007FFFF80001FFFFFC0007F7FFFE000FE1FFFF001FC0FFFF803F803FFF
807F000FFF807E0003FFC0FE0000FFC0FC00007FC0FC00003FC0FC00001FC0FC00000FC0
FC00000FC0FC00000F80FE00000F807E00001F807F00001F003F80003E001FC0007C000F
F803F80003FFFFE00000FFFF8000001FFC0000222E7DAD29>I<000FFC0000007FFF0000
01FC0FC00007F807F0000FF003F8001FE001FC003FE001FC003FC001FE007FC000FF007F
C000FF00FFC000FF00FFC000FF80FFC000FF80FFC000FF80FFC000FF80FFC000FFC0FFC0
00FFC0FFC000FFC0FFC000FFC07FC001FFC07FC001FFC07FC001FFC03FE003FFC01FE003
FFC01FF007FFC00FF80EFFC003FF7CFFC001FFF8FFC0007FF0FFC0000000FF80000000FF
80000000FF80000000FF800F8001FF001FC001FF003FE001FE003FE001FE003FE003FC00
3FE003F8003FC007F8001F800FF0001E001FE0000F807F800007FFFE000001FFF8000000
7FC00000222E7DAD29>I<1F003F807FC0FFE0FFE0FFE0FFE0FFE07FC03F801F00000000
00000000000000000000000000000000001F003F807FC0FFE0FFE0FFE0FFE0FFE07FC03F
801F000B207A9F17>I<0000007C0000000000007C000000000000FE000000000000FE00
0000000000FE000000000001FF000000000001FF000000000003FF800000000003FF8000
00000007FFC00000000007FFC00000000007FFC0000000000FFFE0000000000F7FE00000
00001F7FF0000000001E3FF0000000001E3FF0000000003E3FF8000000003C1FF8000000
007C1FFC00000000780FFC00000000780FFC00000000F80FFE00000000F007FE00000001
F007FF00000001E003FF00000001E003FF00000003E003FF80000003C001FF80000007C0
01FFC00000078000FFC00000078000FFC000000FFFFFFFE000000FFFFFFFE000001FFFFF
FFF000001E00003FF000001E00003FF000003C00003FF800003C00001FF800007C00001F
FC00007800000FFC00007800000FFC0000F0000007FE0000F0000007FE0001F0000007FF
0003F8000003FF00FFFFC001FFFFFEFFFFC001FFFFFEFFFFC001FFFFFE37317DB03E>65
D<000003FF80038000003FFFF007800001FFFFFC0F800007FF007F1F80001FF8000FFF80
007FE00003FF8000FFC00001FF8001FF000000FF8003FE0000007F8007FE0000003F800F
FC0000001F801FF80000001F801FF80000000F803FF80000000F803FF00000000F803FF0
00000007807FF000000007807FF000000007807FE00000000000FFE00000000000FFE000
00000000FFE00000000000FFE00000000000FFE00000000000FFE00000000000FFE00000
000000FFE00000000000FFE00000000000FFE00000000000FFE000000000007FE0000000
00007FF000000000007FF000000003803FF000000003803FF000000003803FF800000003
801FF800000007801FF800000007000FFC0000000F0007FE0000000E0003FF0000001E00
01FF0000003C0000FFC000007800007FE00001F000001FF80003E0000007FF003F800000
01FFFFFE000000003FFFF80000000003FF80000031317BB03C>67
D<FFFFFFFFFFF000FFFFFFFFFFF000FFFFFFFFFFF00000FFC0003FF00000FFC00007F800
00FFC00003F80000FFC00000F80000FFC00000F80000FFC00000780000FFC00000780000
FFC00000380000FFC00000380000FFC00000380000FFC000001C0000FFC007001C0000FF
C007001C0000FFC007001C0000FFC00700000000FFC00700000000FFC00F00000000FFC0
1F00000000FFC03F00000000FFFFFF00000000FFFFFF00000000FFFFFF00000000FFC03F
00000000FFC01F00000000FFC00F00000000FFC00700000000FFC00700000000FFC00700
038000FFC00700038000FFC00700038000FFC00000070000FFC00000070000FFC0000007
0000FFC00000070000FFC000000F0000FFC000000F0000FFC000001E0000FFC000001E00
00FFC000003E0000FFC000007E0000FFC00000FE0000FFC00003FE0000FFC0001FFE00FF
FFFFFFFFFC00FFFFFFFFFFFC00FFFFFFFFFFFC0031317EB036>69
D<FFFFFFC0FFFFFFC0FFFFFFC000FFC00000FFC00000FFC00000FFC00000FFC00000FFC0
0000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC0
0000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC0
0000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC0
0000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC0
0000FFC000FFFFFFC0FFFFFFC0FFFFFFC01A317EB01F>73 D<FFFFFFF00000FFFFFFF000
00FFFFFFF0000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000007000FFC00000
7000FFC000007000FFC00000F000FFC00000F000FFC00000E000FFC00000E000FFC00001
E000FFC00001E000FFC00003E000FFC00003E000FFC00007E000FFC0000FE000FFC0001F
E000FFC0007FC000FFC003FFC0FFFFFFFFFFC0FFFFFFFFFFC0FFFFFFFFFFC02C317EB032
>76 D<00000FFE0000000000FFFFE000000007FFFFFC0000001FFC07FF0000003FE000FF
800000FF80003FE00001FF00001FF00003FE00000FF80007FC000007FC0007FC000007FC
000FF8000003FE001FF8000003FF001FF0000001FF003FF0000001FF803FF0000001FF80
3FF0000001FF807FE0000000FFC07FE0000000FFC07FE0000000FFC0FFE0000000FFE0FF
E0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0
000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE07FE000
0000FFC07FE0000000FFC07FF0000001FFC07FF0000001FFC03FF0000001FF803FF00000
01FF801FF8000003FF001FF8000003FF000FFC000007FE000FFC000007FE0007FE00000F
FC0003FF00001FF80001FF80003FF00000FFC0007FE000003FE000FF8000001FFC07FF00
000007FFFFFC00000000FFFFE0000000000FFE00000033317BB03E>79
D<FFFFFFFFE000FFFFFFFFFE00FFFFFFFFFF8000FFC001FFE000FFC0003FF000FFC0001F
F800FFC0000FFC00FFC0000FFC00FFC00007FE00FFC00007FE00FFC00007FF00FFC00007
FF00FFC00007FF00FFC00007FF00FFC00007FF00FFC00007FF00FFC00007FF00FFC00007
FE00FFC00007FE00FFC0000FFC00FFC0000FFC00FFC0001FF800FFC0003FF000FFC001FF
E000FFFFFFFF8000FFFFFFFE0000FFFFFFE00000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC0000000FFFFFFC00000FFFFFFC000
00FFFFFFC0000030317EB038>I<001FF0038000FFFF078003FFFFCF8007F00FFF801FC0
01FF801F80007F803F00003F807F00001F807E00000F807E00000F80FE00000780FE0000
0780FF00000380FF00000380FF80000380FFC0000000FFE0000000FFFC0000007FFFE000
007FFFFE00003FFFFFC0003FFFFFF0001FFFFFFC000FFFFFFE0007FFFFFF0001FFFFFF00
007FFFFF80001FFFFFC00000FFFFC0000007FFC0000000FFE00000007FE00000003FE000
00001FE0E000001FE0E000000FE0E000000FE0E000000FE0F000000FE0F000000FC0F800
000FC0F800001F80FC00001F80FF00003F00FFC0007E00FFFC01FC00F9FFFFF800F03FFF
E000E007FF000023317BB02E>83 D<3FFFFFFFFFFF003FFFFFFFFFFF003FFFFFFFFFFF00
3FE00FFC01FF007F000FFC003F807E000FFC001F807C000FFC000F8078000FFC00078078
000FFC00078070000FFC00038070000FFC00038070000FFC00038070000FFC000380E000
0FFC0001C0E0000FFC0001C0E0000FFC0001C0E0000FFC0001C000000FFC00000000000F
FC00000000000FFC00000000000FFC00000000000FFC00000000000FFC00000000000FFC
00000000000FFC00000000000FFC00000000000FFC00000000000FFC00000000000FFC00
000000000FFC00000000000FFC00000000000FFC00000000000FFC00000000000FFC0000
0000000FFC00000000000FFC00000000000FFC00000000000FFC00000000000FFC000000
00000FFC00000000000FFC00000000000FFC00000000000FFC00000000000FFC00000000
000FFC000000007FFFFFFF8000007FFFFFFF8000007FFFFFFF800032307DAF39>I<FFFF
FFC003FFFFC0FFFFFFC003FFFFC0FFFFFFC003FFFFC000FFC0000007E00000FFC0000003
C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FF
C0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003
C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FF
C0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003
C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FF
C0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003
C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FF
C0000007C000007FC00000078000007FE00000078000003FE000000F8000003FE000000F
0000001FF000001E0000000FF800003E00000007FC0000FC00000003FF0003F800000000
FFE01FE0000000007FFFFFC0000000000FFFFF000000000000FFF00000003A317EB03F>
I<FFFFFF0000FFFF80FFFFFF0000FFFF80FFFFFF0000FFFF8003FFC000000FF00001FFE0
000007C00000FFE000000F800000FFF000000F8000007FF800001F0000003FF800001E00
00001FFC00003E0000001FFE00007C0000000FFE00007800000007FF0000F800000007FF
8001F000000003FF8001E000000001FFC003E000000001FFE007C000000000FFF0078000
0000007FF00F80000000007FF81F00000000003FFC1E00000000001FFC3E00000000001F
FE7C00000000000FFF78000000000007FFF8000000000007FFF0000000000003FFF00000
00000001FFE0000000000001FFC0000000000000FFC0000000000000FFC0000000000000
FFC0000000000000FFC0000000000000FFC0000000000000FFC0000000000000FFC00000
00000000FFC0000000000000FFC0000000000000FFC0000000000000FFC0000000000000
FFC0000000000000FFC0000000000000FFC0000000000000FFC0000000000000FFC00000
00000000FFC00000000000FFFFFF8000000000FFFFFF8000000000FFFFFF80000039317E
B03E>89 D<007FF8000003FFFF00000FFFFFC0001FE01FF0001FF007F8001FF007FC001F
F003FC001FF001FE000FE001FE0007C001FE00010001FE00000001FE00000001FE000001
FFFE00003FFFFE0001FFF1FE0007FE01FE001FF001FE003FE001FE007FC001FE007F8001
FE00FF8001FE00FF0001FE00FF0001FE00FF0001FE00FF8003FE00FF8007FE007FC00FFE
003FF03EFF001FFFF87FF807FFF03FF800FF801FF825207E9F28>97
D<01F8000000FFF8000000FFF8000000FFF80000000FF800000007F800000007F8000000
07F800000007F800000007F800000007F800000007F800000007F800000007F800000007
F800000007F800000007F800000007F800000007F80FF00007F87FFE0007F9FFFF8007FF
E03FE007FF000FF007FE0007F807FC0007F807F80003FC07F80003FE07F80003FE07F800
01FE07F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80001
FF07F80001FF07F80001FF07F80001FF07F80001FE07F80003FE07F80003FC07FC0003FC
07FC0007F807FE000FF007FF801FE007E7E07FC007C1FFFF8007807FFE0007001FE00028
327EB12E>I<0007FF00007FFFE001FFFFF803FC03FC07F807FC0FF007FC1FE007FC3FC0
07FC3FC003F87FC001F07F800040FF800000FF800000FF800000FF800000FF800000FF80
0000FF800000FF800000FF800000FF8000007FC000007FC000003FC0000E3FE0000E1FE0
001E0FF0003C07F8007803FF01F001FFFFE0007FFF800007FC001F207D9F25>I<000000
07E0000003FFE0000003FFE0000003FFE00000003FE00000001FE00000001FE00000001F
E00000001FE00000001FE00000001FE00000001FE00000001FE00000001FE00000001FE0
0000001FE00000001FE00000001FE0000FF81FE0007FFF1FE001FFFFDFE003FE03FFE00F
F800FFE01FF0007FE01FE0003FE03FC0001FE03FC0001FE07FC0001FE07F80001FE0FF80
001FE0FF80001FE0FF80001FE0FF80001FE0FF80001FE0FF80001FE0FF80001FE0FF8000
1FE0FF80001FE0FF80001FE07F80001FE07FC0001FE07FC0001FE03FC0003FE01FE0007F
E01FE000FFE00FF001FFE007FC07DFF001FFFF9FFF007FFE1FFF000FF01FFF28327DB12E
>I<000FFE0000007FFFC00001FFFFE00003FE0FF00007F801F8000FF000FC001FE000FE
003FC0007F003FC0007F007FC0003F007F80003F807F80003F80FF80003F80FF80003F80
FFFFFFFF80FFFFFFFF80FFFFFFFF80FF80000000FF80000000FF800000007F800000007F
800000007FC00000003FC00003803FE00003801FE00007800FF0000F0007F8003E0003FF
01FC0000FFFFF800003FFFE0000007FF000021207E9F26>I<0000FF000007FFC0001FFF
F0007FC7F000FF0FF801FF0FF801FE0FF803FE0FF803FC0FF803FC07F003FC01C003FC00
0003FC000003FC000003FC000003FC000003FC000003FC0000FFFFF800FFFFF800FFFFF8
0003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC00
0003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC00
0003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC00007FFFF0
007FFFF0007FFFF0001D327EB119>I<001FF007E000FFFE3FF003FFFFFFF807F83FF1F8
0FE00FE1F81FE00FF1F81FC007F0603FC007F8003FC007F8003FC007F8003FC007F8003F
C007F8003FC007F8003FC007F8001FC007F0001FE00FF0000FE00FE00007F83FC00007FF
FF80000EFFFE00000E1FF000000E000000001E000000001E000000001F000000001F8000
00001FFFFFC0000FFFFFF8000FFFFFFE0007FFFFFF8007FFFFFFC007FFFFFFE01FFFFFFF
E03F00007FE07E00000FF0FE000007F0FC000003F0FC000003F0FC000003F0FE000007F0
7E000007E07F00000FE03FC0003FC01FF801FF8007FFFFFE0000FFFFF000001FFF800025
2F7E9F29>I<01F800000000FFF800000000FFF800000000FFF8000000000FF800000000
07F80000000007F80000000007F80000000007F80000000007F80000000007F800000000
07F80000000007F80000000007F80000000007F80000000007F80000000007F800000000
07F80000000007F807F8000007F83FFF000007F87FFF800007F9F03FC00007FBC01FE000
07FF801FE00007FF000FF00007FE000FF00007FC000FF00007FC000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
FFFFC1FFFF80FFFFC1FFFF80FFFFC1FFFF8029327DB12E>I<03C0000FF0001FF8001FF8
001FF8001FFC001FF8001FF8001FF8000FF00003C0000000000000000000000000000000
0000000000000000000001F800FFF800FFF800FFF8000FF80007F80007F80007F80007F8
0007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F8
0007F80007F80007F80007F80007F80007F80007F80007F800FFFF80FFFF80FFFF801133
7DB217>I<01F8000000FFF8000000FFF8000000FFF80000000FF800000007F800000007
F800000007F800000007F800000007F800000007F800000007F800000007F800000007F8
00000007F800000007F800000007F800000007F800000007F8007FFC07F8007FFC07F800
7FFC07F8001FC007F8001F0007F8003E0007F800F80007F801F00007F803E00007F80780
0007F81F000007F83E000007F87E000007F9FE000007FBFF000007FFFF800007FF7FC000
07FE3FE00007FC1FF00007F01FF00007F00FF80007F007FC0007F003FE0007F001FF0007
F001FF0007F000FF8007F0007FC007F0003FE007F0003FF0FFFF80FFFFFFFF80FFFFFFFF
80FFFF28327EB12C>107 D<01F800FFF800FFF800FFF8000FF80007F80007F80007F800
07F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F800
07F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F800
07F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F800
07F80007F80007F800FFFFC0FFFFC0FFFFC012327DB117>I<03F007F8000FF000FFF03F
FF007FFE00FFF07FFF80FFFF00FFF1F03FC3E07F800FF3C01FE7803FC007F7801FEF003F
C007F7000FFE001FE007FE000FFC001FE007FC000FF8001FE007FC000FF8001FE007F800
0FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001F
E007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F800
0FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001F
E007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F800
0FF0001FE0FFFFC1FFFF83FFFFFFFFC1FFFF83FFFFFFFFC1FFFF83FFFF40207D9F45>I<
03F007F80000FFF03FFF0000FFF07FFF8000FFF1F03FC0000FF3C01FE00007F7801FE000
07F7000FF00007FE000FF00007FC000FF00007FC000FF00007F8000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000FFFFC1FFFF80
FFFFC1FFFF80FFFFC1FFFF8029207D9F2E>I<0007FE0000003FFFC00000FFFFF00003FC
03FC0007F000FE000FE0007F001FC0003F803FC0003FC03FC0003FC07F80001FE07F8000
1FE07F80001FE0FF80001FF0FF80001FF0FF80001FF0FF80001FF0FF80001FF0FF80001F
F0FF80001FF0FF80001FF07F80001FE07F80001FE07F80001FE03FC0003FC03FC0003FC0
1FE0007F800FE0007F0007F801FE0003FE07FC0001FFFFF800003FFFC0000007FE000024
207E9F29>I<01F80FF000FFF87FFE00FFF9FFFF80FFFFE07FE00FFF001FF007FE000FF8
07FC0007F807F80007FC07F80003FE07F80003FE07F80003FE07F80001FF07F80001FF07
F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F8
0003FF07F80003FE07F80003FE07F80003FC07FC0007FC07FC000FF807FE000FF007FF80
1FE007FFE07FC007F9FFFF8007F87FFE0007F81FE00007F800000007F800000007F80000
0007F800000007F800000007F800000007F800000007F800000007F800000007F8000000
07F8000000FFFFC00000FFFFC00000FFFFC00000282E7E9F2E>I<03F03F00FFF0FFC0FF
F1FFF0FFF3C7F00FF78FF807F70FF807FE0FF807FE0FF807FC07F007FC03E007FC008007
FC000007F8000007F8000007F8000007F8000007F8000007F8000007F8000007F8000007
F8000007F8000007F8000007F8000007F8000007F8000007F8000007F8000007F80000FF
FFE000FFFFE000FFFFE0001D207E9F22>114 D<00FF870007FFEF001FFFFF003F007F00
7C001F007C000F00F8000F00F8000700FC000700FC000700FF000000FFF800007FFFC000
7FFFF0003FFFFC001FFFFE0007FFFF0001FFFF80001FFF800000FFC000001FC0E0000FC0
E0000FC0F00007C0F00007C0F80007C0FC000F80FE001F80FF803F00FFFFFE00F3FFF800
E07FC0001A207D9F21>I<00380000380000380000380000380000780000780000780000
F80000F80001F80003F80007F8001FF800FFFFFEFFFFFEFFFFFE07F80007F80007F80007
F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007
F80007F80707F80707F80707F80707F80707F80707F80707FC0F03FC0E03FE1E01FFFC00
7FF8000FE0182E7EAD20>I<01F80003F000FFF801FFF000FFF801FFF000FFF801FFF000
0FF8001FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
07F8000FF00007F8001FF00007F8001FF00007F8003FF00007F8007FF00003FC00FFF000
03FE03EFF80001FFFFCFFF80007FFF0FFF80000FFC0FFF8029207D9F2E>I<FFFF801FFE
FFFF801FFEFFFF801FFE07F80003E007F80001C007FC0003C003FC00038003FE00078001
FE00070001FF000F0000FF000E0000FF801E00007F801C00007FC03C00003FC03800003F
E03800001FE07000001FE07000000FF0E000000FF0E000000FF9E0000007F9C0000007FF
C0000003FF80000003FF80000001FF00000001FF00000000FE00000000FE000000007C00
0000007C0000000038000027207E9F2C>I<FFFF0FFFF01FFEFFFF0FFFF01FFEFFFF0FFF
F01FFE0FF0007E0003F00FF8007F0001E007F8007F0001C007F8003F8003C003FC003F80
038003FC007FC0038003FE007FC0078001FE00FFC0070001FF00EFE00F0000FF00EFE00E
0000FF01C7F00E00007F81C7F01C00007F83C7F01C00007FC383F83C00003FC383F83800
003FC701FC3800001FE701FC7000001FEF01FC7000001FFE00FEF000000FFE00FEE00000
0FFC007FE0000007FC007FC0000007FC007FC0000007F8003FC0000003F8003F80000003
F0001F80000001F0001F00000001E0000F00000000E0000E000037207E9F3C>I<FFFF00
FFFCFFFF00FFFCFFFF00FFFC07F8001F8003FC001E0001FE003C0000FF00780000FF80F0
00007FC1E000003FC1E000001FE3C000000FF780000007FF00000007FE00000003FE0000
0001FE00000000FF00000001FF80000001FFC0000003FFE00000079FF000000F0FF00000
1E07F800003C03FC00007801FE0000F001FF0001E000FF8001E0007FC007E0003FC0FFF8
01FFFEFFF801FFFEFFF801FFFE27207E9F2C>I<FFFF801FFEFFFF801FFEFFFF801FFE07
F80003E007F80001C007FC0003C003FC00038003FE00078001FE00070001FF000F0000FF
000E0000FF801E00007F801C00007FC03C00003FC03800003FE03800001FE07000001FE0
7000000FF0E000000FF0E000000FF9E0000007F9C0000007FFC0000003FF80000003FF80
000001FF00000001FF00000000FE00000000FE000000007C000000007C00000000380000
0000380000000070000000007000000000F000003C00E000007E01E00000FF01C00000FF
03800000FF07800000FF0F0000007A3E0000007FFC0000003FF80000000FC0000000272E
7E9F2C>I<3FFFFFFC3FFFFFFC3FFFFFFC3FC00FF83E001FF03C003FF038003FE078007F
C07800FF807001FF807003FF007003FE007007FC00000FFC00001FF800001FF000003FE0
00007FE00E00FFC00E00FF800E01FF000E03FF000E07FE001E07FC001E0FF8001C1FF000
3C3FF0007C3FE000FC7FC007FCFFFFFFFCFFFFFFFCFFFFFFFC1F207E9F25>I
E end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 300dpi
TeXDict begin

%%EndSetup
%%Page: 1 1
1 0 bop 909 315 a Fo(Ox:)519 375 y Fn(An)16 b(A)o(ttribute-Grammar)d
(Compiling)i(System)681 435 y(based)i(on)f(Y)l(acc,)g(Lex,)f(and)i(C:)
588 549 y Fo(T)-7 b(utorial)28 b(In)n(tro)r(duction)795
660 y Fm(No)o(v)o(em)o(b)q(er)15 b(5,)g(1993)683 715
y(c)670 716 y Fl(\015)p Fm(1992,)f(1993)g(Kurt)h(M.)g(Bisc)o(ho\013)699
773 y Fk(bischoff@cs.iastate.edu)164 939 y Fo(1)83 b(In)n(tro)r
(duction)164 1049 y Fj(Ox)19 b Fn(is)f(an)i(attribute-grammar)d
(compiling)g(system)g(based)j(on)f(Y)l(acc,)g(Lex,)g(and)g(C.)164
1109 y(Ox)248 1091 y Fi(1)288 1109 y Fn(generalizes)g(the)h(function)g
(of)h(Y)l(acc)f(in)g(the)g(w)o(a)o(y)g(that)g(attribute)g(grammars)164
1169 y(generalize)14 b(con)o(text-free)g(grammars.)20
b(Ordinary)15 b(Y)l(acc)g(and)h(Lex)f(sp)q(eci\014cations)h(can)164
1229 y(b)q(e)c(augmen)o(ted)f(with)h(de\014nitions)g(of)h(syn)o
(thesized)e(and)h(inherited)f(attributes)h(written)164
1289 y(in)17 b(C/C++)i(syn)o(tax.)25 b(F)l(rom)16 b(these)h(sp)q
(eci\014cations,)h(Ox)f(generates)h(a)g(program)f(that)164
1350 y(builds)e(and)h(decorates)g(attributed)f(parse)h(trees.)k(Ox)c
(accepts)f(a)h(most)f(general)g(class)164 1410 y(of)20
b(attribute)g(grammars.)32 b(The)20 b(user)g(can)g(sp)q(ecify)g
(parse-tree)g(tra)o(v)o(ersals)f(for)i(easy)164 1470
y(ordering)j(of)f(side)g(e\013ects)g(suc)o(h)g(as)i(co)q(de)e
(generation.)43 b(Ox)23 b(handles)h(the)f(tedious)164
1530 y(and)15 b(error-prone)g(details)g(of)g(writing)f(co)q(de)h(for)g
(parse-tree)g(managemen)o(t,)d(so)j(its)g(use)164 1590
y(eases)f(problems)f(of)h(securit)o(y)e(and)j(main)o(tainabilit)o(y)10
b(asso)q(ciated)15 b(with)f(that)g(asp)q(ect)h(of)164
1651 y(translator)i(dev)o(elopmen)o(t.)237 1711 y(Ox)11
b(is)g(a)g(Y)l(acc/Lex/C/C++)h(prepro)q(cessor,)g(and)g(is)f(designed)g
(to)g(bring)g(attribute)164 1771 y(grammars)17 b(to)j(the)e(mainstream)
f(of)i(Unix-based)g(language)g(dev)o(elopmen)o(t.)26
b(Ox)19 b(in-)164 1831 y(herits)h(all)g(of)g(the)g(familiar)f(syn)o
(tax)h(and)h(seman)o(tics)d(of)j(Y)l(acc,)f(Lex,)h(and)g(C/C++.)164
1891 y(This)e(mak)o(es)f(Ox)h(easily)f(accessible)g(to)i(language)g
(designers,)g(dev)o(elop)q(ers,)e(and)i(ex-)164 1952
y(p)q(erimen)o(ters)14 b(who)k(use)e(those)h(to)q(ols.)24
b(It)16 b(also)h(pro)o(vides)f(a)i(ready)e(\\escap)q(e)h(hatc)o(h")g
(in)164 2012 y(case)f(it)g(is)g(desired)g(to)g(return)g(to)h(an)g
(ordinary)f(Y)l(acc)g(implem)o(e)o(n)o(tation.)237 2072
y(This)g(pap)q(er)h(giv)o(es)e(an)h(o)o(v)o(erview)e(of)i(Ox)g(b)o(y)f
(emphasizing)g(examples.)k(It)c(quic)o(kly)164 2132 y(familiarizes)22
b(y)o(ou)k(with)f(the)g(Ox)g(features)g(that)h(are)f(most)g(imme)o
(diately)d(useful.)164 2192 y(A)g(more)g(complete)f(reference,)h(the)h
Fh(Ox)h(User)g(R)n(efer)n(enc)n(e)f(Manual)5 b Fn(,)25
b(accompanies)164 2252 y(the)f(Ox)f(electronic)g(distribution,)i(whic)o
(h)e(can)h(b)q(e)h(obtained)f(free)f(b)o(y)h(writing)g(to)164
2313 y Fg(ox-request)o(@cs)o(.i)o(ast)o(ate)o(.ed)o(u)p
Fn(.)p 164 2358 648 2 v 220 2388 a Ff(1)239 2403 y Fe(The)13
b(name)f(\\Ox")g(comes)h(from)e(an)h(attempt)g(to)h(pronounce)h(an)f
(acron)o(ym)e(for)i(\\An)f(A)o(ttribute-)164 2453 y(Gramma)o(r)g
(Compiling)e(System")961 2599 y Fn(1)p eop
%%Page: 2 2
2 1 bop 237 307 a Fn(F)l(amiliarit)o(y)12 b(with)i(the)g(use)h(of)g(Y)l
(acc,)f(Lex,)g(C,)h(and)g(Mak)o(e)f(is)g(su\016cien)o(t)g(to)h(under-)
164 367 y(stand)i(this)f(tutorial)g(and)h(to)g(b)q(egin)f(using)h(Ox.)k
(Some)15 b(prior)h(exp)q(osure)h(to)f(attribute)164 428
y(grammars)g(is)g(helpful.)23 b(Readers)17 b(with)g(an)g(urge)g(for)h
(details)e(and)i(hands-on)h(exp)q(eri-)164 488 y(ence)c(should)h(use)f
(the)g(index)g(of)h(the)f(reference)f(man)o(ual)g(and)i(should)g(ha)o
(v)o(e)f(access)h(to)164 548 y(a)d(system)e(on)i(whic)o(h)f(Ox)h(is)f
(installed.)20 b(The)12 b(examples)f(herein)h(\(in)g(mac)o
(hine-readable)164 608 y(form\))j(are)h(included)f(with)i(the)f(Ox)g
(distribution.)164 775 y Fo(2)83 b(Con)n(v)n(erting)37
b(a)h(Y)-7 b(acc/Lex)38 b(program)h(for)g(use)288 866
y(with)27 b(Ox)164 975 y Fn(Probably)21 b(the)g(easiest)g(w)o(a)o(y)f
(to)h(get)g(started)g(with)g(Ox)g(is)f(to)i(con)o(v)o(ert)d(an)j
(existing)164 1036 y(Y)l(acc/Lex)382 1017 y Fi(2)417
1036 y Fn(parser)16 b(or)g(translator.)22 b(This)16 b(can)g(usually)f
(b)q(e)h(done)g(without)g(c)o(hanging)164 1096 y(the)f(Y)l(acc)f(and)i
(Lex)e(co)q(de.)21 b(Ox)15 b(can)g(also)h(b)q(e)f(used)g(with)g(Y)l
(acc-only)f(translators,)i(i.e.,)164 1156 y(those)h(with)f(lexical)e
(analyzers)i(hand-co)q(ded)i(in)d(C)i(\(see)f(section)g(9.3\).)164
1300 y Fd(2.1)70 b(A)22 b(parser)i(of)f(arithmetic)d(expressions)164
1393 y Fn(As)13 b(a)g(running)g(example,)e(w)o(e)h(start)h(with)g(a)g
(Y)l(acc/Lex)f(parser)i(for)f(in)o(teger)e(arithmetic)164
1453 y(expressions.)237 1513 y(The)k(Lex)f(\014le)g(is)g(named)f
Fg(scan.l)p Fn(,)f(and)j(sp)q(eci\014es)g(the)f(tok)o(ens)g(of)h(the)f
(language)h(as)164 1573 y(digit)h(strings,)g(paren)o(theses,)g(and)g
(four)h(binary)f(op)q(erators:)164 1677 y Fc(\045{)164
1727 y(#include)k("y.tab.h")164 1777 y(\045})164 1876
y(\045\045)164 1926 y([)i(\\n\\t\\f]+)172 b(;)164 1976
y([0-9]+)260 b(return\(ICONST\);)164 2026 y([\(\)*/+\\-])194
b(return\(yytext[0]\);)164 2076 y(\045\045)237 2190 y
Fn(The)24 b(Y)l(acc)g(\014le)f(\(named)g Fg(gram.y)p
Fn(\))f(sp)q(eci\014es)i(the)g(syn)o(tax.)45 b(The)24
b(grammar)f(is)164 2250 y(disam)o(biguated)15 b(b)o(y)h(use)g(of)h(the)
f Fg(\045left)e Fn(reserv)o(ed)h(w)o(ord:)p 164 2329
648 2 v 220 2359 a Ff(2)239 2374 y Fe(Ox)d(is)g(designed)g(to)g(w)o
(ork)g(also)f(with)g(Y)m(acc)i(and)e(Lex)i(w)o(ork)n(alik)o(es)d(and)i
(C++.)18 b(Throughout)12 b(this)164 2424 y(pap)q(er,)i(\\Y)m(acc",)f
(\\Lex",)g(and)h(\\C")f(can)i(generally)e(b)q(e)i(tak)o(en)f(to)f(mean)
g(\\Y)m(acc)h(or)g(Bison",)f(\\Lex)h(or)164 2474 y(Flex",)f(and)h(\\C)f
(or)h(C++",)g(resp)q(ectiv)o(ely)m(.)961 2599 y Fn(2)p
eop
%%Page: 3 3
3 2 bop 164 307 a Fc(\045token)21 b(ICONST)164 357 y(\045left)g('+')g
('-')164 407 y(\045left)g('*')g('/')164 506 y(\045\045)164
556 y(expr)86 b(:)153 b(expr)86 b('*')108 b(expr)338
606 y(|)153 b(expr)86 b('/')108 b(expr)338 656 y(|)153
b(expr)86 b('+')108 b(expr)338 706 y(|)153 b(expr)86
b('-')108 b(expr)338 756 y(|)153 b('\(')108 b(expr)86
b('\)')338 805 y(|)153 b(ICONST)338 855 y(;)164 905 y(\045\045)164
955 y(main\(\))208 1005 y({return\(yyparse)o(\(\)\);)208
1054 y(})237 1169 y Fn(The)18 b(follo)o(wing)f(Mak)o(e)g(\014le)g(is)h
(used)g(to)g(build)f(and)h(main)o(tain)e(the)i(parser,)g(whic)o(h)164
1229 y(is)e(named)f Fg(gc)p Fn(:)164 1333 y Fc(gc:)21
b(y.tab.o)f(lex.yy.o)338 1382 y(cc)i(-o)f(gc)g(y.tab.o)g(lex.yy.o)f
(-ly)h(-ll)164 1482 y(y.tab.c)f(y.tab.h:)g(gram.y)338
1532 y(yacc)h(-d)h(gram.y)164 1631 y(lex.yy.c:)e(scan.l)338
1681 y(lex)h(scan.l)164 1781 y(y.tab.o:)f(y.tab.c)338
1831 y(cc)i(-c)f(y.tab.c)164 1930 y(lex.yy.o:)f(lex.yy.c)g(y.tab.h)338
1980 y(cc)i(-c)f(lex.yy.c)164 2124 y Fd(2.2)70 b(A)22
b(parser)i(that)f(builds)f(a)h(parse)h(tree)164 2217
y Fn(The)15 b(ab)q(o)o(v)o(e)g(parser)h(do)q(es)g(no)f(seman)o(tic)e
(analysis.)21 b(T)l(o)16 b(get)f(ready)g(for)h(Ox)f(implem)o(en-)164
2277 y(tation)j(of)g(seman)o(tics,)e(w)o(e)h(need)g(merely)e(replace)i
(the)h(follo)o(wing)f(lines)g(in)g(the)h(Mak)o(e)164
2337 y(\014le:)961 2599 y(3)p eop
%%Page: 4 4
4 3 bop 273 307 a Fc(y.tab.c)20 b(y.tab.h:)g(gram.y)447
357 y(yacc)h(-d)h(gram.y)273 457 y(lex.yy.c:)e(scan.l)447
506 y(lex)h(scan.l)164 596 y Fn(with)16 b(these:)273
676 y Fc(oxout.y)k(oxout.l:)g(gram.y)h(scan.l)447 726
y(ox)h(gram.y)e(scan.l)273 826 y(y.tab.c)g(y.tab.h:)g(oxout.y)447
875 y(yacc)h(-d)h(oxout.y)273 975 y(lex.yy.c:)e(oxout.l)447
1025 y(lex)h(oxout.l)164 1116 y Fn(The)16 b(command:)292
1206 y Fg(ox)25 b(gram.y)e(scan.l)164 1297 y Fn(transforms)17
b Fg(gram.y)e Fn(\(called)h(the)i Fh(Y-\014le)t Fn(\))g(in)o(to)f
Fg(oxout.y)p Fn(,)e(and)j(transforms)f Fg(scan.l)164
1357 y Fn(\(called)24 b(the)g Fh(L-\014le)t Fn(\))i(in)o(to)e
Fg(oxout.l)p Fn(.)44 b(These)24 b(Ox)h(outputs)g(replace)f
Fg(gram.y)e Fn(and)164 1418 y Fg(scan.l)14 b Fn(in)i(the)g(remaining)f
(steps)h(of)h(parser)f(construction.)237 1478 y(The)f(user-observ)o(ed)
g(b)q(eha)o(viors)h(of)f(the)g(original)g(program)g(and)h(the)f(one)g
(prepro-)164 1538 y(cessed)f(b)o(y)g(Ox)g(are)g(the)g(same.)20
b(The)14 b(di\013erence)f(is)h(that)h(the)f(v)o(ersion)f(made)h(using)g
(Ox)164 1598 y(and)j(the)f(new)g(Mak)o(e)g(\014le)g(builds)g(a)g(dumm)o
(y)e(\(attribute-less\))i(parse)g(tree,)g(while)f(the)164
1658 y(original)k(builds)h(no)g(parse)g(tree.)30 b(The)20
b(original)f(co)q(de)h(in)f(the)g(example)f(lac)o(ks)h(Y)l(acc)164
1718 y(actions,)25 b(but)e(had)h(it)e(con)o(tained)h(suc)o(h)g
(actions,)h(their)f(e\013ects)g(w)o(ould)g(ha)o(v)o(e)f(b)q(een)164
1779 y(undisturb)q(ed)17 b(b)o(y)e(the)h(Ox)g(prepro)q(cessing.)237
1839 y(Ha)o(ving)i(mo)q(di\014ed)g(our)h(Mak)o(e)f(\014le,)g(w)o(e)g
(are)h(ready)f(to)h(augmen)o(t)f(the)g(Y-\014le)g(and)164
1899 y(L-\014le)e(with)g(Ox)g(constructs.)164 2064 y
Fo(3)83 b(Adding)27 b(Ox-generated)g(seman)n(tics)164
2173 y Fn(This)18 b(section)f(in)o(tro)q(duces)h(the)f(form)g(and)h
(meaning)f(of)h(Ox-sp)q(eci\014c)f(constructs,)h(b)o(y)164
2233 y(w)o(a)o(y)e(of)g(con)o(v)o(erting)g(our)g(parse-tree-building)g
(parser)h(in)o(to)f(a)g(calculator.)237 2293 y(Eac)o(h)d(parse)f(tree)g
(has)h(lea)o(v)o(es)e(lab)q(eled)h(b)o(y)g(the)g Fg(ICONST)f
Fn(tok)o(en.)19 b(Let)13 b(us)f(endo)o(w)h(this)164 2354
y(tok)o(en)20 b(with)g(an)g(attribute)g Fg(string)p Fn(:)27
b(a)21 b(c)o(haracter)e(p)q(oin)o(ter)h(that)h(for)f(eac)o(h)g
Fg(ICONST)164 2414 y Fn(no)q(de)e(is)e(to)i(p)q(oin)o(t)f(to)g(a)g(cop)
o(y)g(of)g(the)g(lexeme)d(corresp)q(onding)k(to)f(the)g(no)q(de.)24
b(This)17 b(is)164 2474 y(done)f(b)o(y)g(placing)g(the)g
Fh(attribute)j(de)n(clar)n(ation)t Fn(:)961 2599 y(4)p
eop
%%Page: 5 5
5 4 bop 292 307 a Fg(@attribute)o(s)23 b({char)h(*string;})e(ICONST)164
409 y Fn(b)q(efore)15 b(the)g(\014rst)h Fg(\045\045)f
Fn(mark)f(in)g(the)i(Y-\014le.)k(The)15 b(ab)q(o)o(v)o(e-men)o(tioned)e
(storage)k(lo)q(cation)164 469 y(created)i(for)g(eac)o(h)g
Fg(ICONST)e Fn(no)q(de)j(is)f(called)f(an)i Fh(attribute)h(instanc)n(e)
k Fn(\(concisely:)g(an)164 529 y Fh(instanc)n(e)t Fn(\).)d(It)16
b(is)g(an)h(instance)f(of)g(the)g Fg(string)e Fn(attribute)i(of)h
Fg(ICONST)p Fn(.)237 589 y(W)l(e)23 b(supply)g(a)h(C)g(macro)e(\(named)
g Fg(lexeme)p Fn(\))f(that)j(constructs)g(a)g(cop)o(y)f(of)g(the)164
650 y(lexeme.)29 b(F)l(or)20 b(brevit)o(y)e(of)i(the)f(example,)f
Fg(lexeme)g Fn(unsafely)h(neglects)h(to)g(c)o(hec)o(k)e(for)164
710 y(return)e(of)h Fg(NULL)d Fn(b)o(y)i Fg(malloc)p
Fn(.)j(Here)c(is)h(the)g(mo)q(di\014ed)f(L-\014le:)164
814 y Fc(\045{)164 863 y(#include)20 b("y.tab.h")164
913 y(#include)g(<string.h>)164 1013 y(#define)g(lexeme)h
(strcpy\(\(char)e(*\)malloc\(yyleng+1\))o(,yyte)o(xt\))164
1063 y(\045})164 1162 y(\045\045)164 1212 y([)j(\\n\\t\\f]+)172
b(;)164 1262 y([0-9]+)260 b(return\(ICONST\);)19 b(@{)i
(@ICONST.string@)e(=)j(lexeme;)e(@})164 1312 y("\(")326
b(return\('\('\);)164 1362 y("\)")g(return\('\)'\);)164
1411 y("*")g(return\('*'\);)164 1461 y("/")g(return\('/'\);)164
1511 y("+")g(return\('+'\);)164 1561 y("-")g(return\('-'\);)164
1611 y(\045\045)237 1725 y Fn(T)l(o)16 b(the)f(righ)o(t)g(of)g(the)g
(lexical)f(rule)g(for)i Fg(ICONST)p Fn(,)c(there)j(is)g(b)q(et)o(w)o
(een)f Fg(@)p Fb(f)h Fn(and)h Fg(@)p Fb(g)e Fn(an)164
1785 y Fh(attribute)i(de\014nition)j Fn(that)14 b(causes)g(the)g
Fg(string)d Fn(attribute)j(instance)f(in)h(eac)o(h)f
Fg(ICONST)164 1845 y Fn(no)q(de)k(to)f(get)h(a)f(p)q(oin)o(ter)g(to)h
(a)g(cop)o(y)e(of)i(the)f(constan)o(t's)h(lexeme)o(.)237
1905 y(Notice)e(that)i(w)o(e)f(ha)o(v)o(e)f(replaced)h(the)g(single)f
(lexical)g(rule:)292 2007 y Fg([\(\)*/+\\-])228 b(return\(yy)o(te)o
(xt[)o(0]\))o(;)164 2109 y Fn(with)14 b(six)f(rules)g(that)h(are)g
(together)g(equiv)m(alen)o(t)e(to)i(that)h(single)e(rule.)19
b(Ox)14 b(w)o(ould)g(ha)o(v)o(e)164 2169 y(b)q(een)21
b(unable)h(to)f(determine)e(from)i(the)g(ob)s(ject)g(of)g(the)g(single)
g Fg(return)f Fn(statemen)o(t)164 2229 y(\(namely)10
b Fg(yytext[0])o Fn(\))f(the)i(sp)q(eci\014c)h(tok)o(en)f(that)h(w)o
(ould)f(b)q(e)h Fg(return)p Fn(ed.)18 b(By)11 b(replacing)164
2289 y(the)19 b(rule,)f(w)o(e)h(mak)o(e)e(the)i Fg(return)p
Fn(ed)e(tok)o(ens)i(explicit,)e(and)j(a)o(v)o(oid)e(a)i(w)o(arning)f
(from)164 2350 y(Ox.)237 2410 y(Eac)o(h)14 b(parse-tree)g(no)q(de)h
(lab)q(eled)f(b)o(y)g Fg(expr)e Fn(is)i(the)g(ro)q(ot)i(of)e(a)h
(subtree)f(corresp)q(ond-)164 2470 y(ing)i(to)h(a)g(sub)q(expression.)k
(Placing)16 b(the)g(attribute)g(declaration:)961 2599
y(5)p eop
%%Page: 6 6
6 5 bop 292 307 a Fg(@attribute)o(s)23 b({long)h(val;})f(expr)164
409 y Fn(in)f(the)g(Y-\014le)g(causes)h(the)f(Ox-generated)h
(translator)g(to)g(allo)q(cate)g(space)f(\(an)h(at-)164
469 y(tribute)17 b(instance\))h(for)g(a)g Fg(long)f Fn(named)g
Fg(val)f Fn(eac)o(h)i(time)e(it)h(creates)h(a)g(no)q(de)h(lab)q(eled)
164 529 y(b)o(y)d Fg(expr)p Fn(.)237 589 y(The)24 b Fh(b)n(o)n(dy)k
Fn(\(the)c(part)h(b)q(et)o(w)o(een)e(curly)g(braces\))i(of)f(an)h
(attribute)f(declaration)164 650 y(resem)o(bles)13 b(that)k(of)f(a)h(C)
f(structure)f(declaration,)h(except)f(that)h(curly)f(braces)h(cannot)
164 710 y(b)q(e)g(nested.)380 692 y Fi(3)237 770 y Fn(The)22
b(de\014nitions)g(for)g(the)g Fg(val)f Fn(attribute)h(of)g
Fg(expr)f Fn(are)h(seen)f(in)h(the)g Fh(attribute)164
830 y(r)n(efer)n(enc)n(e)d(se)n(ctions)k Fn(\(co)q(de)18
b(fragmen)o(ts)e(delimited)f(b)o(y)j Fg(@)p Fb(f)f Fn(and)h
Fg(@)p Fb(g)p Fn(\))g(in)f(the)h(mo)q(di\014ed)164 890
y(Y-\014le.)i(Eac)o(h)14 b(of)g(the)g(attribute)f(de\014nitions)h
(starts)h(with)e(the)h Fh(implicit-mo)n(de)i(annun-)164
951 y(ciator)23 b Fg(@i)p Fn(,)16 b(whose)i(meaning)e(is)h(explained)f
(in)h(section)g(4.1.)24 b(In)17 b(this)h(example,)c(eac)o(h)164
1011 y(attribute)i(reference)e(section)i(con)o(tains)h(exactly)e(one)h
(attribute)g(de\014nition.)p 164 2378 648 2 v 220 2409
a Ff(3)239 2424 y Fe(A)o(ttributes)h(can)f(b)q(e)h(of)f(an)o(y)f(C)h
(fundamen)o(tal)f(or)h(deriv)o(ed)g(t)o(yp)q(e.)26 b(The)16
b(Ox)h(co)q(de)g(in)e(section)i(8)164 2474 y(uses)e(an)f(attribute)g
(that)g(is)g(a)f(C)h(structure.)961 2599 y Fn(6)p eop
%%Page: 7 7
7 6 bop 164 307 a Fc(\045token)21 b(ICONST)164 357 y(\045left)g('+')g
('-')164 407 y(\045left)g('*')g('/')164 506 y(@attributes)e({char)i
(*string;)f(})i(ICONST)164 556 y(@attributes)d({long)i(val;})130
b(expr)164 656 y(\045\045)164 706 y(expr)86 b(:)153 b(expr)86
b('*')108 b(expr)513 756 y(@{)21 b(@i)g(@expr.0.val@)f(=)h
(@expr.1.val@)f(*)h(@expr.2.val@;)41 b(@})338 855 y(|)153
b(expr)86 b('/')108 b(expr)513 905 y(@{)21 b(@i)g(@expr.0.val@)f(=)h
(@expr.1.val@)f(/)h(@expr.2.val@;)41 b(@})338 1005 y(|)153
b(expr)86 b('+')108 b(expr)513 1054 y(@{)21 b(@i)g(@expr.val@)f(=)i
(@expr.1.val@)d(+)j(@expr.2.val@;)84 b(@})338 1154 y(|)153
b(expr)86 b('-')108 b(expr)513 1204 y(@{)21 b(@i)g(@expr.0.val@)f(=)h
(@expr.1.val@)f(-)h(@expr.2.val@;)41 b(@})338 1303 y(|)153
b('\(')108 b(expr)86 b('\)')513 1353 y(@{)21 b(@i)g(@expr.0.val@)f(=)h
(@expr.1.val@;)368 b(@})338 1453 y(|)153 b(ICONST)513
1503 y(@{)21 b(@i)g(@expr.val@)f(=)i(atoi\(@ICONST.str)o(ing@\))o(;)215
b(@})338 1553 y(;)164 1602 y(\045\045)164 1652 y(main\(\))208
1702 y({return\(yyparse)o(\(\)\);)208 1752 y(})237 1859
y Fn(The)11 b(grammar)e(sym)o(b)q(ol)h Fg(expr)f Fn(has)j(three)e
Fh(gr)n(ammar-symb)n(ol)h(o)n(c)n(curr)n(enc)n(es)k Fn(\(namely)164
1919 y Fg(expr.0)p Fn(,)f Fg(expr.1)p Fn(,)f(and)k Fg(expr.2)p
Fn(\))d(in)i(the)g(grammar)f(rule:)292 2016 y Fg(expr)101
b(:)179 b(expr)101 b('*')127 b(expr)164 2113 y Fn(An)16
b Fh(attribute)i(o)n(c)n(curr)n(enc)n(e)i Fn(\(concisely:)g(an)c
Fh(o)n(c)n(curr)n(enc)n(e)t Fn(\))g(is)g(a)h(grammar-sym)o(b)q(ol)c(o)q
(c-)164 2173 y(currence)20 b(together)h(with)g(an)g(attribute)g(of)g
(the)g(sym)o(b)q(ol.)34 b(An)20 b Fh(attribute)j(r)n(efer)n(enc)n(e)164
2233 y Fn(tak)o(es)16 b(the)g(form:)237 2354 y Fg(@)p
Fh(gr)n(ammarsymb)n(ol)p Fg(.)p Fn([)p Fh(inte)n(ger)p
Fg(.)p Fn(])p Fh(attributename)p Fg(@)164 2474 y Fn(where)21
b Fh(attributename)27 b Fn(app)q(ears)c(as)f(an)g(iden)o(ti\014er)d(in)
i(the)h(b)q(o)q(dy)g(of)g(the)f(attribute)961 2599 y(7)p
eop
%%Page: 8 8
8 7 bop 164 307 a Fn(declaration)20 b(for)g Fh(gr)n(ammarsymb)n(ol)p
Fn(.)31 b(If)20 b(in)o(teger)f(is)h Fh(n)p Fn(,)h(the)f(reference)e(is)
i(to)h(the)e Fh(n)p Fn(th)164 367 y(o)q(ccurrence)13
b(of)h Fh(gr)n(ammarsymb)n(ol)j Fn(coun)o(ting)d(from)e(the)i(left)f
(of)h(the)f(rule)g(\(the)h(leftmost)164 428 y(o)q(ccurrence)19
b(b)q(eing)i(the)f(0th\).)33 b(The)20 b(square)g(brac)o(k)o(ets)f(ab)q
(o)o(v)o(e)h(denote)h(that)f Fh(inte)n(ger)164 488 y
Fn(and)d(the)f(second)g Fg(.)22 b Fn(are)16 b(optional)h(\(the)e
(default)h(v)m(alue)g(for)h Fh(inte)n(ger)22 b Fn(b)q(eing)17
b(0\).)237 548 y Fh(A)o(ttribute)i(de\014nitions)j Fn(are)16
b(basically)g(C)g(co)q(de)h(fragmen)o(ts)e(con)o(taining)h(attribute)
164 608 y(references.)22 b(In)17 b(general,)g(an)g(attribute)g
(de\014nition)f(section)h(con)o(tains)g(zero)g(to)g(man)o(y)164
668 y(attribute)g(de\014nitions.)24 b(Eac)o(h)18 b(attribute)f
(de\014nition)g(is)g(announced)h(b)o(y)f(a)h(mo)q(de)e(an-)164
729 y(n)o(unciator,)g(and)g(terminated)f(b)o(y)h Fg(@)p
Fb(g)f Fn(or)i(b)o(y)f(the)g(next)f(mo)q(de)h(ann)o(unciator.)164
895 y Fo(4)83 b(Order)27 b(of)h(A)n(ttribute-Instance)e(Ev)-5
b(aluation)164 1004 y Fn(A)o(ttribute)16 b(grammars)g(sp)q(ecify)g
(seman)o(tics)f(in)i(a)h Fh(de)n(clar)n(ative)j Fn(or)d
Fh(functional)24 b Fn(\(rather)164 1064 y(than)15 b(sequen)o(tial)f(or)
h(imp)q(erativ)o(e\))d(st)o(yle.)19 b(When)c(a)g(parse)h(tree)e(is)g
(created,)g(the)h(tree's)164 1125 y(attribute)d(instances)h(are)g(ev)m
(aluated)f(in)h(an)g(order)g(constrained)g(\(but)g(not)g(fully)e
(deter-)164 1185 y(mined\))g(b)o(y)h(the)h(attribute)g(grammar.)18
b(It)13 b(is)g(clear)f(that)h(in)g(the)f(example)f(of)i(section)g(3,)
164 1245 y(all)h Fg(val)f Fn(instances)i(in)f(the)g(leaf)g(no)q(des)i
(m)o(ust)d(b)q(e)i(ev)m(aluated)f(b)q(efore)h(the)f Fg(val)f
Fn(instance)164 1305 y(of)k(the)f(ro)q(ot)h(no)q(de.)237
1365 y(Ox)22 b(\(rather)g(than)g(the)g(compiler)e(designer\))h
(generates)h(co)q(de)g(that)h(causes)f(in-)164 1426 y(stances)17
b(to)f(b)q(e)h(ev)m(aluated)f(in)g(a)g(correct)g(order.)164
1570 y Fd(4.1)70 b(Dep)r(endency)21 b(relations)h(in)g(the)g(Y-\014le)
164 1652 y Fn(There)h(is)h(a)g(constrain)o(t)f(for)h(eac)o(h)g(grammar)
e(rule)h(in)g(the)g(Y-\014le:)35 b(a)25 b Fh(dep)n(endency)164
1702 y(r)n(elation)20 b Fn(on)d(the)f(attribute)g(o)q(ccurrences)g(in)g
(that)g(rule.)21 b(F)l(or)16 b(the)g(rule:)164 1792 y
Fc(expr)86 b(:)153 b(expr)86 b('*')108 b(expr)513 1842
y(@{)21 b(@i)g(@expr.0.val@)f(=)h(@expr.1.val@)f(*)h(@expr.2.val@;)513
1892 y(@})164 1993 y Fn(there)16 b(is)g(the)g(constrain)o(t)g(that)h
(instances)f(corresp)q(onding)h(to)g Fg(expr.1.va)o(l)c
Fn(and)164 2053 y Fg(expr.2.val)19 b Fn(in)j(sibling)g(parse-tree)h(no)
q(des)g(m)o(ust)e(b)q(e)i(ev)m(aluated)g(b)q(efore)f(the)h(one)164
2113 y(corresp)q(onding)17 b(to)g Fg(expr.0.val)12 b
Fn(in)k(their)g(paren)o(t)g(no)q(de.)237 2173 y(Eac)o(h)f(rule's)g(dep)
q(endency)f(relation)h(is)h(determined)c(b)o(y)j(its)g(individual)f
(attribute)164 2233 y(de\014nitions.)32 b(There)19 b(are)h(sev)o(eral)f
(mo)q(des)g(for)h(comm)o(unic)o(ating)e(dep)q(endency)h(infor-)164
2293 y(mation)d(to)h(Ox.)22 b(The)17 b Fh(implicit)i(mo)n(de)h
Fn(is,)c(for)h(most)f(Ox)g(translators,)i(the)f(only)f(suc)o(h)164
2354 y(mo)q(de)f(needed.)21 b(The)16 b Fh(explicit)j(mo)n(de)h
Fn(is)c(describ)q(ed)g(brie\015y)f(in)h(section)g(9.7.)237
2414 y(The)h(implici)o(t-m)o(o)q(de)e(ann)o(unciator)i
Fg(@i)f Fn(\(see)g(the)g(example)f(in)h(section)g(3\))h(signals)164
2474 y(to)h(Ox)g(the)f(b)q(eginning)i(of)f(an)g(attribute)g
(de\014nition.)25 b(F)l(urther,)18 b(it)f(informs)g(Ox)g(that)961
2599 y(8)p eop
%%Page: 9 9
9 8 bop 164 307 a Fn(an)19 b(instance)g(corresp)q(onding)h(to)f(the)g
(de\014nition's)f Fh(leftmost)24 b Fn(attribute)19 b(reference)e(is)164
367 y(to)d(b)q(e)g(ev)m(aluated)f Fh(after)20 b Fn(those)14
b(corresp)q(onding)g(to)g(other)g(attribute)g(references)e(in)h(the)164
428 y(de\014nition.)25 b(This)17 b(is)h(to)g(sa)o(y)f(that)h(the)g(o)q
(ccurrence)f(corresp)q(onding)h(to)g(the)g(leftmost)164
488 y(reference)f Fh(dep)n(ends)j(on)j Fn(the)c(o)q(ccurrences)f
(corresp)q(onding)i(to)f(the)f(other)h(references)164
548 y(in)d(the)g(de\014nition.)164 692 y Fd(4.2)70 b(Dep)r(endency)21
b(relations)h(in)g(the)g(L-\014le)164 785 y Fn(Note)h(that)h(the)g(mo)q
(de)e(ann)o(unciator)i Fg(@i)f Fn(do)q(es)h(not)g(app)q(ear)h(in)e(the)
h(L-\014le)f(of)h(the)164 845 y(example)19 b(in)j(section)f(3.)37
b(Mo)q(de)22 b(ann)o(unciators)g(are)g(not)g(used)f(in)h(L-\014les.)37
b(An)21 b(at-)164 905 y(tribute)g(reference)f(section)i(in)f(an)i
(L-\014le)f(is)f(executed)g(as)h(a)h(whole)e(whenev)o(er)g(the)164
965 y(corresp)q(onding)16 b(lexical)d(rule)h(is)g(matc)o(hed.)19
b(In)c(the)f(example,)f(this)h(is)h(done)g(whenev)o(er)164
1025 y(the)21 b(Lex-generated)g(scanner)h(matc)o(hes)d(a)j(digit)f
(string.)36 b(Executing)21 b(an)g(attribute)164 1086
y(reference)d(section)i(ma)o(y)f(in)o(v)o(olv)o(e)f(the)i(ev)m
(aluation)g(of)g(sev)o(eral)g(attribute)f(instances.)164
1146 y(An)12 b(attribute)g(reference)f(section)h(in)h(the)f(L-\014le)h
(m)o(ust)e(con)o(tain)h(exactly)f(one)i(attribute)164
1206 y(reference)i(for)i(eac)o(h)g(attribute)f(o)q(ccurrence)g
(de\014ned)h(there)f(\(in)h(the)g(previous)f(exam-)164
1266 y(ple,)f(that)i(for)f Fg(ICONST.stri)o(ng)p Fn(\))o(.)164
1433 y Fo(5)83 b(Using)27 b(global)h(v)-5 b(ariables)164
1542 y Fn(A)o(ttribute)15 b(reference)g(sections)i(can)g(con)o(tain)g
(an)o(y)f(C)i(co)q(de,)e(including)g(references)g(to)164
1602 y(global)h(v)m(ariables.)237 1663 y(In)11 b(our)g(running)g
(example,)f(w)o(e)g(ha)o(v)o(en't)g(y)o(et)g(sho)o(wn)h(ho)o(w)h(to)f
(prin)o(t)f(the)h(main)e(result)164 1723 y(of)18 b(the)f(seman)o(tic)e
(analysis)j(\(i.e.,)e(the)h(v)m(alue)g(of)h(the)f(expression\).)24
b(The)18 b(approac)o(h)g(is)164 1783 y(to)i(cop)o(y)g(the)f
Fg(val)g Fn(attribute)h(instance)f(of)h(the)g(ro)q(ot)h(no)q(de)g(in)o
(to)e(a)h(global)h(v)m(ariable,)164 1843 y(then)e(prin)o(t)f(it)h
(after)g(termination)e(of)i Fg(yyparse\(\))p Fn(.)26
b(W)l(e)19 b(in)o(tro)q(duce)g(a)g(unique)f(start)164
1903 y(pro)q(duction)f(for)g(this)f(purp)q(ose.)23 b(The)16
b(L-\014le)h(need)f(not)h(b)q(e)g(c)o(hanged.)22 b(Here)15
b(is)h(sho)o(wn)164 1964 y(the)g(new)g(Y-\014le,)f(with)h(c)o(hanged)h
(or)f(added)h(lines)e(mark)o(ed)g(b)o(y)g(empt)o(y)f(C)j(commen)o(ts:)
961 2599 y(9)p eop
%%Page: 10 10
10 9 bop 164 307 a Fc(\045token)21 b(ICONST)164 357 y(\045left)g('+')g
('-')164 407 y(\045left)g('*')g('/')164 506 y(\045{)1351
b(/*)21 b(*/)164 556 y(long)g(globVal;)1110 b(/*)21 b(*/)164
606 y(\045})1351 b(/*)21 b(*/)164 706 y(@attributes)e({char)i
(*string;})f(ICONST)164 756 y(@attributes)f({long)i(val;})108
b(s)22 b(expr)653 b(/*)21 b(*/)164 805 y(\045\045)164
855 y(s)152 b(:)h(expr)958 b(/*)21 b(*/)513 905 y(@{)g(@i)g(globVal)g
(=)g(@s.val@)g(=)g(@expr.val@;)129 b(@})65 b(/*)21 b(*/)338
955 y(;)1199 b(/*)21 b(*/)164 1054 y(expr)86 b(:)153
b(expr)86 b('*')108 b(expr)513 1104 y(@{)21 b(@i)g(@expr.0.val@)f(=)h
(@expr.1.val@)f(*)h(@expr.2.val@;)41 b(@})338 1204 y(|)153
b(expr)86 b('/')108 b(expr)513 1254 y(@{)21 b(@i)g(@expr.0.val@)f(=)h
(@expr.1.val@)f(/)h(@expr.2.val@;)41 b(@})338 1353 y(|)153
b(expr)86 b('+')108 b(expr)513 1403 y(@{)21 b(@i)g(@expr.val@)f(=)i
(@expr.1.val@)d(+)j(@expr.2.val@;)84 b(@})338 1503 y(|)153
b(expr)86 b('-')108 b(expr)513 1553 y(@{)21 b(@i)g(@expr.0.val@)f(=)h
(@expr.1.val@)f(-)h(@expr.2.val@;)41 b(@})338 1652 y(|)153
b('\(')108 b(expr)86 b('\)')513 1702 y(@{)21 b(@i)g(@expr.0.val@)f(=)h
(@expr.1.val@;)368 b(@})338 1802 y(|)153 b(ICONST)513
1851 y(@{)21 b(@i)g(@expr.val@)f(=)i(atoi\(@ICONST.str)o(ing@\))o(;)215
b(@})338 1901 y(;)164 1951 y(\045\045)164 2001 y(main\(\))208
2051 y({yyparse\(\);)1109 b(/*)21 b(*/)229 2100 y
(printf\("\045d\\n",globV)o(al\);)825 b(/*)21 b(*/)208
2150 y(})237 2264 y Fn(Up)q(on)h(completion)d(of)j(the)f(call)g(to)h
Fg(yyparse)p Fn(,)d(the)i(tree's)g(attribute)g(instances)164
2325 y(ha)o(v)o(e)14 b(all)g(b)q(een)h(ev)m(aluated.)21
b(The)14 b(ev)m(aluation)h(of)g Fg(@s.val@)e Fn(en)o(tails)h(an)h
(assignmen)o(t)f(to)164 2385 y Fg(globVal)p Fn(.)19 b(The)d(prin)o
(ting)g(of)g Fg(globVal)e Fn(is)i(the)g(last)g(thing)h(done)f(b)o(y)g
(the)g(calculator.)949 2599 y(10)p eop
%%Page: 11 11
11 10 bop 164 315 a Fo(6)83 b(P)n(arse-tree)27 b(tra)n(v)n(ersals)164
425 y Fn(A)18 b(parse)g(tree)g(is)g(m)o(uc)o(h)e(more)h(useful)g(if)h
(it)g(can)g(b)q(e)h(tra)o(v)o(ersed,)e(and)i(if)e(its)h(attribute)164
485 y(instances)e(can)h(b)q(e)g(accessed)f(during)h(tra)o(v)o(ersals.)k
(Suc)o(h)16 b(tra)o(v)o(ersals)g(are)h(particularly)164
545 y(useful)k(for)g(co)q(de)h(generation.)36 b(Ox)21
b(can)g(b)q(e)g(instructed)g(to)g(generate)g(a)h(translator)164
606 y(that)c(p)q(erforms)e(v)m(arious)i(kinds)f(of)h(tra)o(v)o(ersals)f
(after)g(ev)m(aluation)h(of)f(all)g(of)h(the)f(tree's)164
666 y(attribute)f(instances.)164 810 y Fd(6.1)70 b(Application:)28
b(translation)23 b(to)g(pre\014x)164 903 y Fn(The)18
b(follo)o(wing)f(Y-\014le)g(sp)q(eci\014es)h(an)g(expression)f(parser)h
(that)h(translates)f(its)f(\(in\014x\))164 963 y(input)e(to)h(pre\014x)
f(form.)20 b(The)c(L-\014le)f(is)g(the)h(same)e(as)i(that)g(of)g(the)f
(previous)h(example.)949 2599 y(11)p eop
%%Page: 12 12
12 11 bop 164 307 a Fc(\045token)21 b(ICONST)164 357
y(\045left)g('+')g('-')164 407 y(\045left)g('*')g('/')164
506 y(@traversal)f(@preorder)g(yourTrav)164 556 y(@traversal)g
(@preorder)g(yoursToo)164 656 y(@attributes)f({char)i(*string;})f
(ICONST)164 706 y(@attributes)f({long)i(val;})108 b(s)22
b(expr)164 756 y(\045\045)164 805 y(s)152 b(:)h(expr)513
855 y(@{)21 b(@i)g(@s.val@)g(=)g(@expr.val@;)578 905
y(@yoursToo)f(printf\("\\n\045d\\n",@)o(s.val)o(@\);)513
955 y(@})338 1005 y(;)164 1054 y(expr)86 b(:)153 b(expr)86
b('*')108 b(expr)513 1104 y(@{)21 b(@i)g(@expr.0.val@)f(=)h
(@expr.1.val@)f(*)h(@expr.2.val@;)578 1154 y(@yourTrav)f(printf\(")g(*)
i("\);)513 1204 y(@})338 1254 y(|)153 b(expr)86 b('/')108
b(expr)513 1303 y(@{)21 b(@i)g(@expr.0.val@)f(=)h(@expr.1.val@)f(/)h
(@expr.2.val@;)578 1353 y(@yourTrav)f(printf\(")g(/)i("\);)513
1403 y(@})338 1453 y(|)153 b(expr)86 b('+')108 b(expr)513
1503 y(@{)21 b(@i)g(@expr.val@)f(=)i(@expr.1.val@)d(+)j(@expr.2.val@;)
578 1553 y(@yourTrav)e(printf\(")g(+)i("\);)513 1602
y(@})338 1652 y(|)153 b(expr)86 b('-')108 b(expr)513
1702 y(@{)21 b(@i)g(@expr.0.val@)f(=)h(@expr.1.val@)f(-)h
(@expr.2.val@;)578 1752 y(@yourTrav)f(printf\(")g(-)i("\);)513
1802 y(@})338 1851 y(|)153 b('\(')108 b(expr)86 b('\)')513
1901 y(@{)21 b(@i)g(@expr.0.val@)f(=)h(@expr.1.val@;)513
1951 y(@})338 2001 y(|)153 b(ICONST)513 2051 y(@{)21
b(@i)g(@expr.val@)f(=)i(atoi\(@ICONST.str)o(ing@\))o(;)578
2100 y(@yourTrav)e(printf\(")g(\045s)h(",@ICONST.string@\);)513
2150 y(@})338 2200 y(;)164 2250 y(\045\045)164 2300 y(main\(\))208
2350 y({return\(yyparse)o(\(\)\);)208 2399 y(})949 2599
y Fn(12)p eop
%%Page: 13 13
13 12 bop 164 307 a Fn(The)16 b(line)292 409 y Fg(@traversal)22
b(@preorder)g(yourTrav)164 511 y Fn(declares)16 b(a)g(left-to-righ)o(t)
g(preorder)h(tra)o(v)o(ersal)e(named)g Fg(yourTrav)p
Fn(.)k(Supp)q(ose)e(that)g(in)164 571 y(our)d(example,)d(the)j
Fg(yourTrav)c Fn(tra)o(v)o(ersal)j(has)h(reac)o(hed)f(a)h(no)q(de)g(at)
g(whic)o(h)f(a)h(grammar)164 631 y(rule)d Fa(R)g Fn(is)g(applied.)20
b(If)10 b(the)h(attribute)g(reference)f(section)h(of)g
Fa(R)h Fn(con)o(tains)g(the)f Fh(tr)n(aversal-)164 691
y(mo)n(de)17 b(annunciator)h Fg(@yourTrav)c Fn(\(whic)o(h)i(w)o(as)h
(giv)o(en)f(meaning)g(b)o(y)g(its)h Fg(@traversa)o(l)164
751 y Fn(declaration\),)c(then)f(the)g Fg(printf)f Fn(statmen)o(t)g
(follo)o(wing)h Fg(@yourTrav)d Fn(is)k(executed,)e(and)164
812 y(the)j(tra)o(v)o(ersal)g(is)g(con)o(tin)o(ued)g(for)g(the)h
(subtree)f(ro)q(oted)h(at)g(the)f(no)q(de)h(in)f(question.)21
b(Us-)164 872 y(ing)16 b Fg(@postorder)c Fn(instead)17
b(of)f Fg(@preorder)d Fn(w)o(ould)j(cause)g(a)g(tra)o(v)o(ersal)g(that)
g(executes)164 932 y(the)23 b Fg(printf)f Fh(after)29
b Fn(completing)22 b(the)h(tra)o(v)o(ersal)g(of)h(that)g(subtree,)h
(resulting)e(in)h(a)164 992 y(p)q(ost\014x)17 b(translation.)237
1052 y(A)e(tra)o(v)o(ersal)g(that)h(accesses)f(the)g
Fg(val)g Fn(instance)g(in)g(the)h(ro)q(ot)g(no)q(de)g(is)g(an)g
(alterna-)164 1112 y(tiv)o(e)f(to)h(using)h(the)f(global)h(v)m(ariable)
f Fg(globVal)d Fn(of)k(section)f(5.)21 b(Placing)16 b(the)g(line:)292
1214 y Fg(@traversal)22 b(@preorder)g(yoursToo)164 1316
y Fn(in)16 b(the)g(declarations)g(section,)g(and)g(the)g(line:)292
1418 y Fg(@yoursToo)22 b(printf\("\045d\\)o(n",)o(@s.)o(va)o(l@\))o(;)
164 1519 y Fn(in)c(the)h(attribute)f(reference)f(section)h(for)h(the)f
(start)h(pro)q(duction)g(accomplishes)e(the)164 1579
y(same)e(thing)i(as)f(the)g(use)h(of)f Fg(globVal)p Fn(.)237
1640 y(One)h(tra)o(v)o(ersal)g(is)g(done)g(for)h(eac)o(h)f(tra)o(v)o
(ersal)f(declaration,)h(the)g(tra)o(v)o(ersals)g(b)q(eing)164
1700 y(done)e(one)f(after)g(another,)h(in)f(the)g(order)h(in)f(whic)o
(h)f(the)h(declarations)h(app)q(ear.)21 b(In)14 b(the)164
1760 y(example,)e(the)j(declaration)f(of)h Fg(yoursToo)c
Fn(app)q(ears)16 b(after)f(that)g(of)f Fg(yourTrav)p
Fn(,)e(so)j(the)164 1820 y(v)m(alue)h(of)h(the)f(expression)f(is)h
(prin)o(ted)g(after)g(the)g(preorder)g(translation)h(is)f(prin)o(ted.)
164 1987 y Fo(7)83 b(Inherited)27 b(vs.)35 b(Syn)n(thesized)25
b(A)n(ttributes)164 2096 y Fn(It)15 b(is)g(useful)f(to)i(think)f(of)g
(the)g(lexical)e(rules)i(\(i.e.,)e(the)i(rules)g(in)g(the)g(L-\014le\))
g(as)h(virtual)164 2156 y(grammar)10 b(rules)i(\(pro)q(ductions\))g
(whose)h(righ)o(t-hand)f(sides)g(are)g(the)g(empt)o(y)d(string)j(and)
164 2217 y(whose)22 b(left-hand)g(sides,)h(while)e(actual)h(Y)l(acc)f
(tok)o(ens,)h(are)g(virtual)f(non)o(terminals.)164 2277
y(This)h(generic)e(concept)h(of)h Fh(rule)k Fn(is)21
b(consisten)o(t)g(with)h(usual)g(concepts)f(of)h Fh(attribute)164
2337 y(gr)n(ammar)5 b Fn(,)15 b(and)i(leads)f(to)g(the)g(follo)o(wing)g
(de\014nitions:)237 2397 y(An)g(attribute)g(o)q(ccurrence)g
Fa(o)g Fn(in)g(a)h(rule)e Fa(R)i Fn(is)f Fh(synthesize)n(d)22
b Fn(if)15 b(and)i(only)f(if)949 2599 y(13)p eop
%%Page: 14 14
14 13 bop 237 307 a Fb(\017)24 b Fa(o)17 b Fn(is)f(on)g(the)g(LHS)h(of)
f Fa(R)h Fn(and)g(the)f(attribute)g(reference)f(section)g(of)i
Fa(R)g Fn(con)o(tains)286 367 y(a)g(de\014nition)e(of)i
Fa(o)p Fn(,)f(or)237 469 y Fb(\017)24 b Fa(o)16 b Fn(is)g(on)g(the)g
(RHS)f(of)i Fa(R)f Fn(and)g(the)g(attribute)g(reference)e(section)h(of)
h Fa(R)h Fn(con)o(tains)286 529 y(no)g(de\014nition)e(of)i
Fa(o)p Fn(.)237 631 y(An)f(attribute)g(o)q(ccurrence)g
Fa(o)g Fn(in)g(a)h(rule)e Fa(R)i Fn(is)f Fh(inherite)n(d)22
b Fn(if)15 b(and)i(only)f(if)237 733 y Fb(\017)24 b Fa(o)13
b Fn(is)g(on)h(the)e(left-hand)h(side)g(\(LHS\))g(of)g
Fa(R)h Fn(and)g(the)e(attribute)h(reference)e(section)286
793 y(of)16 b Fa(R)h Fn(con)o(tains)g(no)f(de\014nition)g(of)h
Fa(o)p Fn(,)f(or)237 895 y Fb(\017)24 b Fa(o)g Fn(is)e(on)i(the)f(righ)
o(t-hand)h(side)e(\(RHS\))h(of)g Fa(R)h Fn(and)g(the)f(attribute)g
(reference)286 955 y(section)16 b(of)g Fa(R)h Fn(con)o(tains)f(a)h
(de\014nition)f(of)g Fa(o)p Fn(.)237 1056 y(Ox)h(issues)g(an)g(error)g
(message)f(if)h(it)f(\014nds)h(an)h(attribute)e(that)i(has)f(b)q(oth)h
(syn)o(the-)164 1117 y(sized)d(and)i(inherited)e(o)q(ccurrences)h(in)g
(the)f(grammar.)20 b(An)c(attribute)g(is)g Fh(synthesize)n(d)164
1177 y Fn(if)11 b(and)i(only)e(if)h(it)f(has)i(at)f(least)f(one)i(o)q
(ccurrence,)e(and)h(its)g(ev)o(ery)e(o)q(ccurrence)i(is)f(syn)o(the-)
164 1237 y(sized.)22 b(An)16 b(attribute)h(is)f Fh(inherite)n(d)22
b Fn(if)17 b(and)g(only)g(if)f(it)g(has)h(at)h(least)e(one)h(o)q
(ccurrence,)164 1297 y(and)23 b(its)f(ev)o(ery)f(o)q(ccurrence)h(is)g
(inherited.)39 b(It)22 b(follo)o(ws)g(from)g(the)g(ab)q(o)o(v)o(e)g
(that)h(the)164 1357 y(grammar's)17 b(start)i(sym)o(b)q(ol)e(can)i(ha)o
(v)o(e)f(only)g(syn)o(thesized)g(attributes.)28 b(Referring)18
b(to)164 1418 y(returned)g(tok)o(ens)h(as)g(rules)f(emphasizes)g(the)g
(equal)g(status)i(of)f(tok)o(ens)f(and)i(non)o(ter-)164
1478 y(minals,)14 b(inasm)o(uc)o(h)f(as)j(eac)o(h)f(kind)g(of)h(sym)o
(b)q(ol)e(\(except)g(the)h(start)h(sym)o(b)q(ol\))e(can)i(ha)o(v)o(e)
164 1538 y(b)q(oth)h(syn)o(thesized)d(and)i(inherited)f(attributes.)21
b(Eac)o(h)15 b(sym)o(b)q(ol)g(has)h(a)g(distinct)f(name)164
1598 y(space,)h(so)g(same-named)e(attributes)i(of)g(di\013eren)o(t)f
(sym)o(b)q(ols)g(are)g(distinct)g(attributes,)164 1658
y(and)i(can)f(di\013er)g(as)h(to)g(whether)f(they)f(are)i(inherited)e
(or)h(syn)o(thesized.)237 1719 y(F)l(or)g(eac)o(h)f(parse-tree)g(no)q
(de)h(except)f(the)g(ro)q(ot)i(no)q(de,)e(t)o(w)o(o)h(rules)f(of)h(the)
f(Ox)g(input)164 1779 y(sp)q(eci\014cation)21 b(are)h(of)g(particular)f
(in)o(terest.)36 b(The)22 b Fh(home)g(rule)k Fn(is)21
b(the)h(rule)e(applied)164 1839 y(at)i(the)g(no)q(de,)h(i.e.,)e(the)h
(rule)f(whose)i(LHS)f(is)f(the)h(lab)q(el)f(of)h(the)g(giv)o(en)f(no)q
(de,)i(and)164 1899 y(whose)c(RHS)g(sym)o(b)q(ols)e(are)i(the)g(lab)q
(els)f(of)h(the)g(c)o(hildren)e(of)i(the)f(no)q(de.)30
b(The)19 b Fh(p)n(ar)n(ent)164 1959 y(rule)24 b Fn(is)19
b(the)g(rule)g(applied)f(at)i(the)f(no)q(de's)h(paren)o(t.)31
b(The)19 b(attribute)g(de\014nition)g(of)h(a)164 2020
y(syn)o(thesized)c(attribute)h(instance)g(of)h(a)g(giv)o(en)e(no)q(de)i
(is)g(asso)q(ciated)g(with)f(the)g(no)q(de's)164 2080
y(home)i(rule)g(\(i.e.,)f(it)h(app)q(ears)i(in)f(the)f(attribute)h
(reference)e(section)h(for)h(that)g(rule\),)164 2140
y(and)d(de\014nitions)g(of)g(inherited)e(attribute)h(instances)h(are)g
(similarly)c(asso)q(ciated)18 b(with)164 2200 y(the)e(paren)o(t)g
(rule.)237 2260 y(In)i(a)g(legal)g(input)g(sp)q(eci\014cation,)g(eac)o
(h)f(attribute)h(of)g(a)h(sym)o(b)q(ol)e(app)q(earing)i(in)f(a)164
2320 y(rule)e(is)g(either)g(syn)o(thesized)f(or)i(inherited,)e(but)i
(not)g(b)q(oth,)g(so)h(the)e(de\014nitions)g(of)h(all)164
2381 y(attributes)f(\\\014t)h(together")g(completely)c(and)k(without)f
(con)o(tradiction.)949 2599 y(14)p eop
%%Page: 15 15
15 14 bop 164 315 a Fo(8)83 b(Using)27 b(inherited)g(attributes)164
425 y Fn(This)19 b(section)f(giv)o(es)g(an)h(example)d(indicating)i
(the)g(use)h(of)g(inherited)e(attributes)i(for)164 485
y(seman)o(tic)e(analysis)j(in)o(v)o(olving)d(righ)o(t)i(con)o(text.)30
b(The)19 b(example)e(also)j(giv)o(es)f(a)g(b)q(etter)164
545 y(idea)d(of)g(ho)o(w)h(Ox)f(co)q(de)g(is)h(used)f(together)g(with)g
(C)h(co)q(de.)237 606 y(In)c(man)o(y)e(languages,)j(for)g(instance)e(P)
o(ascal,)h(eac)o(h)g(v)m(ariable)f(declaration)h(is)g(essen-)164
666 y(tially)h(a)j(list)e(of)h(iden)o(ti\014ers)e(follo)o(w)o(ed)h(b)o
(y)g(a)h(t)o(yp)q(e)f(sp)q(eci\014er.)21 b(Here)14 b(w)o(e)i(sho)o(w)g
(a)g(simple)164 726 y(language)j(whose)g(ev)o(ery)e(sen)o(tence)g
(consists)i(of)g(suc)o(h)f(a)h(v)m(ariable)f(declaration.)27
b(Our)164 786 y(translator)19 b(parses)h(the)e(input,)g(recording)h(in)
f(a)h(sym)o(b)q(ol)e(ob)s(ject)h(the)g(iden)o(ti\014er)f(and)164
846 y(t)o(yp)q(e)g(of)h(eac)o(h)f(v)m(ariable)g(declared.)24
b(Then)17 b(the)g(sym)o(b)q(ol)g(ob)s(jects)g(are)g(prin)o(ted)g
(during)164 907 y(a)g(p)q(ostorder)g(tra)o(v)o(ersal.)237
956 y(Here)e(is)h(the)g(L-\014le:)164 1048 y Fc(\045{)164
1097 y(#include)k("y.tab.h")164 1147 y(#include)g(<string.h>)164
1247 y(#define)g(lexeme)h(strcpy\(\(char)e(*\)malloc\(yyleng+1\))o
(,yyte)o(xt\))164 1297 y(\045})164 1396 y(\045\045)164
1446 y([)j(\\n\\t\\f]+)172 b(;)164 1496 y(real)304 b(return\(REAL\);)
164 1546 y(integer)238 b(return\(INT\);)164 1596 y(boolean)g
(return\(BOOL\);)164 1645 y([a-zA-Z]+)194 b(return\(IDENT\);)41
b(@{)21 b(@IDENT.string@)e(=)j(lexeme;)e(@})164 1695
y(",")326 b(return\(','\);)164 1745 y(";")g(return\(';'\);)164
1795 y(":")g(return\(':'\);)164 1845 y(.)370 b({fprintf\(stderr,"il)o
(lega)o(l)19 b(character\\n"\);)g(exit\(-1\);})164 1894
y(\045\045)237 1996 y Fn(The)c(de\014nitions)g(in)f(section)h(7)g
(together)g(with)f(the)h(follo)o(wing)g(Y-\014le)f(imply)e(that:)237
2098 y Fb(\017)24 b Fg(string)14 b Fn(is)i(a)h(syn)o(thesized)e
(attribute)h(of)g Fg(IDENT)p Fn(.)237 2200 y Fb(\017)24
b Fg(sym)15 b Fn(is)h(an)h(inherited)e(attribute)h(of)g
Fg(IDENT)p Fn(.)237 2301 y Fb(\017)24 b Fg(tMark)14 b
Fn(is)i(an)h(inherited)e(attribute)h(of)h Fg(varList)p
Fn(.)237 2403 y Fb(\017)24 b Fg(varDecl)14 b Fn(has)j(no)f(attributes.)
949 2599 y(15)p eop
%%Page: 16 16
16 15 bop 164 307 a Fc(\045token)21 b(REAL)f(INT)i(BOOL)f(IDENT)164
407 y(\045{)164 457 y(#include)f(<stdlib.h>)164 506 y(struct)h(sym)g
({char)f(*str,*typeMark;};)164 606 y(struct)h(sym)g(*allocSym\(cp,t\))
208 656 y(char)g(*cp,*t;)208 706 y({struct)f(sym)h(*pSym;)229
756 y(pSym)g(=)h(\(struct)e(sym)h(*\))h(malloc\(sizeof)d(\(struct)h
(sym\)\);)229 805 y(pSym->str)g(=)i(cp;)f(pSym->typeMark)e(=)j(t;)229
855 y(return)f(pSym;)208 905 y(})164 955 y(\045})164
1054 y(@attributes)e({char)i(*string;)f(struct)h(sym)g(*sym;)g(})g
(IDENT)164 1104 y(@attributes)e({char)i(*tMark;)413 b(})21
b(varList)164 1154 y(@traversal)f(@postorder)f(myT)j(/*)f(my)g
(Traversal)f(*/)164 1254 y(\045\045)164 1303 y(varDecl)86
b(:)174 b(varList)20 b(':')h(REAL)g(';')600 1353 y(@{)g(@i)h
(@varList.tMark@)c(=)k("real";)86 b(@})404 1453 y(|)174
b(varList)20 b(':')h(INT)h(';')600 1503 y(@{)f(@i)h(@varList.tMark@)c
(=)k("integer";)e(@})404 1602 y(|)174 b(varList)20 b(':')h(BOOL)g(';')
600 1652 y(@{)g(@i)h(@varList.tMark@)c(=)k("boolean";)e(@})404
1702 y(;)164 1802 y(varList)86 b(:)174 b(IDENT)600 1851
y(@{)21 b(@i)h(@IDENT.sym@)d(=)774 1901 y(allocSym\(@IDENT.st)o(ring@)o
(,@var)o(List.)o(tMark)o(@\);)665 1951 y(@myT)i(printf\("\045s:)f
(\045s;\\n",@IDENT.sy)o(m@->t)o(ypeMa)o(rk,)1188 2001
y(@IDENT.sym@->str\);)600 2051 y(@})404 2100 y(|)174
b(varList)20 b(',')h(IDENT)600 2150 y(@{)g(@i)h(@varList.1.tMar)o(k@)d
(=)i(@varList.tMark@;)665 2200 y(@i)h(@IDENT.sym@)d(=)774
2250 y(allocSym\(@IDENT.st)o(ring@)o(,@var)o(List.)o(tMark)o(@\);)665
2300 y(@myT)i(printf\("\045s:)f(\045s;\\n",@IDENT.sy)o(m@->t)o(ypeMa)o
(rk,)1188 2350 y(@IDENT.sym@->str\);)600 2399 y(@})404
2449 y(;)949 2599 y Fn(16)p eop
%%Page: 17 17
17 16 bop 164 307 a Fc(\045\045)164 357 y(main\(\))208
407 y({return\(yyparse)o(\(\)\);)18 b(})164 573 y Fo(9)83
b(Ov)n(erview)25 b(of)j(other)f(features)164 683 y Fn(This)21
b(section)f(brie\015y)g(describ)q(es)h(some)e(Ox)i(features)f(that)i
(are)e(pro)o(vided)g(for)h(con-)164 743 y(v)o(enience)d(or)i(for)g(adv)
m(anced)h(or)f(sp)q(ecialized)e(use.)32 b(Detailed)20
b(descriptions)f(of)h(these)164 803 y(features)c(app)q(ear)h(in)f(the)g
Fh(Ox)i(User)g(R)n(efer)n(enc)n(e)f(Manual)5 b Fn(.)164
948 y Fd(9.1)70 b(Macro)23 b(facilit)n(y)164 1040 y Fn(Ox's)17
b(input)h(sp)q(eci\014cation)f(ma)o(y)g(b)q(e)h(suc)o(h)f(that)h(the)g
(same)f(or)h(similar)e(text)h(app)q(ears)164 1100 y(in)23
b(more)g(than)h(one)g(place)g(in)f(attribute)h(reference)e(sections.)44
b(Ox)23 b(has)i(a)f(macro)164 1160 y(substitution)16
b(feature)g(that)h(can)g(b)q(e)f(used)g(to)h(decrease)f(v)o(erb)q(osit)
o(y)f(in)h(suc)o(h)g(cases.)164 1305 y Fd(9.2)70 b(Automatic)21
b(generation)h(of)i(cop)n(y)f(rules)164 1397 y Fn(Often)13
b(a)g(Y-\014le)f(has)i(attribute)f(de\014nitions)g(that)h(function)f
(only)f(to)i(cop)o(y)f(an)g(instance)164 1457 y(b)q(elonging)j(to)g
(one)g(no)q(de)g(to)g(a)g(lik)o(e-named)d(instance)j(b)q(elonging)g(to)
g(the)f(no)q(de's)h(par-)164 1517 y(en)o(t)g(or)i(c)o(hild.)k(Large)c
(attribute)f(grammars)f(tend)g(to)i(ha)o(v)o(e)e(man)o(y)g(suc)o(h)h
(de\014nitions,)164 1578 y(whic)o(h)i(are)g(sometimes)e(called)h
Fh(c)n(opy)i(rules)t Fn(.)32 b(The)20 b(situation)f(is)h(conspicuous)g
(when)164 1638 y(con)o(textual)12 b(information)f(is)i(mo)o(v)o(ed)d
(leafw)o(ard)i(via)h(inherited)e(attributes.)20 b(Ox)12
b(syn)o(tax)164 1698 y(pro)o(vides)k(w)o(a)o(ys)g(of)h(sp)q(ecifying)e
(that)i(a)g(cop)o(y)f(rule)f(is)i(global)f(to)h(the)f(attribute)g
(gram-)164 1758 y(mar,)f(ob)o(viating)h(rep)q(etition)f(of)i(attribute)
f(de\014nitions)g(in)g(man)o(y)f(grammar)f(rules.)164
1903 y Fd(9.3)70 b(Using)22 b(Ox)h(with)f(scanners)h(not)g(based)g(on)h
(Lex)164 1995 y Fn(By)15 b(default,)g(Ox)h(pro)o(vides)f(prepro)q
(cessing)h(for)g(Lex)g(\014les)f(augmen)o(ted)f(with)i(Ox)f(con-)164
2055 y(structs.)21 b(By)13 b(using)i(a)g(command)d(line)h(option,)i(Ox)
f(can)g(b)q(e)g(informed)f(that)i(the)f(L-\014le)164
2115 y(con)o(tains)23 b(Ox-augmen)o(ted)e(C)i(co)q(de)g(rather)g(than)g
(the)g(usual)g(Ox-augmen)o(ted)e(Lex)164 2176 y(co)q(de.)164
2320 y Fd(9.4)70 b(Use)22 b(of)h(m)n(ultiple)c(scanners)164
2412 y Fn(Some)e(translators)i(con)o(tain)f(sev)o(eral)f(scanners.)28
b(Suc)o(h)18 b(a)g(translator)h(is)f(designed)g(so)164
2473 y(that)i(at)g(an)o(y)f(momen)o(t,)e(it)i(is)g(using)h(one)f
(scanner)h(or)g(another,)g(and)g(switc)o(hes)f(to)h(a)949
2599 y(17)p eop
%%Page: 18 18
18 17 bop 164 307 a Fn(di\013eren)o(t)16 b(one)h(when)g(there)f(is)g(a)
h(c)o(hange)g(in)f(con)o(text.)22 b(An)16 b(Ox)h(translator)h(that)f
(uses)164 367 y(more)g(than)i(one)f(scanner)h(can)f(b)q(e)h
(constructed)f(b)o(y)g(submitting)f(to)h(Ox)g(more)f(than)164
428 y(one)f(L-\014le.)164 572 y Fd(9.5)70 b(Stripping)22
b(Ox)h(constructs)164 664 y Fn(Occasionally)l(,)11 b(the)h(Ox)f(user)h
(ma)o(y)e(desire)h(copies)h(of)g(the)f(Y-\014le)g(and)i(L-\014le\(s\))f
(stripp)q(ed)164 725 y(of)17 b(Ox-sp)q(eci\014c)f(constructs.)23
b(By)17 b(a)g(command-line)d(option,)j(the)f(Ox)h(user)g(can)g
(\014lter)164 785 y(all)f(Ox-sp)q(eci\014c)f(constructs)h(from)f(the)h
(inputs,)g(to)h(obtain)f(\014les)g(acceptable)f(to)i(Y)l(acc)164
845 y(and)i(Lex.)28 b(The)18 b(original)h(copies)f(of)h(the)f(Y-\014le)
g(and)h(L-\014le\(s\))f(are)h(unc)o(hanged,)g(but)164
905 y(Ox's)d(outputs)i(on)g Fg(oxout*.*)c Fn(con)o(tain)j(neither)f(Ox)
h(constructs)g(nor)h(the)f(usual)g(Ox-)164 965 y(generated)f
(parse-tree-managemen)o(t)e(co)q(de.)164 1110 y Fd(9.6)70
b(Accessing)21 b(Y)-6 b(acc)23 b(pseudo)n(v)l(ariables)164
1202 y Fn(A)o(ttribute)17 b(de\014nitions)g(that)i(refer)e(to)i(the)e
(Y)l(acc)h(pseudo)o(v)m(ariables)g Fg($$)p Fn(,)f Fg($1)p
Fn(,)h Fg($2)p Fn(,)f(etc.)164 1262 y(are)f(p)q(ermitted)f(in)g(v)m
(arious)i(forms,)e(including:)237 1383 y Fg(@i)25 b(@)p
Fh(gr)n(ammarsymb)n(ol)p Fg(.)p Fn([)p Fh(inte)n(ger)p
Fg(.)p Fn(])p Fh(attributename)p Fg(@)15 b(=)25 b($)p
Fa(n)p Fn(;)164 1503 y(where)14 b Fg($)p Fa(n)g Fn(denotes)h(a)g(Y)l
(acc)f(pseudo)o(v)m(ariable.)20 b(It)14 b(is)h(also)g(p)q(ossible)f(to)
h(cop)o(y)f(attribute)164 1563 y(instances)i(in)o(to)g(pseudo)o(v)m
(ariables.)164 1708 y Fd(9.7)70 b(Expressing)23 b(dep)r(endencies)d
(explicitl)o(y)164 1800 y Fn(Supp)q(ose)13 b(that)g(y)o(ou)f(ha)o(v)o
(e)f(a)i(C)f(function)g Fg(fun)f Fn(in)h(a)h(library)l(,)f(and)g(that)h
(y)o(ou)f(w)o(an)o(t)g(to)h(use)164 1860 y(it)k(to)h(de\014ne)f(an)g
(attribute)g(o)q(ccurrence,)g(sa)o(y)g Fg(sym.attrb)p
Fn(,)d(in)j(terms)f(of)i(some)e(other)164 1920 y(o)q(ccurrence)23
b Fg(othersym.o)o(the)o(rA)o(ttr)o(b)p Fn(.)40 b(F)l(urther)24
b(supp)q(ose)h(that)f(the)f(\014rst)h(formal)164 1981
y(parameter)c(of)h Fg(fun)g Fn(is)g(of)g(the)g(same)f(t)o(yp)q(e)h(as)h
Fg(othersym.)o(oth)o(erA)o(tt)o(rb)p Fn(,)d(and)i(that)164
2041 y Fg(fun)p Fn('s)14 b(second)h(formal)f(parameter)f(is)i(a)h(p)q
(oin)o(ter)e(to)i(something)e(of)h(the)g(same)f(t)o(yp)q(e)g(as)164
2101 y Fg(sym.attrb)p Fn(.)21 b(A)16 b(call)h(to)g Fg(fun)f
Fn(c)o(hanges)i(the)f(con)o(ten)o(ts)f(of)i(the)f(lo)q(cation)g
(indicated)f(b)o(y)164 2161 y(its)g(second)g(argumen)o(t.)237
2221 y(It)g(w)o(ouldn't)g(w)o(ork)g(to)h(write:)292 2323
y Fg(@i)25 b(fun\(@other)o(Sym)o(.ot)o(he)o(rAt)o(trb)o(@,)d
(&@sym.attr)o(b@\))o(;)949 2599 y Fn(18)p eop
%%Page: 19 19
19 18 bop 164 307 a Fn(since)19 b(the)g(mo)q(de)f(ann)o(uciator)i
Fg(@i)e Fn(\(see)h(section)g(4.1\))h(implies)d(that)j(the)f(o)q
(ccurrence)164 367 y(app)q(earing)c(\014rst)g(\()p Fg(otherSym.)o(oth)o
(er)o(Att)o(rb)p Fn(\))c(is)j(the)g(o)q(ccurrence)f(b)q(eing)h
(de\014ned,)g(and)164 428 y(that)j(it)e(dep)q(ends)i(on)g
Fg(sym.attrb)o Fn(.)i(Actually)14 b(y)o(ou)j(in)o(tend)e(the)h(opp)q
(osite.)237 488 y(One)c(solution)h(w)o(ould)g(b)q(e)g(to)g(mo)q(dify)e
(the)h(de\014nition)g(of)h Fg(fun)f Fn(\(rev)o(ersing)f(the)i(order)164
548 y(of)e(its)g(formal)f(parameter)g(list\).)19 b(If)11
b(y)o(ou)g(don't)g(w)o(an)o(t)g(to)h(disturb)f(the)g(library)l(,)g(ho)o
(w)o(ev)o(er,)164 608 y(it)16 b(w)o(ould)g(b)q(e)g(b)q(est)h(to)g(use)f
(Ox's)g Fh(explicit)j(mo)n(de)e(annunciator)23 b Fg(@e)15
b Fn(as)i(follo)o(ws:)292 710 y Fg(@e)25 b(sym.attrb)d(:)k(otherSym.)o
(oth)o(er)o(Att)o(rb)c(;)369 770 y(fun\(@other)o(Sym)o(.ot)o(he)o(rAt)o
(trb)o(@,)g(&@sym.attr)o(b@\))o(;)164 872 y Fn(In)c(the)g(\014rst)g
(line)f(ab)q(o)o(v)o(e,)h(Ox)g(is)g(explicitly)d(giv)o(en)i(dep)q
(endency)g(information)h(using)164 932 y(a)f(Mak)o(e-lik)o(e)c(syn)o
(tax:)21 b(it)16 b(is)g(declared)g(that)g Fg(sym.attrb)d
Fn(dep)q(ends)k(on)164 992 y Fg(otherSym.o)o(the)o(rA)o(ttr)o(b)p
Fn(.)38 b(Use)22 b(of)h(the)g(explicit)d(mo)q(de)i(mak)o(es)g(the)g
(order)h(of)g(the)164 1052 y(o)q(ccurrences)16 b(in)f(the)h(second)h
(line's)d(call)i(to)g Fg(fun)f Fn(irrelev)m(an)o(t)g(to)i(Ox's)e
(understanding)164 1112 y(of)i(the)f(dep)q(endencies.)164
1257 y Fd(9.8)70 b(Generating)22 b(ANSI/ISO/C++)i(output)164
1349 y Fn(By)15 b(default,)g(the)h(C)g(co)q(de)g(generated)f(b)o(y)h
(Ox)f(follo)o(ws)h(traditional)f(C)h(syn)o(tax.)21 b(There)164
1409 y(is,)16 b(ho)o(w)o(ev)o(er,)e(a)j(command-line)c(option)k(to)f
(pro)q(duce)h(co)q(de)f(compatible)f(with)164 1470 y(ANSI/ISO/C++)g
(syn)o(tax.)21 b(Th)o(us)c(it)e(is)h(easy)h(to)f(mak)o(e)e(Ox's)i(co)q
(de)g(generation)g(con-)164 1530 y(form)f(to)i(the)f(exp)q(ectations)g
(of)g(practically)f(an)o(y)h(C)h(or)f(C++)h(compiler.)164
1696 y Fo(10)83 b(Ac)n(kno)n(wledgemen)n(ts)164 1806
y Fn(This)19 b(is)f(to)h(thank)f(T)l(erry)g(Dineen,)g(Carolyn)h(Gib)q
(erson,)h(Markus)e(Klingsp)q(or,)h(John)164 1866 y(Levine,)14
b(Carla)i(Marceau,)f(and)g(Mic)o(hael)f(Seager)h(for)g(their)g(helpful)
f(reviews)g(of)i(early)164 1926 y(v)o(ersions)g(of)g(this)g(pap)q(er.)
949 2599 y(19)p eop
%%Trailer
end
userdict /end-hook known{end-hook}if
%%EOF
@EOF
set `sum $sumopt <oxDistG1.04/docs/oxTutor.ps`; if test $1 -ne 63400
then
	echo ERROR: oxDistG1.04/docs/oxTutor.ps checksum is $1 should be 63400
fi
set `wc -lwc <oxDistG1.04/docs/oxTutor.ps`
if test $1$2$3 != 21584827146984
then
	echo ERROR: wc results of oxDistG1.04/docs/oxTutor.ps are $* should be 2158 4827 146984
fi

chmod 755 oxDistG1.04/docs/oxTutor.ps

if test -f oxDistG1.04/docs/oxURM.dvi
then
	echo Ok to overwrite existing file oxDistG1.04/docs/oxURM.dvi\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/docs/oxURM.dvi
	if test -f oxDistG1.04/docs/oxURM.dvi
	then
		echo Error: could not remove oxDistG1.04/docs/oxURM.dvi, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/docs/oxURM.dvi '[non-ascii]'
$unpacker <<'@eof'
begin 755 oxDistG1.04/docs/oxURM.dvi
M]P(!@Y+ '#L      ^@;(%1E6"!O=71P=70@,3DY,RXQ,2XQ-#HP,C PBP  X
M                                                  #_____H )RX
M  "-H/VU  "@ BT  (V@_B8"$(V2 -L(./,\&O(B5@ 11ZX "@    9C;6)XX
M,3#G3W@ZCJ0.@ "-D7T7E/,K6*M1"P ,    #     5C;7(Q,M9!;I8#ZJA!X
MD*QR='1R:6)U=&4M1W)A;6UA<I-#;VUP:6QI;F>34WES=&5MCJ&-D@"D#85BX
M87-E9)8#ZJAO;I-9D?\%5F%C8RR33&5X+)-A;F230SJ.GQN  (V2 (11P^=5X
M<V5RE@:?O%)E9F5R96YC99--86Z1_W*P=6%LCI\:F9J-D@"Z4>CS(DOQ8'D X
M"O,S  H    %8VUR,3#-8IJR(7F6 Z9F2W5R=)--+I-":7-CF&AO"XZD#9F:X
MC9( O-P:3F^5LB%VDV5MDV*03=YE<I8#IF8Q-"R3,3DY,XZAC8V-C8V2 *1KX
M@9ZK@F..CHZ-C8V2 *%@U?,D(2(LF@ *\S, "@    9C;7-Y,3#/#8Z.CHZ2X
M *Q4"LTQ.3DR+)8#IF8Q.3DSDTMU<G2332Z30FES8Y"R(6AO"XZ.CHR+    X
M 0                                                   "J@ G( X
M (V@_;4  (V-D2>  /,O?6@ATP ,    #     9C;7-L,3+:0T].5$5.5%.2X
M 3UCO]8QCHZ@ BT  (V@_??;(XV1)X  YT-O;I;_<K!T96Z3='..GQIB(XV-X
MD2>  /,PPM9.H  ,    #     9C;6)X,3+;,8Z1.1_T3W:0H !E<G9I97>6X
M!(  ;V:357-EC9(!#(L2-(Z.I!H_^(V-D2>  #*.D3D?]%!R96QI;6EN87)YX
MC9(!)X<G-8Z.H8V-D2>  #..D3D?]$&0H !T=')I8G5T99$$@ !D96-L87)AX
M=&EO;G.-D@#J@BTVCHZI#H  C8V1.1_TUC,N,8Z15"9*4V5M86Z0K')T:6-SX
ME@/JJ&]FDV%T=')I8G5T99-D96-L87)A=&EO;G.1!TU,C9$"__WS++?A9Z, X
M#     P    &8VUM:3$RUSJ.E@E#AHV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+_X
M_3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCHV1X
M%M::UC>.CJ&-C9$G@ #;-(Z1.1_T4G5L97.6!(  86YDDV%T=')I8G5T99-OX
MD&  8V-U<G)E;F-E<XV2 + YHS>.CJ&-C9$G@  UCI$Y'_1!D*  ='1R:6)UX
M=&61!(  9&4,;FET:6]N<XV2 /0EO#B.CJ:-C9$Y'_36-2XQCI%4)DI);FAEX
M<FET9626 ^JH=G,ND04XX'-Y;I"L<G1H97-I>F5DDV%T=')I8G5T97.1!)"!X
MC9$"__W7.HZ6"4.&C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.C9$6UIK6.(Z.IHV-X
MD3D?]#4N,HZ15"9*09"L<G1T<FEB=71EE@/JJ')E9F5R96YC99-S96-T:6]NX
M<Y-I;I-T:&6362T,;&61!Z]HC9$"__W7.HZ6"4.&C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+_X
M_3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.C9$6UIK6.8Z.IHV-D50F2C4NX
M,BXQCI%YO\=%>'!L:6-I=)$#ZJAM;Y!3CF1ED0-$V(V1 O_]USJ.E@E#AHV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+_X
M_3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ-D1#VGM8QX
M,(Z.IHV-D50F2C4N,BXRCI%YO\=);7!L:6-I=)$#ZJAM;Y!3CF1ED0-O*(V1X
M O_]USJ.E@E#AHV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ-D1#VGM8Q,8Z.IHV-D50F2C4N,BXSCI%YO\=-:7AE9)$#ZJAM;Y!3X
MCF1ED0)4@(V1 O_]USJ.E@E#AHV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+_X
M_3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCHV1$/:>UC$QCHZFC8V1.1_T-2XSCI%4X
M)DI!D*QR='1R:6)U=&66 ^JH<F5F97)E;F-EDW-E8W1I;VYSDVENDW1H99-,X
M+0QL92AS*9$$I&*-D0+__=<ZCI8)0X:-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.C9$0]I[6,3*.CJ:-C9%4)DHU+C,N,8Z1>;_'1V5N97)AX
M;&ETD*QR>98#ZJAO9I-/>)$'A!N-D0+__=<ZCI8)0X:-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+_X
M_3J.DXV1 O_].HZ-D1#VGM8Q,HZ.IHV-D50F2C4N,RXRCI%YO\=/>)8#ZJAAX
M9&%P=&%T:6]NDW1ODTQE>"=SDVQI;F4M;W)I96Z:K')T9623<WENF'1A>)$'X
MW[J-D0+__=<ZCI8)0X:-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ-D1#VGM8Q,XZ.IHV-D50F2C4N,RXSCI%YO\=297-O;'5T:6]NX
ME@/JJ&]FDV%ME:QR8FEG=6ETDWF6 ^JH<F5G87)D:6YGDW1O:Y"L<F5NDW)EX
M='5R;F5DD06S^HV1 O_]USJ.E@E#AHV1 O_].HZ3C9$"__TZCHV1$/:>UC$TX
MCHZFC8V1.1_T-2XTCI%4)DI#>6-L97.1!;&PC9$"__W7.HZ6"4.&C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ-D1#VGM8Q-8Z.H8V-D2>  -LVCI$Y'_14D?[@ ')A;G-L871IX
M;VZ6!(  :6Z0H !T;Y-#DV-OD&  9&6-D@#;/-DQ-8Z.H8V-D2>  #>.D3D?X
M]%21_N  96UPE6  ;W)A;)L$@ !BDV5H89"@ '9I;W*8;V:83W@M9V5N97)AX
M=&5DF&5VD?]  &%L=6%T;W)SC9%3\C Q-8Z.IHV-D3D?]-8W+C&.D50F2E-TX
M86.0K')KD0/JJ&]PD%..97)A=&EO;G.1"0X4C9$"__W7.HZ6"4.&C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ-D1#VGM8Q-8Z.IHV-D3D?]#<N,HZ15"9*4&QA8V5M96Z0K')TE@/JX
MJ&]FDV=E;F5R871E9)-C;Y!3CF1ED0*'2XV1 O_]USJ.E@E#AHV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MC9$0]I[6,3:.CJ:-C9$Y'_0W+C..D50F2D1E8V]R871I;VZ6 ^JH86YDDW1HX
M99-R96%D>9-S9720+;.-D0+__=<ZCI8)0X:-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCHV1$/:>UC$WCHZAX
MC8V1)X  VSB.D3D?]%!R;V=R86UM:6YGD02  '-TD*  >6QEC9( ]E/S,3>.X
MCJ&-C9$G@  YCI$Y'_10E:  ;W-T9&5C;W)A=&EO;I$$@ !T<F&3=I-E<G-AX
M;'.-D@#2(1DQ.(Z.IHV-D3D?]-8Y+C&.D50F2D5X86UP;&4ZD04XX&EN#'B6X
M ^JH=&^3<')E#'B3=')A;G-L871I;VZ1!$3%C9$"__W7.HZ6"4.&C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.C9$0]I[6,3B.CJ:-C9$Y'_0Y+C*.D50F2D=E;F5RX
M86R1 ^JH9&5S8W)I<'1I;VZ1 XT$C9$"__W7.HZ6"4.&C9$"__TZCI.-D0+_X
M_3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.C9$0]I[6,C&.X
MCJ:-C9%4)DHY+C(N,8Z1>;_'5)'_!59R896L<G:397)S86R1 ^JH<W"04XYEX
M8VD,8V%T:6]N<Y$"X4&-D0+__=<ZCI8)0X:-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ-D1#VGM8R,8Z.IHV-D50F2CDNX
M,BXRCI%YO\=4D?\%5G)AE:QR=I-E<G-A;)8#ZJAA8W1I;VZ3<W"04XYE8VD,X
M8V%T:6]N<Y$$KW&-D0+__=<ZCI8)0X:-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.C9$0]I[6,C*.X
MCHZ.C(L    "                                                X
M   !ZZ "<@  C:#]M0  C8V1)X  VD-/3E1%3E13D@$]8[_6,HZ.H (M  "-X
MH/WV  "-C9$G@ #;,3".D3D?]$]XD02  &UA8W)O<XV2 2>UO#(SCHZD#H  X
MC8V1.1_TUC$P+C&.D50F2DUA8W)OD0/JJ&1E#&YI=&EO;G.1!21]C9$"__W7X
M.HZ6"4.&C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+_X
M_3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ-D1#VGM8R,XZ.H8V-D3D?]#$P+C*.D50F2DUAX
M8W)OD0/JJ'5S97.0 @N-D0+__=<ZCI8)0X:-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ3C9$"__TZCI.-D0+__3J.C9$0]I[6,C2.CJ&-C9$Y'_0Q,"XSX
MCI%4)DI%>&%M<&QED0,<M8V1 O_]USJ.E@E#AHV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCHV1$/:>UC(TCHZIX
M&C_XC8V1)X  VS$QCI$Y'_1!=71O;6%T:6.6!(  9V5N97)A=&EO;I-O9I-CX
M;W"0H !YDW)U;&5SC9( EEE*,C6.CJ&-C9$Y'_36,3$N,8Z15"9*17AA;7!LX
M99$#'+6-D0+__=<ZCI8)0X:-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+_X
M_3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ-D1#VGM8R-XZ.IHV-D2>  -LQ,HZ1X
M.1_T1FEL92UL97:0H !E;)8$@ !O<F=A;FEZ871I;VZ3;V:33WB397:1_T  X
M86QU871O<G.-D7\B+S(YCHZAC8V1.1_TUC$R+C&.D50F2D-O;I6L<G:396Z3X
M=&EO;G.6 ^JH;V:3;F%M:6YGDT]XDV]U='!U=),,;&5SD08_$(V1 O_]USJ.X
ME@E#AHV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.C9$0]I[6,CF.CJ&-C9$Y'_0Q,BXRCI%4)DI2979I97<ZD04XX
MX&-O;9"L<F)I;FEN9Y8#ZJAT:&63;W5T<'5T<Y-O9I-9D?\%5F%C8Y-A;F23X
M3&5XD0R>28V1 O_]USJ.E@E#AHV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.C9$0]I[6,CF.CJ&-C9$Y'_0Q,BXSCI%4X
M)DI#;VV0K')B:6YE9)8#ZJAU<V63;V:33W@LDUF1_P5686-C+)-A;F233&5XX
MD0M >HV1 O_]USJ.E@E#AHV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ-D1#VGM8S,(Z.H8V-D3D?X
M]#$R+C2.D50F2E20K')Y<&EC86R6 ^JH8V]M;6%N9)-S97%U96YC97.1!(1RX
MC9$"__W7.HZ6"4.&C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ-D1#VGM8S,(Z.IHV-D2>  -LQ,XZ1.1_TX
M0V]M;6%N9"UL:6YEE@2  &]P=&EO;G.386YDDV]T:&5RDW"08 !O:6Z0H !TX
M<XV1>P1/,S".CJ&-C9$Y'_36,3,N,8Z15"9*17)R;W*1 ^JH<F5C;Y6L<G:3X
M97)YD0':Z8V1 O_]USJ.E@E#AHV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+_X
M_3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCHV1$/:>UC,QCHZAC8V1.1_T,3,N,HZ15"9*365M;W)YD0/JJ&%L:6=N;65NX
MD*QR=)$&HVF-D0+__=<ZCI8)0X:-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ-D1#VGM8S,8Z.H8V-D3D?]#$S+C..X
MD50F2E-T<FEP<&EN9Y8#ZJA/>)-C;VYS=')U8W1SD0@O'HV1 O_]USJ.E@E#X
MAHV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+_X
M_3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-X
MD0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCHV1$/:>UC,QCHZAC8V1.1_T,3,NX
M-(Z15"9*4')E=I6L<F5NDW1I;F>6 ^JH97AE8W5T:6]NDV]FDV%T=')I8G5TX
M99-D90QN:71I;VZ38V^04XYD99$!GE.-D0+__=<ZCI8)0X:-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MC9$0]I[6,S*.CJ&-C9$Y'_0Q,RXUCI%4)DI#;VZ0K')T<F]LE@/JJ&]FDW-TX
M;W)A9V6386QL;Y!3CF-A=&EO;I-I;I-T:&639V5N97)A=&5DDV5VD?]8Y&%LX
M=6%T;W*1 X4,C9$"__W7.HZ6"4.&C9$"__TZCI.-D0+__3J.DXV1 O_].HZ-X
MD1#VGM8S,HZ.H8V-D3D?]#$S+C:.D50F2E"0K')A<G-EE@/JJ'1R9663<W1AX
M=&ES=&EC<Y$"\K6-D0+__=<ZCI8)0X:-D0+__3J.DXV1 O_].HZ3C9$"__TZX
MCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"X
M__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ-D1#VGM8S,XZ.H8V-D3D?]#$SX
M+C>.D50F2D%D:G5S=&EN9Y8#ZJAT:&63<VEZ97.3;V:33W@G<Y-D871ADW-TX
M<G5C='5R97.1!$?QC9$"__W7.HZ6"4.&C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCHV1$/:>UC,TCHZFC8V1)X  VS$TCI$Y'_1%>&%M<&QEX
M.I$&  !A;I8$@ !I;I"@ '1E9V5RDV-A;&-U;&%T;W*-D@"P@=,S-(Z.IHV-X
MD2>  #$UCI$Y'_1%>&%M<&QE.I$&  !AE@2  &)I;F%R>9-NE:  =6V38I!@X
M &5RD02  '1R86YS;&%T;W*-D@"(X&0S-HZ.IHV-D2>  #$VCI$Y'_1%>&%MX
M<&QE.I$&  !T<F%N<VQA=&EO;I8$@ !T;Y-PD&  ;W-T#'B386YDDW!R90QXX
MC9%M!$XT,(Z.IHV-D2>  $&.D3D?]%5S:6YGE@2  $]XDW=I=&B3;F]N+4QEX
M>)-L97AI8V%LDV%N86QY>F5R<XV1=^ML-#..CJ&-C9$Y'_3602XQCI%4)DI$X
M969A=6QTFP/JJ&-O;I6L<G1E>'0M<V5N<VET:79I=)-YF&]FF$PM#&QEF'!RX
M97!R;Y!3CF-E<W-I;F>1"-/\C9$"__W7.HZ6"4.&C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ-D1#VGM8T,XZ.H8V-X
MD3D?]$$N,HZ15"9*3W@M<')E<')OFE..8V5S<VEN9Y8#ZJAO9I-#+6-OF&1EX
M9)-L97AI8V%LDV%N86QY>F5R<Y$'56Z-D0+__=<ZCI8)0X:-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ-D1#VGM8T,XZ.H8V-D50F2D$N,BXQCI%YO\=%>&%M<&QED0*1X
M4(V1 O_]USJ.E@E#AHV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3X
MC9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_]X
M.HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1X
M O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ3C9$"__TZCI.-D0+__3J.X
MDXV1 O_].HZ3C9$"__TZCI.-D0+__3J.DXV1 O_].HZ-D1#VGM8T,XZ.IHV-X
MD2>  -M"CI$Y'_14D?[@ ')AE:  =I-E<G-A;)$$@ !S96UA;I-T:6-SC9( X
M\YG_-#>.CJ:-C9$G@ !#CI$Y'_1,:7-TE@2  &]FDW)E<V5R=IJ@ &5DDW>8X
M;W)D<Y-A;F23<F5S97)VF&5DDPQL99-N86UE<XV15:JS-3".CHZ.C(L    #X
M                                                   3+: "<@  X
MC:#]M0  C8V1)X  VD-/3E1%3E13D@$]8[_6,XZ.H (M  "-H/WV  "-C9$GX
M@ #;1(Z1.1_T4W5M;6%R>98$@ !O9I-C;VUM86YD+6QI;F63;W!T:6]N<XV2X
M )B 9C4QCHZ.CHR+    !                                       X
M            )1*@ G(  (V@_;4  (V-D2>  -HQD0N_^$^0K')615*1_K'(X
M5DE%5Y8#ZJA/1I-54T62 /QUL-8TCHZ@ BT  (V@_?@  (V-D2>  .<QCI%%X
M3LY/=I'_<K!E<G9I97>6!I^\;V:357-ECI\:8B.-D2>  -9,97B6 KL#86YDX
MDUF1_P5686-CDV%R99-PFE..;Y6L<G>397)F=6R6 KL#86YDDW=I9&5L>2UUX
M<V5DDW1OF&]L<Y-F;W*3=&AEDV%U=&]M871I8Y-G96YE<F%T:6]NCJ0.@ "-X
MD2>  &]FE@-2E&QA;F=U86=EDW)E8V]G;FEZ97)S+I$%!B],97B386-C97!TX
M<Y-ADW-E=)-O9I-U<V5R+7=R:71T96Z3<F5G=6QA<I-E>'!R97-S:6]N<XZAX
MC9$G@ !A;F26!3@I=W)I=&5SDV&30Y-P<F]G<F%MDW1H8723<)!3CF5R9F]RX
M;7.3;&5X:6-A;)-A;F%L>7-I<Y-A8V-O<F1I;F>3=&^3=&AO<V6.H8V1)X  X
M97AP<F5S<VEO;G,ND07V<5F1_P5686-CE@0IV'1R86YS;&%T97.3=7-E<BUWX
M<FET=&5NDV=R86UM87*3<G5L97.3:6Z0K')T;Y-#DW-O=7)C99-C;Y!3CF1EX
MCJ&-D2>  &9O<I8##')ADW-Y;I"L<G1A>)-A;F%L>7IE<BZ1!.[.5VAI;&63X
M=&AE>9-A"V]R9)-<:&^:4XYO:W,BDV9O<I-E>&5C=71I;VZ3;V:3:&%N9"UCX
M;YAD962.H8V1)X  0RUL86YG=6%G998$WVES96UA;IJL<G1I8Y-A8W1I;VYSX
M+)$%')I,97B386YDDUF1_P5686-CDW!R;YAV:61EDVQI='1L99-O=&AE<I-FX
M86-I;&ETF'F39F]RCJ&-D2>  &%U=&]M871I8Y8#ZJAI;7!L96UE;IJL<G1AX
M=&EO;I-O9I-L86YG=6%G99-S96UA;IAT:6-S+HZAC9$Y'_1!D*QR='1R:6)UX
M=&5DE@/0-W!A<G-EDW1R965SDV%R99-O9G1E;I-U<V5DDV%SDV1A=&&3<W1RX
M=6-T=7)E<Y-I;I-E=I'_6.1A;'5A=&]R<Y-F;W*.H8V1)X  ;&%N9W5A9V5SX
M+I$(3IY/9G1E;I8$\>=T:&63;&%N9W5A9V63:6UP;&5M96Z0K')T97*3:&%NX
M9"UC<F%F='.38V^04XYD99-F;W*38G5I;&1I;F<LCJ&-D2>  '1R896L<G:3X
M97)S:6YG+)L#/NYA;F26 Q0 97:1_UCD86QU871I;F>3871T<FEB=71E<Y-OX
M9I-P87)S99-T<F5E<RR886YDDV9O<I-P87)S92UT<F5E+7)E;&%T962.H8V1X
M)X  ;65M;W)YE@1]*&UA;F%G96UE;IJL<G0ND0;P7T&1!'T"69'_!59A8V.3X
M<W"04XYE8VD,8V%T:6]NDV1E#&YE<Y-ADV-O;IAT97AT+69R9663;&%N9W5AX
M9V6.H8V1)X  86YDE@0UP&&3;6%P<&EN9Y-F<F]MDW1H99-S9723;V:3;&5GX
M86R3<V5ND*QR=&5N8V5SDW1ODW1H99-S9723;V:3<&%R<V63=')E97,LD01(X
MAF)U=(ZAC9$G@ !C;Y!3CF1EE@/JJ&9O<I-P87)S92UT<F5EDVUA;F%G96UEX
M;IJL<G23:7.3;F]TDV=E;F5R871E9)-A=71O;6%T:6-A;&QYDV*8>9-9D?\%X
M5F%C8RZ.H8V1.1_T5&AEE@5[8T]XC8V3G_NE,O,-?'M9!P (    "     1CX
M;7(XN#&.CI$/MLK6=7-E<I-C86Z3<W"04XYE8VEF>9-ADVQA;F=U86=EDW5SX
M:6YGDW1H99-F86UI;&EA<I-L86YG=6%G97.3;V:.H8V1)X  3&5XE@-]<&%NX
M9)-9F_\%5F%C8RR1 Y-(;W*3=&%KD*QR99-A;I-E>&ES=&EN9Y-,97@O69AAX
M8V.3<W"04XYE8VD,8V%T:6]N+)$#DTAA;F23861DDW-E;6%ND*QR=&EC<XZAX
MC9$G@ !T;Y8$8C%T:&63;&%N9W5A9V638IJL<GF3875G;65NF'1I;F>3=&AEX
MDW-PD%..96-I#&-A=&EO;I,,;&5SDW=I=&B39&5C;&%R871I;VYSDV%N9(ZAX
MC9$G@ !D90QN:71I;VYSE@/JJ&]FDW20K')Y<)I3CF5DDV%T=')I8G5T97.3X
M;V:3<&%R<V4M=')E99-N;YAD97,NCJ&-D3D?]%1H8726 ]$;<W"04XYE8VD,X
M8V%T:6]NDV-O;G-T:71U=&5SDV%ND_,NF[N(0  ,    #     9C;71I,3+9X
M871T<FEB=71ED00;N6=RD?]F9F%M;6%RD0%*J]8LD0/6-V%N9)-F<F]MDVETX
MDT]XDV-A;HZAC9$G@ !A=71O;6%T:6-A;&QYE@,^KF=E;F5R871EDV%ND]EEX
M=F%L=6%T;W*1!(E9UG=R:71T96Z3:6Z369O_!59A8V,LE@-A$TQE>"R386YDX
ME@,^KD,NDT:8;W*389-G:7:0K')E;HZAC9$G@ !I;G!U="R; U:9=&AEE@,QX
ME65VD?]8Y&%L=6%T;W*38G5I;&1SDV&3<&%R<V63=')E92R89&5T97)M:6YEX
M<Y-A;I-O<F1E<I-O9I-E=I'_6.1A;'5A=&EO;I-F;W*.H8V1)X  871T<FEBX
M=71E<Y8$);EO9I-T:&63=')E92R;!#1]86YDDW"04XYE<F9O<FUS+)AF;W*3X
M96%CD*QR:)-A='1R:6)U=&4LF'1H99-S96UA;I"L<G1I8Y-A8W1I;VZ.H8V1X
M)X  <F5Q=6ER9626 O#&=&^397:1_UCD86QU871EDVET+I$$Y954:&ESDW!AX
M<G-EDW1R9663:7.3;6%N86=E9)-I;F1E<)!3CF5N9&5NFJQR=&QYDV]FDV%NX
MF'F3=')E97..H8V1)X  ;6%N86=E9)8$?)]BFJQR>9-H86YD+7=R:71T96Z3X
M0Y-C;Y!3CF1E+)$$H1UB=723:6YF;W)M871I;VZ3;6&8>9-BD%..99-M;YAVX
MF&5DDV*04XYE=)AWF&5E;HZAC9$G@ !T:&66 ^JH97:1_UCD86QU871O<BUMX
M86YA9V5DDW1R966386YDDV%ND*QR>9-G;&]B86R39&%T89-S=')U8W1U<F4NX
MCJ&-D3D?]$%D9&ET:6]N86QL>9'_!58LD0.K6G1H998#FX9/>)-U<V5RDV-AX
M;I-E87-I;'F3<W"04XYE8VEF>9-P87)S92UT<F5EDW1R896L<G:397)S86QSX
ME@.;AG1H872387)ECJ&-D2>  '"04XYE<F9O<FUE9)8%+ )A9G1E<I-E=I'_X
M6.1A;'5A=&EO;I-O9I-T:&63=')E92=SDV%T=')I8G5T97.386YDDW1H8723X
M<F5F97*3=&^3=&AO<V6.H8V1)X  871T<FEB=71E<RZ1"4%+4W5CE:QR:)L%X
M0LQT<F&3=I-E<G-A;'.89W)E871L>9AS:6UP;&EF>9AT87-K<YAS=6.3:)AAX
M<YAC;Y!3CF1EF&=E;F5R871I;VZ.H8V1)X  86YDE@/JJ'1H99-G871H97)IX
M;F>3;V:38V]M<&EL871I;VZ3<W1A=&ES=&EC<RZ.H8V1.1_T5&AEE@22IVQAX
M;F=U86=EDV1E<VEG;F5RDVESDV9R965DDV9R;VV3=&AEDW1E9&EO=7.386YDX
MDV5R<F]R+7!R;VYEDV1E=&%I;'..H8V1)X  ;V:6!<$?=W)I=&EN9Y-C;Y!3X
MCF1EDV9O<I-P87)S92UT<F5EDVUA;F%G96UE;I"L<G0ND0J\1$]X+6=E;F5RX
M871E9)-E=I'_6.1A;'5A=&]R<Y-U<V6.H8V1)X  ;65M;W)Y+6UA;F%G96UEX
M;I6L<G2;!)?.=&5CDVAN:7%U97.8=&AA=)AB<FEN9YAL87)G99AT:6UE+64.X
M8VEE;F-YF&=A:6YSF&^3=I-E<HZ1)X  GPJ(AXD  &9F )O_9)\+  "-C8V1X
M#8.0G_Q>__,(V9.@4@ '    !P    1C;7(WLS&.CI$2  /S&4OQ8'D "@  X
M  H    %8VUR,3#$5&AEE@,J8&YA;6637$]X(I-O<FEG:6YA=&5DDV%SDV&3X
M:&]M;W!H;VYEDV9O<I-A;I-A8W)O;IJXXWEMDV9O<I-<06Z309AT=')I8G5TX
M99-'<F%M+8ZD#   C6UA<I8#82Q#;VUP:6QI;F>34WES=&5M(BZ1!)5-2723X
M=YJXXV%SDVYO=&EC9623;&%T97*3=&AA=)-E=IAE<GF3>9AA:Y-I<Y-A;I-OX
MF'B386YDDW1H87233WB39V5N97(MCJ&-86QI>F5SE@-5571H99-F=6YC=&EOX
M;I-O9I-9D?\JJF%C8RZ.CHZ,BP    4                             X
M                     "6IH )R  "-H/VU  "-C9$G@ #:,I$+O_A04D5,X
M24U)3D%2D?\%5EF2 1DOD=8UCHZ@ BT  (V@_?8  (V1)X  :&%N9"UB=6ELX
M=)8#CJEE=I'_6.1A;'5A=&]R<Y-T:&%TDW5S99-T:&638V]M;6]NDW1E8Y"LX
M<FAN:7%U99-O9I-C86QL:6YGD_,QWX:U5  ,    #     9C;71T,3+<;6%LX
M;&]CD]9O;F-ECJ0.@ "-D2>  &9O<I8#?LME86.:K')HDW!A<G-E+71R9663X
M;F^04XYD92Z1!13L06QS;RR1 Y1>3WB3<')OF'9I9&5SDW-E8W5R:728>9-BX
MF'F3=&5S=&EN9Y-T:&639&4,;FET:6]NCJ&-D2>  &9O<I8$$C=C;VYS:7-TX
M96YC>9-A;F238V]M<&QE=&5N97-S+)$$'!MA;F23=&AEDT]X+6=E;F5R871EX
M9)-E=I'_6.1A;'5A=&]RDW"04XYE<F9O<FUSCJ&-D2>  '1E<W1SE@6ZSW1OX
MDV5N<W5R99-T:&%TDV&38VER8W5L87*39&4,;FET:6]NDVAA<Y-N;W23<')EX
M=I6L<F5NDW1E9)8%NL]E=I'_6.1A;'5A=&EO;I-O9HZAC9$G@ !A='1R:6)UX
M=&5S+HZAC9$Y'_1/>)8$#MEI<Y-ADW!R97!R;Y!3CF-E<W-O<I-T:&%TDV%CX
M8V5P='.3=)6L<G>3;Y8$#MEO<I-M;W)EDPQL97,LD007Y6%N9)-T<F%N<VQAX
M=&5SDW1H97-ECJ&-D2>  &END*QR=&^6 [9N#&QE<Y-S=6ET86)L99-F;W*3X
M:6YP=723=&^33&5XC8V3G_NE,K@RCHZ1#"S@UF%N9)-9D?\%5F%C8RZ1!2=WX
M5VET:)-F97>397AC97!T:6]N<RR1 \#@86QLDTQE>"V.H8V1)X  :6YP=70OX
M69'_!59A8V,M:6YP=726!"D(<&%I<G.3;V:3#&QE<Y-T:&%TDV-O;G-T:71UX
M=&63<F5C;V=N:7IE<G.3;W*3=')A;G-L871O<G.387)ECJ&-D2>  &QE9V%LX
ME@. QVEN<'5T<Y-T;Y-/>"Z1!1655&B:K')U<Y-MF'5CF&B397AI<W1I;F>3X
M<V]F=)AWF&%R99-I<Y-A;65N86)L99-T;Y-M;Y!3CF1I#&-A=&EO;HZAC9$GX
M@ !U<VEN9Y8$YGM/>"R1!25O86YDDVEM<&QE;65NFJQR=&%T:6]N<Y-T:&%TX
MDW5S99-/>)-C86Z38I!3CF638V]NF':897)T9623<W1E<)AW:7-EDV*8>8ZAX
MC9$G@ !H86YDE@3Y0W1ODUQP=7)E(I-,97@O69'_!59A8V.3:6UP;&5M96Z:X
MK')T871I;VYS+I$(9+!4:&ESDVUA:YAE<Y-/>)-WF&5L;"US=6ET9623=&^.X
MH8V1)X  ;&%N9W5A9V6;!+1>9&5S:6=N97)S+)8$YLQE>'"04XYE<FEM96Z0X
MK')T97)S+)-A;F28:6UP;&5M96Z0K')T97)SF&%L<F5A9'F89F%M:6QI87*8X
M=VET:(ZAC9$G@ !,97@LE@/JJ%F1_P5686-C+)-A;F230RZ.GR@55HV-D2> X
M .<RCI%%3LY0<F5L:6UI;F%R>8Z?&F(CC9$G@ #62726!%,&:7.387-S=6UEX
M9)-T:&%TDW1H99-R96%D97*3:7.39F%M:6QI87*3=VET:)-T:&63=7-EDV]FX
MDUF1_P5686-CDUN-2F]H;G-O;I$#ZJ@W-8Z1.:N572R.H8V1)X  3&5XE@/UX
MU5N-3&5S:Y$#ZJ@W-8Z1)Q#W72R1 _B@86YDDT.36XU+4I$#ZJ@X.(Z1(7+"X
M73N1 _ML3WB3<WEND*QR=&%C=&ECDV-O;G-T<G5C='.387)EDV1E<V-R:6*0X
M4XYE9)-M86EN;'F.H8V1)X  87.6 ZSN875G;65NFJQR=&%T:6]N<Y-O9I-TX
M:&63;&%N9W5A9V5SDV%C8V5P=&5DDV*8>9-T:&]S99-T;Y!3CF]L<RZ-C9$%X
M)$V?^Z4RN#..CI$/")[64')I;W*386-Q=6%I;BV.H8V1)X  =&%N8V66!&N<X
M=VET:)-T:&638F%S:6.3:61E87.3;V:3871T<FEB=71EDV=R86UM87)SDRAFX
M;W*3:6YS=&%N8V4LD02+V6%SDV9O=6YDDVENCJ&-D2>  %N-5Y'_!59A:71EX
MD0/JJ#@TCI$ML)==E@/JJ&]RDUN-06AODS@VCI$DX)U=*9-I<Y-H96QP9G5LX
M+HZAC9$Y'_1!;I8$!FI/>)-I;G!U=)-S<)I3CF5C:0QC871I;VZ38V]N<VESX
M='.3;V:38723;&5A<W23=)6L<G>3;Y8$!FH,;&5S.I$%<&1ADW-Y;I"L<G1AX
M8W1I8Y-S<)AE8RV.H8V1)X  :0QC871I;VZ6!)VM*'=H:6.:K')HDW)E<V5MX
MF&)L97.389-9D?\%5F%C8Y-I;G!U=)-S<)!3CF5C:0QC871I;VZ386YDDVESX
MDV-A;&QE9)-AD]E9+0QL9=8ICJ&-D2>  '1H8726!)"(3WB3=')A;G-L871EX
M<Y-I;I"L<G1ODV&369'_!59A8V.3:6YP=723<W"04XYE8VD,8V%T:6]N+)$$X
MN?]A;F23;VYEDV]RDVUO<F63;&5X:6-A;(ZAC9$G@ !S<)!3CF5C:0QC871IX
M;VYSE@-=URAW:&ECFJQR:)-R97-E;9AB;&633&5XDVEN<'5TDW-PD%..96-IX
M#&-A=&EO;G.386YDDV%R99-C86QL9623V4PM#&QEUG,ICJ&-D2>  '1H8726X
M W,P3WB3=')A;G-L871E<Y-I;I"L<G1ODTQE>)-I;G!U=)-S<)!3CF5C:0QCX
M871I;VYS+I$%$0U5<W5A;&QYDW1H97)EDVESDV5X86-T;'F3;VYECJ&-D2> X
M $PM#&QE+)$%#6IB=726!--#86Z397:1_UCD86QU871O<I-T:&%TDW5S97.3X
M;6]R99-T:&%NDV]N99-L97AI8V%LDV%N86QY>F5RDUN-3&5S:Y$#ZJ@W-8Z1X
M)Q#W78ZAC9$G@ !M89JL<GF6!)R58I!3CF638V]N<W1R=6-T96238IAYDW-UX
M8FUI='1I;F>3=&^33WB3;6]R99-T:&%NDV]N99-,+0QL92Z1!TZG5&AI<Y-MX
M86XMCJ&-D2>  '5A;)8$^D)P<F5S96Z:K')T<Y-D97-C<FEP=&EO;G.3;V:3X
M=&AEDT]X+7-PD%..96-I#&.38V]N<W1R=6-T<Y-T:&%TDVUAF'F387!PD%..X
M96%RDVENCJ&-D2>  '1H97-EE@3VP0QL97,LD04YQV%SDW>:K')E;&R387.3X
M<)!3CF5R=&EN96Z8=)-U;F1E<FQY:6YGDV-O;F-E<'1S+I$(72M4:&5S99-CX
M;VYS=')U8W1SDV%R98ZAC9$G@ !I;&QU<W1R871E9)8#Z?%M86EN;'F38IJLX
M<GF3=7-I;F>39G)A9VUE;IAT<Y-O9I-T:')E99-E>&%M<&QE<Y-O9I-/>)-IX
M;G!U=)-S<)!3CF5C:0PMCI$G@ "?"HB'B0  9F8 F_]DGPL  (V-C9$-@Y"?X
M_%[_LS*.CI$2  /$5&AEE@*%=6=E;F5R86R39&5S8W)I<'1I;VYSDVENDW1HX
M:7.3;6%ND+CC=6%LDV%S<W5M99-T:&63=7-EDV]FDV&33&5X+6)A<V5DDVQEX
M>&EC86R386YA;'EZ97(NCJ0,  "-2726 H75:7.3<)!''6]S<VEB;&4LFP*OX
M56AOE;CC=Y-E=I-E<BR8=&^6 H75=7-EDT]XDW=I=&B3;&5X:6-A;)-A;F%LX
M>7IE<G.3:&%N9"UW<FET=&5NDVENDT,ZDV1E=&%I;'.387)EDV=I=I"XXV5NX
MCJ&-<V5P87)A=&5L>98#554H:6Z387!PD$<=96YD:7B302DNCI\,  *-C8V1X
M#8.0G_Q>_[,SCHZ1$@ #Q%Q9D?\JJF%C8R(LE@,5'UQ,97@B+)-A;F2; P42X
M7$,BD0,$_F-A;BR3:6Z8=&AI<YAM86Z0N.-U86PLDV*01QUEF'1A:Y"XXV5NX
MF'1OF&UE86Z87%F1_RJJ86-CF&]RF$)I<V]N(BR37$QE>(ZAC6]RE@-5549LX
M97@B+)-A;F237$.3;W*30RLK(BR3<F5S<)!''65C=&EVD+CC96QYD?\JJBZ.X
MCHZ,BP    8                                                 X
M #*RH )R  "-H/VU  "-C9$G@ #:,Y$+O_A!EO\%5E144DE"551%D0/JJ$1%X
M0TQ!4D&35$E/3E.2 ,0![-8VCHZ@ BT  (V@_?8  (V1)X  8V%T:6]N<RR6X
M ^JH=&AEDV-O;7!L971EDW1E>'1SDV]FDW=H:6.0K')HDV%P<)!3CF5A<I-IX
M;I-S96-T:6]N<Y,Q-"R3,34LDV%N9),Q-BZ.I Z  (V1.1_T5VET:&ENE@7YX
MCD]X+7-PD%..96-I#&.38V]N<W1R=6-T<RR1!GU(0RUS=)JL<GEL99-A;F23X
M0RLK+7-TF'EL99-C;VUM96Z8='.3;6&8>8ZAC9$G@ !A<'"04XYE87*6!C=BX
M86Z:K')Y=VAE<F63=VAI=&5S<&%C99-M89AYDV%P<)!3CF5A<BZ1#!\.5&AEX
MDV=L;V)A;)-I9&5NF'1I#&5R<Y-O9I-/>"V.H8V1)X  9V5N97)A=&5DE@5;X
MS4.38V^04XYD92R1!;@7;&EKFJQR99-T:&]S99-G96YE<F%T96238IAYDUF1X
M_P5686-CDV%N9)-,97@LD06X%V%R99-P<F4,>&5DDV*8>8ZAC9$G@ #<>7G6X
M+)$$\G=S;Y8$O;1T:&633WB3=7-E<I-C86Z3896L<G:3;VEDE@2]M&YA;663X
M8V]N#6EC='.3:6Z3=&AEDV=E;F5R871E9)-E=I'_6.1A;'5A=&]RDV*0K')YX
MCJ&-D2>  &%B<W1A:6YI;F>6 ^JH9G)O;9-T:&63=7-EDV]FDV=L;V)A;)-IX
M9&5ND*QR=&D,97)SDW1H87238I!3CF5G:6Z3=VET:)/<>7G6+HZ?*!56C8V1X
M)X  YS..D45.SD&1_W*P='1R:6)U=&61!I^\9&5C;&%R871I;VYSCI\:8B.-X
MD2>  -9!<Y8$(&ID97-C<FEBFE..9623:6Z36XU*;VAN<V]ND0/JJ#<UCI$YX
MJY5=+)$$+=IT:&639&5C;&%R871I;VYSDW-E8W1I;VZ3;V:389-9D?\%5F%CX
M8Y-I;G!U=)-S<)AE8RV.H8V1)X  :0QC871I;VZ6!$E$:7.3=&AEDW!A<G23X
M=&AA=)-P<F5C961E<Y-T:&63#')S=)/<)263UFUA<FLLD01@ZF%N9)-I;I-IX
M=)-T:&63=7-E<I-M89"L<GF.H8V1)X  9&5C;&%R998#8&)T:&63<W1A<G23X
M<WEME:QR8I!3CF]L+)L#? IT;VN396YS+)AA<W-OE5..8VEA=&EV:71I97,LX
MF'5N:6]N<RR80YL#8&)C;Y-D99AS96-T:6]N<RR1 WP*971C+HZAC9$G@ !4X
M:&66 Y:262T,;&638V]NFJQR=&%I;G.3<W5CF&B389-D96-L87)A=&EO;G.3X
M<V5C=&EO;BR1 Z=C86YDDVENDVETDV%R99-PD%..97)M:71T962386QLDV]FX
MCJ&-D2>  '1H998#G(9C;VYS=')U8W1SDV]FDUF1_P5686-CDV1E8VQA<F%TX
M:6]N<Y-S96-T:6]N<RR1 ZPF87.3=Y"L<F5L;)-A<Y-/>)$'.0S9871T<FEBX
M=71ED0/K9&1EEO]F9F-L87*382V.H8V1)X  =&EO;G.1 /W=UBZ1!OE#06Z6X
M!( >871T<FEB=71EDV1E8VQA<F%T:6]NDV-O;G-I<W1SDV]FDW1H99-R97-EX
M<G::K')E9)-WF&]R9)/<0&%T=')I8G5T97..H8V1)X  UF9O;&QOE:QR=Y-EX
M9)L#2SIBDWF8\RTA(BR:  P    *    !F-M<WDQ,-AFUBR6 VL=86Z8871TX
M<FEB=71EF&1E8VQA<F%T:6]NF&QI<W0LD]AGUBR386YDF&&8;&ES=)AO9IAGX
M<F%M;6%RF'-Y;9"L<F*04XYO;',NCJ&-D3D?]%-U<'":4XYO<V66!59&=&AAX
M=)-ADV=R86UM87*3:&%SDV&3<WEMD*QR8IAO;)/<8FET;&ES=)/686YDDW1HX
M99-F;VQL;Y"L<G=I;F>3870MCJ&-D2>  '1R:6)U=&61 ^JH9&5C;&%R871IX
M;VXZCJ08@ "-D49@ =Q 871T<FEB=71E<Y8&+,U[9FQO8723=F%L=64[DVENX
M=)-S8V%L92QL96YG=&@[?9-B:71L:7-TCJ&-D2>  -94:&5NE@2EL71H99-/X
M>"UG96YE<F%T962397:1_UCD86QU871O<BR1!-1T=VAE;I-B=6EL9&EN9Y-AX
MDW!A<G-E+71R9663;F^:4XYD99-L86*896QE9(ZD#H  C9$G@ #<8FET;&ESX
M=-8LD0,6.6%L;&^04XYC871E<Y8"X1US=&]R86=EDV9O<I-ADPUO8723;F%MX
M9623W'9A;'5ED]9A;F23:6Z0K')T96=E<G.3;F%M9623W'-C86QECJ&-D2> X
M -9A;F21 ^JHW&QE;F=T:-8NCJ&-D3D?]$%NE@0/?F%T=')I8G5T99-D96-LX
M87)A=&EO;I-L:7-TDRAI;I-T:&63<')E=FEO=7.397AA;7!L92R1!!BS=&AEX
MDW!A<G238I!3CF5TE:QR=Y-E96Z.H8V1)X  8W5R;'F6!=(E8G)A8V5S*9-RX
M97-E;9"L<F)L97.389-#DW-T<G5C='5R99-D96-L87)A=&EO;I-L:7-T+I$*X
M[U=$:6=I=)-S=')I;F=SDV%N9(ZAC9$G@ !#+7-TE:QR>6QEFP4LLFED96Z3X
M=&D,97)S+)$%?35A<YAWDV5L;)AA<YAT:&689F]L;&^3=VEN9YACDVAA<F%CX
M=&5R<YAA;F28<F5S97)VDV5DF'>3;W)D<RR.H8V1)X  87)R86YG9626 ^JHX
M86-C;W)D:6YGDW1ODT.3<WEND*QR=&%X+)-A<F63;&5G86R3:6Z3871T<FEBX
M=71EDV1E8VQA<F%T:6]NDVQI<W1S.HZI&(  C9%8YFC<*I8&+,TZDSN3+)-CX
M:&%RDW-H;W)TDVEN=)-L;VYGDV9L;V%TDV1O=6)L98ZAC9%QF9QS:6=N9626X
M!BS-=6YS:6=N9623<W1R=6-TDW5N:6]NDV5N=6V.IHV1)X  UDYO=&66 ]//X
M=&AA=)-C=7)L>9-B<F%C97.3;6&0K')YDVYO=)-A<'"04XYE87*3:6YS:61EX
MDRAA;F23<V^3<W1R=6-T=7)E<Y-A;F23=6YI;VYSCJ&-D2>  &UAFJQR>98%X
M5OEN;W238I!3CF639&5C;&%R9623:6YS:61E*9-A='1R:6)U=&639&5C;&%RX
M871I;VZ3;&ES=',ND0E]TD1E<W!I=&63=&AI<RR1!;(-86Z8>8ZAC9$G@ !FX
M=6YD86UE;IJL<G1A;)8#*+IO<I-D97)I=IAE9)-TF'EPFE..99-PF&5R;6ETX
M=&5DDVENDV&30Y-P<F]G<F%MDVUAD*QR>9-BF&63=7-E9)-A<Y-A;I-A="V.X
MH8V1)X  =')I8G5T998#*')TD*QR>7":4XYEDW-PF&5C:0QE<CJ1!-?%69'_X
M!59A8V.3:6YP=723<W"896-I#&-A=&EO;G.3;V9T96Z38V]ND*QR=&%I;I-#X
MDV-OF&1EDW-E8W1I;VYSCJ&-D2>  &*:4XYE=)6L<G>3965NE@/TY=PEV&:3X
MUF%N9)/<)=AGUBR1 _=T86YDDW1H97-EDV%R99-A;'-ODW"897)M:71T9623X
M:6Z33WB3:6YP=723<W"896-I#&-A=&EO;G,NCHZ.C(L    '            X
M                                       _'J "<@  C:#]M0  C8V1X
M)X  VC21"[_X4I"L<E5,15.6 ^JH04Y$DT&1_P565%1224)55$633T-#55)2X
M14Y#15.1?=C;UC>.CJ "+0  C:#]]@  C9$G@ !!;I6L<GF; R>U=)-Y<)!3X
MCF68;F%M99AG:7:396Z8;65A;FEN9YABDWF8=7-I;F>8W'-T<G5C=-8LE@-.X
ML]QU;FEO;M8LD]QT>7!E9&5FUBR3;W*8W"-D969I;F6.I Z  (V1)X  UFENX
ME@/JJ&&3<')E=FEO=7.30Y-C;YI3CF1EDW-E8W1I;VZ3;6&0K')YDV*899-UX
M<V5DDV%SDV%NDV%T=')I8G5T99-TD*QR>7"899-S<)AE8VD,97(NCJ&-D3D?X
M]%1H998#^&)L:7-TDV]FDV=R86UM87*3<WEMFJQR8I!3CF]L<Y-F;VQL;YAWX
M:6YGD]AGD]9I<Y-ADW"04XYO<W-I8FQYDV5M<'28>9-L:7-TDV]FDUF1_P56X
M86-CCJ&-D2>  '1O:YJL<F5N<Y8#3_,H:6YC;'5D:6YGDV.8:&%R86-T97*3X
M8V]N<W1A;IAT<RF386YDDVYO;IAT97)M:6YA;',LD0-NY&UE;9ABD%..97)SX
MDV]FDW1H99-L:7-TCJ&-D2>  &*04XYE:6YGE@/JJ'-E<&%R871E9)-BD*QRX
M>9-W:&ET97-P86-E+HZAC9$Y'_1!;&R6 IQP=7-E<Y-O9I-T:&6369'_!59AX
M8V.3<F5S97)VFJQR9623=YAO<F1SD]PE=&]K96[6+)8"WTC<)6QE9G36+)/<X
M)7)I9VATUBR386YDD0*<<-PE;F]N87-S;V..H8V1)X  UFV0K')U<W26 ^JHX
M<')E8V5D99-A;&R3;V:3=&AEDV%T=')I8G5T99-D96-L87)A=&EO;G,NCI\BX
MRJN-C9$G@ #S-QKR(E8 #F9F  H    &8VUB>#$PXC,N,8Z133A 4V5M86Z0X
MBCUT:6-SE@6%'&]FDV%T=')I8G5T99-D96-L87)A=&EO;G..GQ9  (V1)X  X
MUD%NE@._@6%T=')I8G5T99-D96-L87)A=&EO;I-I;F9O<FUSDT]XDW1H8723X
M96%CFJQR:)-S>6V88I!3CF]LDVENDW1H99-G<F%M;6%RDW-Y;2V.H8V1)X  X
M8II3CF]LE@5B &QI<W23:&%SDV%T=')I8G5T97.3;V:3=&AEDVYA;65SDV%NX
M9)-TD*QR>7"897.387!PF&5A<FEN9Y-I;I-T:&63871T<FEB=71ECJ&-D2> X
M &1E8VQA<F%T:6]NE@0SV6QI<W0ND084<DEFD]=AD]9A<'":4XYE87)SDVENX
MDW1H99-A='1R:6)U=&639&5C;&%R871I;VZ3;&ES=)-A;F23UW.3UF%P<)AEX
M87)SCJ&-D2>  &ENE@,^NW1H99-G<F%M;6%RDW-Y;9"L<F*:4XYO;)-L:7-TX
M+)$#81YT:&5ND]=AD]9I<Y-S86EDDW1OD]EBD?]F9F5L;VYGD01,/=9T;Y/7X
M<Y/6;W*3=&^38IAEDV%NDV%T=')I8G5T98ZAC9$G@ !O9I8$Q$#7<]8ND0?%X
MJ45A8YJL<FB39W)A;6UA<I-S>6V88I!3CF]LDVAA<Y-I='.3;YAW;I-A='1RX
M:6)U=&63;F%M99-S<&%C92Z1!\6I5VAE;I-T:&6.H8V1)X  97:1_UCD86QUX
M871O<I8%%B%C<F5A=&5SDV&3;F^:4XYD99-L86*896QE9)-BFJQR>9-O;F63X
M;V:3=&AEDVQI<W1E9)-S>6V88II3CF]L<RR1!6$ :72386QL;YAC871E<XZAX
MC9$G@ !S=&]R86=EE@4SI&]FDW1H99-S<)I3CF5C:0QE9)-TD*QR>7"899-FX
M;W*396%CD*QR:)-O9I-T:&63;F%M9623871T<FEB=71E<RZ1"1/309$%,T]SX
M=&]R86=ECJ&-D2>  &QOFE..8V%T:6]NE@1[,G-ODV%L;&^88V%T9623:7.3X
M8V%L;&5DDV%ND]EA='1R:6)U=&61!+@0:6YS=&%N8YO_9F9ED05@XM8H8V]NX
M8VES96QYD?\%5BR1!)]586Z3V6EN<W1A;F.899$ Y;#6*8ZAC9$G@ !I;I8#X
MZJAT:&63<&%R<V63=')E92Z1!3C@26YS=&%N8V5SDVUAD*QR>9-BFE..99-SX
M86EDDW1OD]EBD?]F9F5L;VYGD03X*M9T;Y-N;YAD97,NCI\H%5:-C9$G@ #GX
M-(Z114[.4G5L97.6!I^\86YDDV%T=')I8G5T99-OD0"-3V-C=7)R96YC97..X
MGQIB(XV1)X  UEF1_P5686-CE@/M\&=R86UM87*3<G5L97.3*'!R;Y!3CF1UX
M8W1I;VYS*2R1 ^["86YDDW1H99-O8I$ IQQJ96-T<Y-O9I/<<F5T=7)ND]9SX
M=&%T96UE;I"L<G1SDVENCJ&-D2>  $QE>)8#CK%A8W1I;VYSDRAE86.:K')HX
MDW-U8YAHDV]BD0"G'&IE8W238I!3CF5I;F>389-T;VN896XI+)$#H19A<F63X
M:&5R99-R969E<G)E9)-T;Y-G96YE<FEC86QL>8ZAC9$G@ !A<Y8#W 79<G5LX
M97.1 /W=UBZ1!3/_4VEN8V633WB386-C97!T<Y-T:&638V]N<W1R=6-T<Y-OX
M9I-9D?\%5F%C8Y-A;F233&5X+)$#WO-A;F23<&%S<V5SDW1H97-ECJ&-D2> X
M '5N8Y"L<FAA;F=E9"R1!!_+=&AEE@05*F-O<G)E<W":4XYO;F1I;F>38V]NX
M<W1R=6-T<Y-O9I-/>)-I;G!U=)-S<)AE8VD,8V%T:6]N<Y-A<F6386QS;XZAX
MC9$G@ !C86QL9626!3N5V7)U;&5SD0#]W=8ND0DKJ$5A8YJL<FB3<G5L99-IX
M<Y-V:65WF&5DDV%SDV&3<V5Q=65N8V63;V:39W)A;6UA<I-S>6V88I!3CF]LX
M<RR1!8_1=&AECJ&-D2>  &]BD0"G'&IE8W26 JGI;V:396%CFJQR:)/<<F5TX
M=7)ND]9S=&%T96UE;IATDVENDV&33&5XDV%C=&EO;I-BD%..96EN9Y-ADW-EX
M<75E;F-EDV-O;G-I<W1I;F>3;V:.H8V1)X  898"QP)S:6YG;&639W)A;6UAX
M<I-S>6V:K')BD%..;VPND037J51H99-L969T;6]S=)-S>6V88I!3CF]LDV]FX
MDV&3<G5L99-I<Y-C86QL9623=&AED]EL969T+6AA;F2.H8V1)X  <VED99L$X
MY 76*-E,2%.1 7,SUBDNE@/^551H99/9<FEG:'0M:&%N9)$$14MS:61EF-8HX
MV5)(4Y$!<S/6*9$#_E!C;VUP<FES97.3=&AEDW)U;&4G<Y-O=&AE<I-S>6V0X
MK')BD%..;VQS+HZAC9$G@ !!D0799'-Y;9"L<F*54XYO;"=SFP79Y'"3;W-IX
M=&EO;IAI;IAAF')U;&68=&]G971H97*8=VET:)AA;IAA='1R:6)U=&68;V:8X
M=&AA=)AS>6V0K')BDV]LCJ&-D2>  &-O;G-T:71U=&66!")686Z3V6%T=')IX
M8G5T99$$9F)OEO]F9F.38W5R<I-E;F.399$%" ;6*&-O;F-I<V5L>9'_!58LX
MD00P06%NFP0B5MEODV.38W5R<I-E;F.399$ Y;#6*9AI;IAT:&%TF')U;&4NX
MD07?Z4EFCJ&-D2>  '1H998$5JAA='1R:6)U=&63:6Z3<75E<W1I;VZ3:7.3X
MUV'6+)$$<:AT:&63;YI3CF-C=7)R96YC99-I<Y-S86EDDW1ODV*899-A;I/9X
M;Y;_9F9CDV-U<G*396YCDV61!)9Z;V:.H8V1)X  UV'6+I$%..!3=7!PD%..X
M;W-I;F>6 ^JH=&AED]Q 871T<FEB=71E<Y/69&5C;&%R871I;VZ3;V:3<V5CX
M=&EO;I,SDV%N9)-T:&63<G5L93J.GQB  (V11F !W&YU;98>X $ZD2LYFV)IX
M=&QI<W21!BS-1$]4DV)I=&QI<W2.CHZ,BP    @                     X
M                             $H@H )R  "-H/VU  "-C9$G@ #:-9$+X
MO_A!D?\%5E144DE"551%D0/JJ$1%1DE.251)3TY3D@#4*FK6.(Z.H (M  "-X
MH/WV  "-D2>  '1H998%L<]A='1R:6)U=&63;YI3CF-C=7)R96YC99/<<V-AX
M;&63UF]FDW1H99-L969T;6]S=)-A<'"896%R86YC99-O9I/<8FET;&ES=)/6X
M:7..I Z  (V1)X  9&5N;W1E9)8%K8MI;I-/>)-C;YI3CF1EDV%SD]QB:71LX
M:7-T+C N<V-A;&76+)$&'D-W:&EL99-T:&63871T<FEB=71EDV^88V-U<G)EX
M;F-ECJ&-D2>  -QS8V%L998#0)S6;V:3=&AEDW)I9VB0K')T;6]S=)-A<'"0X
M4XYE87)A;F-EDV]FD]QB:71L:7-TD]9I<Y-D96YO=&5DD]QB:71L:7-T+C$NX
M<V-A;&76+HZAC9$Y'_1);I8$G=IG96YE<F%L+)$$RJ9A='1R:6)U=&63;Y!3X
MCF-C=7)R96YC97.387)EDVYA;65DDV*:K')YDV&39W)A;6UA<I-S>6V88I!3X
MCF]L+)$$RJ9F;VPMCJ&-D2>  &QOE:QR=Y-E9)L#;B5BDWF889APE5..97)IX
M;Y-D+)$#APQF;VQL;Y6L<G>39628;W!T:6]N86QL>9ABDWF889AN;VXM;F5GX
M871I=I-EF&1E8VEM86R8:6Z3=&5G97*886YDCJ&-D2>  &%N;W1H97*;!*IMX
M<)53CF5R:6^39"R1!-I?9F]L;&^5K')WDV5DF&*3>9AT:&68;F%M99AO9IAAX
M;IAA='1R:6)U=&68;V:8=&AA=)AS>6V38I!3CF]L+I$'>#!4:&6.H8V1)X  X
M:6Z:K')T96=E<I8#,BYA;F23=&AEDW-E8V]N9)-PE5..97)I;Y-DE@,R+F%RX
M99-N965D9623;VYL>9-W:&5NDV&39VEVF&5NDV=R86UM87*3<WEMF&*04XYOX
M;(ZAC9$G@ !A<'":4XYE87)SE@-QGFUO<F63=&AA;I-O;F-EDVENDW1H99-RX
M=6QE+)$#B=-I;I-W:&ECD*QR:)-C87-EDW1H;W-EDV1I<W1I;F-TDV%P<)AEX
M87)A;F-E<XZAC9$G@ !A<F6; [$.;I6L<G5MDV*04XYE<F5DF&9R;VV8;&5FX
M=)AT;YAR:6=HDW28=VET:)AC;VYS96-U=&EVDV68:6YC<F5A<VEN9YAI;I-TX
M96=E<G.8<W1A<G1I;F>.H8V1)X  =VET:)8#ZJC<,-8ND04XX$:1_P56;W*3X
M89-S>6V:K')BD%..;VR3W%B3UG=I=&B386Z3871T<FEB=71ED]QAUBR3W%@NX
M89/6:7.389-S>6YO;IAY;9-F;W*3W%@N,"YAUBZ.H8V1.1_T09$$Q>EG:7:0X
MK')E;I8$QB)R=6QEDV%N9)-A;I-A='1R:6)U=&63;Y!3CF-C=7)R96YC99-IX
M;I-T:&%TDW)U;&638V]N<W1I='5T99-A;I/9870MCJ&-D2>  '1R:6)U=&61X
M!#,U;Y;_9F9CDV-U<G*396YCDV61!-!8UFENE@/JJ'1H99-G<F%M;6%R+HZ?X
M*!56C8V1)X  YS6.D45.SD&1_W*P='1R:6)U=&61!I^\9&4,;FET:6]N<XZ?X
M&F(CC9$G@ #61I'_!59O<I8$XD]E86.:K')HDW)U;&4LD04@.'1H99-/>)-UX
M<V5RDVUAF'F3<')OF'9I9&6386Z3V6%T=')I8G5T99L%%M=REO]F9F5F97*3X
M96YCDV68<V638W1I;VZ1 .6PUBR1!2 X9&4MCJ&-D2>  &QI;6ET9626!&(]X
M8IJL<GF3W$#89I/686YDD]Q V&?6+)$$@")A;F23;W!T:6]N86QL>9-C;VZ8X
M=&%I;FEN9Y-D90QN:71I;VYSDV]FDV%T=')I8G5T99-OD%..8RV.H8V1)X  X
M8W5R<F5N8V5SE@3]TF]FDW1H99-G:7::K')E;I-R=6QE+I$(<E]!F'1T<FEBX
M=71EDV^04XYC8W5R<F5N8V5SDVUAF'F38I!3CF639&4,;F5DDW1H97)E:6Z.X
MH8V1)X  :6Z6! /#=&5R;7.3;V:3=&AEDW)U;&4G<Y-O=&AE<I-A='1R:6)UX
M=&63;YI3CF-C=7)R96YC97.386YDDT.38V^89&63<W5CD*QR:)-A<Y-G;&]BX
M86R.H8V1)X  =I'_6.1A<FEA8FQE<RR6 ^JH8V]N<W1A;I"L<G1S+)-M86-RX
M;W,LDV%N9)-F=6YC=&EO;I-C86QL<RZ.GR+*JXV-D2>  .(U+C&.D4TX0$ENX
M:&5R:71E9)8%A1QV<RZ1!UPE<WEND(H]=&AE<VEZ9623871T<FEB=71E<XZ?X
M%D  C9$G@ #606Z6 ^JH871T<FEB=71EDV^04XYC8W5R<F5N8V63UV^3UFENX
MDV&3<G5L99/74I$$ _+6:7.3V7-Y;G1H97-I>F61_V9F9)$%*3O6:6:386YDX
MDV]N;'F3:6:.J1B  (V-C8V1-=QH,2Z.CHZ11-_LUV^6 ^M0UFESDV]NDW1HX
M99-,2%.3;V:3UU*;! 2:UF%N9)-T:&63871T<FEB=71EDW)E9F5R96YC99-SX
M96-T:6]NDV]FD]=2F-9C;VZ0K')T86EN<XZAC9%$W^QAE@/JJ&1E#&YI=&EOX
M;I-O9I/7;]8LDV]RCJ:-C8V-D37<:#(NCHZ.D43?[-=OE@/3<=9I<Y-O;I-TX
M:&634DA3D0/3:V]FD]=2FP/LN]9A;F23=&AEDV%T=')I8G5T99-R969E<F5NX
M8V63<V5C=&EO;I-O9I/74IC68V]ND*QR=&%I;G..H8V11-_L;F^6 ^JH9&4,X
M;FET:6]NDV]FD]=OUBZ.IHV1.1_T06Z6 ^JH871T<FEB=71EDV^04XYC8W5RX
M<F5N8V63UV^3UFENDV&3<G5L99/74I$$ _+6:7.3V6EN:&5R:71ED?]F9F21X
M!2D[UFEFDV%N9)-O;FQYDVEFCJ:-C8V-D37<:#$NCHZ.D43?[-=OE@/K4-9IX
M<Y-O;I-T:&633$A3DV]FD]=2FP0$FM9A;F23=&AEDV%T=')I8G5T99-R969EX
M<F5N8V63<V5C=&EO;I-O9I/74IC68V]ND*QR=&%I;G..H8V11-_L;F^6 ^JHX
M9&4,;FET:6]NDV]FD]=OUBR3;W*.IHV-C8V1-=QH,BZ.CHZ11-_LUV^6 ]-QX
MUFESDV]NDW1H99-22%.1 ]-K;V:3UU*; ^R[UF%N9)-T:&63871T<FEB=71EX
MDW)E9F5R96YC99-S96-T:6]NDV]FD]=2F-9C;VZ0K')T86EN<XZAC9%$W^QAX
ME@/JJ&1E#&YI=&EO;I-O9I/7;]8NCHZ.C(L    )                    X
M                              !6#: "<@  C:#]M0  C8V1)X  VC61X
M"[_X09'_!5945%))0E5419$#ZJA$149)3DE424].4Y( U"IJUCF.CJ "+0  X
MC:#]]@  C9$Y'_1!;I8$1_EE<G)O<I-M97-S86=EDVESDVES<W5E9)-I9I-AX
M;I-A='1R:6)U=&63:7.39F]U;F23=&^3:&&5K')VDV66!$?Y8I!3CF]T:)-SX
M>6Z0K')T:&4MCJ0.@ "-D2>  '-I>F5DE@/$+V%N9)-I;FAE<FET9623;Y!3X
MCF-C=7)R96YC97.3:6Z3=&AEDV=R86UM87(ND04L#4%NDV%T=')I8G5T99-IX
M<Y/9<WEN=&AE<VEZ99'_9F9DCJ&-D2>  -9I9I8%M*%A;F23;VYL>9-I9I-IX
M=)-H87.38723;&5A<W23;VYEDV^:4XYC8W5R<F5N8V4LD08G(&%N9)-I='.3X
M97:0K')E<GF3;YAC8W5R<F5N8V63:7..H8V1)X  <WEND*QR=&AE<VEZ960NX
MD046SD%NE@.$<V%T=')I8G5T99-I<Y/9:6YH97)I=&61_V9F9)$$PP;6:6:3X
M86YDDV]N;'F3:6:3:723:&%SDV%TDVQE87-TDV]N99-OD%..8V-U<BV.H8V1X
M)X  <F5N8V4LD02./6%N9)8$;89I='.397::K')E<GF3;Y!3CF-C=7)R96YCX
M99-I<Y-I;FAE<FET960ND0;!>4ETDV9O;&QOF'=SDV9R;VV3=&AEDV%BD%..X
M;YAVF&63=&AA=(ZAC9$G@ !T:&66 WY^9W)A;6UA<B=SDW-T87)TDW-Y;9JLX
M<F*04XYO;)-M89AYDVAAF':899-O;FQYDW-Y;IAT:&5S:7IE9)-A='1R:6)UX
M=&5S+I$%%-)2969E<G)I;F>.H8V1)X  =&^6!'$5<F5T=7)N9623=&]KFJQRX
M96YSDV%SDW)U;&5SDV5M<&AA<VEZ97.3=&AEDV5Q=6%LDW-T871U<Y-O9I-TX
M;VN896YSDV%N9)-N;VXMCJ&-D2>  '1E<FUI;F%L<RR1!*&;:6YA<VV5K')UX
M8Y-HE@1]!&%SDV5A8YJL<FB3:VEN9)-O9I-S>6V88I!3CF]LDRAE>&-E<'23X
M=&AEDW-T87)TDW-Y;9ABD%..;VPIDVUAF'F.H8V1)X  :&&5K')VDV66 W<3X
M8I!3CF]T:)-S>6Z:K')T:&5S:7IE9)-A;F23:6YH97)I=&5DDV%T=')I8G5TX
M97,ND04265-I;F-EDV5A8YAHDW-Y;9ABD%..;VR3:&%SDV&39&ES+8ZAC9$GX
M@ !T:6YC=)8$G*EN86UEDW-P86-EDRAS96-T:6]NDS,N,2DLD03)*7-A;64MX
M;F%M9623871T<FEB=71E<Y-O9I-D:0ME<F5NFJQR=)-S>6V88I!3CF]L<XZAX
MC9$G@ !A<F66!)'/9&D+97)E;IJL<G23871T<FEB=71E<RR1!+N886YDDVUAX
MF'F39&D+97*387.3=&^3=VAE=&AE<I-T:&5YDV%R99-I;FAE<FET9623;W*.X
MH8V1)X  <WEND*QR=&AE<VEZ960NCJ&-D3D?]$:1_P56;W*6 [T+96%CD*QRX
M:)-P87)S92UT<F5EDVYOFE..9&6397AC97!TDW1H99-R;YAO=)-N;YAD92R1X
M \8J=)6L<G>3;Y8#O0MR=6QE<Y-O9I-T:&633WB3:6YP=72.H8V1)X  <W"0X
M4XYE8VD,8V%T:6]NE@4R[V%R99-O9I-P87)T:6-U;&%RDVEND*QR=&5R97-TX
M+I$)$;94:&63V6AO;661!6#S<G5L99$&&)_6:7.3=&AEDW)U;&6387!P;&EEX
M9(ZAC9$G@ !A=)8%0Z1T:&63;F^:4XYD92R6!9GC:2YE+BR3=&AEE@5#I')UX
M;&63=VAO<V633$A3D05#2VESDW1H99-L86*896R3;V:3=&AEDV=I=I"L<F5NX
MDVYOF&1E+)$%F>-A;F2.H8V1)X  =VAO<V66!(2T4DA3D02$C'-Y;9"L<F*:X
M4XYO;'.387)EDW1H99-L86*896QSDV]FDW1H99-CD*QR:&EL9')E;I-O9I-TX
M:&63;F^89&4ND0<'!%1H99/9<);_9F9A<I-E;G2.H8V1)X  <G5L99$%D,_6X
M:7.6!*L?=&AEDW)U;&6387!P;&EE9)-A=)-T:&63;F^04XYD92=SDW!A<F5NX
MD*QR="Z1!WI$5&AEDV%T=')I8G5T99-D90QN:71I;VZ3;V:388ZAC9$G@ !SX
M>6Z:K')T:&5S:7IE9)8$,MUA='1R:6)U=&63:6YS=&%N8V63;V:389-G:7:8X
M96Z3;F^:4XYD99-I<Y-A<W-OF&-I871E9)-W:71HDW1H99-N;YAD92=SCJ&-X
MD2>  &AO;666!,&-<G5L99,H:2YE+BR1!/=':72387!PD%..96%R<Y-I;I-TX
M:&63871T<FEB=71EDW)E9F5R96YC99-S96-T:6]NDV9O<I-T:&%TDW)U;&4IX
M+(ZAC9$G@ !A;F26! /'9&4,;FET:6]N<Y-O9I-I;FAE<FET9623871T<FEBX
M=71EDVEN<W1A;F-E<Y-A<F63<VEM:6QA<FQYDV%S<V^04XYC:6%T9623=VETX
M:(ZAC9$G@ !T:&66 ^JH<&%R96Z0K')TDW)U;&4NCJ&-D3D?]$ENE@1;5&&3X
M;&5G86R3:6YP=723<W"04XYE8VD,8V%T:6]N+)$$=W]E86.:K')HDV%T=')IX
M8G5T99-O9I-ADW-Y;9ABFE..;VR387!PF&5A<FEN9Y-I;I-ACJ&-D2>  ')UX
M;&66! +5:7.396ET:&5RDW-Y;I"L<G1H97-I>F5DDV]RDVEN:&5R:71E9"R;X
M! C@8G5TDVYO=)-BD%..;W1H+)AS;Y-T:&639&4,;FET:6]N<Y-O9I-A;&R.X
MH8V1)X  871T<FEB=71E<Y8#ZJA<#'23=&]G971H97(BDV-O;7!L971E;'F3X
M86YDDW=I=&AO=7238V]ND*QR=')A9&EC=&EO;BZ.GR+*JXV-D2>  .(U+C*.X
MD4TX0$&0BCUT=')I8G5T998%A1QR969E<F5N8V63<V5C=&EO;G.3:6Z3=&AEX
MDUDM#&QECI\60 "-D2>  -94:&66!'6RV7)U;&5SD02S G-ED?]F9F-T:6]NX
MD05;8M9O9I-ADUF1_P5686-CDPQL99-F;VQL;Y"L<G=SDW1H99,,<G-TD]PEX
M)9/6;6%R:Y-;C4IO:&YS;VZ1 ^JH-S6.D3FKE5TLD028=6%N9(ZAC9$G@ !CX
M;VZ:K')T86EN<Y8$;1!T:&63<')OD%..9'5C=&EO;G.3*')U;&5S*9-O9I-TX
M:&639W)A;6UA<BZ1!L 707.3;65NF'1I;VYE9)-A8I!3CF^8=IAE+)$$C:ITX
M:&6.H8V1)X  3WB6!/%,=7-E<I-M89JL<GF3875G;65NF'2396%CF&B3<G5LX
M99-BF'F386Z3871T<FEB=71EDW)E9F5R96YC99-S96-T:6]N+)$%,O5E86.8X
M:)-O9HZAC9$G@ !W:&ECFJQR:)8$-M=I<Y-D96QI;6ET96238IAYD]Q V&:3X
MUF%N9)/<0-AGUBR1!$GC86YDDW=H:6.8:)-C;VZ8=&%I;G.3>F5R;Y-O<I-MX
M;W)ED]EA='1R:6)U=&6.H8V1)X  9&4,;FET:6]N<Y$ _=W6+I$-M%I7:&5NX
ME@1UPG!R97-E;I"L<G0LD028B'1H99-A='1R:6)U=&63<F5F97)E;F-EDW-EX
M8W1I;VZ3:7.3=&AEDVQA<W23:71E;8ZAC9$G@  H;W1H97*6 [<,=&AA;I-AX
MDW1E<FUI;F%T:6YGDW-E;6EC;VQO;BF3:6Z389-R=6QE+HV-D04GK)_[I3*XX
M-(Z.D0\/7-9#;VYC97!T=6%L;'F1_P56+)$#P5YA;I-A='1R:6)U=&6.H8V1X
M)X  9&4,;FET:6]NE@/>GFAA<Y-AD]ED97"6_V9F96YD96YC>9L$*"1PDV%RX
M=)$(X8#686YDE@/>GF%ND]EE=F%L=6%T:6]NF'"1_V9F87)TD0$D1-8LD0?"X
M#&)U=)-S>6Z0K')T86-T:6-A;&QYD?\%5BR.D2>  )\*B(>)  !F9@";_V2?X
M"P  C8V-D0V#D)_\7O^S-(Z.D1(  \14:)JXXW5SE@+;&VETDV1OD$<=97.3X
M;F]TDW!R96-E9&6386Z8>9-9F_\JJF%C8Y-A8W1I;VZ3;W*3=&AEDUF886-CX
MDW)E<V5R=IJXXV5DDW>8;W)DD_,?W^H\>  *    "@    9C;71T,3#*)7!RX
M96.3Q&ENDW1H99-R=6QE+(Z?#   C6%N9)8#555A;IJXXWF39F]L;&^8=VENX
M9Y-I9&5NF'1I#&5RDVV8=7-TDV*01QUEDW1H99-,2%.3;V:3=&AEDVYE>'23X
M<G5L92Z.CHZ,BP    H                                         X
M         & 3H )R  "-H/VU  "-C9$G@ #:-9$+O_A!D?\%5E144DE"551%X
MD0/JJ$1%1DE.251)3TY3D@#.2F[6,3".CJ "+0  C:#]]@  C9$G@ !T:&66X
M!+ ]<&%R='.3;6&:K')YDV*04XYEDV-O;9AB:6YE9)-O<I-S97!A<F%T92Z1X
M!XF@5&AE<F6387)EDW1H<F5EDVUOD%..9&5SDV]FDV5X<')E<RV.I Z  (V1X
M)X  <VEO;I8#8W1O9I-A='1R:6)U=&639&4,;FET:6]N<RR1 WY_86YDDV1IX
M"V5R96Z:K')TDVUOD%..9&5SDVUAF'F38I!3CF63=7-E9)-W:71H:6Z389-SX
M:6YG;&6.H8V1)X  871T<FEB=71EE@3J]7)E9F5R96YC99-S96-T:6]N+I$(X
M.<A%86.0K')HDV%T=')I8G5T99-D90QN:71I;VZ38I!3CF5G:6YSDW=I=&B3X
M89/99&4,;FDMCJ&-D2>  '1I;VZ6!'V^;6^1_V9F9&6386YN=6YC:6%T;W*1X
M!89JUBC<0&76+)8$4 7<0&G6+)-O<IL$.[_<0&W6+"F386YDF&ESF'1E<FUIX
M;F%T96288I"L<GF886YO=&AE<IAM;Y!3CF1ECJ&-D2>  &%N;IJL<G5N8VEAX
M=&]RE@/JJ&]RDV*8>9$'U5#<0-AGUBZ.GQ]*JXV-D2>  -LU+C(N,8Z14,  X
M17AP;&EC:721!(  ;6^08 !D98Z?$\  C9$G@ #626Z6!%K7=&AI<RR1!';CX
M=&AEDVUO<W23<)I3CF^5K')WDV5R9G5LE@1:UV%N9)-M;W-TDW:0K')E<F*8X
M;W-EDV%T=')I8G5T99-D90QN:71I;VZ3;6^89&4LD0CMQF%NCJ0,  "-D2> X
M &%T=')I8G5T998#;E]D90QN:71I;VZ3=&%KFJQR97.3=&AEDV9O<FV3;V:3X
MW$!ED]8H;6YE;6]N:6.39F]RD]EE>'!L:6-I=)$$DJ/6*9-F;VQL;YAWF&5DX
MDV*8>8ZAC9$G@ !AFP22/MED97"6_V9F96YD96YC>9$$S3]E>'!RDV5S<VEOX
M;I$%=^[6*'=H:6.0K')HF&5X<')E<W-E<YAT:&689&5PD%..96YD96YC>9APX
M87)TF&]FF'1H99AD90PMCJ&-D2>  &YI=&EO;BF; [7/9F]L;&^5K')WDV5DX
MF&*3>9AA;IC9979A;'5A=&EO;I$$ J)E>'!RD?]F9F5S<VEO;I$$FW_6*'=HX
M:6.3:)AE>'!R97-S97.8=&AEF&5VD?]8Y&%L=6%T:6]NCJ&-D2>  '!A<G0IX
M+I$$Y1-);I8"[T!T:&639F]L;&^:K')W:6YGDV5X86UP;&4LD0,AB'1H99-AX
M='1R:6)U=&63<F5F97)E;F-EDW-E8W1I;VZ38V]NF'1A:6YSDW1H<F5ECJ&-X
MD2>  &%T=')I8G5T998#ZJAD90QN:71I;VYS+)-E86.0K')HDV5X<')E<W-EX
M9)-I;I-T:&6397AP;&EC:723;6^04XYD93J.GQ8  (V10;_QRFYU;98:/_$ZX
MD22_ZV)I=&QI<W21!3_]1$]4DV)I=&QI<W2.H8V1:[_90'N6!3_]0&63;G5MX
M+G9A;'5EDSJ38FET;&ES="XP+G9A;'5EDV)I=&QI<W0N,2YV86QU93N.H8V2X
M (L_QT!N=6TN=F%L=65 E@4__3V30&)I=&QI<W0N,"YV86QU94"3*Y- 8FETX
M;&ES="XQ+G9A;'5E0),[CJ&-D7M_T$!EE@4__6)I=&QI<W0N,"YS8V%L99,ZX
MDSN.H8V2 (L_QT!B:71L:7-T+C N<V-A;&5 E@4__3V3,),[CJ&-D7M_T$!EX
ME@4__6)I=&QI<W0N,2YS8V%L99,ZDV)I=&QI<W0N,2YL96YG=&B3.XZAC9( X
MBS_'0&)I=&QI<W0N,2YS8V%L94"6!3_]/9,M0&)I=&QI<W0N,2YL96YG=&A X
MDSN.H8V1:[_90'V.H8V1:[_9.XZ?&(  C9$Y'_3609$$=^5D97"04XYE;F1EX
M;F-YE@1X"65X<')E<W-I;VZ3;6%KFJQR97.397AP;&EC:723=&AEDV-O;G-TX
M<F%I;IAT<Y-O;I-T:&63;W)D97*3;V:.I Z  (V1)X  97AE8W5T:6]NE@1CX
M>F]FDV5VD?]8Y&%L=6%T:6]NDV5X<')E<W-I;VYSDV%N9)-I<Y-ADVYO;BUEX
M;7!TD*QR>9-L:7-TDV]FDV%T=')I8G5T99-OD%..8RV.H8V1)X  8W5R<F5NX
M8V5SE@0[QF]FDW1H99-R=6QE+)$$4 UF;VQL;Y6L<G>3962;!#O&8I-YF&&8X
M8V]L;VXLD010#69O;&QODW>396288I-YF&&8<)!3CF]S<VEB;'F896UP=)-YX
MF&QI<W2.H8V1)X  ;V:6!/;6871T<FEB=71EDV^:4XYC8W5R<F5N8V5SDV%NX
M9)-ADW1E<FUI;F%T:6YGDW-E;6EC;VQO;BZ1"%UK5&AEDV^88V-U<G)E;F-EX
M<Y-T;XZAC9$G@ !T:&66!)**;&5F=)-O9I-T:&638V]L;VZ387)EDW-A:623X
M=&^3V61E<);_9F9E;F21!,V%=7"3;VZ1!7@ZUBAH96YC998$DHIA<F638V%LX
M;&5DD0DE%-ED97"1_V9F96YD96YT<XZAC9$G@ #6;V:1 -8X*98#NLMT:&]SX
M99-T;Y-T:&63<FEG:)JL<G0LD0/$7F%N9)-A<F63=&AEDV^04XYC8W5R<F5NX
M8V5SD]ED90QN99'_9F9DD03Y7M9I;I-T:&639VEVF&5NDV%T=')I8G5T98ZAX
MC9$G@ !D90QN:71I;VXND04NQ%1H998#S%-OD%..8V-U<G)E;F-E<Y-T;Y-TX
M:&63<FEG:)"L<G2387)EDV-A;&QE9)/99&5PEO]F9F5N9&6397.1!,HPUF]FX
ME@/,4W1H;W-EDV]NDW1H98ZAC9$G@ !L969T+I$%@I]!;I8$ SUE=I'_6.1AX
M;'5A=&EO;I-E>'!R97-S:6]NDVESDV)A<VEC86QL>9-ADT.38V^04XYD99-FX
M<F%G;65NFJQR=)-T:&%TDVUAF'F38V]N+8ZAC9$G@ !T86ENFP1$@-EA='1RX
M:6)U=&61!(7*<I;_9F9E9F5RDV5N8Y-E<Y$ _=W6+)$(M>QE86.5K')HF&]FX
MF'=H:6.3:)AI<YAA;IAA='1R:6)U=&68;Y!3CF-C=7)R96YC99AE;F-L;W-EX
M9(ZAC9$G@ !W:71H:6Z6 _P^W$"3UG-Y;96L<F*:4XYO;',ND05MHT&3='1RX
M:6)U=&66 _P^<F5F97)E;F-E<Y-BF&5H896L<G:3998#_#YA<Y-#DW:1_UCDX
M87)I86)L97,LD00 I&%N9)-A;&R3;V:3=&AECJ&-D2>  '5S=6%LE@1X-4.3X
M;W"04XYE<F%T;W)S+)L$FYES=6.0K')HDV%SDW1H;W-EDV9O<I-A<FET:&UEX
M=&EC+)AL;V=I8V%L+)AA;F23<)I3CF]I;I"L<G1E<I-O<)AE<F$MCJ&-D2> X
M '1I;VYS+)L#:FMM89"L<GF6 TI<8I!3CF6387!P;&EE9)-T;Y-T:&5M+)AAX
M<Y-I;I-ADT.3<')O9W)A;2Z1!0-Q5&AEDV5VD?]8Y&%L=6%T:6]NDV5X<')EX
M<W-I;VZ.H8V1)X  :6UM961I871E;'F6 ^JH9F]L;&^0K')W<Y-T:&63<V5MX
M:6-O;&]NDV]FDW1H99-D97"04XYE;F1E;F-YDV5X<')E<W-I;VXNCJ&-D3D?X
M]%1H998%%I5/>"UG96YE<F%T962397:;_UCD86QU871O<I-CD*QR:&^04XYOX
M<V5SDV%NDV5VF&%L=6%T:6]NDV]R9&5RDW-U8Y"L<FB3=&AA=)-T:&6.H8V1X
M)X  97:1_UCD86QU871I;VZ6 [WC97AP<F5S<VEO;G.39F]RDV%L;)-O9I-TX
M:&639&5PD%..96YD965SDVENDW1H99-D90QN:71I;VZ387)EDV5X96-U=&5DX
MCHZ.C(L    +                                                X
M  !M,J "<@  C:#]M0  C8V1)X  VC61"[_X09'_!5945%))0E5419$#ZJA$X
M149)3DE424].4Y( SDINUC$QCHZ@ BT  (V@_?8  (V1)X  8II3CF5F;W)EX
ME@,EI'1H;W-EDV]FDW1H99-D97"896YD96Z0K')T<RZ1!/<T57-U86QL>9-TX
M:&5R99-I<Y-ADW-I;F=L99-D97"896YD96Z:K')TDVENDV&39VEVF&5NCJ0.X
M@ "-D2>  &%T=')I8G5T998%.QED90QN:71I;VXLFP6/-F)U=)-I;I-S;VUEX
MDV-A<V5S+)AC;YI3CF1EDVUAD*QR>9-BF&63;6%D99-M;W)EDV-O;7!A8W2.X
MH8V1)X  8I"L<GF6!%].<&QA8VEN9Y-M;W)EDW1H86Z3;VYEDV%T=')I8G5TX
M99-OFE..8V-U<G)E;F-EDVENDV&39&5PF&5N9&5NFJQR=)-L:7-T+)$$?'ATX
M:&5R96*8>8ZAC9$G@ !C;VV0K')B:6YI;F>6!)R[=&AEDV1E#&YI=&EO;G.3X
M;V:3=&AO<V63:6Z3=&AEDVQI<W0ND0=/&51H99-E=I'_6.1A;'5A=&EO;I-EX
M>'!R97-S:6]NDVESCJ&-D2>  &5X96-U=&5DE@+=/6]NDV*:4XYE:&%L9I-OX
M9I-T:&639&5PF&5N9&5NFJQR='.3V71A:V5NE@,[D6%SDV&3<V5TD0$D1-8LX
MD0,3'W)A=&AE<I8"W3UT:&%NDV]N8V639F]RDV5A8YAHCJ&-D2>  &1E<)!3X
MCF5N9&5NFJQR="Z1!Q0H5&AI<Y8$B15I<Y-K;F^8=VZ387.3V7-O;'9I;F>1X
M!9:7UG1H99-A='1R:6)U=&63:6YS=&%N8V5SDV-O<G)E<W"04XYO;F1I;F>.X
MH8V1)X  =&^6 ^JH=&AEDV^04XYC8W5R<F5N8V5SDVENDW1H8723<V5T+HZIX
M'TJKC8V1)X  VS4N,BXRCI%0P !);7!L:6-I=)$$@ !M;Y!@ &1ECI\3P "-X
MD2>  -94:&66!$_&V6EM<&QI8VETD020)VUOD?]F9F1ED0#EL-8LD0C2''=HX
M:6.0K')HDVESDW1H99-U<W5A;)-M;Y!3CF1EDV]FDV5X<')E<W-I;F>3871TX
M<FEB=71EDV1E#&YI+8ZD#   C9$G@ !T:6]N<RR1! _\<WENE:QR=&%C=&ECX
M86QL>9L$"(5C;VV38FEN97.8=&AEF&1E<)!3CF5N9&5N8WF8<&%R=)AW:71HX
MF'1H99AE=I'_6.1A;'5A=&EO;IAP87)T+HZAC9$G@ !4:&66 ^JH9F]L;&^:X
MK')W:6YGDT]XDV-OD%..9&63:7.397%U:7:1_UCD86QE;IATDW1ODW1H8723X
M;V:3=&AEDW!R96-E9&EN9Y-E>&%M<&QE+HZ?%@  C9%!O_'*;G5MEAH_\3J1X
M)+_K8FET;&ES=)$%/_U$3U238FET;&ES=(ZAC9%KO]E >Y8%/_U :9- ;G5MX
M+G9A;'5E0),]DT!B:71L:7-T+C N=F%L=65 DRN30&)I=&QI<W0N,2YV86QUX
M94 [CJ&-D7M_T$!IE@4__4!B:71L:7-T+C N<V-A;&5 DSV3,#N.H8V1>W_0X
M0&F6!3_]0&)I=&QI<W0N,2YS8V%L94"3/9$*?_HM0&)I=&QI<W0N,2YL96YGX
M=&A .XZAC9%KO]E ?8ZAC9%KO]D[CI\8@ "-D2>  -9);I8$WPQT:&ESDVUOX
MD%..9&4LD04<)6%NDV%T=')I8G5T99-D90QN:71I;VZ3=&%KFJQR97.3=&AEX
MDV9O<FV3;V:3W$!ID0F^&-9F;VQL;YAWF&5DDV*8>9-A;HZD#H  C9$G@ !EX
M=I'_6.1A;'5A=&EO;I8#+%]E>'!R97-S:6]N+I$$^7)4:&63;6^04XYD99-AX
M;FZ0K')U;F-I871O<I/<0&F1!EB^UFEN9F]R;7.33WB3=&AA=)-T:&639&4,X
M;FDMCJ&-D2>  '1I;VZ6 Z"(:&%SDV&3<VEN9VQEDV1E<)I3CF5N9&5ND*QRX
M="R1 Z];;F%M96QYDW1H99,,<G-TDV%T=')I8G5T99-OF&-C=7)R96YC99-RX
M969E<F5N8V5DCJ&-D2>  &ENE@2$3W1H99-E=I'_6.1A;'5A=&EO;I-E>'!RX
M97-S:6]N+I$'!=14:&639&5PD%..96YD965SDVENDW1H99-D90QN:71I;VZ3X
M8V]N<VES=)-O9I-A;&R.H8V1)X  V6]T:&5RD04U4]9A='1R:6)U=&66 ^JHX
M;Y!3CF-C=7)R96YC97.3<F5F97)E;F-E9)-I;I-T:&6397:1_UCD86QU871IX
M;VZ397AP<F5S<VEO;BZ.IHV-D2>  -LU+C(N,XZ14,  36EX9621!(  ;6^0X
M8 !D98Z?%D  C9$G@ #936EX99;_9F9DD02/%FUODV1ED0F"[-9A='1R:6)UX
M=&66!$Z>9&4,;FET:6]N<Y-A<F6386YN;W5N8V5DDV*:K')YDW1H99-R97-EX
M<G:89623=YAO<F21")T\W$!MUBZ.H8V1)X  5&AE<F66!2X%9F]L;&^:K')WX
MDV]N99-O<I-M;W)EDV1E<)!3CF5N9&5NF'1S+)L%?MUADW-E;6EC;VQO;BR8X
M86YDDV%NDV5VD?]8Y&%L=6%T:6]NDV5X+8ZAC9$G@ !P<F5S<VEO;BZ1"5(EX
M5&AEE@5(:F^04XYC8W5R<F5N8V5SDW)E9F5R96YC9623:6Z3=&AEDV5VD?]8X
MY&%L=6%T:6]NDV5X<')E<W-I;VXLD06?VF5X8V5P=(ZAC9$G@ !T:&]S998$X
MRE!T:&%TDV%L<V^387!PFE..96%RDV*89725K')WDV5E;I8$RE#<0&V3UF%NX
M9)-T:&63<V5M:6-O;&]N+)$% CIA<F63=&%KD*QR96Z3=&^38IAEDW1H98ZAX
MC9$G@ !D97":4XYE;F1E97.6!.=S:6Z3=&AEDV1E#&YI=&EO;BZ1""]#5&B0X
MK')U<Y-T:&639&5PF&5N9&5NFJQR='.387)EDV=I=IAE;I-E>'!L:6-I=&QYX
MDV%N9(ZAC9$G@ !T:&66!+/>9&5PFE..96YD965SDVEM<&QI8VET;'F1_P56X
M+I$'E(-4:&638V^89&63:6Z3=&AEDV9O;&QOD*QR=VEN9Y-E>&%M<&QEDVAAX
M<Y-T:&63<V%M98ZAC9$G@ !M96%N:6YGE@/JJ&%SDW1H8723:6Z3=&AEDW!RX
M979I;W5SDW25K')WDV\NCHZ.C(L    ,                            X
M                      !Y(: "<@  C:#]M0  C8V1)X  VC61"[_X09'_X
M!5945%))0E5419$#ZJA$149)3DE424].4Y( SDINUC$RCHZ@ BT  (V@_?8 X
M (V10;_QRFYU;98:/_$ZD22_ZV)I=&QI<W21!3_]1$]4DV)I=&QI<W2.I P X
M (V1:[_90'N6!3_]0&V3;G5M+G9A;'5EDSN.H8V2 (L_QT!N=6TN=F%L=65 X
ME@4__3V30&)I=&QI<W0N,"YV86QU94"3*Y- 8FET;&ES="XQ+G9A;'5E0#N.X
MH8V1>W_00&F6!3_]0&)I=&QI<W0N,2YS8V%L94"3/9,MDT!B:71L:7-T+C$NX
M;&5N9W1H0#N.H8V1>W_00&V6!3_]8FET;&ES="XP+G-C86QEDSN30&)I=&QIX
M<W0N,"YS8V%L94"3/9,P.XZAC9%KO]E ?8ZAC9%KO]D[CI\BRJN-C9$G@ #BX
M-2XSCI%-.$!!D(H]='1R:6)U=&66!84<<F5F97)E;F-EDW-E8W1I;VYSDVENX
MDW1H99-,+0QL92AS*8Z?%D  C9$G@ #61&4,;FET:6]N<Y8#5@AO9I-I;FAEX
M<FET9623871T<FEB=71E<Y-O9I-T;VN0K')E;G.387)EDV%S<V^:4XYC:6%TX
M9623=VET:)-R=6QE<Y-A<'"896%R+8ZD#H  C9$G@ !I;F>6 OY5:6Z3=&AEX
MDUDM#&QE+)$#+9EW:&EL99-T:&5I<I-S>6Z0K')T:&5S:7IE9)-A='1R:6)UX
M=&5SDV%R99-D90QN9623:6Z3=&AEDTPM#&QE*',I+HZAC9$G@ !/>)8$II1PX
M<F^:4XYC97-S97.3=&AEDUDM#&QEDV*8969O<F63<')OF&-E<W-I;F>3=&AEX
MDTPM#&QE*',I+I$';*-)9I-ADV=I=I"L<F5NDV%T=')I8G5T98ZAC9$G@ !OX
MD%..8V-U<G)E;F-EE@/#:F]FDV&3=&]KFJQR96Z3:7.3;F]TDV1E#&YE9)-IX
M;I-T:&6362T,;&4LD0/+0W1H96Z3=&AEDV%T=')I8G5T99-I<Y-T86N896Z.X
MH8V1)X  =&^6 ^JH8I!3CF63<WEND*QR=&AE<VEZ960NCJ&-D3D?]$QE>&ECX
M86R6!$:L<G5L97.387)EDV%S<V^04XYC:6%T9623=VET:)/<<F5T=7)ND]9SX
M=&%T96UE;I"L<G1SDVENDTQE>)-A8W1I;VYS+I$&3.U!9BV.H8V1)X  =&5RX
ME@3$471H99-T97)M:6YA=&EN9Y-S96UI8V]L;VZ3;V:396%CFJQR:)-S=6.8X
M:)-S=&%T96UE;IAT+)$$^KMT:&5R99-M89AYDV%P<)!3CF5A<I-ACJ&-D2> X
M '"04XYO<W-I8FQYE@/4MF5M<'20K')YD]EA='1R:6)U=&6;!!\)<I;_9F9EX
M9F5RDV5N8Y-EF'-EDV-T:6]ND0#EL-8LFP/9&F1E;&EM:71E9)8#U+9BD*QRX
M>9/<0-AFD]9A;F23W$#89]8LF&ENDW=H:6.0K')HCJ&-D2>  &%R998#ZJADX
M90QN962386QLDV]FDW1H99-S>6Z:K')T:&5S:7IE9)-A='1R:6)U=&5SDV]FX
MDW1H99/<<F5T=7)NUF5DDW1O:YAE;BZ.H8V1.1_T3F]T998$VYMT:&%TDV5AX
M8YJL<FB3<)!3CF]I;IATDV]FD]QR971U<FZ3UF]FD]QY>6QE>)/6;9AU<W23X
M8I!3CF63V65X<&QI8VETD07_W]9I;I-T:&63<V5N<V6.H8V1)X  =&AA=)8#X
ML,1T:&63=&5X=)-MFJQR=7-TDV*04XYE87*3=&AEDT.3<F5S97)VF&5DDW>8X
M;W)DD]QR971U<F[6+I$%)91);I-P87)T:6-U;&%R+)$#O%C<<F5T=7)NUG..X
MH8V1)X  ;9"L<G5S=)8#J"%N;W238I!3CF639&]N99-W:71H:6Z30Y-M86-RX
M;W,LD0.U;W5N;&5S<Y-T:&633"T,;&63:7.3<&%S<V5DDW1H<F]U9VB3=&AEX
MDT..H8V1)X  <')E<')OFE..8V5S<V]RE@-3!W!R:6]RDW1ODW!R;YAC97-SX
M:6YGDV*:K')YDT]X+I$%!E5'=6%R86Z8=&5E:6YGDW1H:7.3<')O<)!3CF5RX
M=)AYDV]FD]QY>6QE>(ZAC9$G@ #6:7.6 ^JH=&AEDW)E<W"04XYO;G-I8FELX
M:72:K')YDV]FDW1H99-/>)-U<V5R?&ETDVESDVYO=)-CF&AE8YAKF&5DDV*8X
M>9-/>"Z.GQ]*JXV-D2>  -LU+C,N,8Z14,  1V5N97)A;&ETD*  >98$@ !OX
M9I-/>(Z?$\  C9$G@ #65&AEE@-PV6-L87-SDV]FDV%T=')I8G5T99-G<F%MX
M;6%R<Y-A8V-E<'1E9)-BFJQR>9-/>)-I<Y-R97-T<FEC=&5DDV]N;'F387.3X
M9F]L;&^8=W,ZCJ0,  "-D2>  '-Y;IJL<G1H97-I>F5DE@,I56%T=')I8G5TX
M97.3;V:3=&]KF&5N<Y-D;Y-N;W23:&&8=IAEDV1E<)!3CF5N9&5E<RZ1!/AOX
M09AT=')I8G5T99-D90QN:71I;VYSCJ&-D2>  &ENE@5AG'1H99-,+0QL92ASX
M*9-C86Z3=&B:K')U<Y-BD%..99-W<FET=&5NDVUO<F63<VEM<&QYDW1H86Z3X
M:6Z3=&AEDUDM#&QE.I$()LAE86.8:(ZAC9$G@ !A='1R:6)U=&66!&;L;YI3X
MCF-C=7)R96YC99-I<Y-D90QN96238I"L<GF3<F5F97)R:6YGDW1ODVETDVENX
MDT.38V^89&4LD02%_65X86-T;'F3;VYC99-I;HZAC9$G@ !T:&66!'AJ871TX
M<FEB=71EDW)E9F5R96YC99-S96-T:6]NDV%S<V^04XYC:6%T9623=VET:)-TX
M:&63W')E='5R;I/6<W1A=&5M96Z0K')T+)$$F]IA<Y-I;HZAC9$G@ !T:&66X
M ^JH9F]L;&^:K')W:6YGDV5X86UP;&63*'=H97)E:6Z3W$-/3E-4UB=SDV]NX
M;'F3<WENF'1H97-I>F5DDV%T=')I8G5T99-I<Y/<=F%LUBDZCI\6  "-D4&_X
M\<I;,"TY72N1#[_W<F5T=7)N*$-/3E-4*3N6!3_]0'N3<W-C86YF*'EY=&5XX
M="PB)60B+"9 0T].4U0N=F%L0"D[DT!]CI\8@ "-D2>  -94:)"L<G5SE@/XX
MHVUOFE..9&639&5C;&%R871I;VYSDV%N9)-D97"896YD96YC>9-E>'!R97-SX
M:6]N<Y-A<F63=6YN96-E<W-A<GF3:6Z3=&AECI\.@ "-D2>  $PM#&QE*',IX
M+HZ.CHR+    #0                                              X
M    @MN@ G(  (V@_;4  (V-D2>  -HUD0N_^$&1_P565%1224)55$61 ^JHX
M1$5&24Y)5$E/3E.2 ,Y*;M8Q,XZ.H (M  "-H/WV  "-C9$G@ #;-2XS+C*.X
MD5#  $]XE@2  &%D87!T871I;VZ3=&^33&5X)W.3;&EN92UO<FEE;IJ@ '1EX
M9)-S>6Z8=&%XCI\60 "-D2>  -97:&5NE@-$Z4]XDVESDW!R;Y!3CF-E<W-IX
M;F>3=&AEDTPM#&QEDV%N9)-H87.3<F5C;V=N:7IE9)-ADW)U;&63*&DN92XLX
MD0-F#W1H99-O8I$ IQQJ96-TDV]FCJ0.@ "-D2>  &&6!&CYW')E='5R;I/6X
M<W1A=&5M96Z:K')T*2R1!(B-:6:3=&AED]QR971U<F[69623=&]KF&5NDVAAX
M<Y-S>6Z8=&AE<VEZ9623871T<FEB=71E<RR1!(B-3WB.H8V1)X  ;&^04XYOX
M:W.6 T[,9F]RDV%NDV%T=')I8G5T99-R969E<F5N8V63<V5C=&EO;I-F;VQLX
M;YJL<G=I;F>3=&AED]QR971U<FZ3UG-T871E;65NF'0ND04$[$]X)W..H8V1X
M)X  <G5L97.6 L#^9F]RDW)E8V]G;FEZ:6YGDV%T=')I8G5T99-R969E<F5NX
M8V63<V5C=&EO;G.3:6Z3=&AEDTPM#&QEDV%R99-A9&%P=&5DDV9R;VV.H8V1X
M)X  =&AEFP-#H7>5K')ADWF83&5XF&%C=&EO;G.887)EF'1E<FUI;F%T960ZX
MD03E74]XF&=I=I-E<YAU<)AL;Y!3CF]K:6YGF&9O<IAA;IAA='1R:6)U=&68X
M<F5F+8ZAC9$G@ !E<F5N8V66 PNK<V5C=&EO;I-W:&5NDVETDW!A:7)SDW1HX
M99-R:6=HFJQR=&UO<W23<FEG:)ATDV-U<FQYDV)R86-EDVENDW1H99-A8W1IX
M;VZ3=VET:(ZAC9$G@ !T:&66 V[(;&5F=&UO<W23;&5F=)-C=7)L>9-B<F%CX
M92R1 X>/;W*3=VAE;I-I=)-E;F-O=6Z:K')T97)SDV&3;F5W;&EN99-U;G!RX
M;W1E8W1E9)-BF'F.H8V1)X  8W5R;'F6 ^JH8G)A8V5S+I$%..!.97=L:6YEX
M<Y-A<F63:6YS:6=N:0QC86Z0K')TDVEN<VED99-A='1R:6)U=&63<F5F97)EX
M;F-EDW-E8W1I;VYS+HZAC9$Y'_1%>&%M<&QE<Y8%$3!O9I-C;W)R96-TDV%NX
M9)-I;F-O<G)E8W23<WENFJQR=&%XDV%R99-S:&^8=VZ38I!3CF5L;YAW+I$(X
MK'A!;&R3;V:3=&AECJ&-D2>  &-O<G)E8W26 ^JH9F]R;7.3<VAOFJQR=VZ3X
M87)EDW-E;6%NF'1I8V%L;'F397%U:7:1_UCD86QE;IATDW1ODV]N99-A;F]TX
M:&5R+HZ?&X  C8V-C9$X_^_8#XZ.CI%$W^S6:6YC;W)R96-TE@/W/2AA='1RX
M:6)U=&63<F5F97)E;F-EDW-E8W1I;VZ387!PD%..96%R<Y-T;Y-T:&63<FEGX
M:)JL<G23;V:3=&AEDW)I9VB8="V.H8V11-_L;6]S=)8#ZJAC=7)L>9-B<F%CX
M92DZCJ0=@ "-D43?[-Q;82UZ02U:72N6!BS->Y-C;W5N="@I.Y-R971U<FZ3X
M240[DWV30'N30$E$+FYA;65 DSV3:60H*3N30'V.H8V-C8V1./_OV ^.CHZ1X
M1-_LUFEN8V]R<F5C=)8%694H871T<FEB=71EDW)E9F5R96YC99-S96-T:6]NX
MDVYO=)-P87)TDV]FDW)U;&4LD06U4'-I;F-EDW1H99-,97B.J0Z  (V11-_LX
M86-T:6]NE@/JJ&ESDW1E<FUI;F%T96238I"L<GF386Z3=6YP<F]T96-T9623X
M;F5W;&EN92DZCJ&-D43?[-Q;82UZ02U:72N6!BS-8V]U;G0H*3N3<F5T=7)NX
MDTE$.XZFC9( @I_N0'N6!BS-0$E$+FYA;65 DSV3:60H*3N30'V.H8V-C8V1X
M./_OV ^.CHZ11-_LUF-O<G)E8W0ZCJ&-D43?[-Q;82UZ02U:72N6!BS->Y-CX
M;W5N="@I.Y-R971U<FZ3240[D0Q9FD![DT!)1"YN86UE0),]DVED*"D[DT!]X
MDWV.H8V-C8V1./_OV ^.CHZ11-_LUF-O<G)E8W0ZCJ&-D43?[-Q;82UZ02U:X
M72N6!BS-<F5T=7)NDTE$.Y- >Y-C;W5N="@I.Y- 240N;F%M94"3/9-I9"@IX
M.Y- ?8ZAC8V-C9$X_^_8#XZ.CI%$W^S68V]R<F5C=#J.H8V11-_LW%MA+7I!X
M+5I=*Y8&+,U[DV-O=6YT*"D[DW)E='5R;I-)1#N.IHV2 ([YB$![E@8LS4!)X
M1"YN86UE0),]DVED*"D[DT!]CJ:-D@""G^Y]CHZ.C(L    .            X
M                                      ",TJ "<@  C:#]M0  C8V1X
M)X  VC61"[_X09'_!5945%))0E5419$#ZJA$149)3DE424].4Y( SDINUC$TX
MCHZ@ BT  (V@_?8  (V-C8V1./_OV ^.CHZ11-_LUF-O<G)E8W0ZCI\=@ "-X
MD43?[-Q;82UZ02U:72N6!BS-8V]U;G0H*3N3<F5T=7)NDTE$.Y$,69I >XZDX
M#H  C9(!$*990$E$+FYA;65 E@8LS3V3:60H*3N.H8V2 01,OT!]CI\?2JN-X
MC9$G@ #;-2XS+C..D5#  %)E<V]L=71I;VZ6!(  ;V:386V5H !B:6=U:723X
M>98$@ !R96=A<F1I;F>3=&]KD*  96Z3<F5T=7)N962.GQ9  (V1)X  UD&6X
M ^JH<VQI9VB:K')TDV1I#F-U;'28>9-A<FES97.3:6Z3<G5L97.3;&EKF&6.X
MI!B  (V11F !W')E='5R;BAY>71E>'1;,%TI.XZAC9$G@ #686YDCJ&-D49@X
M =QR971U<FXH8V]N9)8&+,T_DU1/2T5.,9,ZDU1/2T5.,BD[CJ&-D2>  -9FX
M;W*6 R%7=VAI8YJL<FB33WB38V%N;F]TDV1E=&5R;6EN99-A=)-E=I'_6.1AX
M;'5A=&]R+6=E;F5R871I;VZ3=&EM99-W:&ECF&B3=&]KF&5NDW=I;&R.GPZ X
M (V1)X  8I!3CF61 ^JHW')E='5R;M9E9"Z.I P  (V1.1_T26Z6!"C;=&AEX
MDPQR<W238V%S92R1!#AG=VAE<F5I;I-N;Y-D96-L87)E9)-T;VN:K')E;I-OX
M<I-CF&AA<F%C=&5RDV-O;G-T86Z8=)-I<Y-R96,MCJ&-D2>  &]G;FEZ9626X
M!.94:6Z3=&AED]QR971U<F[6962397AP<F5S<VEO;BR1!24_3WB387-S=6UEX
M<Y-T:&%TDW1H99-T;VN0K')E;I/<<F5T=7)NUF5DCJ&-D2>  &AA<Y8#ZJANX
M;Y-A='1R:6)U=&5S+)-A;F23:7-S=65SDV&3=YJL<F%R;FEN9Y-L:6N893J.X
MJ18  (V10;_QRF]X.I8%/_US8V%N+FPZDW=A<FYI;F<ZDVQI;F63.#J386UBX
M:6=U;W5SDV9O<FV3;V:3<F5T=7)NDV]FDW1O:V5N+HZAC9%,/^MU;FMN;W=NX
ME@4__6YO9&63='EP92TM87-S=6UI;F>3;F^3871T<FEB=71E<RZ.IHV1.1_TX
MUDENE@2^>'1H99-S96-O;F238V%S92R1!/-L=VAE<F5I;I-M;W)EDW1H86Z3X
M;VYEDV1E8VQA<F5DDW1O:YJL<F5NDV]RDV.8:&%R86-T97*.H8V1)X  8V]NX
M<W1A;I"L<G26!*X):7.3<F5C;V=N:7IE9"R1!-[A=&AEDVYOFE..9&6387!PX
MF&5N9&5DDW1ODW1H99-T<F5EDV1U<FEN9Y-E=I'_6.1A;'5A=&EO;I-I<XZAX
MC9$G@ !O9I8#B71T:&63=)JL<GEPD%..99-O9I-T:&639&5C;&%R9623=&]KX
MF&5NDV]RDV.8:&%R86-T97*38V]N<W1A;IATDV%P<)!3CF5A<FEN9Y/9;&5FX
M=&UO<W21!*VXUFENCJ&-D2>  '1H998#ZJAE>'!R97-S:6]N+I$%..!/>)-IX
M<W-U97.389-WFJQR87)N:6YGDVQI:YAE.HZFC9%!O_'*;W@ZE@4__7-C86XNX
M;#J3=V%R;FEN9SJ3;&EN99,X.I-A;6)I9W5O=7.39F]R;9-O9I-R971U<FZ3X
M;V:3=&]K96XNCJ&-D4P_ZVUU;'1I<&QEE@4__71O:V5N<Y-I;I-O8FIE8W23X
M;V:3<F5T=7)NDW-T871E;65N="Z.GQB  (V1)X  UE1H99L%L,%A8I!3CF^5X
MK')VDV68=Y-A<FYI;F=SF'-H;W5L9)ABD%..99AT86N396Z8<V5R:6]U<VQYX
MD?\%5BR1!B)'8I!3CF5C875S99AT:&688V]N9&ET:6]N<YAO9HZD#H  C9$GX
M@ !W:&ECFJQR:)8$&HYT:&5YDW>887)NDV-A;I-R97-U;'23:6Z3=&AEDV=EX
M;F5R871E9)-E=I'_6.1A;'5A=&]RDV%T=&5M<'1I;F>3=&^386-C97-SCJ&-X
MD2>  &%T=')I8G5T998$<09I;G-T86YC97.3=&AA=)-A<F63;F]N97AI<W1EX
M;IJL<G23;W*3;V:3=&AEDW=R;VYGDW28>7"04XYE+I$&R_M4:&5S99-K:6YDX
M<XZAC9$G@ !O9I8$,D!WFJQR87)N:6YG<Y-A<F63;6]S=)-O9G1E;I-S965NX
MDW=H96Z3#')S=)-C;VZ8=IAE<G1I;F>386Z397AI<W1I;F>369'_!59A8V,OX
M3&5XCJ&-D2>  '1R86YS;&%T;W*6 ^JH=&^33W@NCJ&-D3D?]$&1 ME88V]NX
M9&ET:6]NE@+9GF-A=7-I;F>3;VYEDV]FDW1H99-A8II3CF^5K')VDV4M9&5SX
M8W)I8IAE9)L"V9YWDV%R;FEN9W.8;6&3>9ABD%..99AT;VQE<F%T962.H8V1X
M)X  :6:6 Z;(=&AEDT]XDW5S97*3=IJL<F5R:0QE<Y-T:&%TDV9O<I-T:&63X
M<G5L99,H:2YE+BR1 [1;;V*1 *<<:F5C=)-O9I-T:&63W')E='5R;I/6<W1AX
M=&5M96Z8="F.H8V1)X  :6Z1 ^JH<75E<W1I;VXZCHZ.C(L    /        X
M                                          "4(: "<@  C:#]M0  X
MC8V1)X  VC:1"[_X5%)!3E-,09'_!59424].E@/JJ$E.5$^30Y$$]/I#3T1%X
MD@"Z]NO6,36.CJ "+0  C:#]]@  C8V-C9$X_^_8#XZ.CI%$W^S686QLE@-ZX
M96]FDW1H99-T;VN:K')E;G.3=&AA=)-C86Z38I!3CF63W')E='5R;M9E9)-FX
M;W*3=&AEDW)U;&6387)EDV-O;IAT86EN9623:6Z3=&AECJ0.@ "-D43?[&=RX
M86UM87(M<WEMD*QR8I!3CF]LE@/JJ&QI<W23*'-E8W1I;VZ3,RF3;V:389-SX
M:6YG;&63871T<FEB=71EDV1E8VQA<F%T:6]N+HZ?& 4$C8V-C9$X_^_8#XZ.X
MCI%$W^S6;F^6!6/Z=&]KD*QR96Z3=&AA=)-C86Z38II3CF63W')E='5R;M9EX
M9)-F;W*3=&AEDW)U;&6387!PF&5A<G.3:6Z389-G<F%M;6%R+8ZAC9%$W^QSX
M>6V0K')BD%..;VR6 ^JH;&ES=)-O9I-A;I-A='1R:6)U=&639&5C;&%R871IX
M;VXNCI\BBR"-C9$G@ #B-2XTCI%-.$!#>6-L97..GQ9  (V1)X  UDETE@1NX
M8VESDV5A<WF3=&^3=W)I=&6386Z3871T<FEB=71EDV=R86UM87*3<W5CD*QRX
M:)-T:&%TDW-O;663871T<FEB=71EDVEN<W1A;F-ECJ&-D2>  &]FE@6D0'-OX
M;663<&%R<V63=')E99-H87.389-CFJQR:&%I;I-O9I-D97"04XYE;F1E;F-IX
M97.3=&AA=)-L96%D<Y-B86.8:Y-T;Y-I='-E;&8NCJ&-D2>  %-U8YJL<FB6X
M V7<89-G<F%M;6%RDVESDV-A;&QE9)/98VERD?]F9F-U;&%RD0%*J]8LD0. X
M;&%N9)-S=6.8:)-ADV.8:&%I;I-O9I-D97"04XYE;F1E;F-I97.3:7.38V%LX
M;&5DCJ&-D2>  &&6!.KLV6-Y8VQED0#EL-8ND0@YK4:1_P56;W*3<W5CD*QRX
M:)-ADW1R964LD04J_71H97)EDVESDV%NDV%T=')I8G5T99-I;G-T86YC99-TX
M:&%TDW1H99-E=I'_6.1A;'5A=&]RCJ&-D2>  &-A;FYO=)8$GFUBD%..96=IX
M;I-T;Y-S;VQVFJQR99-U;IAT:6R3=&AA=)-I;G-T86YC99-H87.386QR96%DX
M>9-BD%..965NDW-O;':8960ND0=4+D&1!)X^8WEC;&6.H8V1)X  86QS;Y8%X
M;21M86N:K')E<Y-I=)-I;7"04XYO<W-I8FQEDW1ODW-O;':899-A;IAYDV%TX
M=')I8G5T99-I;G-T86YC99-T:&%TDVAA<Y-ADV.8:&%I;HZAC9$G@ !O9I8$X
MAN%D97"04XYE;F1E;F-I97.3;&5A9&EN9Y-T;Y-A;I-I;G-T86YC99-I;I6LX
M<G:3;VQVDV5DE@2&X6ENDW1H99-C>6-L92Z1!PV*0VER8W5L87)I=)"L<GF3X
M:7..H8V1)X  =7-U86QL>98%'T5N;W23:6Z:K')T96YD96238IAYDW1H99-EX
M=I'_6.1A;'5A=&]RDV1E<VEG;F5R+I$(UK=!D04>]6=E;F5R86R38VER8W5LX
M87)I=)AYDW1E<W2.H8V1)X  <)I3CF5R9F]R;65DE@3\$F%TDV5VD?]8Y&%LX
M=6%T;W(M9V5N97)A=&EO;I-T:6UEDW>0K')O=6QDDW)E<75I<F6397APF&]NX
M96Z0K')T:6%LDW)U;FYI;F>.H8V1)X  =&EM998$K@-F;W*3<V]M99-I;G!UX
M='.36XU*87IAE:QR>9-E<FF1 ^JH-S6.D3E'45TND0>"\E"0K')O;'EN;VUIX
M86PM=&EM99-T97-T<Y-F;W*3<W"04XYE8VEA;)-K:6YD<XZAC9$G@ !O9I8$X
MN5YN;VXM8VER8W5L87)I=)JL<GF387)EDVMN;YAW;BR1!.T,8G5TDW1H99-PX
M<F5S96Z8=)-VF&5R<VEO;I-O9I-/>)-D96%L<Y-W:71HDW1H98ZAC9$G@ !PX
M<F]B;&5ME@/JJ&*:K')YDV.8:&5CF&MI;F>39F]RDV-Y8VQE<Y-A=)-E=I'_X
M6.1A;'5A=&EO;I-T:6UE+HZI)]7+C8V1)X  YS:.D45.SE21_E@0<F%N<VQAX
M=&EO;I8&G[QI;I'_<K!T;Y-#DV-OD0"-3V1ECI\:8B.-D2>  -9/>)8$5C1TX
M<F%N<VQA=&5SDV%T=')I8G5T99-D96-L87)A=&EO;G.3:6Z0K')T;Y-#DW-TX
M<G5C='5R99-D96-L87)A=&EO;G,LD01Q%W=I=&B3=&AECJ&-D2>  &%T=')IX
M8G5T998#ZJAN86UE<Y-A<'":4XYE87)I;F>387.3<W1R=6-T=7)EDVUE;9"LX
M<F*897)S+HZAC9$Y'_14:&66!6#:97:1_UCD86QU871I;VZ397AP<F5S<VEOX
M;I-O9I-E86.:K')HDV%T=')I8G5T99-D90QN:71I;VZ3:7.38V]P:65DDW:8X
M97)B82V.H8V1)X  =&EME@5;^FENFJQR=&^33W@G<Y-O=71P=70LD06X3F5XX
M8V5P=)-T:&%TDV%T=')I8G5T99-R969E<F5N8V5SDV%R99-T<F%N<VQA=&5DX
MDVENF'1OCJ&-D2>  '!A<F5ND*QR=&AE<VEZ9626 ^JH<F5F97)E;F-E<Y-TX
M;Y-#DW:1_UCD87)I86)L97,NCJ:-C9$G@ #G-XZ114[.5)'^6!!E;7"6 (U/X
M;W)A;)L'3OUBDV5H89'_<K!V:6]RF&]FF$]X+6=E;F5R871E9)AE=I'^Y6!AX
M;"V.GQ8  (V114[.=6%T;W)SCI\=XB.-C9$G@ #B-RXQCI%-.$!3=&%CD(H]X
M:Y$%A1QO<)!UPF5R871I;VYSCI\60 "-D2>  -9);F%S;96L<G5CDVB6!$P#X
M87.386Z3;W)D:6YA<GF369'_!59A8V,O3&5XDW)E8V]G;FEZ97*396UP;&^0X
MK')Y<Y-A;I-,4I$$2^IP87)S:6YGDV%L9V\MCJ&-D2>  ')I=&AME@+(QUN-X
M06AOD0/JJ#@VCI$DX)U=+)$# L%E86.:K')HDVEN<'5TDV5NF'1A:6QSDV&3X
M<V5Q=65N8V63;V:3;&^04XYO:Y'_6.1A:&5A9',LE@,"P7-H:69T<RR386YDX
MD0+(QW)E9'5C+8Z.CHR+    $                                   X
M                G#J@ G(  (V@_;4  (V-D2>  -HWD0N_^%1%35!/4D%,X
ME@/JJ$)%2$&;_K'(5DE/4I-/1I-/D*QR6)$!-!DM1T5.15)!D?\%5E1%1)-%X
M5IA!3%5!D?\%5E1/4E.1#[ZBUC$VCHZ@ BT  (V@_?8  (V1)X  =&EO;G,LX
MD02]7F%N9)8$DSIADW-T86.:K')KDV]FDW!A<G-E<I-S=&%T97.3:7.3;6%IX
M;IAT86EN960ND0<RE4:;_P56<F]MDV]R9&EN87)YDUF886-C+TQE>(ZD#H  X
MC9$G@ !S;W5R8V4LD06ORT]XE@55*F=E;F5R871E<Y-A;I-E=I'_6.1A;'5AX
M=&]RDW=H;W-ED]QY>7!A<G-ED]9G;Y!3CF5SDW1H<F]U9VB3=&AEDW-A;66.X
MH8V1)X  <V5Q=65N8V66!0W+;V:3;&^:4XYO:Y'_6.1A:&5A9',LE@56E'-HX
M:69T<RR386YDE@4-RW)E9'5C=&EO;G.387.39&^897.3=&AED]QY>7!A<G-EX
MD]9O9I-T:&6.H8V1)X  ;W)D:6YA<GF6 ^JH69'_!59A8V,O3&5XDW)E8V]GX
M;FEZ97(NCJ&-D3D?]%1H998$5(I/>"UG96YE<F%T962397:1_UCD86QU871OX
M<BR;!&\#:6Z38G5I;&1I;F>389-P87)S99-T<F5E+)AM86ENFJQR=&%I;G.3X
M89-S=&%CF&N.H8V1)X  ;V:6!&YT<W5B=')E97,ND0;$151H99-O<)!3CF5RX
M871I;VYSDV]NDW1H99-S=&%CFJQR:Y-O9I-S=6)T<F5E<Y-A<F63<WEN8YAHX
M<F]N:7IE9)-W:71HCJ&-D2>  '1H998$R?YO<)I3CF5R871I;VYSD]QY>7!AX
M<G-ED]9PF&5R9F]R;7.3;VZ3:71SDW-T86.0K')KDV]FDW!A<G-E<I-S=&%TX
M97,LD04!U&5X8V5P=)-T:&%TCJ&-D2>  &]PD%..97)A=&EO;G.;!'+A:6Z5X
MK')VDV]L=FEN9YAT:&687&UA<FN397*8;F]NDW1E<FUI;F%L<R*8*'-E99A;X
MC4IO:&YS;VZ1 ^JH-S6.D3FKE5TIF&EN<V5R=&5DCJ&-D2>  &ENFJQR=&^6X
M ^JH=&AEDV=R86UM87*38IAYDUF1_P5686-CDV%R99-I9VYO<F5D+HZAC9$YX
M'_14:&66!< M97:1_UCD86QU871O<I-M86ENFJQR=&%I;G.3:71SDW-T86.8X
M:Y-O9I-S=6)T<F5E<Y-A<Y-F;VQL;YAW<RZ1"KEO3&^04XYO:Y'_6.1A:&5AX
M9'..H8V1)X  8V]I;F-I9&66!8)P=VET:)-C86QL<Y-T;Y/<>7EL97C6+I$*X
M #=*=7-TDV*04XYE9F]R99-AD]QR971U<FZ3UFESDV5X96-U=&5DDVENDV&3X
M3&5XCJ&-D2>  &%C=&EO;BR1 YRF86Z6 XDE:6UA9V63;V:389-L96%FDVYOX
MD%..9&63:7.38W)E871E9)-I;I-T:&6397:1_UCD86QU871O<B=SD]EL;Y;_X
M9F9O:V%H99-A9)$#V91B=0ME<I$!2JO6+(ZAC9$G@ !A;F26!!V8:71SDW-YX
M;IJL<G1H97-I>F5DDV%T=')I8G5T99-I;G-T86YC97.387)EDW-O;':89623X
M86YDDW!L86-E9)-I;I-T:&%TDV)U"V5R+HZAC9$G@ !!E:QR=)L#[;-E86.3X
M:)AS:&EF="R1 ^YU89AL96%FF&YOE5..9&68:7.88W)E871E9)AF<F]MF'1HX
M99AI;6%G99AI;IAT:&68;&^3;VN1_UCD86AE86288G4+97(LCJ&-D2>  &%NX
M9)8$_YMT:&63<W5B=')E99-C;VYS:7-T:6YGDV]FDW1H8723;&5A9I-N;Y!3X
MCF1EDVESDW!U<VAE9)-O;IJL<G1ODW1H99-S=&%CF&LND0AWN4&8=(ZAC9$GX
M@ !E86.:K')HE@0\ZG)E9'5C=&EO;BR1!%%[>F5R;Y-O<I-M;W)EDW-U8G1RX
M965SDV%R99-PE5..;W!PDV5DE@0\ZF9R;VV3=&AEDW-T86.8:RR1!%%[86YDX
MDW1H96ERCJ&-D2>  ')OE5..;W1SFP1=TF*396-O;668=&AEF&.0K')H:6QDX
M<F5NF&]FF&&8;F5W;'DM8W)E871E9)AN;Y-D92R1!'J=>6EE;&1I;F>889ANX
M97>8<W5B=')E92Z.H8V1)X  5&AEE@.(.')OFE..;W23;V:3=&AEDVYE=Y-SX
M=6)T<F5EDVESDV=I=I"L<F5NDV&3;&%BF&5LDW1ODVEN9&EC871EDW1H99-PX
M<F^89'5C=&EO;I-BF&5I;F>.H8V1)X  87!P;&EE9)8%2>5A=)-T:&63;F^0X
M4XYD92R1!:&T86YDDW1H99-N97>3<W5B=')E99-I<Y-P=7-H9623;VZ:K')TX
M;Y-T:&63<W1A8YAK+I$)5I94:&6.H8V1)X  <&%R<V66!2YY=')E99-I<Y-CX
M;VUP;&5T9623=7"04XYO;I-E;F23;V:3:6YP=723=&]G971H97*3=VET:)-RX
M961U8W1I;VZ3=&^3=&AECJ&-D2>  '-T87)TD0/JJ'-Y;9"L<F*04XYO;"Z.X
MGR+*JXV-D2>  .(W+C*.D4TX0%!L86-E;65ND(H]=)8%A1QO9I-G96YE<F%TX
M96238V^0=<)D98Z?%D  C9$G@ #60V^04XYD998$0HQF;W*3<&%R<V4M=')EX
M99-M86YA9V5M96Z0K')TDV%N9)-A='1R:6)U=&6397:1_UCD86QU871I;VZ3X
M:7.3<&QA8V5DDVENDUF1_P5686-CCJ&-D2>  &%N9)8#TF5,97B386-T:6]NX
M<Y-I;I-/>"=SDV]U='!U="Z1!3#*26:389-G:7:0K')E;I-R=6QEDVENDW1HX
M99-9+0QL99-H87.386Z3;W)D:6YA<GF.H8V1)X  69'_!59A8V.6 TW?86-TX
M:6]N+)$#;3MT:&633W@M9V5N97)A=&5DDV-OD%..9&63:7.3<&QA8V5DD]EAX
M9G1E<I$$F(K686Z0K')YDW!R;V=R86UM97(M<W5P<&QI962.H8V1)X  0Y8%X
M$$QC;Y!3CF1EDV-O;IJL<G1A:6YE9)-I;I-T:&6386-T:6]N+I$(J<U)9I-AX
MDV=I=IAE;I-R=6QEDVENDW1H99-9+0QL99-L86.8:W.389-9D?\%5F%C8XZAX
MC9$G@ !A8W1I;VXLFP.\UV%NE@.Q8V%C=&EO;I-I<Y-C<F5A=&5D+)AA;F23X
M=&AEDT]X+6=E;F5R871E9)-C;Y!3CF1EDVESDW!L86-E9)-T:&5R92Z1!27)X
M5&AECJ&-D2>  &%C=&EO;G.6 [I=<V^38W)E871E9)-A<F63:6Z0K')T<F^:X
M4XYD=6-E9)-O;FQYDV%TDW1H99/996YD<Y$$N#K6;V:3<G5L97,LD0/$!7-OX
MDUF1_P5686-CDV1OF&5SDVYO=(ZAC9$G@ !C<F5A=&66 S6G89-M87)KFJQRX
M97*3;F]NF'1E<FUI;F%LDV9O<I-T:&6386-T:6]N+)$#6=MA;F23=&AEDTQ!X
M3%(H,2F3<')O<)!3CF5R=)AYDV]FDW1H98ZAC9$G@ !G<F%M;6%RE@/JJ&ESX
MDW5N80ME8W1E9"Z.H8V1.1_T5VAE;I8$D$YA;I-A='1R:6)U=&63<F5F97)EX
M;F-EDW-E8W1I;VZ3:6Z386Z33"T,;&638V]ND*QR=&%I;G.39&4,;FET:6]NX
M<Y-F;W*.H8V1)X  ;6]R998#MGYT:&%NDV]N99-A='1R:6)U=&63;Y53CF-CX
M=7)R96YC92R1 \#M8V^39&66 [9^9F]RDVEM<&QE;65ND*QR=&EN9Y-T:&]SX
M99-D90QN:71I;VYSCJ&-D2>  &ESE@-^$V5X96-U=&5DDVENDW1H99-S86UEX
MDV]R9&5RDVENDW=H:6.0K')HDW1H99-D90QN:71I;VYSDV%P<)!3CF5A<I-IX
M;I-T:&%TDW-E8W1I;VXNCJ&-D3D?]$:1_P56;W*6!EPT=&AEDV%T=')I8G5TX
M99-OD%..8V-U<G)E;F-E<Y-D90QN9623:6Z3=&AEDUDM#&QE+)$&^)=/>)-AX
M;F23=&AEDT]X+8ZAC9$G@ !G96YE<F%T9626 VDR97:1_UCD86QU871O<I-PX
MFE..97)F;W)MDV%N86QY<V5SDW1ODV1E=&5R;6EN99-W:&5NDW1ODV5X96-UX
M=&63=&AEDV-OF&1ECHZ.C(L    1                                X
M                  "ET: "<@  C:#]M0  C8V1)X  VCB1"[_X4%*0K')/X
M1U)!34U)3D>1 ^JH4U193$62 -V?7=8Q-XZ.H (M  "-H/WV  "-D2>  '-EX
M9VUE;IJL<G26 Y7K=&AA=)-E=I'_6.1A;'5A=&5SDV&39VEVF&5NDV%T=')IX
M8G5T92Z1!1RA5&AEDV]R9&5RDV]FDV5X96-U=&EO;I-O9I-T:&638V^04XYDX
M98ZD#H  C9$G@ !S96=M96Z:K')T<Y8#%U!A<W-OD%..8VEA=&5DDW=I=&B3X
M=&AEDV1E#&YI=&EO;G.3:6Z389-G:7:896Z3871T<FEB=71EDW)E9F5R96YCX
M99-S96-T:6]NCJ&-D2>  &ESE@1FO&1E=&5R;6EN96238I"L<GF3=&AEDV1EX
M<)!3CF5N9&5N8VEE<Y-O9I-T:&639&4,;FET:6]N<RR1!(7!86YDDVESDVYOX
M=)-N96-E<W-A<FEL>8ZAC9$G@ !R96QA=&5DE@/JJ'1ODW1H99-O<F1E<I-OX
M9I-A<'"04XYE87)A;F-EDV]FDW1H99-D90QN:71I;VYS+HZAC9$Y'_13;VUEX
ME@29#&%T=')I8G5T99-OFE..8V-U<G)E;F-E<RR1!,2E9F]RDV5X86UP;&63X
M=&AO<V63=&AA=)-H896L<G:3998$F0QN;Y-D97"896YD965S+(ZAC9$G@ !AX
M<F66!6>H97:1_UCD86QU871E9)-A<Y-P87)TDV]FDW1H99-9D?\%5F%C8Y-AX
M8W1I;VZ397AE8W5T9623=7"04XYO;I-R961U8W1I;VZ38I"L<GF3=&AECJ&-X
MD2>  &%S<V^54XYC:6%T962; SI0<')ODV1U8W1I;VXND03^&$1E#&YI=&EOX
M;G.8;V:8<W5CD*QR:)AODV-C=7)R96YC97.887)EF&%L;&^5K')WDV5DF'1OX
MF&-O;I-T86ENCJ&-D2>  ')E9F5R96YC97.6 X)V=&^3=&AEDUF1_P5686-CX
MDW!S975D;Y"L<G:1_UCD87)I86)L97.3W"0DUBR6 Y=-W"0QUBR3W"0RUBR3X
M971C+I$%%B5)9I8#@G9/>)-D971E<FUI;F5SDW1H872.H8V1)X  898#ROQGX
M:7:0K')E;I-A='1R:6)U=&63;YI3CF-C=7)R96YC99-C86YN;W238IAEDV5VX
MD?]8Y&%L=6%T96238723<F5D=6-T:6]NDW1I;64LD0/146%N9)-T:&6.H8V1X
M)X  9&4,;FET:6]NE@/JJ')E9F5R<Y-T;Y-S=6.:K')HDV&3<'-E=61OF':1X
M_UCD87)I86)L92R33WB3:7-S=65SDV%NDV5R<F]RDVUE<W-A9V4NCI\BRJN-X
MC9$G@ #B-RXSCI%-.$!$96-O<F%T:6]NE@6%'&%N9)-T:&63<F5A9'F3<V5TX
MCI\60 "-D2>  -94:&66!'$[3W@M9V5N97)A=&5DDV5VD?]8Y&%L=6%T;W*3X
M;6%I;I"L<G1A:6YSDV&3<V5TDV]FDV%T=')I8G5T99-I;G-T86YC97.3=&AAX
M=)-A<F6.H8V1)X  <F5A9'F6!0/5=&^38I!3CF63<V]L=IJL<F5D+)8%2B!IX
M+F4N+)-T:&]S998% ]5W:&]S99-E=IAE<GF39&5PFE..96YD9663:&%SDV*8X
M965NDW-O;':0K')E9"R1!4H@8G5TCJ&-D2>  '=H:6.5K')HFP37G6AADW:3X
M99AN;W28=&AE;7-E;':397.88I!3CF5E;IAS;VQVDV5D+I$'_[]$=7)I;F>8X
M<&%R<VEN9YAO9IAT:&68:6YP=70LD042VFETF&ESCJ&-D2>  '"04XYO<W-IX
M8FQEE@+,*71ODW)E;6^5K')VDV66 LPI86Z3871T<FEB=71EDVEN<W1A;F-EX
MDV9R;VV3=&AI<Y/9<I;_9F9EDV%D>9$#*]YS9721 21$UBR6 P5U<V]L=I"LX
M<F6; LPI:70LDV%N9)AT:&5NCJ&-D2>  &.5K')H96.3:Y8#]HEW:&5T:&5RX
MDW1H99-S;VQV:6YGDV]FDW1H8723:6YS=&%N8V63:&%SDV-A=7-E9)-A;IJLX
M<GF3;V:3:71SDV1E<)!3CF5N9&5NF'1SCJ&-D2>  '1OE@-5 6*:4XYEDW)EX
M861YDW1ODV*899-S;VQVFJQR960ND04&_DEN<W1A;F-E<Y-T:&%TDV%R99-TX
M:)AU<Y-M861EDW)E861YDV%R99-T:&5NDW!L86-E9(ZAC9$G@ !I;I8%LWYTX
M:&63<F5A9'F3<V5T+I$*DV%297":4XYE871I;F>3=&AI<Y-P<F^88V5S<Y-UX
M;IJL<G1I;)-T:&63<F5A9'F3<V5TDVESDV5M<'28>9-I<XZAC9$G@ !K;F^:X
MK')W;I8$Y91A<Y/99&66_V9F8Y-O<I-A=&EO;I$ Y;#6+I$(*:5&D?\%5F]LX
M;&^8=VEN9Y8$Y91ADV1E8V]R871I;VXLD04D3V9U<G1H97*3<&%R<VEN9Y-OX
M9I-T:&63:6YP=72.H8V1)X  ;6&0K')YE@,JAW)E<W5L=)-I;I-C<F5A=&EOX
M;I-O9I-P87)S92UT<F5EDVYOD%..9&5SDV%N9)-I;G-E<G1I;VZ3;V:3871TX
M<FEB=71EDVEN<W1A;F-E<XZAC9$G@ !I;IJL<G1OE@0/FG1H99-R96%D>9-SX
M970ND06GME-CF&AE9'5L:6YGDV]FDV1E8V]R871I;VYSDVESDW"04XYE<F9OX
M<FUE9)-A=71O;6%T:6-A;&QYDV*8>8ZAC9$G@ !T:&6;!)EU97:6_UCD86QUX
M871O<BZ1!T5&17:386QU871I;VZ8;V:889AG:7:5K')E;IAS>6Z3=&%C=&ECX
M86QL>2UC;W)R96-TF&EN<'5TF&ENDW:3;VQVDV5SF&%TCJ&-D2>  &QE87-TX
ME@4>[6]N99-D96-O<F%T:6]N+)$%:_YT:&%TDW"04XYE<F9O<FUE9)-A9G1EX
M<I-T:&63#&YA;)-R961U8W1I;VZ3=&^3=&AEDW-T87)TCJ&-D2>  '-Y;9"LX
M<F*04XYO;"Z.GR@55HV-D2>  .<XCI%%3LY0<F]G<F%M;6EN9Y$&G[QS=)'_X
M<K!Y;&6.GQIB(XV1)X  UD1E#&YI=&EO;G.6 ^JH;V:3V6%T=')I8G5T99$$X
M,S5G<I'_9F9A;6UA<I$!2JO6+),H9F]RDVEN<W1A;F-EDW1H;W-EDVENDUN-X
M3&]R:&^3.#B.D2W:YUV386YDCJ&-D2>  %N-5Y'_!59A:71ED0/JJ#@TCI$MX
ML)==*98%21!E;7!L;Y"L<GF3;F^3;F]T:6]NDV]FDV5X96-U=&EO;I$*DB!SX
M97%U96YC92Z1"5095&AEDW5S=6%LDT]XDW!R;RV.H8V1)X  9W)A;6UI;F>6X
M YYZ<W2:K')Y;&63:6Z8=IAO;':897.39&4,;FEN9Y-S>6Z8=&AE<VEZ9623X
M871T<FEB=71EDV^04XYC8W5R<F5N8V5SDV]FDW1O:YAE;G..H8V1)X  :6Z6X
M [XD=&5R;7.3;V:3W'EY=&5X=)/686YDD]QY>6QE;F>3UF%N9)-O=&AE<I-SX
M=6.0K')HDV1A=&&3<W1R=6-T=7)E<Y-O9I-T:&63;&5X:6-A;(ZAC9$G@ !AX
M;F%L>7IE<BZ1!3((5&AE;I8#UA]T:&63871T<FEB=71EDV1E#&YI=&EO;G.3X
M;V:396%CD*QR:)-P<F^04XYD=6-T:6]NDV%R99-W<FET=&5NDV]N;'F.H8V1X
M)X  :6Z6 QU@=&5R;7.3;V:38V]N<W1A;I"L<G1SDV%N9)-O=&AE<I-A='1RX
M:6)U=&63;YI3CF-C=7)R96YC97.3;V:3=&AA=)-P<F^89'5C=&EO;BZ1!/1SX
M1I'_!59O<HZAC9$G@ !AE@-\$F=I=IJL<F5NDW-E;IAT96YC92R1 Y(P=&AEX
MDW-Y;IAT:&5S:7IE9)-A='1R:6)U=&63:6YS=&%N8V5SDV]FDW1H99-T;VN8X
M96YSDW1H96Z38V]M+8Z.CHR+    $@                              X
M                    LGN@ G(  (V@_;4  (V-D2>  -HYD0N_^%!/4U1$X
M14-/4D&1_P565$E/3I$#ZJA44D&1_K'(5D524T%,4Y( HX>RUC$XCHZ@ BT X
M (V@_?8  (V1)X  <&QE=&5L>98#W+%D971E<FUI;F63=&AEDW:1_UCD86QUX
M97.3;V:386QLDV%T=')I8G5T99-I;G-T86YC97.3;V:3=&AEDW!A<G-EDW1RX
M964ND04T.%1H98ZD#H  C9$G@ !A='1R:6)U=&66 U\U:6YS=&%N8V5SDV]FX
MDW1H99-R;YI3CF]TDVYOF&1EDV%R99-O9G1E;I-O9I-P87)T:6-U;&%RDVENX
MD*QR=&5R97-T+)$#>QAA;F23=&AE:7*.H8V1)X  9&4,;FET:6]N<Y8$(*)OX
M9G1E;I-C;VZ0K')T86ENDV-OD%..9&63=&AA=)-C;W!I97.3=&AE:7*3=IO_X
M6.1A;'5E<Y-T;Y-G;&]B86R30Y-VF&%R:6%B;&5S+(ZAC9$G@ !S;Y8#ZJATX
M:&%TDW1H97F3;6&0K')YDV*:4XYEDW5S9623:6Z38V^89&6397AE8W5T9623X
M869T97*3=&AEDW)E='5R;I-F<F]MD]QY>7!A<G-EUBZ.H8V1.1_T4VEN8V66X
M!(Q:871T<FEB=71EDV1E#&YI=&EO;G.3:6Z33WB38V^04XYD99-M89JL<GF3X
M8V]NF'1A:6Z386Z8>9-#DV-OD%..9&4LD02TQG1H99-/>(ZAC9$G@ !P<F]GX
M<F%M;65RE@2<KFUAFJQR>9-D979I871EDV9R;VV3=&AEDW-A9F6387!P<F]AX
M8YAHDV1E<V-R:6*:4XYE9)-A8IAOE:QR=I-EFP2<KF*3>9AU<VEN9XZAC9$GX
M@ !N;VXM<F^04XYO=)8%HU!A='1R:6)U=&639&4,;FET:6]N<Y-T:&%TDW)EX
M8623;W*3=W)I=&639VQO8F%LDW:1_UCD87)I86)L97,ND0IBUT)E9F]R98ZAX
MC9$G@ !A='1E;7!T:6YGE@1__'1H99-U<V63;V:3<VED99-E"V5C=',LD02EX
M471H99-P<F]G<F%M;65RDW-H;W5L9)-BD%..99-F86UI;&EA<I-W:71HCJ&-X
MD2>  '1H998#ZJAM871E<FEA;)-O9I-S96-T:6]NDS<NCJ&-D3D?]%-I;F-EX
ME@.4I71H99-O<F1E<I-O9I-E=IO_6.1A;'5A=&EO;I-O9I-A='1R:6)U=&5SX
MDV*0K')YDW1H99-/>"UG96YE<F%T962397:886QU871O<HZAC9$G@ !I<Y8"X
MK@AN;W2397AP;&EC:723:6Z3=&AEDT]XDVEN<'5TDW-PD%..96-I#&-A=&EOX
M;G,LD0+M6W5S=6%L;'F3:723:7.3;F]TDV-O;I6L<G:396YI96Z3=)8"K@ATX
M;Y-U<V6.H8V1)X  871T<FEB=71EE@/FAV1E#&YI=&EO;G.39F]RDV]R9&5RX
M+7-E;G-I=&EVFJQR99-S:61EDV4+96-T<Y-S=6.8:)-A<Y$'S0YC;Y!3CF1EX
MDV=E;F5R871I;VXNCJ&-D3D?]$&1!5K=8V]M;6]NE@5;/&=E;F5R86R387!PX
M<F]A8Y"L<FB3=&^3=')A;G-L871I;VZ3:7.3=&^38G5I;&2386YDDV1E8V]RX
M871EDV&.H8V1)X  <&%R<V66!.SD=')E99,H;65A;IJL<G=H:6QEDW"04XYEX
M<F9O<FUI;F>3<V]M99-O9I-T:&638YAH96.8:W.39F]RDW-E;6%NF'1I8Y-EX
M<G)O<G,I+(ZAC9$G@ !A;F26!8BM=&^3=&AE;I-M86N:K')EDV]N99-O<I-MX
M;W)EDV1E=&5R;6EN871E+6]R9&5RDW1R9663=')AF':897)S86QSDV9O<I,,X
M;F%LCJ&-D2>  &5R<F]RFP/JJ&.5K')H96.3:W,LF&=A=&AE<FEN9YAO9IACX
M;VUP:6QA=&EO;IAS=&%T:7-T:6-S+)AC;Y!3CF1EF&=E;F5R871I;VXLF&5TX
M8RZ.H8V1.1_T3WB6 ^#G:&%SDV&39F%C:6QI=)JL<GF39F]RDW-PD%..96-IX
M#&-A=&EO;I-O9I-S=6.8:)-T<F&8=IAE<G-A;',LD0/BVV%N9)-T:&ESDVESX
MDW1H99-T;W!I8XZAC9$G@ !O9I8#ZJAS96-T:6]NDSDNCI\H%5:-C9$G@ #GX
M.8Z114[.4);_<K!O<W1D96-O<F%T:6]ND0:?O'1R89-VDV5R<V%L<XZ?&F(CX
MC9$G@ #65&AEE@.MG&ED96&3;V:39&5C;W)A=&EO;I-WD*QR87.39&5S8W)IX
M8I!3CF5DDVENDW-E8W1I;VZ3-RXS+I$%)(?94&]S=&1EEO]F9F.3;W*3871IX
M;VZ1!)-,UG)E9F5R<Y$#K9QT;XZAC9$G@ !A;IJL<GF6 WA"=&EM99-A9G1EX
M<I-T:&63V0QN86R1!+;5UF1E8V]R871I;VZ3;V:3=&AEDW!A<G-EDW1R964LX
MD0./(W=H:6.8:)-F;VQL;YAW<Y-P87)S:6YGDV]FCJ&-D2>  &&6 RA=8V]RX
M<F5C=)-I;G!U="Z1!/@<5&AI<Y-S96-T:6]NDW-H;YJL<G=SDVAOF'>3=&AEX
MDT]XDW5S97*38V%NDV-A=7-ED]EPEO]F9F]S=&1EDV.3;W*3871I;VZ.H8V1X
M)X  ='*1_V9F879E<G-A;'.1 /W=UBR1"C[^96%CFJQR:)8$X;IO9I-W:&ECX
MF&B3<)I3CF5R;6ET<Y-A8V-E<W.3*&ENDV&3=7-E<BUS<)AE8VD,9623;W)DX
M97(IDW1ODW1H98ZAC9$G@ !T<F5E)W.6 ^JH871T<FEB=71EDVEN<W1A;F-EX
M<RZ.GR+*JXV-D2>  .(Y+C&.D4TX0$5X86UP;&4ZD0=<)6EN#'B6!84<=&^3X
M<')E#'B3=')A;G-L871I;VZ.GQ9  (V1)X  UE1H998#G1]P<F]B;&5MDV]FX
MDW!A<G-I;F>3:6X,>)-A<FET:&UE=&ECDV5X<')E<W-I;VYS+)$#K*%A;F23X
M=&AE:7*3=')A;G-L871I;VZ3=&^.H8V1)X  <')E#'B6 ^JH9F]R;9-S97)VX
MFJQR97.3=&^3:6Z8=')OFE..9'5C99-/>"=SDW"8;W-T9&5C;W)A=&EO;I-TX
M<F&5K')VDV5R<V%LD0/JJ&9A8VEL:723>9'_!58NCJ&-D3D?]%1H998$5IUTX
M;VN:K')E;G.3;V:3=&AEDV5X86UP;&63;&%N9W5A9V6387)EDV1E=&5R;6ENX
M96238IAYDW1H99-F;VQL;YAW:6YGDTPMCJ&-D2>   QL93J.CHZ,BP   !, X
M                                                 +YPH )R  "-X
MH/VU  "-C9$G@ #:.9$+O_A03U-41$5#3U)!D?\%5E1)3TZ1 ^JH5%)!D?ZQX
MR%9%4E-!3%.2 *.'LM8Q.8Z.H (M  "-H/X"  "-D2>  ,HE>XZD#   C9$GX
M@  C:6YC;'5D99$%/_TB>2YT86(N:"*.H8V1)X  (VEN8VQU9&61!3_](F]XX
M;W5T+F@BCJ&-D2>  "5]CI\8  "-D2>  "4ECJ&-D2>  %N1!3_]7&Y<=%QFX
M72J1%/_T.XZAC9$G@ !;,"TY72N1*?_H<F5T=7)N*$-/3E-4*3N6!3_]0'N3X
M<W-C86YF*'EY=&5X="PB)60B+"9 0T].4U0N=F%L0"D[DT!]CJ&-D2>  %PHX
MD3[_W')E='5R;B@G*"<I.XZAC9$G@ !<*9$^_]QR971U<FXH)RDG*3N.H8V1X
M)X  7"N1/O_<<F5T=7)N*"<K)RD[CJ&-D2>  %PJD3[_W')E='5R;B@G*B<IX
M.XZAC9$G@  ND40_V69P<FEN=&8H<W1D97)R+")I;&QE9V%LD04__6-H87)AX
M8W1E<EQN(BD[CJ&-D2>  "4ECI\G@ "-D3D?]-94:&66 ^JH9F]L;&^0K')WX
M:6YGDUDM#&QEDV-O;7!L971E<Y-T:&63<W"04XYE8VD,8V%T:6]NDV]FDW1HX
M99-E=I'_6.1A;'5A=&]R+HZ.CHR+    %                           X
M                        R%Z@ G(  (V@_;4  (V-D2>  -HYD0N_^%!/X
M4U1$14-/4D&1_P565$E/3I$#ZJA44D&1_K'(5D524T%,4Y( HX>RUC(PCHZ@X
M BT  (V@_@(  (V1)X  RB5T;VME;I$%/_U#3TY35(ZD#   C9$G@  E;&5FX
M=)$%/_TG*R>.H8V1)X  )6QE9G21!3_])RHGCJD8  "-D2>  $!A='1R:6)UX
M=&5SE@4__7MI;G23=F%L.WV30T].4U2.H8V1)X  0'1R879E<G-A;)8%/_U X
M;&5F='1O<FEG:'230'!R96]R9&5RDTQ2<')ECJ:-D2>  "5[CJ&-D2>  "-IX
M;F-L=61ED04__2)O>&]U="YH(HZAC9$G@  C:6YC;'5D99$%/_T\<W1D:6\NX
M:#Z.H8V1)X  )7V.IHV1)X  )26.H8V1)X  97AP<I84__0ZD22_ZV5X<'*3X
M)RHGD1H_\65X<'*2 (,_M2\JE@4__7)U;&63,9,J+XZAC9%[?]! >Y8%/_U X
M3%)P<F61"G_Z<')I;G1F*"*3*I,B*3N30'V.IHV147_H?)$DO^ME>'!RD13_X
M]"<K)Y$:/_%E>'!RD@"#/[4O*I8%/_UR=6QEDS*3*B^.H8V1>W_00'N6!3_]X
M0$Q2<')ED0I_^G!R:6YT9B@BDRN3(BD[DT!]CJ:-D5%_Z'R1)+_K)R@GD1H_X
M\65X<'*1%/_T)RDGD@"(?[(O*I8%/_UR=6QEDS.3*B^.IHV147_H?)$DO^M#X
M3TY35)( T?^(+RJ6!3_]<G5L99,TDRHOCJ&-D7M_T$![E@4__4!,4G!R99$*X
M?_IP<FEN=&8H(I,E9),B+$!#3TY35"YV86Q *3N30'V.H8V147_H.XZAC9$GX
M@  E)8Z?)   C9$G@ !M86EN*"F.H8V1,?_Z>WEY<&%R<V4H*3N.H8V1-S_WX
M<')I;G1F*")<;B(I.XZAC9$Q__I]CI\G@ "-D3D?]-94:&6;!A,P<V5Q=65NX
M8V4ZD0F)\-Q =')A=F5R<V%LE@8LS4!L969T=&]R:6=H=)- <')E;W)D97*3X
M3%)P<F68UG-PD%..96-I#&5SCJ0.@ "-D2>  '1H8726!#K&89-L969T+71OX
M+7)I9VB:K')TDW!R96]R9&5RDW1R89AVF&5R<V%LDV]FDW1H99-P87)S99-TX
M<F5EDV*:4XYEDW"897)F;W)M96238I"L<GF3=&AECJ&-D2>  &5VD?]8Y&%LX
M=6%T;W*6!,7-869T97*3=&AEDPQN86R39&5C;W)A=&EO;BR1!/R686YDDW1HX
M8723=&AEDW1R896L<G:397)S86R6!,7-8I!3CF63:61E;I"L<G1I#&5DDV%SX
MCJ&-D2>  -Q,4G!R9=8ND0:AM$YO=&66!&+O=&AA=)/<3%)P<F63UFESDW!RX
M;V=R86UM97(M9&4,;F5D+)$$@0!A;F23:7.3V6YO=)$%AS/686Z33WB3<F5SX
M97)VD*QR962.H8V1)X  =Y"L<F]R9"Z.H8V1.1_T16%CFJQR:)8$D%%A='1RX
M:6)U=&63<F5F97)E;F-EDW-E8W1I;VZ3:6Z3=&AEDV%BD%..;YAVF&6362T,X
M;&638V]NF'1A:6YSDV&3V71RD?]F9F%V97)S86R.H8V1)X  86-T:6]NFP/RX
MDG-PEO]F9F638VD,97*1!.\!UG-T87)T:6YGE@.D5G=I=&B3=&AED]ET<I;_X
M9F9A=F5R<V%LF&UODV1EF&%N;G5N8VEA=&]RD03O =Q 3%)P<F76+)$#LF9WX
M:&ECD*QR:(ZAC9$G@ !I<Y8#ZJAD90QN9623:6Z3=&AEDV%BFE..;Y6L<G:3X
M92UM96Z3=&EO;F5DE@/JJ-Q =')A=F5R<V%LD]9S<)AE8VD,8V%T:6]N+HZ.X
MCHR+    %0                                                  X
MRI2@ G(  (V@_;4  (V-D2>  -HYD0N_^%!/4U1$14-/4D&1_P565$E/3I$#X
MZJA44D&1_K'(5D524T%,4Y( HX>RUC(QCHZ@ BT  (V@_?8  (V1.1_T5VAEX
M;I8%R2ET:&63W$Q2<')ED]9T<F&5K')VDV5R<V%LFP7)*7)E86.3:&5SF&&8X
M;F^04XYD99AA=)AW:&ECDVB8<G5L99@QF&ESF&%P<&QI960LCJ0.@ "-D2> X
M &%NE@5G.V%S=&5R:7-KDVESDW!R:6Z:K')T960LD07&8'1H96Z396%CF&B3X
M<W5B=')E99-R;Y!3CF]T9623872389-CF&AI;&23;V:3=&AEDVYOD%..9&63X
M:7..H8V1)X  =')AE:QR=I-E<G-E9"R1 \82=&AEE@.\[&QE9G1M;W-TDW-UX
M8G1R9663#')S="Z1!2FA5&AEDV*04XYE:&&:K')V:6]RDV]FDW1H99-T<F&8X
M=IAE<G-A;)-A=)-ADVYOD%..9&6.H8V1)X  8726!4TN=VAI8YJL<FB3<G5LX
M99,RDVESDV%P<&QI9623:7.3=&AEDW-A;64LD06ET&5X8V5P=)-T:&%TDV&3X
M<&QU<Y-S:6=NDVESDW!R:6Z8=&5DCJ&-D2>  &EN<W1E8626!(75;V:386Z3X
M87-T97)I<VLND0<*9U=H96Z3W$Q2<')ED]9R96%CFJQR:&5SDV&3;F^04XYDX
M99-F;W*3<G5L99,S+)$$K*!N;Y-T<F&8=IAE<G-A;(ZAC9$G@ !A8W1I;VZ6X
M X];:7.3<)I3CF5R9F]R;65D+)$#H9YB=723=&AEDV.0K')H:6QD<F5NDV]FX
MDW1H99-N;YAD99-A<F63=')AE:QR=I-E<G-E9)L#CUMR96-U<G-I=I-E;'F8X
M87..H8V1)X  9&5S8W)I8I53CF5DFP/J6F%BDV^5K')VDV689F]RF&YOD%..X
M9&5SF&9O<IAR=6QE<Y@QF&%N9)@R+I$%.,94:&68W'9A;)C6871T<FEB=71EX
MF&]FF'1H99C<0T].4U2.H8V1)X  UF.:K')H:6QDE@2H4FESDW!R:6Z8=&5DX
MDW=H96Z389-N;Y!3CF1EDV9O<I-R=6QEDS23:7.3<F5A8YAH960ND0=QW4YOX
MDV%C=&EO;I-I<Y-PD%..97)F;W)M962.H8V1)X  9'5R:6YGE@/JJ&&3=')AX
ME:QR=I-E<G-A;)8#ZJAO9I-ADW-U8G1R9663=&AA=)-C;VYS:7-T<Y-O9I-AX
MDW1E<FUI;F%LDVYOD%..9&4NCI\BRJN-C9$G@ #B.2XRCI%-.$!'96YE<F%LX
MD06%'&1E<V-R:7!T:6]NCJ060 "-C9$G@ #;.2XR+C&.D5#  %21_N  <F&5X
MH !VDV5R<V%LD02  '-PD&  96-I#&-A=&EO;G..H8V1)X  UE1H998$43]/X
M>)-P<F]G<F%M;65RDVUAD*QR>9-P;&%C99-I;I-T:&639&5C;&%R871I;VYSX
MDW-E8W1I;VZ3*'1H99-P87)TDV*04XYE9F]R98ZD#H  C9$G@ !T:&66!$UQX
M#')S=)/<)263UFUA<FLIDV]FDW1H99-9+0QL99-O;F63;W*3;6]R99/9='*6X
M_V9F879E<G-A;)$$C@)S<)-EDV-I#&.3871I;VYSD0#]W=8ND09A/%-U8Y"LX
M<FB1!$UQ88ZAC9$G@ !S<)!3CF5C:0QC871I;VZ6 Y3'8V]N<VES='.3;V:3X
M=&AEDW)E<V5R=IJL<F5DDW>8;W)DD]Q =')A=F5R<V%LUBR1 Z7T9F]L;&^8X
M=YAE9)-BF'F389/9='*1_V9F879E<BV.H8V1)X  <V%LFP/YQW-PEO]F9F63X
M8VD,97*8<V63<75E;F.399$$D=[686YDE@.L+F&3;F]N+65M<'2:K')YDW-EX
M<75E;F-EDV]FDVED96Z8=&D,97)S+)$#N*QT:&63:61E;IAT:0QE<G..H8V1X
M)X  8I!3CF5I;F>6!)$J<V5P87)A=&5DDV*:K')YDW=H:71E<W!A8V4ND0<LX
M9D&1!)#_=')AF':897)S86R3<W"04XYE8VD,97*3<V5Q=65N8V63;6&8>9-CX
M;VZ8=&%I;HZAC9$G@ !T:&66 ^JH9F]L;&^:K')W:6YGD]ET<I;_9F9A=F5RX
M<V%LD00S-7-PDV638VD,97)SD03HA=8H:6Z6 ^JH86Z8>9-O<F1E<BDZCJ08X
M@ "-C8V-D3C_[]@/CHZ.D43?[-9A=)8#ZJAM;W-TDV]N99-O9CJ1!3C@W$!PX
M;W-T;W)D97+6+)/<0'!R96]R9&5RCJ&-C8V-D3C_[]@/CHZ.D43?[-9A=)8#X
MZJAM;W-TDV]N99-O9CJ1!3C@W$!L969T=&]R:6=H=-8LD]Q <FEG:'1T;VQEX
M9G2.H8V-C8V1./_OV ^.CHZ11-_LUF]P=&EO;F%L;'DZD04XX-Q 9&ES86)LX
M98ZAC9$G@ #626:6 \=(;F5I=&AE<I/<0'!O<W1O<F1E<I/6;F]RD]Q <')EX
M;W)D97*3UF%P<)!3CF5A<G.3:6Z3=&AEDW-E<75E;F-E+)$#SEMT:&63=')AX
ME:QR=I-E<G-A;(ZD#H  C9$G@ !I<Y8#V=1PD%..;W-T;W)D97*38IJL<GF3X
M9&5F875L="Z1!3-$09$#V=!L969T+71O+7)I9VB8=)-T<F&8=IAE<G-A;)-IX
M<Y-S<)!3CF5C:0QE9)-BF'F39&5F875L=)-W:&5NCJ&-D2>  &YE:71H97*6X
M ^JHW$!L969T=&]R:6=H=)/6;F]RD]Q <FEG:'1T;VQE9G23UF%P<)!3CF5AX
M<G,NCJ&-D3D?]$:1_P56;VQL;YJL<G=I;F>6!*I>=&AEDPQN86R39&5C;W)AX
M=&EO;BR1!-I+=&AEDW!A<G-EDW1R9663:7.3=')AF':897)S9623;VYC99-FX
M;W*396%CF&B.H8V1)X  =')AE:QR=I-E<G-A;)8$R<QS<)I3CF5C:0QC871IX
M;VXND0?6351H99-O<F1E<I-O9I-PF&5R9F]R;6EN9Y-T:&63=')AE:QR=I-EX
M<G-A;'.1!,G,8V]R<F5S<)AO;F1SCJ&-D2>  '1OE@5P/71H99-O<F1E<I-OX
M9I-A<'":4XYE87)A;F-EDV]FDW1H99-T<F&5K')VDV5R<V%LE@5P/7-PF&5CX
M:0QC871I;VYS+I$)R9]4:&63W$!D:7-A8FQECJ&-D2>  -9R97-E<G:5K')EX
M9)L#]YUWDV]R9)AC875S97.8=&AEF&=E;F5R871E9)AE=I'_6.1A;'5A=&]RX
MF'1OF'-K:7"886Z3>9AT<F&3=I-E<G-A;)AI;IAW:&]S98ZAC9$G@ !S<)I3X
MCF5C:0QC871I;VZ6 ^JH:72387!PF&5A<G,LDW=H:6.:K')HDVUAF'F38I!3X
MCF63=7-E9G5LDV9O<I-D96)U9V=I;F<NCJ&-D3D?]%1H998#ZJAC;Y!3CF1EX
MDV9R86=M96Z0K')T.HZ?&(  C9%&8 '<0'1R879E<G-A;)8&+,U <')E;W)DX
M97*33%)P<F6.H8V11F !0'1R879E<G-A;)$&+,U,4G!O<W2.CHZ,BP   !8 X
M                                                 -!/H )R  "-X
MH/VU  "-C9$G@ #:.9$+O_A03U-41$5#3U)!D?\%5E1)3TZ1 ^JH5%)!D?ZQX
MR%9%4E-!3%.2 *.'LM8R,HZ.H (M  "-H/WV  "-D2>  &%P<)I3CF5A<FENX
M9Y8#%FEI;I-T:&639&5C;&%R871I;VYSDW-E8W1I;VZ3<W"896-I#&5SDW1HX
M870LD0- W&%F=&5RDW1H99,,;F%LDV1E8V]R871I;VXLCJ0.@ "-D2>  '1HX
M998#)EIG96YE<F%T962397:1_UCD86QU871O<I-I<Y-T;Y-PD%..97)F;W)MX
MDV&3;&5F="UT;RUR:6=HFJQR=)-P<F5O<F1E<I-T<F&8=IAE<G-A;)-N86UEX
M9(ZAC9$G@ #<3%)P<F76+)L#ZJAF;VQL;Y6L<G>396288I-YF&&8;&5F="UTX
M;RUR:6=HDW28<)!3CF]S=&]R9&5RF'1R89-VDV5R<V%LF&YA;65DF-Q,4G!OX
M<W36+HZ?'TJKC8V1)X  VSDN,BXRCI%0P !4D?[@ ')AE:  =I-E<G-A;)8$X
M@ !A8W1I;VZ3<W"08 !E8VD,8V%T:6]N<XZ?%D  C9$G@ #626Z6 ]Q3861DX
M:71I;VZ3=&^3871T<FEB=71EDV1E#&YI=&EO;G.3*'-E8W1I;VZ3-2XR*2R1X
M ]\P=&AEDV%T=')I8G5T99-R969E<F5N8V63<V5C+8ZAC9$G@ !T:6]N<Y8#X
M^DQO9I-T:&6362T,;&63;6&:K')YDV-O;IAT86END]ET<IO_9F9A=F5R<V%LX
ME@1!E6%C=&EO;I-S<)AEF&-I#&.8871I;VYSD0#]W=8ND05GS$5A8Y"L<FB6X
M _I,;V:3=&AE<V6.H8V1)X  8V]N<VES='.6 [PE;V:389/9='*6_V9F879EX
M<G-A;)L$"'1M;Y-D99AA;FYU;F-I871O<I$!2JO6+)$#Q7)F;VQL;Y6L<G>3X
M962; [PE8I-YF&&8<V5Q=65N8V68;V:8V61Y;F%M:6..H8V1)X  ='*6_V9FX
M879E<G-A;)L$,Z9M;Y-D:0QE<G.1"-0CUF%N9)8#ZR-AD]ET<I'_9F9A=F5RX
M<V%LF&%C=&EO;I$ Y;#6+I$%.E)!DW1R896L<G:397)S86R6 ^LC;6^04XYDX
M99-A;FZ0K')U;F-I871O<I-I<XZAC9$G@ #<0)L#ZJC69F]L;&^5K')WDV5DX
MF&EM;65D:6%T96QYF&*3>9AT:&68;F%M99AO9IAAF'!R979I;W5S;'DM9&5CX
M;&%R9628=')ADW:397)S86PNCJ0,  "-D3D?]%-U<'"04XYO<V6;!!+^=')AX
ME:QR=I-E<G-A;)AS<)53CF5C:0QC871I;VYSF&]FF-Q,4G!R99C686YDF-Q,X
M4G!O<W28UF%SF&%BDV^5K')VDV4ND06QXU1H96Z8:6Z.H8V1)X  =&AEE@/JX
MJ&-OD%..9&639G)A9VUE;I"L<G0ZCI\6  "-D4&_\<ISD13_]#J1&C_Q97APX
M<HZAC9%[?]! >Y8%/_U 3%)P;W-TDW!R:6YT9B@B7&XB*3N1??^X+RJ3,9,JX
M+XZAC9( BS_'0$Q2<&]S=)8%/_U <F5V;W)D97*3*#$IDW!R:6YT9B@B<&]SX
M=&9I>#J6"G_Z(BD[DR\JE@4__3*3*B^.H8V2 (L_QT!,4G!R99$*?_I <F5VX
M;W)D97*6!3_]*#$IDW!R:6YT9B@B7&XB*3N1-'_B+RJ3,Y,J+XZAC9( BS_'X
M0$Q2<')ED0I_^G!R:6YT9B@B<')E9FEX.I$/O_<B*3N14__0+RJ6!3_]-),JX
M+XZAC9%[?]! ?8ZAC9%;_^([CI\8@ "-D2>  -9T:&66 X6;871T<FEB=71EX
MDW)E9F5R96YC99-S96-T:6]NDVAA<Y-F;W5RDW1R896L<G:397)S86R6 X6;X
M86-T:6]NDW-PD%..96-I#&-A=&EO;G.386YDDVYOCJ0.@ "-D2>  &%T=')IX
M8G5T998$[RMD90QN:71I;VYS+I$(1FA%86.:K')HDW-PD%..96-I#&-A=&EOX
M;I-I<Y-A;FYO=6YC96238IAYDV5I=&AE<I/<0$Q2<')ED]9O<HZAC9$G@ #<X
M0$Q2<&]S=-8ND04CW$5A8YJL<FB6 ZN=;V:3=&AED]QP<FEN=&:3UG-T871EX
M;65NF'1SDV-O;G-T:71U=&5SDV&3=')AF':897)S86R386-T:6]N+I$%(]Q4X
M:&6.H8V1)X  9F]R;98$9?=O9I-ADW1R896L<G:397)S86R6!&7W86-T:6]NX
MDVESDW1H8723;V:389-#DV-OD%..9&639G)A9VUE;IJL<G0LD02$RV5X8V5PX
M=)-T:&%TDVETDVUAF'F.H8V1)X  8V]ND*QR=&%I;I8#ZJAR969E<F5N8V5SX
MDW1ODW1H99-A='1R:6)U=&63;YI3CF-C=7)R96YC97.3;V:3=&AEDV%S<V^8X
M8VEA=&5DDW)U;&4NCJ&-D3D?]%1H998$M'IS96-O;F2386YDDW1H:7)DDW-PX
MD%..96-I#&-A=&EO;G.396%CFJQR:)-H89AVF&63W$!R979O<F1E<I$&+,THX
M,2F3UF%SDV&39'DMCJ&-D2>  &YA;6ECFP08DW1R896L<G:397)S86R8;6^0X
M4XYD:0QE<BZ1!<*A09$$&(=D>6YA;6ECF'1R89-VDV5R<V%LF&UOD%..9&D,X
M97*8:7.896ET:&5RF-Q <F5V;W)D97*.H8V1)X  UF]RFP6^&MQ <F5V9&ERX
M96-T:6]NUBR1!C+V9F]L;&^5K')WDV5DF&*3>9AAF'!A<F5NDW1H97-I>F5DX
MF&5X<')E<W-I;VZ8=&AA=)AC;VYF;W)M<XZAC9$G@ !T;Y8%71%#DW-Y;IJLX
M<G1A>"R1!;FK97AC97!TDW1H8723:723;6&8>9-R969E<I-T;Y-T:&63<G5LX
M92=SDV%T=')I8G5T99-OD%..8V-U<G)E;F-E<RZ.H8V1)X  W$!R979O<F1EX
M<I8%M@_686YDD]Q <F5V9&ER96-T:6]ND]9M89JL<GF396%CF&B3;Y!3CF-CX
M=7*38723;6]S=)-O;F-EDVENDV&39VEVF&5NCJ&-D2>  '1R896L<G:397)SX
M86R6!7T>86-T:6]NDW-PFE..96-I#&-A=&EO;BZ1"?!!26:3W$!R979D:7)EX
M8W1I;VZ3UF%P<)AE87)SDVENDW25K')WDV^1!7T>=')ADW:397)S86R.H8V1X
M)X  86-T:6]NE@.-QG-PD%..96-I#&-A=&EO;G.3=VET:&ENDV&39VEVFJQRX
M96Z3871T<FEB=71EDW)E9F5R96YC99-S96-T:6]N+)$#H%IT:&63=)AWF&^3X
M<W"04XYE8RV.H8V1)X  :0QC871I;VYSE@8(\VV:K')U<W23:&&8=IAEDV1IX
M"V5R96Z8=)-A;FZ8=6YC:6%T;W)S+I$+D\!$>6YA;6ECDW1R89AVF&5R<V%LX
MDVUOD%..9&D,97)SCJ&-D2>  &%R998%7B1U<V5DDW1ODV^5K')VDV5R<FEDX
M998%7B1T:&63=')AE:QR=I-E<G-A;)8%7B1S<)!3CF5C:0QC871I;VYSDV]FX
MDV&39VEVFJQR96Z3=')AF':897)S86R3=VAE;HZAC9$G@ !I=)8#1<5R96%CX
MFJQR:&5SDV&39VEVF&5NDVMI;F23;V:3;F^:4XYD92Z1!0'J5&AEDVUOF&1IX
M#&5RD]Q <F5V;W)D97*3V65X<'*1!)!PUFUE86YSDW)O=6=H;'F.H8V1)X  X
M7')E=IJL<F5R<V66 ^Q=;W)D97*3W&EFD]EE>'!RD0%*J]8B+I$%/@!7:&5NX
MDW1H99/<3%)P<F63UG1R89AVF&5R<V%LDW)E86.8:&5SDV&3;F^04XYD99-AX
M=)-W:&ECF&B.H8V1)X  =&AEE@0&S7)U;&63W'.1!BS-.I$,69IE>'!RD]9IX
M<Y-A<'!L:65D+)L$#==T:&6397AP<F5S<VEO;I/<*#$ID]9I<Y-E=I'_6.1AX
M;'5A=&5D+)AA;F238I!3CF5C875S98Z.CHR+    %P                  X
M                                VP"@ G(  (V@_;4  (V-D2>  -HQX
M,)$+O_A/E:QR6)$%'L%-09-#4I-/4Y(!&$FSUC(SCHZ@ BT  (V@_?8  (V1X
M)X  :726 ^2B:7.3;F]N>F5R;RR; ^76=&AEDW1H:7)DDW1R896L<G:397)SX
M86R1 ^2B86-T:6]N+)AW:&ECDVB; ^2B<')I;I-T<YAAF&QI;F689F5E9"R1X
M ^76:7.897AE8W5T962.I Z  (V1)X  87.6 S+2:6:3W$Q2<')ED]9WFJQRX
M97)EDV&3<)!3CF]S=&]R9&5RDW1R89AVF&5R<V%L+)8#5Y=I+F4N+)/9869TX
M97*1!'U]UG1H998#,M)R96-U<G-I=IAEDW1R89AVF&5R<V%LDV]FDW1H98ZAX
MC9$G@ !S=6)T<F5EE@1& 7)OFE..;W1E9)-A=)-T:&63;F^89&4G<Y-S;VQEX
MDV.:K')H:6QD+I$&2NQ4:&6397AE8W5T:6]NDV]FDW1H99-F;W5R=&B3=')AX
MF':897(MCJ&-D2>  '-A;)8#\HAA8W1I;VXLD0/T@-QP<FEN=&8H(G!R969IX
M>#J1#%F:(BD[D0/V>-9I<Y-N;W2380ME8W1E9)-BFJQR>9-A;IAYDV1Y;F%MX
M:6.3=')AF':897)S86R.H8V1)X  ;6^54XYD:0QE<BR1!0T%86YDFP32\V^3X
M8V-U<G.886-C;W)D:6YGF'1OF-Q,4G!R9=8G<Y@H<W1A=&EC*9AS<)-E8VD,X
M8V%T:6]N+)$%#05I+F4ND0?QP-EBEO]F9F5F;W*398ZAC9$G@ #6=&AEFP/JX
MJ'1R896L<G:397)S86R8;V:8=&AEF&.3:&EL9)AS=6)T<F5E+HZAC9$Y'_17X
M:&5NE@2EEG1H99/<3%)P;W-TD]9T<F&5K')VDV5R<V%LFP2EEG)E86.3:&5SX
MF&&8;F^04XYD99AA=)AW:&ECDVB8W'.1!BS-.I$,69IE>'!RD0K28]9I<YAAX
M<"V.H8V1)X  <&QI960LFP2-2'1H998$;,%S96-O;F23=')AE:QR=I-E<G-AX
M;)8$;,%A8W1I;VZ3:7.397AE8W5T960LF'1H99-T<F&5K')VDV5R<V%LE@1LX
MP7!R;Y!3CF-E961SDW1ODW1H98ZAC9$G@ !CFJQR:&EL9)8#ZJAS=6)T<F5EX
M+)-T:&5NDW1H99,,<G-TDW1R89AVF&5R<V%LDV%C=&EO;I-I<Y-E>&5C=71EX
M9"Z.H8V1.1_T5&AEE@12'G!R96-E9&EN9Y-D97-C<FEP=&EO;I-I<Y-G96YEX
M<F%L;'F3<W4.8VEE;I"L<G239F]RDW5N9&5R<W1A;F1I;F>3<)!3CF]S="V.X
MH8V1)X  9&5C;W)A=&EO;IL"][5T<F&5K')VDV5R<V%L<RR1 RA,8G5TF&%PX
M<)!3CF5N9&EXF$*88V]NDW1A:6YSF&&8<'-E=61OE5..8V^39&689&5S8W)IX
M<'1I;VZ8=&AA=(ZAC9$G@ !D97-C<FEBFE..97.6 ^JH=&AEDV*896AAD*QRX
M=FEO<I-S;VUE=VAA=)-M;W)EDV9O<FUA;&QYD?\%5BZ.H8V1.1_T1I'_!59AX
M8VEL:72:K')YE@3+EV9O<I-I;F]R9&5RDW1R89AVF&5R<V%LDVESDW1ODV*0X
M4XYEDVEM<&QE;65NF'1E9)-I;I-F=71U<F63=IAE<G-I;VYSDV]FCJ&-D2> X
M $]X+HZ?*!56C8V1)X  YS$PCI%//FA/>)$&G[QM86-R;W..GQIB(XV1)X  X
MUD]X)W.6!$H7:6YP=723<W":4XYE8VD,8V%T:6]NDVUAD*QR>9-BF&63<W5CX
MD*QR:)-T:&%TDW1H99-S86UEDV]RDW-I;6EL87*3=&5X=)-A<'"896%R<XZAX
MC9$G@ !I;I8%6(MM;W)EDW1H86Z3;VYEDW!L86-EDVENDV%T=')I8G5T99-RX
M969E<F5N8V63<V5C=&EO;G,ND0F"B51H97)EDVESDV&3;6%C<F^.H8V1)X  X
M<W5B<W1I='5T:6]NE@/JJ&9E871U<F63=&AA=)-C86Z38II3CF63=7-E9)-TX
M;Y-D96-R96%S99-VE:QR97)BF&]S:723>98#ZJAI;I-S=6.0K')HDV-A<V5SX
M+HZ?(LJKC8V1)X  XC$P+C&.D55_ZDUA8W)OD06%'&1E#&YI=&EO;G..GQ9 X
M (V1)X  UD]XE@2/%FUA8W)O<Y-A<F639&4,;F5DDVENDW1H99-D96-L87)AX
M=&EO;I-S96-T:6]NDV]FDW1H99-9+0QL92Z1!R8I4W5CD*QR:)-ADV1E9BV.X
MH8V1)X  :6YI=&EO;I8$6]!C;VYS:7-T<Y-O9I-T:&63W$!M86-R;Y/6<F5SX
M97)VFJQR9623=YAO<F0LD01X&F%NDVED96Z8=&D,97*3*'1H99-N86UEDV]FX
MDW1H98ZAC9$G@ !M86-R;RDLFP5Q@&&6!2-5;&5F=)-P87)E;I"L<G1H97-IX
M<RR889-P87)A;65T97*3;&ES="R889-R:6=HFJQR=)-P87)E;IAT:&5S:7,LX
MD05Q@'1H99-BE5..;Y-D>8ZAC9$G@ !O9I8$+:AT:&63;6%C<F\LD00^:&%NX
M9)-T:&63W$!E;F23UG)E<V5R=IJL<F5DDW>8;W)D+I$& >!4:&63<&%R86UEX
M=&5RDVQI<W23:7.389-PD%..;W-S:6)L>8ZAC9$G@ !E;7!TFJQR>98"_$ASX
M97%U96YC99-O9I-I9&5NF'1I#&5R<RR1 ROU96%CF&B3*&EN8VQU9&EN9Y-TX
M:&63;&%S="R1 ROU:6:3=&AEDVQI<W23:7.3;F]N96UP=)AY*8ZAC9$G@ !FX
M;VQL;Y6L<G>3962; _YS8I-YF&&88V]M;6$ND05T0$5A8Y-HF&ED96Z3=&D,X
M97*8:7.889AS97%U96YC99AO9IAL971T97)SF&%N9)AD:6=I=',LD00#9F*0X
M4XYE+8ZAC9$G@ !G:6YN:6YGE@/4PW=I=&B389-L971T97(ND04QE%1H99-BX
ME5..;Y-D>98#U,-O9I-T:&63;6%C<F^3:7.389-S96=M96Z0K')TDV]FDV%RX
M8FET<F%R>9-T97AT+(ZAC9$G@ !T97)M:6YA=&5DE@4?!F*:K')YDW1H99,,X
M<G-TDV^04XYC8W5R<F5N8V63;V:3W$!E;F36+)$%;!UW:71HDW1H99-F;VQLX
M;YAW:6YGDV5X8V5P=&EO;G,ZCJ&-D2>  %=H96Z6!(L3:6YS:61EDV&38V]MX
M;65NFJQR=)-O<I-ADW-T<FEN9RR1!+,M;W*3=VAE;I-P<F5C961E9)-I;6UEX
M9&EA=&5L>9-BF'F3=&AECJ&-D2>  &)A8YJL<FMS;&%S:)8$6\-E<V-A<)!3X
MCF638YAH87)A8W1E<BR1!'@)86Z3;Y!3CF-C=7)R96YC99-O9I/<0&5N9)/6X
M:7.38V]N<VED97)E9)-P87)TDV]FDW1H98ZAC9$G@ !M86-R;YL$8%!BE5..X
M;Y-D>9@H:&5N8V689&^397.8;F]TF'1E<FUI;F%T99AT:&68;6%C<F\I+I$&X
MF=E3=6.5K')HF&&88F%CDVMS;&%S:)ACDVAA<BV.H8V1)X  86-T97*6 ^JHX
M:7.39&5L971E9)-F<F]MDW1H99-M86-R;Y-BE5..;Y-D>9'_!58NCHZ.C(L X
M   8                                                  #G%* "X
M<@  C:#]M0  C8V1)X  VC$PD0N_^$^5K')8D04>P4U!DT-2DT]3D@$82;/6X
M,C2.CJ "+0  C:#]]@  C8V1)X  XC$P+C*.D55_ZDUA8W)OD06%''5S97..X
MJ19  (V1)X  UD]XE@6-*VUA8W)O<Y-A<F63=7-E9)-O;FQYDVENDV%T=')IX
M8G5T99-R969E<F5N8V63<V5C=&EO;G.386YDDVENDV]T:&5RDT]XCJ0.@ "-X
MD2>  &UA8W)O<RZ1!GL 4W5B<W1I='5T:6]NE@16"&^04XYC8W5R<Y-W:&5RX
M99-ADVUA8W)ODW5S99-I<Y-E;F-O=6Z0K')T97)E9)-O=71S:61EDV]FDV&.X
MH8V1)X  <W1R:6YG+)8#ZJAC;VUM96Z0K')T+)-O<I-A='1R:6)U=&63;F%MX
M92Z.H8V1.1_T09$$&<YM86-R;Y8$&=IU<V638V]N<VES='.3;V:3=&AEDVYAX
M;663;V:389-P<F5V:6]U<VQY+61E#&YE9)-M86-R;RR1!"6G86YDDV%NCJ&-X
MD2>  &%R9W5M96Z:K')TE@,S)VQI<W23:6Z3<&%R96Z8=&AE<V5S+I$$^[54X
M:&6387)G=6UE;IATDVQI<W23:7.389-PD%..;W-S:6)L>9-E;7!TF'F3<V5QX
M=65N8V6.H8V1)X  ;V:6!)!3=&5X=)-F<F%G;65NE:QR=',LD02YOF5A8Y-HX
ME@204RAI;F-L=61I;F>3=&AEDVQA<W0IDW-U8YJL<FB39G)A9VUE;IATDW1EX
M<FUI;F%T96238IAYDV&.H8V1)X  8V]M;6$ND03S($ENE@,9:65X<&%N9&ENX
M9Y-ADVUA8W)ODW5S92R1 T-"96%CFJQR:)-T97ATDV9R86=M96Z8=)-I<Y-SX
M=6)S=&ET=71E9)-F;W*396%CF&B.H8V1)X  ;YI3CF-C=7)R96YC998$'9AIX
M;I-T:&63;6%C<F^38IAOF&1YDV]FDW1H99-C;W)R97-PF&]N9&EN9Y-P87)AX
M;65T97*3:6Z3=&AEDVUA8W)OCJ&-D2>  &1E#&YI=&EO;BZ1""SN26:;!.:MX
M8V]M;6%S+)8%):YP87)E;I"L<G1H97-E<RR3;W*88F%CD*QR:W-L87-H97.8X
M87)EF'1OF&%P<)!3CF5A<IAI;IAAF'1E>'2.H8V1)X  9G)A9VUE;I6L<G0LX
MD00Y3'1H97F;!"F2;9-U<W288I!3CF68<')E8V5D96288I-YF&)A8Y-K<VQAX
M<VB897-C87"04XYEF&.3:&%R86-T97)S+)$$.4QW:&ECDVB887)ECJ&-D2> X
M ')E;6^5K')VDV5DE@/JJ&1U<FEN9Y-S=6)S=&ET=71I;VXNCJ&-D3D?]$ETX
ME@/&)&ESDVYO=)-N96-E<W-A<GF3=&AA=)-T:&639&4,;FET:6]NDV]FDV&3X
M;6%C<F^3<')E8V5D99-T:&%TDV]FDV%N;W1H97*.H8V1)X  ;6%C<F^6 TZOX
M:6Z3=VAI8YJL<FB3:723:7.3=7-E9"R1 VWA87.3;F^3;6%C<F^3<W5B<W1IX
M='5T:6]NDV^04XYC8W5R<Y-U;IAT:6R33WB3<')OD%..8V5S<V5SCJ&-D2> X
M '1H998#ZJAA='1R:6)U=&63<F5F97)E;F-EDW-E8W1I;VYS+HZ?(LJKC8V1X
M)X  XC$P+C..D55_ZD5X86UP;&6.IHV1)X  UE1H998#ZJAF;VQL;Y"L<G=IX
M;F>397AC97)P='.39G)O;9-ADUDM#&QEDVEL;'5S=')A=&63=&AEDW5S99-OX
M9I-/>)-M86-R;W,NCHZ.C(L    9                                X
M                  #R"Z "<@  C:#]M0  C8V1)X  VC$QD0N_^$&0K')5X
M5$]-09;_!59424.; ^JH1T5.15)!DU1)3TZ83T:80T]069A2D*QR54Q%4Y%<X
M^)?6,C6.CJ "+0  C:#]^RJJC8V?^   C9$Y'_0NCJ0$  "-D3D?]"Z.H8V1X
M.1_T+HZ.CJD4*02-D2>  ,I ;6%C<F^1!3_]97AP<F1E9G,H;W L*8ZD#   X
MC9$Q__I :98%/_U 97AP<BXQ+F5N=D"3/9- 97AP<BYE;G9 .XZAC9$Q__I X
M:98%/_U 97AP<BXR+F5N=D"3/9- 97AP<BYE;G9 .XZAC9$Q__I :98%/_U X
M97AP<BYT>7!E0),]DW1Y<&5297-O;'9E*$!E>'!R+C$N='EP94 L0&5X<'(NX
M,BYT>7!E0"PI.XZAC9$Q__I :98%/_U 97AP<BYV86QU94"3/9-E>'!R179AX
M;"AO<"Q 97AP<BYT>7!E0"Q 97AP<BXQ+G1Y<&5 +$!E>'!R+C(N='EP94 LX
MCJ&-D@#/?Z! 97AP<BXQ+G9A;'5E0"Q 97AP<BXR+G9A;'5E0(ZAC9( NG^LX
M*3N.H8V1)X  0&5N9(Z?&   C9$G@ ! ;6%C<F^1!3_]='EP95)E<V]L=F4HX
M='EP93$L='EP93(L*8ZAC9$W/_<H*'1Y<&4QE@4__3T]DW1Y<&4R*9,_DW1YX
M<&4QDSJ31DQ/051465!%*8ZAC9$G@ ! 96YDCI\84ZZ-C9_X  "-D3D?]-8NX
MCJ0$  "-D3D?]"Z.H8V1.1_T+HZ.CJ:-D2>  ,HE)8Z?&2D#C8V?^   C9$YX
M'_36+HZD!   C9$Y'_0NCJ&-D3D?]"Z.CHZFC9$G@ #*97AP<I$%/_TZD22_X
MZV5X<'*1%/_T)RHGD1H_\65X<'*.H8V16__B0'N6!3_]97AP<F1E9G,H)RHGX
M+"F30'V.H8V147_H?)$DO^ME>'!RD13_]"<O)Y$:/_%E>'!RCJ&-D5O_XD![X
ME@4__65X<')D969S*"<O)RPIDT!]CJ&-D5%_Z'R1)+_K97AP<I$4__0G*R>1X
M&C_Q97AP<HZAC9%;_^) >Y8%/_UE>'!R9&5F<R@G*R<L*9- ?8ZAC9%1?^A\X
MD22_ZV5X<'*1%/_T)RTGD1H_\65X<'*.H8V16__B0'N6!3_]97AP<F1E9G,HX
M)RTG+"F30'V.H8V147_H.XZ?&;<[C8V?^   C9$Y'_36+HZD!   C9$Y'_0NX
MCJ&-D3D?]"Z.CHZD#H  H8V1)X  5&AEE@0W?VED96Z0K')T:0QE<I/<97APX
M<D5V86R3UG)E9F5R96YC9623:6Z3=&AEDV1E#&YI=&EO;I-O9I-T:&63W&5XX
M<')D969SD]9M86-R;XZAC9$G@ !I<Y8#SPIT:&63;F%M99-O9I-E:71H97*3X
M89-#DVUA8W)ODV]RDT.39G5N8W1I;VXND04OJU1H99-/>)-M86-R;Y/<='EPX
M95)E<V]L=F6.H8V1)X  UF%BD%..;Y6L<G:399L#%Z=C;VZ3=&%I;G.8;F^8X
M3W@M<W"04XYE8VD,8YAC;VYS=')U8W1SF&%N9"R1 T':87.889AM871T97*8X
M;V:8<W23>6QE+)$#0=IC;W5L9)AH89-VDV6.H8V1)X  8I!3CF5E;I8#ZJADX
M96-L87)E9)-I;G-T96%DDV%SDV&30Y-M86-R;Y-O<I-#DV9U;F-T:6]N+HZ?X
M)\0YC8V1)X  YS$QCI%//FA!=71O;6%T:6.6!I^\9V5N97)A=&EO;I-O9I-CX
M;W"1_W*P>9-R=6QE<XZ?&F(CC9$G@ #63V9T96Z6 RGJ89-9+0QL99-H87.3X
M871T<FEB=71EDV1E#&YI=&EO;G.3=&AA=)-F=6YC=&EO;I-O;FQYDW1ODV-OX
M<)"L<GF386Z3:6YS=&%N8V6.H8V1)X  8II3CF5L;VYG:6YGE@+"QG1ODV]NX
M99-N;YAD99-T;Y-ADVQI:Y"L<F4M;F%M9623:6YS=&%N8V638IAE;&]N9VENX
M9Y-T;Y-T:&63;F^89&4G<Y-P87)E;I"L<G2.CHZ,BP   !H             X
M                                     />0H )R  "-H/VU  "-C9$GX
M@ #:,3&1"[_X09"L<E543TU!EO\%5E1)0YL#ZJA'14Y%4D&35$E/3IA/1IA#X
M3U!9F%*0K')53$53D5SXE]8R-HZ.H (M  "-H/WV  "-D2>  &]RE@7)RF.:X
MK')H:6QD+I$*UD9,87)G99-A='1R:6)U=&639W)A;6UA<G.3=&5N9)-T;Y-HX
M89AVF&63;6%NF'F3<W5CF&B39&4,;FET:6]N<RR.I Z  (V1)X  =VAI8Y"LX
M<FB6!+6987)EDW-O;65T:6UE<Y-C86QL9623V6.1_V9F;W!YD03MOG)U;&5SX
MD0#]W=8ND0>9LE1H99-S:71U871I;VZ3:7.38V]N<W!I8W5O=7.3=VAE;HZAX
MC9$G@ !C;VZ:K')T97AT=6%LE@/JJ&EN9F]R;6%T:6]NDVESDVUOF':89623X
M;&5A9G>887)DDW9I89-I;FAE<FET9623871T<FEB=71E<RZ.H8V1.1_T5&AEX
ME@0FC4]XDW5S97*3;6&0K')YDW!L86-EDVENDW1H99-D96-L87)A=&EO;G.3X
M<V5C=&EO;I-O9I-T:&6362T,;&63=&AEDV-O;BV.H8V1)X  <W1R=6-T.HZAX
MH8V1.1_TW$!A=71O:6YHD0/JJ-<\UDE$C9$ M'B)  !F9@ #AF:.D00ZWFQIX
M<W37/HZAH8V1)X  UG=H97)EE@0)B=<\UDE$C9$ M'B)  !F9@ #AF:.D00ZX
MWFQI<W37/I/6:7.389-W:&ET97-P86-E+7-E<&%R871E9)-L:7-TDV]FDV%TX
M=')I8G5T99-N86UE<RZ1!96#4W5P<)!3CF]S98ZAC9$G@ !T:&%TE@.OKMQAX
M='1R8DE$D0.OG]9I<Y-S=6.:K')HDV%NDV%T=')I8G5T99-N86UE+)$#NWIAX
M;F23=&AEDV%BD%..;YAVF&638V]N<W1R=6-TDVESDV9O;&QOF'>8962.H8V1X
M)X  8IJL<GF6 Y;"86Z3W$!A='1R:6)U=&5SD]9D96-L87)A=&EO;I-W:&5RX
M96*8>9/<871T<F))1)$#EJS6:7.39&5C;&%R962387.386Z3871T<FEB=71EX
MCJ&-D2>  &]FE@/]MW1H99-G<F%M;6%RDW-Y;9JL<F*04XYO;)/<9U-Y;=8NX
MD05R#51H96Z33WB3:VYOF'=SDW1H8723W&%T=')B2421 _VRUFESDV%NDVENX
M:&5R:71E9(ZAC9$G@ !A='1R:6)U=&66 PB?;V:3W&=3>6W6+I$$[8A&D?\%X
M5G5R=&AE<BR1 S749F]RDV%NFJQR>9-R=6QEDVAAF'9I;F>3W&=3>6V3UF]NX
MDW1H99-22%,LDT]XDW-E87)CF&AE<XZAC9$G@ !T:&%TE@/?*W)U;&4G<Y-AX
M='1R:6)U=&63<F5F97)E;F-EDW-E8W1I;VZ39F]RDV1E#&YI=&EO;G.3;V:3X
M=&AEDU)(4Y$#WREOD%..8V-U<G)E;F-E<XZAC9$G@ !O9I8$* _<871T<F))X
M1-8NDU=H96Z3<W5CFJQR:)-ADV1E#&YI=&EO;I-I<Y-M:7-S:6YG+)$$-VE/X
M>)-CF&AE8YAK<Y-W:&5T:&5RDW1H99-,2%..H8V1)X  :&%SE@/3+&%NDV^0X
M4XYC8W5R<F5N8V63;V:3W&%T=')B2436+I-)9I-S;RR1 ]?>3WB39V5N97)AX
M=&5SDV1E#&YI=&EO;G.3=&AA=)-C;W"0K')YDW1H872.H8V1)X  3$A3FP03X
M06^04XYC8W5R<F5N8V66!!-,=&^396%CD*QR:)-22%.8W&%T=')B2428UF^0X
M4XYC8W5R<F5N8V63=&AA=)-L86.0K')K<Y-ADV1E#&YI=&EO;BZ1!;++26:.X
MH8V1)X  =&AE<F66 ^JH:7.3;F^3<W5CD*QR:)-,2%.3;Y!3CF-C=7)R96YCX
M92R33WB3:7-S=65SDV%NDV5R<F]RDVUE<W-A9V4NCJ&-D3D?]%1H97)EE@2WX
MXVESDV%NDV%N86QA9V]U<Y-C;VYS=')U8W239F]RDV%U=&]M871I8Y-G96YEX
M<F%T:6]NDV]FDV1E#&YI=&EO;G..H8V1)X  ;V:6 ^JH<WEND*QR=&AE<VEZX
M9623;Y!3CF-C=7)R96YC97,ZCJ&AC9$Y'_3<0&%U=&]S>6Z1 ^JHUSS6242-X
MD0"T>(D  &9F  .&9HZ1!#K>;&ES=-<^CJ&AC9$G@ #65VAE;I8%=8)T:&63X
MW$!A=71O<WEND]9C;VYS=')U8W23:7.3=7-E9"R1!=@Y3WB3=')I97.3=&^3X
M<W5P<&QYDVUI<W-I;F>39&4,;FDMCJ&-D2>  '1I;VYSE@2+3V]FDW-Y;IJLX
M<G1H97-I>F5DDV^04XYC8W5R<F5N8V5SDV*8>9-S96%R8YAH:6YGDW1H99-2X
M2%.1!(LE9F]RDW-A;64M;F%M9623;Y!3CF,MCJ&-D2>  &-U<G)E;F-E<RZ1X
M"DMX26:6!9N%97AA8W1L>9-O;F63<W5CD*QR:)-22%.1!9L6;Y!3CF-C=7)RX
M96YC99-I<Y-F;W5N9"R1!@>]3WB39V5N97)A=&5SDV&.H8V1)X  9&4,;FETX
M:6]NE@/JJ'1ODV-O<)"L<GF3:723=&^3=&AEDTQ(4RR3;W1H97)W:7-EDW1HX
M97)EDVESDV%NDV5R<F]R+HZAC9$Y'_14:&61!(I,86*:4XYOE:QR=I-E+61EX
M<V-R:6*89626!(I,8V]N<W1R=6-T<Y-H896L<G:3998$BDQADV=L;V)A;)-CX
MD*QR:&%R86-T97*3:6Z3=&AA=)-ADW-I;F=L98ZAC9$G@ #<0&%U=&]S>6Z6X
M X'.UF]RD]Q 875T;VEN:)/69&5C;&%R871I;VZ38V%NDV5A<VEL>9-BD%..X
M99-U<V5DDW1ODW-U<'!L>9-M:7-S:6YGDV1E#"V.H8V1)X  ;FET:6]N<Y8"X
MR/9F;W*386QLDV^04XYC8W5R<F5N8V5SDV]FDV%T=')I8G5T97.3;V:389-GX
M:7::K')E;I-N86UE+I$$V$]4:&5S99-R97-E<G:89623=YAO<F1SCJ&-D2> X
M &UAFJQR>98$A_!BD%..99-U<V5DDVENDV&3;6]R99-C;VYS97)VD?]8Y&%TX
M:7:899-WF&&8>9-T:&%TDV=E;F5R871E<Y-M:7-S:6YGDV1E#&YI=&EO;G..X
MH8V1)X  ;VYL>98#ZJAF;W*3;YI3CF-C=7)R96YC97.38IAE;&]N9VEN9Y-TX
M;Y-ADW-E;&5C=&5DDW-E=)-O9I-G<F%M;6%RDW-Y;9"L<F*8;VQS.HZAC9$YX
M'_1!D*QR='1R:6)U=&66!@A/9&5C;&%R871I;VYSDV%R99-W<FET=&5NDV%SX
MDW5S=6%L+)$&C[AE>&-E<'23=&AA=)/<0&%U=&]I;FB3UF]RCJ&-D2>  -Q X
M875T;W-Y;I8%"I?6;6&0K')YDV%P<)I3CF5A<I-BF&5F;W)EDW1H99-A='1RX
M:6)U=&4G<Y-TD*QR>7"899-S<)AE8VD,97*3*&DN92XLD052DV%F=&5RD]AFX
MD]9O<HZAC9$G@ #<.]8I+I$%-R57:&5R998#Y7C7/-9)1(V1 +1XB0  9F8 X
M X9FCI$$.MYL:7-TUSZ3UFESDW1H99-U<W5A;)-C;VUM82V3<V5P87)A=&5DX
MDVQI<W23;V:3871T<FEB=71EDVYA;65S+(ZAC9$G@ !A;F26 ^JHW&%T=')BX
M2423UFESDV&3;65MD*QR8I!3CF5RDV]FD]<\UDE$C9$ M'B)  !F9@ #AF:.X
MD00ZWFQI<W37/M8ZCJ&.CHR+    &P                              X
M                    _<6@ G(  (V@_;4  (V-D2>  -HQ,9$+O_A!D*QRX
M551/34&6_P565$E#FP/JJ$=%3D5209-424].F$]&F$-/4%F84I"L<E5,15.1X
M7/B7UC(WCHZ@ BT  (V@_?8  (V1.1_TW$!A='1R:6)U=&5SD16*G-AFCI\3X
M*JJ-C9_X  "-D@"BWZS6+HZD!   C9( HM^L+HZAC9( HM^L+HZ.CJ0.@ "-X
MD@"BWZS<0&%U=&]I;FB; ^JHUSS6=)"L<GEPE5..97-PDV5CUSZ8/-9)1(V1X
M +1XB0  9F8  X9FCI$$.MYL:7-TUSZ8W#N.GQ)__HV-G_@  (V2 *+?K-8NX
MCJ0$  "-D@"BWZPNCJ&-D@"BWZPNCHZ.H8V2 )$_N-AGCJ&-D@"5*F#7/-9GX
M<F%M;6%RC9$ M'B)  !F9@ #AF:.E@0ZWG-Y;9"L<F*04XYO;(V1 +1XB0  X
M9F8  X9FCI-L:7-TUSZ.H:&-D2>  -9D96-L87)E<Y8$O-S<871T<F))1)$$X
MO*7687.386Z3:6YH97)I=&5DDV%T=')I8G5T99-W:&5N97::K')E<I-I=)-OX
MD%..8V-U<G.3:6Z389-S>6V88I!3CF]LCJ&-D2>  &ENFP/$D=<\UF=R86UMX
M87*-D0"T>(D  &9F  .&9HZ6!#K><WEMD*QR8I!3CF]LC9$ M'B)  !F9@ #X
MAF:.DVQI<W37/M8ND04L+D:1_P56=7)T:&5R+)$#S#!T:&ESF&EN<W1R=6-TX
M<YA/>)AT;YAA='1E;7!TF'1OF'-U<'!L>8ZAC9$G@ !M:7-S:6YGE@/JJ&1EX
M#&YI=&EO;G.3;V:3<W5CFJQR:)-OD%..8V-U<G)E;F-E<Y-BF'F38V]PF'EIX
M;F>39G)O;9-T:&633$A3+HZAC9$Y'_3<0&%U=&]S>6Z6 ^JHUFUAD*QR>9-BX
MFE..99-U<V5DDVQOF&-A;&QYDVENDV%NDV%N86QA9V]U<Y-M86YN97(NCJ&-X
MD3D?]$:1_P56;W*6!,QQ<V%F972:K')YDVENDW1H99-U<V63;V:3W$!A=71OX
M<WEND]9A;F23W$!A=71O:6YHUBR1!03D=&AE<F63:7.3<')OF'9I9&5DDW1HX
M98ZAC9$G@ #<0'=A<FZ6!$=KUG)E<V5R=IJL<F5DDW>8;W)D+I$&3RI7:&5NX
MDVETDVEM;65D:6%T96QYDV9O;&QOF'=SD]Q 875T;W-Y;I/6;W*3W$!A=71OX
M:6YHUBR.H8V1)X  3WB6!(24:7-S=65SDV&3=YJL<F%R;FEN9Y-F;W*396%CX
MF&B39&4,;FET:6]NDW-U<'!L:65DDV*8>9-V:7)T=663;V:3=&AEDW!R96-EX
M9&EN9XZAC9$G@ #<0&%U=&]S>6Z6!6V3UF]RD]Q 875T;VEN:-8ND0G!HMQ X
M=V%R;I/6:7.3;6%I;FQYDW1ODV*:4XYEDW5S9623=VAE;I-M;YAD:69Y:6YGX
MDW1H98ZAC9$G@ !A='1R:6)U=&61 ^JH9W)A;6UA<BZ.GR+*JXV-D2>  .(QX
M,2XQCI%5?^I%>&%M<&QECI\60 "-D2>  -94:&66 ^JH9F]L;&^:K')W:6YGX
MDV-OD%..9&639G)A9VUE;IATDVENDW1H99-D96-L87)A=&EO;G.3<V5C=&EOX
M;I-O9I-T:&6362T,;&4ZCHZ.C(L    <                            X
M                      $)): "<@  C:#]M0  C8V1)X  VC$QD0N_^$&0X
MK')55$]-09;_!59424.; ^JH1T5.15)!DU1)3TZ83T:80T]069A2D*QR54Q%X
M4Y%<^)?6,CB.CJ "+0  C:#]^RJJC8V?^   C9%<7]PNCJ0$  "-D5Q?W"Z.X
MH8V17%_<+HZ.CI\8@ "-D49@ =Q 875T;VEN:)$&+,UE;G:.J1T  (V11F !X
M0&%T=')I8G5T97.6!BS->W-T<G5C=)-E;G:3*F5N=CN.I Z  (V2 ):F:G)EX
M9TYU;51Y<&61!BS-;6%X4F5G3G5M.XZAC9( D'F=?8ZAC9( D'F=97AE8T5LX
M96V1!BS-<W1A=&5M96YTCJ:-D49@ 4!A=71O<WEND08LS6UA>%)E9TYU;8ZFX
MC9%&8 % 871T<FEB=71E<Y8&+,U[<W1R=6-TDV5N=I,J96YV.XZAC9( EJ9JX
M0&%U=&]I;FB6!BS-<F5G3G5M5'EP99-R96=.=6T[CJ&-D@"6IFIR96=.=6U4X
M>7!ED08LS6UA>%)E9TYU;3N.H8V2 ):F:G-T<G5C=)8&+,US>6V3*F9O<FU0X
M87)A;4QI<W0[CJ&-D@"6IFIS=')U8W26!BS-<WEMDRIF=6YC.XZAC9( EJ9JX
M;&EN94YU;51Y<&61!BS-;&EN93N.H8V2 )!YG7V.H8V2 )!YG6%C=%!A<F%MX
M3&ES=(ZFC9%&8 % 871T<FEB=71E<Y8&+,U[<W1R=6-TDV5N=I,J96YV.XZAX
MC9( EJ9J0&%U=&]S>6Z6!BS-0'=A<FZ3<W1R=6-TDW-Y;9,J=F%R3&]C+"IFX
M=6YC3&]C.XZAC9( EJ9J<F5G3G5M5'EP99$&+,UR96=.=6T[CJ&-D@"6IFIRX
M96=.=6U4>7!ED08LS6UA>%)E9TYU;3N.H8V2 )!YG7V.H8V2 )!YG6)L;V-KX
MD08LS6)L;V-K16QE;4QI<W2.GQHJJHV-G_@  (V17%_<UBZ.I 0  (V17%_<X
M+HZAC9%<7]PNCHZ.H:&-D2>  &-A=7-E<Y8%HPI/>)-T;Y-A='1E;7!TDW1OX
MDV%U=&]M871I8V%L;'F3<W5P<&QYDVUI<W-I;F>39&4,;FET:6]N<Y-F;W*3X
M;Y!3CF,MCJ&-D2>  &-U<G)E;F-E<Y$#ZJAO9CJ.CHZ,BP   !T         X
M                                         0Y H )R  "-H/VU  "-X
MC9$G@ #:,3*1"[_X1DE,12U,159%3)8#ZJA/4IJL<D=!3DE:09'_!59424].X
MDT]&DT^86)$%'L%%5I'^L<A!3%5!D?\%5E1/4E.1.8."UC(YCHZ@ BT  (V@X
M_?8  (V-C8V1./_OV ^.CHZ11-_LW&5N=I8"G'#69F]RD]QE>&5C16QE;=8LX
ME@+?2-QS=&%T96UE;G36+)/<86-T4&%R86U,:7-TUBR3W&)L;V-KUBR386YDX
MD0*<<-QB;&]C:T5L96U,:7-TCJ08@ "-C8V-D3C_[]@/CHZ.D43?[-QM87A2X
M96=.=6V6 ^JHUF9O<I/<86-T4&%R86U,:7-TUBR3W&)L;V-KUBR386YDD]QBX
M;&]C:T5L96U,:7-TCJ&-C8V-D3C_[]@/CHZ.D43?[-QR96=.=6V6 ^JHUF9OX
M<I/<86-T4&%R86U,:7-TCJ&-C8V-D3C_[]@/CHZ.D43?[-QV87),;V.6 ^JHX
MUF9O<I/<8FQO8VN3UF%N9)/<8FQO8VM%;&5M3&ES=-8LDW=I=&B3=Y"L<F%RX
M;FEN9XZAC8V-C9$X_^_8#XZ.CI%$W^S<9G5N8TQO8Y8#ZJC69F]RD]QB;&]CX
M:Y/686YDD]QB;&]C:T5L96U,:7-TUBR3=VET:)-WD*QR87)N:6YGCI\H%5:-X
MC9$G@ #G,3*.D4\^:$9I;&4M;&5VD?]RL&5LE@:?O&]R9V%N:7IA=&EO;I-OX
M9I-/>)-E=I'^Y6!A;'5A=&]R<XZ?'>(CC8V1)X  XC$R+C&.D55_ZD-O;I6*X
M/7:396Z3=&EO;G.6!84<;V:3;F%M:6YGDT]XDV]U='!U=),,;&5SCJD60 "-X
MD2>  -9/>)8#KW9T<F%N<VQA=&5SDW1H99-9+0QL99-I;IJL<G1ODV&3#&QEX
MDV1E<W1I;F5DDV9O<I-P<F^04XYC97-S:6YGDV*8>9-9D?\%5F%C8RR1 [M-X
M9VEVF&5NDW1H98ZD#H  C9$G@ !N86UED09Y,-QO>&]U="YYUBZ;!/[;5&AEX
ME@,\F$PM#&QE<Y-A<F63=')A;G-L871E9)-I;I"L<G1ODPQL97.39&5S=&ENX
M96239F]RDTQE>"Z826:3=&AE<F6.H8V1)X  :7.6 V3^97AA8W1L>9-O;F63X
M3"T,;&4LD0-_N6ET<Y-C;W)R97-PD%..;VYD:6YGDV]U='!U=),,;&63:7.3X
M;F%M9623W&]X;W5T+FS6+I$%#%))9I-T:&5R98ZAC9$G@ !I<Y8%GFUM;W)EX
MDW1H86Z3;VYEDTPM#&QE+)$&"UYT:&638V]R<F5S<)!3CF]N9&EN9Y-O=71PX
M=71SDV%R99-N86UE9)/<;WAO=70P+FS6+(ZAC9$G@ #<;WAO=70Q+FS6+)8#X
MZJC<;WAO=70R+FS6+)-E=&,NCI\BRJN-C9$G@ #B,3(N,HZ157_J4F5V:65WX
M.I$&VRUC;VV0BCUB:6YI;F>6!(,K=&AEDV]U='!U='.3;V:369'^GKAA8V.3X
M86YDDTQE>(ZFC9$G@ #626Z6!*-A9&5VD*QR96QO<&EN9Y-A;I-O<F1I;F%RX
M>9,H:2YE+BR;!-&/;F]N+4]X*9-9D?\%5F%C8R],97B397:1_UCD86QU871OX
M<BR8W'DN=&%B+F.3UF%N9(ZAC9$G@ #<;&5X+GEY+F.6 T CUF-A;I-BD%..X
M99-C;VUP:6QE9)-I;6UE9&EA=&5L>9-I;IJL<G1ODV%NDV5X96-U=&%B;&63X
M#&QEDV*8>9-P;&%C:6YGDW1H98ZAC9$G@ !L:6YECJ08@ "-D5CF:-PC:6YCX
M;'5D99$&+,TB;&5X+GEY+F,BCJ&-D2>  -9I;I8#ZJAADT,M8V^:4XYD99-SX
M96-T:6]NDV]FDW1H99-9D?\%5F%C8Y-I;G!U=)-S<)AE8VD,8V%T:6]NDUN-X
M3&5S:Y,W-8Z1)Q#W72Z.I Z  (V1.1_T06QT97)N871I=IJL<F5L>9;_!58LX
MD0.XT5F386-CE@.L6V-A;I-BD%..99-I;G-T<G5C=&5DDRABF'F3=7-I;F>3X
M=&AED]PM9)/68V]M;6%N9"UL:6YEDV]P+8ZAC9$G@ !T:6]N*98#)"YT;Y-PX
M<F^04XYD=6-EDV&3<V5P87)A=&63#&QED]QY+G1A8BYHD]9T:&%TDV-O;IJLX
M<G1A:6YSDV1E8VQA<F%T:6]N<Y-N965D96238IAYCJ&-D2>  &*:4XYO=&B6X
M V;\W'DN=&%B+F.3UF%N9)/<;&5X+GEY+F/6+I$%#/Q4:&63=)6L<G>3;Y8#X
M9OP,;&5SDVUAD*QR>9-T:&5NDV*899-C;VUP:6QE9)-S97!A<F%T96QYCJ&-X
MD2>  &EFE@/JJ'1H99-L:6YECJ08@ "-D5CF:-PC:6YC;'5D99$&+,TB>2YTX
M86(N:"*.H8V1)X  UFESE@*O"G!L86-E9)-I;I-ADT,M8V^:4XYD99-S96-TX
M:6]N<Y-O9I-T:&633&5XDVEN<'5TDW-PF&5C:0QC871I;VXND03/JU1H99-TX
ME:QR=Y-OD0*O"G)E<W5L=&EN9XZ?#H  C9$G@ !O8I$ IQQJ96-TE@/JJ QLX
M97.38V%NDW1H96Z38II3CF63;&EN:Y"L<F5DDW1ODW!R;YAD=6-EDV%NDV5XX
M96-U=&%B;&63#&QE+HZ.CHR+    '@                              X
M                   !$=*@ G(  (V@_;4  (V-D2>  -HQ,Y$+O_A#3TU-X
M04Y$+4Q)3D66 ^JH3U!424].4Y-!3D233U1(15*34$])3E13D4?82]8S,(Z.X
MH (M  "-H/WV  "-C9$G@ #B,3(N,XZ157_J0V]MD(H]8FEN9626!84<=7-EX
MDV]FDT]X+)-9D?Z>N&%C8RR386YDDTQE>(ZI%D  C9$G@ #65&AE<F66!"4OX
M87)EDV-E<G1A:6Z39&5C;&%R871I;VYSDW1H8723;9"L<G5S=)-BD%..99-VX
M:7-I8FQEDV9R;VV386QLDV]FDW1H99,,;&5SDW!R;RV.I Z  (V1)X  9'5CX
M9626 PC58I"L<GF33W@ND03MFD)YDV1E9F%U;'0LD0,U_T]XDW!R;Y!3CF1UX
M8V5SDPQL97.3<W5I=&%B;&639F]RDW-E<&%R871EDV-O;7!I;&%T:6]N+(ZAX
MC9$G@ !I;F%S;96L<G5CDVB6! ^A87.3=&AEDUF1_P5686-C+61E<W1I;F5DX
MDPQL99-A;F23=&AEDTQE>"UD97-T:6YE9),,;&4H<RF396%CFJQR:)-C;VZ8X
M=&%I;HZAC9$G@ !T:&66!.2;8V]M;6]NDV1E8VQA<F%T:6]N<RZ1"":Z3WB3X
M86QS;Y-S=7!PD%..;W)T<Y-T:&63;VYE+7-T97"39&5VE:QR96QO<&UE;I-TX
MD03DFV%P+8ZAC9$G@ !P<F]A8Y"L<FB6!!:B9&5S8W)I8II3CF5DDV%BF&^5X
MK')VDV4ND06\SD)YE@06HG!L86-I;F>3W"UHD]9O;I-/>"=SDV-O;6UA;F23X
M;&EN92R1!"&@=&AEDV1E<VEG;F5RCJ&-D2>  &-A;&QSE@3N1&9O<I-G96YEX
M<F%T:6]NDV]FDV&3#&QED]QO>&]U="YHD]9C;VZ0K')T86EN:6YGDW1H99-CX
M;VUM;VZ39&5C;&%R871I;VYS+(ZAC9$G@ !W:&ECFJQR:)8#ZJAA<F63=&AEX
M;I-A8G-E;IATDV9R;VV33W@G<Y-O=&AE<I-O=71P=723#&QE<RZ1!3C@26Z3X
M=&AI<Y-C87-E+)-T:&63;&EN98ZD&(  C9%8YFC<(VEN8VQU9&61!BS-(F]XX
M;W5T+F@BCJ&-D2>  -9I<Y8#ZJAP;&%C9623:6Z3=&AEDUDM#&QE+HZ?(LJKX
MC8V1)X  XC$R+C2.D55_ZE20BCUY<&EC86R6!84<8V]M;6%N9)-S97%U96YCX
M97..IHV1)X  UE1H998%HH%F;VQL;Y"L<G=I;F>3<V5Q=65N8V63;V:3<VAEX
M;&R38V]M;6%N9'.3:7.386Z397AA;7!L99-O9I-T:&63<V5P87)A=&6.I Z X
M (V1)X  8V]M<&EL871I;VZ6!.@G87!P<F]A8Y"L<FB39&5S8W)I8I!3CF5DX
M+I$(,5Y);I-T:&ESDV5X86UP;&4LD04GAT]XDW1R86YS;&%T97.3=&AEDUDMX
M#&QECJ&-D2>  -QE=BY9FP0L*]9I;I"L<G1OE@0L/-QO>&]U="YYD]9A;F23X
M=&AEDTPM#&QED]QE=BY,F-9I;I"L<G1OD]QO>&]U="YLUBZ1!?V=5&AEDVQAX
M<W238V]M;6%N9)-O9HZAC9$G@ !T:&66 ^JH<V5Q=65N8V63;&EN:W.3=&AEX
MDW25K')WDV^6 ^JH;V*1 *<<:F5C=),,;&5S+)-Y:65L9&EN9Y-T:&6397AEX
M8W5T86)L99,,;&63W&5VUBZ.J1D  (V147_HRF]XE@4__65V+EF3978N3(ZDX
M#   C9%1?^AY86-CE@4__2UDDV]X;W5T+GF.H8V147_H;&5XD04__6]X;W5TX
M+FR.H8V147_H8V.6!3_]+6.3>2YT86(N8XZAC9%1?^AC8Y8%/_TM8Y-L97@NX
M>7DN8XZAC9%1?^AC8Y8%/_TM;Y-E=I-Y+G1A8BYODVQE>"YY>2YODRUL;),MX
M;'F.IHV1.1_TUE1H998#ZJAF;VQL;Y"L<G=I;F>38V]M;6%N9)-S97%U96YCX
M99-D;Y!3CF5SDV&3;VYE+7-T97"38V]M<&EL871I;VXNCI\6  "-D5%_Z,IOX
M>)8%/_TM:)-E=BY9DV5V+DR.H8V147_H>6%C8Y$%/_UO>&]U="YYCJ&-D5%_X
MZ&QE>)$%/_UO>&]U="YLCJ&-D5%_Z&-CE@4__7DN=&%B+F.3+6QLDRUL>8Z?X
M*!56C8V1)X  YS$SCI%//FA#;VUM86YD+6QI;F66!I^\;W!T:6]N<Y-A;F23X
M;W1H97*3<)$ C4]O:6Z1_W*P='..GQIB(XV1)X  UE1H:7.6 _\6<V5C=&EOX
M;I-D97-C<FEBFE..97.3<V]M99,,;F63<)AO:6Z0K')T<RR1! 0Q;6]S=&QYX
MDW)E;&%T9623=&^33WB38V]M;6%N9"UL:6YECI\.@ "-D2>  &]P=&EO;G,NX
MD04XX%5S998#ZJAO9I-T:&]S99-O<'1I;VYSDVESDW-U;6UA<FEZ9623:6Z3X
M87!PD%..96YD:7B31"Z.CHZ,BP   !\                             X
M                     1G8H )R  "-H/VU  "-C9$G@ #:,3.1"[_X0T]-X
M34%.1"U,24Y%E@/JJ$]05$E/3E.304Y$DT]42$52DU!/24Y44Y%'V$O6,S&.X
MCJ "+0  C:#]]@  C8V1)X  XC$S+C&.D55_ZD5R<F]RD06%'')E8V^5BCUVX
MDV5R>8ZI%D  C9$G@ #669'_!59A8V.6 XU?:&%SDW!R;YJL<G9I<VEO;G.3X
M9F]RDV)U:6QD:6YGDW!A<G-E<G.3=&AA=)-A='1E;7!TDW1ODW)E8V^8=IAEX
M<I-F<F]MDW-Y;IAT87B.I Z  (V1)X  97)R;W)S+)L$'C5A;F26!!/F=&AEX
MDV1E<VEG;F5RDV-A;I-U<V63=&AEDW>0K')O<F1SD]QE<G)O<M8LF-QY>65RX
M<F]KUBR886YDD]QY>6-L96%R:6Z.H8V1)X  UG1OE@.HHFEM<&QE;65NFJQRX
M=)-S=6.8:)-E<G)O<I-R96-OF':897)YDUN-2F]H;G-O;I$#ZJ@W-8Z1.:N5X
M72Z1!2+>5VAE;I-ADW!A<G-E<I-T:&%TDV5M<&QOF'ESCJ&-D2>  '-U8Y6LX
M<FB;!,6E=&5CDVAN:7%U97.89&5T96-T<YAAF'-Y;I-T87B897)R;W(LD03\X
M9&ETF&UADWF8871T96UP=)AT;YAR96-ODW:397*88I-YF'"04XYO<"V.H8V1X
M)X  <&EN9Y8$LT1I=&5M<Y-F<F]MDVET<Y-S=&%CFJQR:Y-O<I-BF'F39&ESX
M8V%R9&EN9Y-T;VN896YS+I$'DK5$=7)I;F>3;F]R;6%LDW!A<G-I;F<LCJ&-X
MD2>  '1H998$M"Q/>"UG96YE<F%T962397:1_UCD86QU871O<I-S>6YCFJQRX
M:')O;FEZ97.3:71SDW-T86.8:Y-O<)!3CF5R871I;VYSDW=I=&B3=&AO<V63X
M;V:.H8V1)X  =&AEE@4**5F1_P5686-C+6=E;F5R871E9)-P87)S97*3*'-EX
M99-S96-T:6]NDS<I+I$(EV)7:&5NDW1H99-P87)S97*3:7.38G5I;'23=7-IX
M;F>.H8V1)X  W&5R<F]RUBR6 ]-GW'EY97)R;VO6+)-O<IL#S9?<>7EC;&5AX
M<FENUBR386YDF&&8<WEND*QR=&%XF&5R<F]RF&^04XYC8W5R<RR3=&AI<YASX
M>6YCD*QR:')O;FEZ82V.H8V1)X  =&EO;I8$CV=I<Y-L;W-T+I$')QQ)=)-IX
M<Y-PD%..;W-S:6)L99-F;W*3=&AEDV5VD?]8Y&%L=6%T;W*3=&^38V]R<G5PX
M=)-I='.3<W1A8Y"L<FN386YDDV=ODV]U=(ZAC9$G@ !O9I8#R=QC;VZ:K')TX
M<F]LDVENDW-U8YAHDV-A<V5S+I$%+?%/>)-P<F^8=FED97.3=&AEDV9U;F-TX
M:6]ND]QY>7EE<G)O<I/6=&^3<')E=IAE;IATDW-U8YAHCJ&-D2>  &.:K')HX
M86]S+I$(@BQ4:&66!0,7<&%R<V5RDV-A;&QSD]QY>65R<F]RD]9U<)!3CF]NX
MDV%NF'F3<WENF'1A>)-E<G)O<BR1!4DR86YDDW1H99-D97-I9VYE<HZAC9$GX
M@ !S:&]U;&26!9X%=W)I=&63W'EY97)R;W*3UG-U8YJL<FB3=&AA=)/<>7EYX
M97)R;W*3UFESDV5X96-U=&5DDV%TDVQE87-TDV]N8V6396%CF&B.H8V1)X  X
M=&EM998%$9#<>7EE<G)O<I/6:7.38V%L;&5D+I$(K9=!;IJL<GF3<WENF'1AX
M>)-E<G)O<I-W:6QLDW1H96Z38V%N8V5LDW!A<G-E+71R96638V]N+8ZAC9$GX
M@ !S=')U8W1I;VZ6 VU\86YDDV%T=')I8G5T99-E=I'_6.1A;'5A=&EO;BR1X
M X:%86YDDVETDVESDV5N<W5R9623=&AA=)-T:&6369'_!59A8V,M9V5N97)AX
M=&5DCJ&-D2>  &-OD%..9&66 W7H8V%NDV-O;I6L<G1I;I-U998#=>AS869EX
M;'F1_P56+I$%$?55<V63;V:3W'EY>65R<F]RD]9I<Y-U;FYE8V5S<V%R>9-BX
M=723:&%R;6QE<W.3:6:3=&AECJ&-D2>  %DM#&QEE@/JJ&UA:YJL<F5SDVYOX
MDW5S99-O9I-T:&63=YAO<F1SD]QE<G)O<M8LD]QY>65R<F]KUBR386YDD]QYX
M>6-L96%R:6[6+HZ?(LJKC8V1)X  XC$S+C*.D55_ZDUE;6]R>9$%A1QA;&EGX
M;FUE;I"*/72.IHV1)X  UDUA;IJL<GF6 QT98V]M<'5T:6YGDW-Y<W1E;7.3X
M:&&8=IAEDVAA<F1WF&%R92UR96QA=&5DDV-O;G-T<F%I;IAT<Y-O;I-T:&63X
M861D<F5S<V5SCJ&-D2>  '5S9626 SO49F]RDVUE;6]R>9-A8V-E<W-E<RZ1X
M!/Z91I'_!59O<I-E>&%M<&QE+)$#7LMF;W*389-C97)T86ENDW2:K')Y<)!3X
MCF63:723;6&8>9-BD%..99-R97%U:7)E9(ZAC9$G@ !T:&%TE@.>8'1H99,,X
M<G-TDV*:K')Y=&63;V:3<W1O<F%G99-F;W*396%CF&B3=I'_6.1A<FEA8FQEX
MDV]FDW1H8723=)AY<)!3CF63<F5S:61EDV%TDV%NDV5VF&5N+8ZAC9$G@ !NX
ME:QR=6V38II3CF5R9626!5'[861D<F5S<RZ1"6[95&AE;I-A;I-I;G-T<G5CX
M=&EO;I-T;Y-A8V-E<W.389-VD?]8Y&%R:6%B;&63;V:3=&AA=)-TD*QR>7"8X
M98ZAC9$G@ !A=)8$2:IA;I-OFE..9&0M;I6L<G5MDV*897)E9)8$2:IA9&1RX
M97-SDW)E<W5L='.3:6Z389-R=6XM=&EM99-E<G)O<BZ1!E7E5VAE;I-/>)-IX
M<Y-G:7:0K')E;HZAC9$G@ !T:&66!4!,W"UAUTZ1!H$PUF-O;6UA;F0M;&ENX
M99-O<'1I;VXLD065M&ETDW!R;Y!3CF1U8V5SDV%NDV5VD?]8Y&%L=6%T;W*3X
M=&AA=)-A;&EG;G.386QLDT..H8V1)X  <W1R=6-T=7)E<Y8#@C]O;I-A9&1RX
M97-S97.39&EV:7-I8FQEDV*:K')YDW1H99-I;IAT96=E<I/73I$!0.36+I$%X
M%A)4:&639&5F875L=)-VD?]8Y&%L=6639F]RDW1H:7..H8V1)X  86QI9VYMX
M96Z5K')TFP/JJ&-O;G-T86Z3=)AI<Y@T+)AW:&ECDVB8:7.8861E<75A=&68X
M9F]RF&YE87)L>9AA;&R88W5R<F5NDW288V]M<'5T97)S+HZ?(LJKC8V1)X  X
MXC$S+C..D55_ZE-T<FEP<&EN9Y8%A1Q/>)-C;VYS=')U8W1SCJ:-D2>  -9/X
M8V-A<VEO;F%L;'F1_P56+)$$*?=T:&66!!U-9&5S:6=N97*3;6&0K')YDW=IX
M<VB38V]P:65SDV]FDW1H99-9+0QL99-A;F233"T,;&4H<RF39G)E99-O9HZAX
MC9$G@ !/>"US<)53CF5C:0QCFP,_#&-O;G-T<G5C=',ND03_K%-U<'"3;W-EX
M+)8#85YF;W*8:6YS=&%N8V4LDW1H87288Y"L<FAA;F=E<YAT;YAT:&68=6YDX
M97)L>6EN9XZAC9$G@ !G<F%M;6%RE@0&JF%R99-U;F1E<I-C;VYS:61E<F%TX
M:6]N+)$$#:IA;F23=&AA=)-I=)-I<Y-D97-I<F5DDW1ODW1E<W23=VAE=&AEX
M<I-T:&6.H8V1)X  ;F5WE@2'76=R86UM87*3:&%SDW!A<G-I;F>38V]N#6ECX
M=',ND0<._U21_P56;Y-S871I<V9YDT]XDW-E;6%NFJQR=&EC<Y-M:6=HF'23X
M<F5Q=6ER98ZAC9$G@ !W<FET:6YGE@+FW&%T=')I8G5T99-D90QN:71I;VYSX
MDV9O<I-A;I"L<GF3;F5WDW)U;&5S+I$$XD=/>"=SDV]U='!U=)-O;I/<;WAOX
M=70N>9/68V]U;&2.CHZ,BP   "                                  X
M                 2%HH )R  "-H/VU  "-C9$G@ #:,3.1"[_X0T]-34%.X
M1"U,24Y%E@/JJ$]05$E/3E.304Y$DT]42$52DU!/24Y44Y%'V$O6,S*.CJ "X
M+0  C:#]]@  C9$G@ !T:&5NE@/JJ&*04XYEDW-U8FUI='1E9)-T;Y-9D?\%X
M5F%C8Y-T;Y-T97-TDV9O<I-P87)S:6YGDV-O;@UI8W1S+HZD#H  C9$Y'_14X
MD?\%5F^;!6QK896L<G:3;VEDF'1H99AA8I!3CF^3=I-E+6UE;I-T:6]N9628X
M=W)I=&EN9YAO9IAA='1R:6)U=&689&4,;FET:6]N<RR1!<S<=&AEF&1E+8ZAX
MC9$G@ !S:6=N97*6!8+48V%NDW5S99-/>"=SD]PM4Y$%@FO68V]M;6%N9"ULX
M:6YEDV]P=&EO;BR1!>C?=VAI8Y"L<FB3#&QT97)SDV%L;)-/>"US<)!3CF5CX
M:0QCCJ&-D2>  &-O;G-T<G5C='.6 ^TR9G)O;9-T:&63:6YP=71SDV%N9)-YX
M:65L9'.3#&QE<Y-A8V-E<'1A8FQEDW1ODUF1_P5686-CDV%N9)-,97@ND05 X
M?51H98ZAC9$G@ !O<FEG:6YA;)8#A-]C;W!I97.3;V:3=&AEDUDM#&QEDV%NX
M9)-,+0QL92AS*9-A<F63=6YCD*QR:&%N9V5D+)$#F3IB=7233W@G<Y-O=71PX
M=71SDV]NCJ&-D2>  -QO>&]U="XJE@+L[]9C;VZ0K')T86ENDVYE:71H97*3X
M3WB38V]N<W1R=6-T<Y-N;W*3=&AEDW5S=6%LDT]X+6=E;F5R871E9)-P87)SX
M92UT<F5ECJ&-D2>  &UA;F%G96UE;I"L<G21 ^JH8V^04XYD92Z.J2(  (V-X
MD2>  .(Q,RXTCI%5?^I0<F5VE8H]96Z3=&EN9Y8#KA-E>&5C=71I;VZ3;V:3X
M871T<FEB=71EDV1E#&YI=&EO;I-C;Y!UPF1ECI\60 "-D2>  -9&D?\%5F%UX
M;'2:K')YE@5L^W5S97(M=W)I='1E;I-C;Y!3CF1EDVENDV%T=')I8G5T99-RX
M969E<F5N8V63<V5C=&EO;G.3;6&8>9-C875S99-A8FYO<BV.H8V1)X  ;6%LX
ME@0]Z'1E<FUI;F%T:6]NDV]FDW1H99-/>"UG96YE<F%T962397:1_UCD86QUX
M871O<BZ1!C*?1I'_!59O<I-I;G-T86YC92R1!%*W9&5R969E<F5N8VEN9XZAX
MC9$G@ !AE@1@7W-T<F&:K')YDW"04XYO:6Z8=&5RDVUAF'F38V]R<G5P=)-TX
M:&6397:1_UCD86QU871O<B=SDV1A=&&3<W1R=6-T=7)E<Y-A;F238V%U<V63X
M:723=&^.H8V1)X  9F%L<V5L>98#UY!R97"04XYO<G2389-C>6-L99-D=7)IX
M;F>3871T<FEB=71EDV5VD?]8Y&%L=6%T:6]N+I$%,H-4:&63W"UND]9C;VUMX
M86YD+6QI;F63;W MCJ&-D2>  '1I;VZ6 LN?:7.389-D96)U9V=I;F>39F5AX
M='5R99-T:&%TDV-A;I-BD%..99-U<V5DDW1ODVES;VQA=&63=&AEDV4+96-TX
M<Y-O9I-A;F]M86QO=7..H8V1)X  871T<FEB=71EE@1+0F1E#&YI=&EO;I-CX
M;Y!3CF1E+I$&6JU7:&5NDT]XDVESDW5S9623=VET:)-T:&ESDV]P=&EO;BR1X
M!&-H=&AEDV=E;F5R871E9(ZAC9$G@ !E=IO_6.1A;'5A=&]RE@36OG5S97.3X
M=&AEDW)E861YDW-E=)-A<Y-U<W5A;)-T;Y-D971E<FUI;F6386Z397:886QUX
M871I;VZ3;W)D97*39F]RCJ&-D2>  &%T=')I8G5T998#LZ=I;G-T86YC97,LX
MD0.^IV%N9)-S=&EL;)-CE:QR:&5CDVMSE@.SIV9O<I-C>6-L97,ND04FBD5AX
M8YJL<FB3=&EM99-I=)-I<Y-R96%D>9-T;Y-S;VQVF&6.H8V1)X  86Z1!$CRX
M:6YS=&%N8V4LFP1@A6AOE:QR=Y-E=I-E<BR8:726!$CR<W1O<'.3<VAO<G23X
M;V:397AE8W5T:6YGDW1H99-C;Y!3CF1EDV9O<I-T:&639&4,;FET:6]NCJ&-X
MD2>  &]FE@2K<W1H8723:6YS=&%N8V4ND0=[0%=H96Z3W"UND]9I<Y-U<V5DX
M+)$$VZ5T:&639&5S:6=N97*3<VAO=6QDDW1A:Y"L<F63<W"04XYE8VEA;)-NX
M;W1I8V6.H8V1)X  ;V:6!"@[=&AEDV4+96-T<Y-U<)!3CF]NDV]T:&5RDW1RX
M86YS;&%T:6]NDW!H87-E<Y-O9I-S=6.:K')HDW-U<'!R97-S:6]NDV]FDW-EX
M;6%NF'1I8XZAC9$G@ !A;F%L>7-I<RZ.IHV-D2>  .(Q,RXUCI%5?^I#;VZ0X
MBCUT<F]LE@>CVV]FDW-T;W)A9V6386QL;Y!UPF-A=&EO;I-I;I-T:&639V5NX
M97)A=&5DCI\2  "-D55_ZF5VD?\4>V%L=6%T;W*.GQ9  (V1)X  UE=H96Z6X
M ZLX:6YI=&EA;&EZ:6YGDVET<V5L9BR1 [?H=&AEDT]X+6=E;F5R871E9)-EX
M=I'_6.1A;'5A=&]RDV%L;&^04XYC871E<Y-M96UO<GF39F]RDVET<XZAC9$GX
M@ !VF_]8Y&%R:6]U<Y8#W,MD871ADW-T<G5C='5R97,ND04T05=H96Z397:8X
M86QU871I;F>389-L87)G99-I;G!U="R1 ]^1:723;6&0K')YDVAA<'"04XYEX
M;I-T:&%TCJ&-D2>  '1H998$!@YS<&%C99-A;&QOD%..8V%T96239F]RDV&3X
M9VEVFJQR96Z39&%T89-S=')U8W1U<F63:7.3:6YA9&5Q=6%T92Z1!8L326Z3X
M<W5CF&B389-C87-E+(ZAC9$G@ !T:&66!0KX97:1_UCD86QU871O<I-I<W-UX
M97.386Z397)R;W*3;65S<V%G99-I;F1I8V%T:6YGDW=H:6.:K')HDV1A=&&3X
M<W1R=6-T=7)EDW>887..H8V1)X  97AC965D9626 U[186YDDW-U9V=E<W1IX
M;F>386Z387!P<F]P<FEA=&5L>9-L87)G97*3<VEZ92Z1!0I#5&AEDW-I>F5SX
MDV]FDW1H97-EDV1A=&&.H8V1)X  <W1R=6-T=7)E<Y8#YB!M89JL<GF38I!3X
MCF639&5T97)M:6YE9)-BF'F3=&AEDV1E9F%U;'23=I'_6.1A;'5E<Y-B=6ELX
M=)-I;IAT;Y-/>"R1 ^<(;W*38IAYDW1H98ZAC9$G@ !E=I'_6.1A;'5A=&]RX
ME@.C)F1E<VEG;F5R)W.3=7-EDV]FDW1H99/<+5G784Z1!.0*UF]P=&EO;I-OX
M;I-T:&633WB38V]M;6%N9)-L:6YE+)$#L7-W:&5R98ZAC9$G@ #7898#;J_6X
M:7.386Z386QP:&%BFE..971I8Y-CD*QR:&%R86-T97*3=&AA=)-S<)AE8VD,X
M97.3=&AEDV1A=&&3<W1R=6-T=7)EDW1ODV*899-S:7IE9"R1 X=Z86YDCJ&-X
MD2>  -=.D01EKM9I<Y8#),IA;I-I;I"L<G1E9V5RDW1H87239&5T97)M:6YEX
M<Y-T:&63<VEZ99-O9I-D871ADW-T<G5C='5R99/789/6*'-E99-A<'"04XYEX
M;F1I>)-$*2Z.H8V1.1_T5&AEE@676&5VF_]8Y&%L=6%T;W*39&5S:6=N97*3X
M8V%NDV5A<VEL>9-B=6EL9)-A;I-E=IAA;'5A=&]RDW1H872386-C97!T<Y-TX
M:&6.H8V1)X  <V%M998$VQ#<+5G784Z1!AOTUF-O;6UA;F0M;&EN99-O<'1IX
M;VYSDV%C8V5P=&5DDV*0K')YDT]X.I$'&;!">9-S<)!3CF5C:69Y:6YGDW1HX
M99/<+5E9CHZ.C(L    A                                        X
M          $M6: "<@  C:#]M0  C8V1)X  VC$SD0N_^$-/34U!3D0M3$E.X
M198#ZJA/4%1)3TY3DT%.1)-/5$A%4I-03TE.5%.11]A+UC,SCHZ@ BT  (V@X
M_?8  (V1)X  ;W!T:6]NE@1U*6]NDT]X)W.38V]M;6%N9)-L:6YE+)$$E\E/X
M>)-I<Y-I;G-T<G5C=&5DDW1ODV1E8VQA<F63:6Z3=&AEDV=E;F5R871E9(ZDX
M#H  C9$G@ !E=I'_6.1A;'5A=&]RE@2*0&&39G5N8W1I;VZ3W'EY>4-H96-KX
M1F]R4F5S:7IE<Y/6=&AA=)-C86Z3<F5A9)/<;6%I;M8G<Y-A<F=U;65ND*QRX
M='..H8V1)X  *&DN92XLD0,>P71H998"Z\AC;VUM86YD+6QI;F63;W!T:6]NX
M<Y-P87-S9623=&^3=&AEDV=E;F5R871E9)-E=I'_6.1A;'5A=&]R*9-A;F23X
M861J=7-TCJ&-D2>  '-I>F5SE@2/=V%C8V]R9&EN9VQYD?\%5BZ1!R=-5VAEX
M;I-U<VEN9Y-T:&63W"U969$$CTW6;W!T:6]N+)$$N*MT:&639&5S:6=N97*3X
M<VAO=6QDDV%R<F%N9V6.H8V1)X  =&AEE@/JJ&5VD?]8Y&%L=6%T;W(G<Y/<X
M;6%I;I/6<')O9W)A;9-A8V-O<F1I;F>3=&^3=&AEDV9O;&QOD*QR=VEN9Y-FX
M;W)M.HZ?$G_^C8V?^   C9$Y'_0NCJ0$  "-D3D?]"Z.H8V1.1_T+HZ.CJ06X
M  "-D2>  ,IV;VEDD04__7EY>4-H96-K1F]R4F5S:7IE<R@I.XZI'&..C8V?X
M^   C9$Y'_36+HZD!   C9$Y'_0NCJ&-D3D?]"Z.CHZAC9$G@ #*;6%I;BAAX
M<F=C+&%R9W8ICJ0,  "-D3'_^FEN=)$%/_UA<F=C.XZAC9$Q__IC:&%RD04_X
M_2IA<F=V6UT[CJ&-D3'_^GN.GQK__8V-G_@  (V1.1_TUBZ.I 0  (V1.1_TX
M+HZAC9$Y'_0NCHZ.GQ8  (V1-S_WRB\JE@4__51H:7.3:7.397AE8W5T9623X
M8F5F;W)EDV-A;&QI;F>3>7EP87)S99,J+XZAC9$W/_=Y>7E#:&5C:T9O<E)EX
M<VEZ97,H87)G8RQA<F=V*3N.IHV-G_@  (V1.1_TUBZ.I 0  (V1.1_T+HZAX
MC9$Y'_0NCHZ.I!8  (V1-S_WRGEY<&%R<V4H*3N.IHV-G_@  (V1.1_TUBZ.X
MI 0  (V1.1_T+HZAC9$Y'_0NCHZ.H8V1,?_ZRGV6!3_]+RJ3;6%I;I,J+XZ?X
M(LJKC8V1)X  XC$S+C:.D55_ZE"0BCUA<G-EE@6%''1R9663<W1A=&ES=&ECX
M<XZ?%D  C9$G@ #64&QA8VEN9Y8%;=G<+763UF]NDT]X)W.38V]M;6%N9)-LX
M:6YEDV-A=7-E<Y-G96YE<F%T:6]NDV]FDV%NDV5VD?]8Y&%L=6%T;W*3=&AAX
M=(ZD#H  C9$G@ !P<FENE:QR=',LD00+2V9O<IL$!,1E86.3:)AI;G!U="R1X
M! M+<W1A=&ES=&EC<YAR96=A<F1I;F>8=&AEF'!A<G-EF'1R96688G5I;'28X
M9F]RF'1H99AI;G!U="Z.H8V1)X  5&AE<V66 ^JH:6YC;'5D99-NE:QR=6V3X
M8I!3CF5R<Y$#ZJAO9CJ.I!B  (V-C8V1./_OV ^.CHZ11-_LUG1E<FUI;F%LX
ME@/JJ&YOD%..9&5SDV%N9)-T:&5I<I-A='1R:6)U=&63:6YS=&%N8V5S+(ZAX
MC8V-C9$X_^_8#XZ.CI%$W^S6;F]ND*QR=&5R;6EN86R6 ^JH;F^04XYD97.3X
M86YDDW1H96ERDV%T=')I8G5T99-I;G-T86YC97,LCJ&-D2>  &%N9)8#ZJAOX
M=&AE<I-S=&%T:7-T:6-S+HZ.CHR+    (@                          X
M                       !.1N@ G(  (V@_;4  (V-D2>  -HQ-)$+O_A%X
M6$%-4$Q%.I8#ZJA!3I-)3E1%1T52DT-!3$-53$&1_P565$]2D7NFNM8S-(Z.X
MH (M  "-H/WV  "-C9$G@ #B,3,N-XZ157_J061J=7-T:6YGE@6%''1H99-SX
M:7IE<Y-O9I-/>"=SDV1A=&&3<W1R=6-T=7)E<XZ?%D  C9$G@ #63WB6!.DJX
M:71S96QFDV-A;&QSDW-Y<W1E;9-M96UO<GF386QL;Y!3CF-A=&EO;I-R;W5TX
M:6YE<Y-T;Y-O8G1A:6Z3<W1O<F%G99-F;W*3:71SCJ0.@ "-D2>  &END*QRX
M=&5R;F%LE@/6?61A=&&3<W1R=6-T=7)E<RZ1!3(G5&AEDV1E9F%U;'23<VEZX
M97.3;V:3=&AE<V639&%T89-S=')U8W1U<F5SDV%R99-Q=6ET98ZAC9$G@ !GX
M96YE<F]U<RR1!A7<86YDE@6FT65X8V5E9&EN9Y-T:&5MDW>:K')O=6QDDV*0X
M4XYEDW-O;65W:&%TDW5NF'5S=6%L+I$*;5Q);I-C87-EDV%NF'F.H8V1)X  X
M;V:6!<'!=&AE<V63:7.397AC965D960LD08WAT]XDW!R:6Z0K')T<Y-A;I-EX
M<G)O<I-M97-S86=EDVEN9&EC871I;F>3=&AEDW5S99-O9I-ACJ&-D2>  &-OX
M;6UA;F0M;&EN998#@"UO<'1I;VZ3;V:3=&AEDV9O<FV3W"U8UV%.FP3!$=9TX
M;Y-M86N0K')ED]=.F-9T:&63<VEZ99-O9I-D871ADW-T<G5C='5R98ZAC9$GX
M@ #78=8NCI\H%5:-C9$G@ #G,32.D4\^:$5X86UP;&4ZD0C4^F%NE@:?O&ENX
MD?]RL'1E9V5RDV-A;&-U;&%T;W*.GQIB(XV1)X  UE1H:7.6!27N<V5C=&EOX
M;I-H87.33WB38V^04XYD99-F;W*386Z397:1_UCD86QU871O<I-O9I-S:6UPX
M;&6397AP<F5S<VEO;G.3:6Z5K')VDV]L=FEN9XZAC9$G@ !MFJQR=6QT:7!LX
M:6-A=&EO;I8%:,9A;F23861D:71I;VXND0FS.U-I;F-EDW1H99-G<F%M;6%RX
MDVAA<Y-O;FQYDW-Y;IAT:&5S:7IE9)-A="V.H8V1)X  =')I8G5T97,LD05:X
MD'1H998%$/M/>)-I;7!L96UE;IJL<G1A=&EO;I-O"V5R<Y-L:71T;&63861VX
MD?]8Y&%NF'1A9V63;YAVF&5RDV]N99-T:&%TDW5S97..H8V1)X  ;VYL>98#X
MZJA9D?\%5F%C8Y-A;F233&5X.Y-I=)-I<Y-P<F5S96Z:K')T962387.389-VX
MF&5R>9-E87-YDV5X86UP;&63;V:33WB3=7-A9V4NCJ0,  "-D3D?]%1H998#X
M"[],+0QL99-S<)!3CF5C:0QE<Y-T:&%TDW1H99-T;VN:K')E;G.387)EDV1IX
M9VETDW-T<FEN9W,LE@,X5'!A<F5NF'1H97-E<RR3W"<J)]8LDV%N9(ZAC9$GX
M@ #<)RLGUCJ.GQ8  (V1)X  RB5[CJ&-D2>  "\JE@4__65X<'(N3#J1"G_ZX
M3"UF:6QEDV9O<I-ADW-I;7!L99-E>'!R97-S:6]NDVQA;F=U86=EDRHOCJ&-X
MD2>  "-I;F-L=61ED04__2)Y+G1A8BYH(HZAC9$G@  C:6YC;'5D99$%/_TBX
M;WAO=70N:"*.H8V1)X  )7V.GQ@  (V1)X  )26.H8V1)X  6Y$%/_U<;EQTX
M7&9=*I$:/_$[CJ&-D2>  %LP+3E=*Y$O/^5R971U<FXH0T].4U0I.Y$%/_U X
M>XZAC9( A?_*<W-C86YF*'EY=&5X="PB)60B+"8H0$-/3E-4+G9A;$ I*3N1X
M!3_]0'V.H8V1)X  7"B11#_9<F5T=7)N*"<H)RD[CJ&-D2>  %PID40_V7)EX
M='5R;B@G*2<I.XZAC9$G@ !<*Y%$/]ER971U<FXH)RLG*3N.H8V1)X  7"J1X
M1#_9<F5T=7)N*"<J)RD[CJ&-D2>  "4ECHZ.C(L    C                X
M                                  $^\J "<@  C:#]M0  C8V1)X  X
MVC$TD0N_^$5804U03$4ZE@/JJ$%.DTE.5$5'15*30T%,0U5,09'_!5943U*1X
M>Z:ZUC,UCHZ@ BT  (V@_?8  (V1.1_T5&AEE@4[D6=R86UM87*3:7.39&ESX
M86V:K')B:6=U871E9)-BF'F3=7-EDV]FDUF1_P5686-C)W.3W"5L969TD]9RX
M97-E<G:89623=YAO<F0NCJ0,  "-D2>  $5A8Y"L<FB6!=:#<&%R<V4M=')EX
M99-N;YI3CF1EDVQA8IAE;&5DDV*:K')YD]QSUBR6!E%ZW&76+)-O<I8%UH/<X
M0T].4U21!=8$UFAA<Y-A;I-I;IAT96=E<I-A='1R:6)U=&6.H8V1)X  :6YSX
M=&%N8V66 UB6;F%M9623W'9A;-8ND04(+U5S99-O9I-T:&639VQO8F%LDW:1X
M_UCD87)I86)L99/<<U9A;)/6;V*0K')V:6%T97.3<)!3CF]S=&1E8V]R871IX
M;VZ.H8V1)X  =')AE:QR=I-E<G-A;"Z.GQ8  (V1)X  RB\JE@4__65X<'(NX
M63J1"G_Z62UF:6QEDV9O<I-ADW-I;7!L99-E>'!R97-S:6]NDVQA;F=U86=EX
MDRHOCJ&-D2>  "5L969TD04__2<K)XZAC9$G@  E;&5F=)$%/_TG*B>.H8V1X
M)X  )71O:V5ND04__4-/3E-4CJ08  "-D2>  $!A='1R:6)U=&5SE@4__7MLX
M;VYGDW9A;#M]DW.399-#3TY35(ZAC9$G@  E>XZD#   C9$G@  C:6YC;'5DX
M99$%/_TB;WAO=70N:"*.H8V1)X  ;&]N9Y$%/_US5F%L.XZAC9$G@  E?8ZIX
M&   C9$G@  E)8ZAC9$G@ !SEB2_ZSJ398ZAC9%1?^A >Y8%/_U :9-S5F%LX
MDSV30',N=F%L0),]DT!E+G9A;$ [D3[_W$!]CJ&-D5%_Z#N.H8V1)X  998DX
MO^LZDV63)RLGD1H_\66.H8V147_H0'N6!3_]0&F30&4N,"YV86Q DSV30&4NX
M,2YV86Q DRN30&4N,BYV86Q .Y$/O_= ?8ZAC9%1?^@[CJ&-D2>  &66)+_KX
M.I-EDR<J)Y$:/_%ECJ&-D5%_Z$![E@4__4!IDT!E+C N=F%L0),]DT!E+C$NX
M=F%L0),JDT!E+C(N=F%L0#N1#[_W0'V.H8V147_H.XZAC9$G@ !EEB2_ZSJ3X
M)R@GD1H_\663)RDGCJ&-D5%_Z$![E@4__4!IDT!E+G9A;$"3/9- 92XQ+G9AX
M;$ [D5D_S4!]CJ&-D5%_Z#N.H8V1)X  998DO^LZDT-/3E-4CJ&-D5%_Z$![X
ME@4__4!IDT!E+G9A;$"3/9- 0T].4U0N=F%L0#N13K_30'V.H8V147_H.XZAX
MC9$G@  E)8ZFC9$G@ !M86EN*"F.H8V1)X  >WEY<&%R<V4H*3N.H8V1++_]X
M<')I;G1F*"(E9%QN(BQS5F%L*3N.H8V1)X  ?8Z.CHR+    )           X
M                                       !12&@ G(  (V@_;4  (V-X
MD2>  -HQ-9$+O_A%6$%-4$Q%.I8#ZJA!DT))3D%2F_\%5EF33E5-0D52DU12X
M04Y33$&85$]2D526'M8S-HZ.H (M  "-H/WV  "-D3D?]%1H998#A1=F;VQLX
M;Y"L<G=I;F>38V]M;6%N9)-S97%U96YC99-I<Y-U<V5DDW1ODV)U:6QDDV%NX
MDV5X96-U=&%B;&63#&QED]QC86QCCJ0,  "-D2>  -9F<F]ME@/JJ'1H99-AX
M8II3CF^5K')VDV61 ^JH<W"896-I#&-A=&EO;G,ZCJD6  "-D5%_Z,IO>)8%X
M/_TM:)-E>'!R+EF397AP<BY,CJ&-D5%_Z'EA8V.6!3_]+623;WAO=70N>8ZAX
MC9%1?^AL97B1!3_];WAO=70N;(ZAC9%1?^AC8Y8%/_TM8Y-Y+G1A8BYCCJ&-X
MD5%_Z&-CE@4__2UCDVQE>"YY>2YCCJ&-D5%_Z&-CE@4__2UODV-A;&.3>2YTX
M86(N;Y-L97@N>7DN;Y,M;'F3+6QLCI\H%5:-C9$G@ #G,36.D4\^:$5X86UPX
M;&4ZD0C4^F&6!I^\8FEN87)YDVZ6_W*P=6V38I$ C4]E<I$&G[QT<F%N<VQAX
M=&]RCI\:8B.-D2>  -94:&ESE@8%\FEL;'5S=')A=&5SDW1H99-U<V63;V:3X
M3WB3=&^38G5I;&2386Z397:1_UCD86QU871O<I-B87-E9)-O;I-A;I-E>&%MX
M+8ZD#H  C9$G@ !P;&66!30+871T<FEB=71EDV=R86UM87*1"F@6=&AA=)-AX
M<'":4XYE87)SDVENDW1H99-S96UI;F%LDW!A<)AE<I-O;I-T:&63<W5BD0"GX
M'&IE8W2.H8V1)X  6XU+;I"L<G5T:)$#ZJ@V.(Z1,*"572Z1"![15&AEE@3AX
M^&EN<'5TDRAA9G1E<I-R96UOFJQR=I'_6.1A;)-O9I-W:&ET97-P86-E*9-IX
M<Y-E:71H97*389-N;VYE;7!TF'F.H8V1)X  <W1R:6YGE@/2_&]FDV)I;F%RX
M>9-D:6=I='.3;W*3=)6L<G>3;YL#TOQS=6.3:)AS=')I;F=SF'-E<&%R871EX
M9)ABDWF889APE5..97)I;Y-D+I$%,/Q4:&ESF&EN<'5TCJ&-D2>  &ESE@.6X
M<&ENFJQR=&5R<')E=&5DDV%SDV&38FEN87)YDW)E<')E<V5NF'1A=&EO;I-OX
M9I-ADPUO871I;F>3<)!3CF]I;IATDVZ8=6V88I!3CF5R+)$#ITAW:&ECF&B3X
M:7..H8V1)X  =&AE;I8#ZJAP<FEND*QR=&5DDV]NDW1H99-S=&%N9&%R9)-OX
M=71P=723:6Z3:71SDV)A<V4M=&5NDV9O<FTNCJ0,  "-D3D?]$:1_P56;VQLX
M;Y"L<G=I;F>6 ^JH:7.3=&AEDW1E>'23;V:3=&AEDTPM#&QE.HZFC9$G@ #*X
M)7N.H8V1)X  (VEN8VQU9&61!3_](GDN=&%B+F@BCJ&-D2>  "5]CI\8  "-X
MD2>  "4ECJ&-D2>  %LP79$^_]QR971U<FZ1!3_]6D523SN.H8V1)X  6S%=X
MD3[_W')E='5R;I$%/_U/3D4[CJ&-D2>  %PND40_V7)E='5R;I$%/_U$3U0[X
MCJ&-D2>  %M<;EQT7':1!3_]79$??^X[CJ&-D2>  "Z127_6>V9P<FEN=&8HX
M<W1D97)R+")I;&QE9V%LD04__6-H87)A8W1E<EQN(BD[CJ&-D7M_T&5X:70HX
M+3$I.XZAC9%V/]-]CHZ.C(L    E                                X
M                  %)MZ "<@  C:#]M0  C8V1)X  VC$UD0N_^$5804U0X
M3$4ZE@/JJ$&30DE.05*;_P5669-.54U"15*35%)!3E-,09A43U*15)8>UC,WX
MCHZ@ BT  (V@_?8  (V1.1_T2&5R998#ZJAI<Y-T:&63=&5X=)-O9I-T:&63X
M62T,;&4ZCI\6  "-D2>  ,HE=&]K96Z6!3_]6D523Y-/3D631$]4CJD8  "-X
MD2>  $!A='1R:6)U=&5SE@4__7MF;&]A=)-V86QU93N3:6YTDW-C86QE.WV1X
M8[_'8FETCJ0,  "-D2>  $!A='1R:6)U=&5SE@4__7MF;&]A=)-V86QU93N3X
M:6YTDW-C86QE+&QE;F=T:#M]D3[_W&)I=&QI<W2.H8V1)X  0&%T=')I8G5TX
M97.6!3_]>V9L;V%TDW9A;'5E.WV2 )U_IFYU;8ZFC9$G@  E<W1A<G21!3_]X
M;G5MCJ:-D2>  "5[CJ&-D2>  "-I;F-L=61ED04__3QS=&1I;RYH/HZAC9$GX
M@ !F;&]A=)$%/_UN=6U686QU93N.H8V1)X  )7V.CHZ,BP   "8         X
M                                         4\:H )R  "-H/VU  "-X
MC9$G@ #:,361"[_X15A!35!,13J6 ^JH09-"24Y!4IO_!599DTY534)%4I-4X
M4D%.4TQ!F%1/4I%4EA[6,SB.CJ "+0  C:#]]@  C9$G@ #*)26.I P  (V1X
M)X  8FETD1H_\3J1)+_K6D523XZAC9%[?]! >Y8%/_U :9- 8FET+G9A;'5EX
M0),]DS [CJ&-D@"+/\<O*I8%/_UV86QU99-I<Y-S>6YT:&5S:7IE9)-F;W*3X
M8FET+I$*?_HJ+XZAC9( BS_'+RJ6!3_]<V-A;&63:7.3:6YH97)I=&5DDV9OX
M<I-B:70ND13_]"HOCJ&-D7M_T$!]CJ&-D5%_Z#N.J1@  (V1)X  8FETD1H_X
M\3J1)+_K3TY%CJ&-D7M_T$![E@4__4!IDT!B:70N=F%L=65 DSV3='=O5&]4X
M:&4H0&)I="YS8V%L94 I.XZAC9%[?]! ?8ZAC9%1?^@[CJ:-D2>  &)I=&QIX
M<W21!3_].I$DO^MB:72.H8V1>W_00'N6!3_]0&F30&)I=&QI<W0N=F%L=65 X
MDSV30&)I="YV86QU94 [CJ&-D@"+/\= :98%/_U 8FET+G-C86QE0),]DT!BX
M:71L:7-T+G-C86QE0#N.H8V2 (L_QT!IE@4__4!B:71L:7-T+FQE;F=T:$"3X
M/9,Q.XZAC9( BS_'+RJ6!3_]=F%L=66386YDDVQE;F=T:)-A<F63<WEN=&AEX
M<VEZ96239F]RDV)I=&QI<W0ND0I_^BHOCJ&-D@"+/\<O*I8%/_US8V%L99-IX
M<Y-I;FAE<FET96239F]RDV)I=&QI<W0ND5/_T"HOCJ&-D7M_T$!]CJ:-D5%_X
MZ'R1)+_K8FET;&ES=)$%/_UB:72.H8V1>W_00'N6!3_]0&F30&)I=&QI<W0NX
M,"YV86QU94"3/9- 8FET;&ES="XQ+G9A;'5E0),KDT!B:70N=F%L=65 .XZAX
MC9( BS_'0&F6!3_]0&)I="YS8V%L94"3/9- 8FET;&ES="XP+G-C86QE0#N.X
MH8V2 (L_QT!IE@4__4!B:71L:7-T+C$N<V-A;&5 DSV30&)I=&QI<W0N,"YSX
M8V%L94"3*Y,Q.XZAC9( BS_'0&F6!3_]0&)I=&QI<W0N,"YL96YG=&A DSV3X
M0&)I=&QI<W0N,2YL96YG=&A DRN3,3N.H8V1>W_00'V.H8V147_H.XZFC9$GX
M@ !N=6V1&C_Q.I$DO^MB:71L:7-TCJ&-D7M_T$![E@4__4!IDVYU;59A;'5EX
MDSV30&YU;2YV86QU94"3/9- 8FET;&ES="XP+G9A;'5E0#N.H8V2 (L_QT!IX
ME@4__4!B:71L:7-T+G-C86QE0),]DS [CJ&-D@"+/\<O*I8%/_UV86QU99-IX
M<Y-S>6YT:&5S:7IE9)-F;W*3;G5M+I,J+XZAC9%[?]! ?8ZFC9%1?^A\D22_X
MZV)I=&QI<W21!3_]1$]4D1H_\6)I=&QI<W2.H8V1>W_00'N6!3_]0&F3;G5MX
M5F%L=663/9- ;G5M+G9A;'5E0),]CJ&-D@"JO[5 8FET;&ES="XP+G9A;'5EX
M0)8%/_TKDT!B:71L:7-T+C$N=F%L=65 .XZAC9( BS_'0&F6!3_]0&)I=&QIX
M<W0N,"YS8V%L94"3/9,P.XZAC9( BS_'0&F6!3_]0&)I=&QI<W0N,2YS8V%LX
M94"3/9,MDT!B:71L:7-T+C$N;&5N9W1H0#N.H8V1>W_00'V.H8V147_H.XZAX
MC9$G@  E)8Z.CHR+    )P                                      X
M           !4.V@ G(  (V@_;4  (V-D2>  -HQ-9$+O_A%6$%-4$Q%.I8#X
MZJA!DT))3D%2F_\%5EF33E5-0D52DU1204Y33$&85$]2D526'M8S.8Z.H (MX
M  "-H/WV  "-D2>  ,IM86EN*"F.I P  (V1,?_Z>VEFD04__2@A*'EY<&%RX
M<V4H*2DICJ&-D4;_[G!R:6YT9B@B)3,P+C$U9EQN(BQN=6U686QU92D[CJ&-X
MD3'_^GV.GS   (V1)X  9FQO8726!3_]='=O5&]4:&4H:6XID40_V2\JDW)EX
M='5R;G.3,I-R86ES9623=&^3=&AEDW!O=V5RDVENDRHOCJ&-D3'_^FEN=)$%X
M/_UI;CN.H8V1,?_Z>VEFE@4__2AI;I,\DS IDW)E='5R;I,H,2XPDR^3='=OX
M5&]4:&4H+6EN*2D[CJ&-D3<_]VEFE@4__2AI;I,]/9,P*9-R971U<FZ3,2XPX
M.XZAC9%&_^YE;'-EE@4__7)E='5R;I,H,BXPDRJ3='=O5&]4:&4H:6Z3+9,QX
M*2D[CJ&-D3'_^GV.GS^  (V1.1_TUD-O;G-T<G5C=&EO;I8#M<MO9I-T:&63X
M86*04XYOE:QR=I-EE@.URV5VD?]8Y&%L=6%T;W*39F]L;&^0K')W<Y-T:&63X
M<V5P87)A=&638V]M<&EL871I;VZ387 MCJ0.@ "-D2>  '!R;V%CD*QR:)8#X
MZJAD97-C<FEBD%..9623:6Z3<V5C=&EO;I,Q,BZ.H8V1.1_T4F5M;YJL<G9IX
M;F>6 [/9=&AEDT]X+7-PD%..96-I#&.38V]N<W1R=6-T<Y-A;F23=&AED]QPX
M<FEN=&:3UG-T871E;65NF'239G)O;9-T:&6.H8V1)X  86*04XYOE:QR=I-EX
ME@/9.W-O=7)C99-Y:65L9'.389-P86ERDV]FDPQL97.3=&AA=)-C;VYS=&ETX
M=71EDV&3<V5M86Z0K')T:6-S+69R9663<F5C;V=N:7IE<HZAC9$G@ !O9I8#X
MZJAB:6YA<GF3;I6L<G5MDV*04XYE<G,NCHZ.C(L    H                X
M                                  %62J "<@  C:#]M0  C8V1)X  X
MVC$VD0N_^$5804U03$4ZE@/JJ%1204Y33$&1_P565$E/3I-43Y-03U-41DE8X
MDT%.1)-04D5&25B1*J7?UC0PCHZ@ BT  (V@_?@  (V-D2>  .<Q-HZ13SYHX
M17AA;7!L93J1"(.L=')A;G-L871I;VZ6!?T@=&^3<)$ C4]O<W0,>)-A;F23X
M<')E+8Z?%@  C9%//F@,>(Z?&F(CC9$G@ #626Z6!.'.=&AI<Y-E>&%M<&QEX
M+)$%'YAT:&639V5N97)A=&5DDV5VD?]8Y&%L=6%T;W*3:7.3=&^3<)I3CF5RX
M9F]R;9-TE:QR=Y-OD03ASG"8;W-T9&5C;W)A=&EO;HZD#H  C9$G@ !T<F&5X
MK')VDV5R<V%L<RR1!.8U;VYEE@2SY69O<I-P<FENFJQR=&EN9Y-T:&63<')EX
M#'B39F]R;9-O9I-ADV=I=IAE;I-I;@QXDV5X<')E<W-I;VXLD03F-6%N9(ZAX
MC9$G@ !O;F66!(&P9F]RDW!R:6Z:K')T:6YGDW1H99-PD%..;W-T#'B39F]RX
M;2Z1!OWX5&AEDW1O:YAE;G.3;V:3=&AEDVQA;F=U86=EDV%R99-S<)!3CF5CX
M:0QE9(ZAC9$G@ !A<Y$#ZJAF;VQL;Y"L<G=S.HZ?&0  C9$G@ #*)7N.I P X
M (V1)X  +RJ6!3_]3"UF:6QEDV9O<I-T<F%N<VQA=&EO;I-O9I-I;F9I>)-EX
M>'!R97-S:6]N<Y,J+XZAC9$G@  C:6YC;'5D99$%/_TB>2YT86(N:"*.H8V1X
M)X  (VEN8VQU9&61!3_](F]X;W5T+F@BCJD8  "-D2>  &-H87*1!3_]*FQEX
M>&5M92@ICJ&-D3'_^GMC:&%RD04__2ID=6T[CJ&-D3<_]V1U;98%/_T]DRACX
M:&%RDRHI;6%L;&]C*'EY;&5N9RLQ*3N.H8V1-S_W<W1R8W!Y*&1U;2QY>71EX
M>'0I.XZAC9$W/_=R971U<FZ1!3_]9'5M.XZAC9$Q__I]CJ:-D2>  "5]CJ:-X
MD2>  "4ECJ&-D2>  %N1!3_]7&Y<=%QF72J127_6.XZAC9$G@ !;,"TY72M<X
M+C];,"TY72J1+S_E<F5T=7)N*$-/3E-4*3N6!3_]0'N30$-/3E-4+FQE>&5MX
M94"3/9-L97AE;64H*3N30'V.H8V1)X  6T$M6F$M>E]=6T$M6F$M>E\P+3E=X
M*I$*?_IR971U<FXH240I.YL4__1 >Y8%/_U 240N;&5X96UE0),]DVQE>&5MX
M92@I.YA ?8ZAC9$G@ !<*)%S?[YR971U<FXH)R@G*3N.H8V1)X  7"F1<W^^X
M<F5T=7)N*"<I)RD[CJ&-D2>  %PKD7-_OG)E='5R;B@G*R<I.XZAC9$G@ !<X
M*I%S?[YR971U<FXH)RHG*3N.H8V1)X  7"^1<W^^<F5T=7)N*"<O)RD[CJ&-X
MD2>  %PMD7-_OG)E='5R;B@G+2<I.XZAC9$G@  E)8Z.CHR+    *0      X
M                                           !686@ G(  (V@_;4 X
M (V-D2>  -HQ-I$+O_A%6$%-4$Q%.I8#ZJA44D%.4TQ!D?\%5E1)3TZ35$^3X
M4$]35$9)6)-!3D234%)%1DE8D2JEW]8T,8Z.H (M  "-H/WV  "-D3D?]%1HX
M998$8\D,<G-TDW1R896L<G:397)S86R6!&/)<)!3CF5R9F]R;65DDVESDVYAX
M;65DD]Q,4G!R9=8LD02"$F%N9)-T:&63<V5C;VYDDVESDVYA;65DCJ0.@ "-X
MD2>  -Q,4G!O<W36+I$&%BI">98$-&MD969A=6QT+)$$1MQBD%..;W1HDV%RX
M99-L969T+71O+7)I9VB:K')TDW1R89AVF&5R<V%L<RZ1!A8JW$Q2<&]S=)/6X
M:7.389-PD%..;W-T;W)D97*.H8V1)X  =')AE:QR=I-E<G-A;)L#ZJABDWF8X
M9&5F875L="Z1!3C@W$Q2<')EF-9I<YAS<)!3CF5C:0QE9)AA<YAAF'!R96]RX
M9&5RF'1R89-VDV5R<V%L+HZ?)0  C9$G@ #*+RJ6!3_]62UF:6QEDV9O<I-TX
M<F%N<VQA=&EO;I-O9I-I;F9I>)-E>'!R97-S:6]N<Y-T;Y-P<F5F:7B386YDX
MDW!O<W1F:7B3*B^.I P  (V1)X  )71O:V5NE@4__4E$DT-/3E-4CJ&-D2> X
M "5S=&%R=)$%/_USCJ&-D2>  "5L969TE@4__2<K)Y,G+2>.H8V1)X  )6QEX
M9G26!3_])RHGDR<O)XZI&   C9$G@ ! 871T<FEB=71E<Y8%/_U[8VAA<I,JX
M;&5X96UE.WV324230T].4U2.H8V1)X  0'1R879E<G-A;)8%/_U <')E;W)DX
M97*33%)P<F6.H8V1)X  0'1R879E<G-A;)$%/_U,4G!O<W2.IHV1)X  )7N.X
MH8V1)X  (VEN8VQU9&61!3_](F]X;W5T+F@BCJ&-D2>  "-I;F-L=61ED04_X
M_3QS=&1I;RYH/HZAC9$G@  E?8Z.CHR+    *@                      X
M                           !7AZ@ G(  (V@_;4  (V-D2>  -HQ-I$+X
MO_A%6$%-4$Q%.I8#ZJA44D%.4TQ!D?\%5E1)3TZ35$^34$]35$9)6)-!3D23X
M4%)%1DE8D2JEW]8T,HZ.H (M  "-H/WV  "-D2>  ,HE)8ZD#   C9$G@ !SX
MEB2_ZSJ397AP<HZAC9%[?]! >Y8%/_U 3%)P;W-TDW!R:6YT9B@B7&XB*3N.X
MH8V2 (L_QT!,4G!O<W26!3_]0')E=F]R9&5RDR@Q*9-P<FEN=&8H(G!O<W1FX
M:7@ZD0I_^B(I.XZAC9( BS_'0$Q2<')ED0I_^D!R979O<F1E<I8%/_TH,2F3X
M<')I;G1F*")<;B(I.XZAC9( BS_'0$Q2<')ED0I_^G!R:6YT9B@B<')E9FEXX
M.I$/O_<B*3N.H8V1>W_00'V.H8V1)X  97AP<I84__0ZD22_ZV5X<'*3)RHGX
MD1H_\65X<'*.H8V1>W_00'N6!3_]0$Q2<&]S=)-P<FEN=&8H(I,JDR(I.XZAX
MC9( BS_'0$Q2<')ED0I_^G!R:6YT9B@BE@4__2J3(BD[CJ&-D7M_T$!]CJ&-X
MD5%_Z'R1)+_K97AP<I$4__0G*R>1&C_Q97AP<HZAC9%[?]! >Y8%/_U 3%)PX
M<F61"G_Z<')I;G1F*"*3*Y,B*3N.H8V2 (L_QT!,4G!O<W26!3_]<')I;G1FX
M*"*3*Y,B*3N.H8V1>W_00'V.H8V147_H?)$DO^ME>'!RD13_]"<O)Y$:/_%EX
M>'!RCJ&-D7M_T$![E@4__4!,4G!O<W23<')I;G1F*"*3+Y,B*3N.H8V2 (L_X
MQT!,4G!R99$*?_IP<FEN=&8H(I8%/_TODR(I.XZAC9%[?]! ?8ZAC9%1?^A\X
MD22_ZV5X<'*1%/_T)RTGD1H_\65X<'*.H8V1>W_00'N6!3_]0$Q2<&]S=)-PX
M<FEN=&8H(I,MDR(I.XZAC9( BS_'0$Q2<')ED0I_^G!R:6YT9B@BE@4__2V3X
M(BD[CJ&-D7M_T$!]CJ&-D5%_Z'R1)+_K)R@GD1H_\65X<'*1%/_T)RDGCJ&-X
MD5%_Z'R1)+_K242.H8V1>W_00'N6!3_]0$Q2<&]S=)-P<FEN=&8H(I,E<Y,BX
M+$!)1"YL97AE;65 *3N.H8V2 (L_QT!,4G!R99$*?_IP<FEN=&8H(I8%/_TEX
M<Y,B+$!)1"YL97AE;65 *3N.H8V1>W_00'V.H8V147_H?)$DO^M#3TY35(ZAX
MC9%[?]! >Y8%/_U 3%)P;W-TDW!R:6YT9B@BDR5SDR(L0$-/3E-4+FQE>&5MX
M94 I.XZAC9( BS_'0$Q2<')ED0I_^G!R:6YT9B@BE@4__25SDR(L0$-/3E-4X
M+FQE>&5M94 I.XZAC9%[?]! ?8ZAC9%1?^@[CJ&-D2>  "4ECI\D  "-D2> X
M &UA:6XH*8ZAC9$Q__I[>7EP87)S92@I.XZAC9$Q__I]CHZ.C(L    K    X
M                                              %A/* "<@  C:#]X
MM0  C8V1)X  VD&1"[_X55-)3D>6 ^JH3Y"L<EB;!1[!5TE42)-.3TXM3$58X
MF$Q%6$E#04R304Y!3)'_!5996D524Y%#%^S6-#..CJ "+0  C:#]^   C8V1X
M)X  YT&.D4IE4U5S:6YGE@:?O$]XDW=I=&B3;F]N+4QE>)-L97AI8V%LDV%NX
M86QY>F5R<XZ?'>(CC8V1)X  XD$N,8Z1476P1&5F875L=)L'9_9C;VZ5BCUTX
M97AT+7-E;G-I=&EV:723>9AO9IA,+0QL99AP<F5P<F^0=<)C97-S+8Z?$@  X
MC9%1=;!I;F>.J19  (V1)X  UE5N;&5S<Y8$F1-I;G-T<G5C=&5DDV]T:&5RX
M=VES92R1!,2N3WB3<V5A<F.:K')H97.396%CF&B33"T,;&639F]RD]QR971UX
M<FZ3UG-T871E;65NF'1SCJ0.@ "-D2>  &ENE@0TN'1H99-C;VZ:K')T97ATX
MDV]FDT,M8V^04XYD96233&5XDV%C=&EO;G,ND087$5-I;F-EDW1H99-S=')IX
M;F>3W')E='5R;I/6;9AU<W238I!3CF63:6<MCJ&-D2>  &YO<F5DE@.\I6]UX
M='-I9&63;V:3=&AA=)-C;VZ0K')T97ATDRAF;W*3:6YS=&%N8V4LFP/%V6ENX
MDV&33&5XDW)E9W5L87*397AP<F5S<VEO;BDLF'1H98ZAC9$G@ !D969A=6QTX
ME@2]46*:4XYE:&&0K')V:6]RDV]FDT]X+7!R97!R;YAC97-S:6YGDVESDW1OX
MDV%S<W5M99-T:&%TDW1H99-,+0QL99-C;VYF;W)M<XZAC9$G@ !T;Y8%"!MTX
M:&63<WENFJQR=&%XDV]FDV&3*'"04XYO<W-I8FQYDT]X+6%U9VUE;IAT960IX
MDTQE>),,;&4ND0B1.E1HF'5SDT]XDW)E8V]G;FEZ97..H8V1)X  =&AEE@/)X
M)G1H<F5ED]QR971U<FZ3UG-T871E;65NFJQR='.3:6Z3=&AEDV9O;&QOF'=IX
M;F>3*'5N875G;65NF'1E9"F39G)A9VUE;IATDV]FDV%NCJ&-D2>  $PM#&QEX
M.HZAGQ JJHV-G_@  (V1.1_T+HZD!   C9$Y'_0NCJ&-D3D?]"Z.CHZ?%7XNX
MC9$G@ #<<F5N86UE<Y$2AF=R971U<FXH5$M?4D5.04U%4RD[CJ&-D2>  ')EX
M='5R;I$8LS1R971U<FXH5$M?4D5455).*3N.H8V1)X  <F5V97)S99$2AF=RX
M971U<FXH5$M?4D5615)312D[CI\8TX.-C9_X  "-D3D?]-8NCJ0$  "-D3D?X
M]"Z.H8V1.1_T+HZ.CJ&AC9$G@ !A<Y8%K=!PD%..;VENFJQR='.3;V:3W')EX
M='5R;I/6;V:3=&]KF&5N<Y-BF'F3W'EY;&5XUBZ1"H)73W@G<Y-S96YS:71IX
M=FETF'F3=&^3=&AEDV-O;IAT97ATCJ&-D2>  &]FE@/,L71H99-S=')I;F>3X
MW')E='5R;I/6:6Z3=&AEDW-E8V]N9)-,97B3<F5G=6QA<I-E>'!R97-S:6]NX
MDV%BD%..;Y6L<G:399L#S+%P<F5VDV5NDW1SF&ET<XZAC9$G@ !E<G)O;F5OX
M=7.6 ^JH<F5C;V=N:71I;VZ387.389-PD%..;VEND*QR=)-O9I/<<F5T=7)NX
MD]9F<F]MDW1H99-L97AI8V%LDV%N86QY>F5R+HZ?(D87C8V1)X  XD$N,HZ1X
M476P3W@M<')E<')OFG7"8V5S<VEN9Y8%A1QO9I-#+6-OF&1E9)-L97AI8V%LX
MDV%N86QY>F5R<XZFC9$G@ #63WB;!1[Y86QWE:QR89-Y<YAI9VYO<F5SF'1HX
M99AS=')I;F>8W')E='5R;IC6:6Z8=&AEF&-O;I-T97ATF&]FF$,O0RLKF&-OX
M;6UE;I-T<XZAC9$G@ !A;F26!3R-<W1R:6YGDV-O;G-T86Z:K')T<RZ1"2Z0X
M5VAE;I-G:7:896Z3=&AED]PM1Y$%/#?68V]M;6%N9"UL:6YEDV]P=&EO;I-PX
M<F5C961I;F>.H8V1)X  =&AEE@1@$FYA;663;V:386Z33"T,;&4LD01];6ETX
MDVEG;F]R97.3W')E='5R;I/9;VYL>9/6:6Z3=&AO<V638V]NE:QR=&5X=',NX
MD0:9'U1HDW5SE@1@$F&3#&QECJ&-D2>  &-O;IJL<G1A:6YI;F>6 S[V0R]#X
M*RN38V^04XYD99-M89AYDV*04XYEDV%U9VUE;IAT9623=VET:)-A='1R:6)UX
M=&63<F5F97)E;F-EDW-E8W1I;VYSCJ&-D2>  &%N9)8% ;5I;G!U=)-T;Y-/X
M>)-A<Y-A;I-,+0QL92Z1"'X(5&AEDV^04XYC8W5R<F5N8V5SDV]FDW1H99-SX
M=')I;F>3W')E='5R;I/6;9"L<G5S=(ZAC9$G@ !C;VEN8VED998#ZJAE>&%CX
M=&QYDW=I=&B3W')E='5R;M9SDV]FDW1O:Y"L<F5N<RZ.GQ[&%XV-D2>  -M!X
M+C(N,8Z15#''17AA;7!L98ZFC9$G@ #64W5P<)!3CF]S998#RQ!I=)-I<Y-DX
M97-I<F5DDW1ODV-O;I6L<G:397)TE@/+$'1ODT]XDV&3=')A;G-L871O<I-TX
M:&%TDW5S97.3=&AEDV9O;&QOD*QR=VEN9Y-#CJ&-D2>  &-OD%..9&66 ^JHX
M9F]RDVET<Y-L97AI8V%LDV%N86QY>F5R.HZ.CHR+    +               X
M                                   !9:^@ G(  (V@_;4  (V-D2> X
M -I!D0N_^%5324Y'E@/JJ$^0K')8FP4>P5=)5$B33D].+4Q%6)A,15A)0T%,X
MDT%.04R1_P5665I%4E.10Q?LUC0TCHZ@ BT  (V@_?8  (V1)X  RB-I;F-LX
M=61ED04__3QS=&1I;RYH/HZD#   C9$G@  C:6YC;'5D99$%/_T\<W1R:6YGX
M+F@^CJ&-D2>  "-I;F-L=61ED04__2)Y+G1A8BYH(HZI&   C9$G@  C9&5FX
M:6YEE@4__6)U9G-I>F63.#".H8V1)X  8VAA<I$%/_UB=69;8G5F<VEZ95T[X
MCJ&-D2>  &-H87*1!3_]*FQE>$)U9CN.IHV1)X  8VAA<I$%/_TJ;&5X96UEX
M*&EN4W1R:6YG*8ZAC9$Q__IC:&%RD04__6EN4W1R:6YG6UT[CJ&-D3'_^GMRX
M971U<FZ6!3_]<W1R8W!Y*"AC:&%RDRHI;6%L;&]C*#$K<W1R;&5N*&EN4W1RX
M:6YG*2DL:6Y3=')I;F<I.WV.IHV1)X  :6YTD04__7EY;&5X*"F.H8V1,?_ZX
M>V-H87*6!3_]*F)U9G"3/9-B=68[CJ:-D3<_]W=H:6QEE@4__2@H*F)U9G"3X
M/9-G971C:&%R*"DIDR$]DT5/1BF.H8V10;_Q>VEFE@4__2AB=69PDST]DRABX
M=6:3*Y-B=69S:7IEDRV3,2DICJ&-D5:_Y7MF<')I;G1F*'-T9&5R<BPB97ACX
M965D9626!3_]8G5F9F5R7&XB*3N397AI="@M,2D[?8ZAC9%&_^YI9I8%/_THX
M*"IB=69PDST]DR>3)RF1"G_Z?'R3*"IB=69PDST]DR=<;B<IDWQ\CJ&-D5O_X
MXB@J8G5F<)8%/_T]/9,G7'0G*9-\?),H*F)U9G"3/3V3)UQF)RF.H8V15K_EX
M*8ZAC9%6O^5[:6:6!3_]*&)U9G"3/3V38G5F*9-C;VYT:6YU93N396QS99-BX
M<F5A:SM]CJ&-D4;_[FEFE@4__2@A:7-A;&YU;2@J8G5F<"DIDWMF<')I;G1FX
M*'-T9&5R<BPB:6QL96=A;)-C:&%R86-T97)<;B(I.Y-E>&ET*"TQ*3M]CJ&-X
MD4;_[F)U9G K*SN.H8V10;_Q?8ZAC9$W/_=I9I8%/_TH8G5F<),A/9-B=68IX
MCJ&-D4;_[GLJ*RMB=69PE@4__3V3)UPP)SN.H8V13#_K;&5X0G5FE@4__3V3X
M;&5X96UE*&)U9BD[CJ&-D4P_ZV)U9G"6!3_]/9-L97A"=68[CJ&-D4P_ZVEFX
MD04__2AI<V%L<&AA*&QE>$)U9ELP72DICJ&-D5O_XGMW:&EL998%/_TH*F)UX
M9G"3(3V3)UPP)RF.H8V1:[_9:6:1!3_]*&ES9&EG:70H*F)U9G K*RDICJ&-X
MD7M_T'MF<')I;G1F*'-T9&5R<BPB:6QL96=A;)8%/_US=')I;F=<;B(I.Y-EX
M>&ET*"TQ*3M]CJ&-D6$_WW)E='5R;I$%/_TH241%3E0I.XZAC9%;_^)]CJ&-X
MD4P_ZVEFD04__2AI<V1I9VET*&QE>$)U9ELP72DICJ&-D5O_XGMW:&EL998%X
M/_TH*F)U9G"3(3V3)UPP)RF.H8V1:[_9:6:1!3_]*&ES86QP:&$H*F)U9G KX
M*RDICJ&-D7M_T'MF<')I;G1F*'-T9&5R<BPB:6QL96=A;)8%/_US=')I;F=<X
M;B(I.Y-E>&ET*"TQ*3M]CJ&-D6$_WW)E='5R;I$%/_TH24-/3E-4*3N.H8V1X
M6__B?8ZAC9%&_^Y]CJ&-D3<_]W)E='5R;I$%/_TP.XZAC9$Q__I]CHZ.C(L X
M   M                                                  %MZJ "X
M<@  C:#]M0  C8V1)X  VD&1"[_X55-)3D>6 ^JH3Y"L<EB;!1[!5TE42)-.X
M3TXM3$58F$Q%6$E#04R304Y!3)'_!5996D524Y%#%^S6-#6.CJ "+0  C:#]X
M]@  C9$Y'_14:&66!$+M0Y-R97-E<G::K')E9)-WF&]R9)/<<F5T=7)ND]9OX
MD%..8V-U<G.3:6Z3=&AEDPQL99-E>&%C=&QYDV9O=7*3=&EM97,ND09!KT]NX
M;'F.I Z  (V1)X  =)6L<G>3;Y8$'AUO9I-T:&5S99-OFE..8V-U<G)E;F-EX
M<Y-C;W)R97-PF&]N9)-T;Y/<<F5T=7)NUG.3;V:3=&]KFJQR96YSDV*8>9-TX
M:&63;&5X:6-A;)-A;BV.H8V1)X  86QY>F5R+I$&G.M4:&66!&%687!P<F]AX
M8YJL<FB3:7.3=&^397AC:7-EDV9R;VV3=&AEDPQL99-ADW-E8W1I;VZ3;V:3X
M8V^04XYD99-C;VZ8=&%I;FEN9XZAC9$G@ !T:&]S99L$ISYTE:QR=Y-OF&^5X
M4XYC8W5R<F5N8V5SF"AA;F28;F^8;W1H97)S*2R1!-9D<&QA8V68=&AA=)ACX
M;Y-D99AS96-T:6]NF&ETF&ENF&&8<V5P+8ZAC9$G@ !A<F%T998$L]0,;&4LX
MFP3F'V%N9)-S=6)M:723=&AEDVYE=Y,,;&63=&^33WB387.389-N;VXM3&5XX
MDTPM#&QE+)ABD*QR>9-U<VEN9Y-T:&6.H8V1)X  W"U'D0/,Q]9O<'1I;VXNX
MFP4N[4]XE@/,SW1R86YS;&%T97.3=&AEDVYE=Y,,;&6386YDDW!L86-E<Y-IX
M=)-O;I/<;WAO=70N;-8NF%1H99-E>&-I<V5DCJ&-D2>  &-OD%..9&66 ^JHX
M:7.3<F5P;&%C9623:6Z3=&AEDV]R:6=I;F%LDPQL99-BD*QR>9-T:&63;&ENX
M93J.I!B  (V11F !W"-I;F-L=61ED08LS2)O>&]U="YL(HZAC9$Y'_362&5RX
M998$/(II<Y-T:&633"T,;&4LD011 W=H:6.:K')HDVAA<Y-BD%..965NDV%UX
M9VUE;IAT96238IAYDW28=YAODV%T=')I8G5T99-R969E<F5N8V6.J0Z  (V1X
M)X  <V5C=&EO;G,ZCI\9  "-D4P_Z\II9I$%/_TH:7-A;'!H82AL97A"=69;X
M,%TI*8ZD#   C9%;_^)[=VAI;&66!3_]*"IB=69PDR$]DR=<,"<ICJ&-D6N_X
MV6EFD04__2AI<V1I9VET*"IB=69P*RLI*8ZAC9%[?]![9G!R:6YT9BAS=&1EX
M<G(L(FEL;&5G86R6!3_]<W1R:6YG7&XB*3N397AI="@M,2D[?8ZAC9%A/]]RX
M971U<FZ6!3_]*$E$14Y4*3N1"G_Z0'N30$E$14Y4+G-T<FEN9T"3/9-L97A"X
M=68[DT!]CJ&-D5O_XGV.H8V13#_K:6:1!3_]*&ES9&EG:70H;&5X0G5F6S!=X
M*2F.H8V16__B>W=H:6QEE@4__2@J8G5F<),A/9,G7# G*8ZAC9%KO]EI9I$%X
M/_TH:7-A;'!H82@J8G5F<"LK*2F.H8V1>W_0>V9P<FEN=&8H<W1D97)R+")IX
M;&QE9V%LE@4__7-T<FEN9UQN(BD[DV5X:70H+3$I.WV.H8V183_?<F5T=7)NX
ME@4__2A)0T].4U0I.Y- >Y- 24-/3E-4+G-T<FEN9T"3/9-L97A"=68[DT!]X
MCJ&-D5O_XGV.GQN  (V1.1_TUDAE<F66 S?V:7.3=&AEDW-KFJQR96QE=&]NX
MDV]FDW1H99-L97AI8V%LDV%N86QY>F5R+)$#6[-W:&ECF&B3;F^8=Y/<(VENX
M8VQU9&76<Y-T:&63#&QE<XZFC9$G@ #<;WAO=70N:)8#ZJC686YDD]QO>&]UX
M="YLUCJ.CHZ,BP   "X                                         X
M         7-KH )R  "-H/VU  "-C9$G@ #:09$+O_A54TE.1Y8#ZJA/D*QRX
M6)L%'L%7251(DTY/3BU,15B83$5824-!3)-!3D%,D?\%5EE:15)3D4,7[-8TX
M-HZ.H (M  "-H/WV  "-D2>  ,HC:6YC;'5D99$%/_T\<W1D:6\N:#Z.I P X
M (V1)X  (VEN8VQU9&61!3_]/'-T<FEN9RYH/HZAC9$G@  C:6YC;'5D99$%X
M/_TB>2YT86(N:"*.H8V1)X  (VEN8VQU9&61!3_](F]X;W5T+F@BCJD8  "-X
MD2>  "-D969I;F66!3_]8G5F<VEZ99,X,(ZAC9$G@ !C:&%RD04__6)U9EMBX
M=69S:7IE73N.H8V1)X  8VAA<I$%/_TJ;&5X0G5F.XZFC9$G@ !C:&%RD04_X
M_2IL97AE;64H:6Y3=')I;F<ICJ&-D3'_^F-H87*1!3_]:6Y3=')I;F=;73N.X
MH8V1,?_Z>W)E='5R;I8%/_US=')C<'DH*&-H87*3*BEM86QL;V,H,2MS=')LX
M96XH:6Y3=')I;F<I*2QI;E-T<FEN9RD[?8ZFC9$G@ !I;G21!3_]>7EL97@HX
M*8ZAC9$Q__I[8VAA<I8%/_TJ8G5F<),]DV)U9CN.IHV1-S_W=VAI;&66!3_]X
M*"@J8G5F<),]DV=E=&-H87(H*2F3(3V314]&*8ZAC9%!O_%[:6:6!3_]*&)UX
M9G"3/3V3*&)U9I,KDV)U9G-I>F63+9,Q*2F.H8V15K_E>V9P<FEN=&8H<W1DX
M97)R+")E>&-E961E9)8%/_UB=69F97)<;B(I.Y-E>&ET*"TQ*3M]CJ&-D4;_X
M[FEFE@4__2@H*F)U9G"3/3V3)Y,G*9$*?_I\?),H*F)U9G"3/3V3)UQN)RF3X
M?'R.H8V16__B*"IB=69PE@4__3T]DR=<="<IDWQ\DR@J8G5F<),]/9,G7&8GX
M*8ZAC9%6O^4ICJ&-D5:_Y7MI9I8%/_TH8G5F<),]/9-B=68IDV-O;G1I;G5EX
M.Y-E;'-EDV)R96%K.WV.H8V11O_N:6:6!3_]*"%I<V%L;G5M*"IB=69P*2F3X
M>V9P<FEN=&8H<W1D97)R+")I;&QE9V%LDV-H87)A8W1E<EQN(BD[DV5X:70HX
M+3$I.WV.H8V11O_N8G5F<"LK.XZAC9%!O_%]CJ&-D3<_]VEFE@4__2AB=69PX
MDR$]DV)U9BF.H8V11O_N>RHK*V)U9G"6!3_]/9,G7# G.XZAC9%,/^ML97A"X
M=6:6!3_]/9-L97AE;64H8G5F*3N.H8V13#_K8G5F<)8%/_T]DVQE>$)U9CN.X
MIHV1)X  (VEN8VQU9&61!3_](F]X;W5T+FPBCJ:-D4;_[GV.H8V1-S_W<F5TX
M=7)ND04__3 [CJ&-D3'_^GV.CHZ,BP   "\                         X
M                         7E#H )R  "-H/VU  "-C9$G@ #:0I$+O_A4X
M4D&1_K'(5D524T%,D0/JJ%-%34%.5$E#4Y( TMLAUC0WCHZ@ BT  (V@_?@ X
M (V-D2>  .="CI%)@@!4D?Y8$')AEO]RL':397)S86R1!I^\<V5M86Z3=&ECX
M<XZ?&F(CC9$G@ #65&AEE@/?V&*:4XYE:&&0K')V:6]RDV]FDW"8;W-T9&5CX
M;W)A=&EO;I-T<F&5K')VDV5R<V%L<YL#W]AWDV%SF&EL;'5S=')A=&5DF&ENX
MF'1H99AE>&%M<&QE<YAO9HZD#H  C9$G@ !S96-T:6]NE@*]VCDN,BZ1!-2;X
M26Z3=FEE=Y-O9I-T:&]S99-E>&%M<&QE<RR1 OH#=&AEDT,M;&EKD*QR99-PX
M<V5U9&^54XYC;Y-D998"O=II;I-T:&ESDV%P<)!3CF5N9&EXCJ&-D2>  &AOX
M;&1SE@+D*&YODW-U<G!R:7-E<RR1 QBH8G5TDV1E<V-R:6*:4XYE<Y-S=6.0X
MK')HDV*896AAD*QR=FEO<I-S;VUE=VAA=)-M;W)EDV9O<FUA;&QYD?\%5BZ1X
M!.%@5&AECJ&-D2>  '1R896L<G:397)S86QSE@/>HV%R99-C87)R:65DDV]UX
M=)-BFJQR>9-ADW-I;F=L99-C86QLDV]FD]QD;U1R879E<G-A;'.3UBABD%..X
M96QOF'<IDV%F=&5RDW1H98ZAC9$G@  ,;F%LD0/JJ&1E8V]R871I;VXNCI\9X
M  "-D2>  ,IE;G5ME@4__6]R9&5R5'EP99-[4%)%3U)$15(L4$]35$]21$52X
M?3N.I P  (V1)X  96YU;98%/_UD:7)E8W1I;VY4>7!EDWM,14945$]224=(X
M5"Q224=(5%1/3$5&5'T[CJDP  "-D2>  &5N=6V6!3_];W)D97)4>7!EDW-TX
M871I8T]R9&5R*'1R879E<G-A;)-4*8ZAC9$Q__I[:6:6!3_]*$!P<F5O<F1EX
M<I-A<'!E87)SDVENDW1H99-T<F%V97)S86R3<W!E8VEF:6-A=&EO;I-O9I-4X
M*8ZAC9%,/^MR971U<FZ1!3_]4%)%3U)$15([CJ&-D3<_]W)E='5R;I$%/_U0X
M3U-43U)$15([CJ&-D3'_^GV.IHV1)X  96YU;98%/_UD:7)E8W1I;VY4>7!EX
MDW-T871I8T1I<F5C=&EO;BAT<F%V97)S86R35"F.H8V1,?_Z>VEFE@4__2A X
M<FEG:'1T;VQE9G2387!P96%R<Y-I;I-T:&63=')A=F5R<V%LDW-P96-I9FECX
M871I;VZ3;V:35"F.H8V13#_K<F5T=7)ND04__5))1TA45$],1494.XZAC9$WX
M/_=R971U<FZ1!3_]3$5&5%1/4DE'2%0[CJ&-D3'_^GV.IHV1)X  :6YTE@4_X
M_6ES1&ES86)L960H=')A=F5R<V%LDU0ICJ&-D3'_^GMI9I8%/_TH0&1I<V%BX
M;&6387!P96%R<Y-I;I-T:&63=')A=F5R<V%LDW-P96-I9FEC871I;VZ3;V:3X
M5"F.H8V13#_K<F5T=7)ND04__3$[CJ&-D3<_]W)E='5R;I$%/_TP.XZAC9$QX
M__I]CHZ.C(L    P                                            X
M      %]AZ "<@  C:#]M0  C8V1)X  VD*1"[_X5%)!D?ZQR%9%4E-!3)$#X
MZJA314U!3E1)0U.2 -+;(=8T.(Z.H (M  "-H/WV  "-D2>  ,IV;VEDE@4_X
M_7!D5')A=BAP87)S95]T<F5E7VYO9&633BR3=')A=F5R<V%LDU0ICJ0,  "-X
MD3'_^GMG<F%M;6%R7W)U;&66!3_]4CN1/O_<+RJ3=&AEDW)U;&6387!P;&EEX
M9)-A=)-.DRHOCJ&-D3<_]V5N=6V6!3_];W)D97)4>7!EDV]R9&5R6UI=.Y$/X
MO_<O*I8*?_I:DSX]DR.6!3_];V:3=')A=F5R<V%LDV%C=&EO;I-S<&5C<XZAX
MC9( _K^%9F]RE@4__523:6Z34I$*?_HJ+XZAC9$W/_=E;G5ME@4__61I<F5CX
M=&EO;E1Y<&639&ER96-T:6]N.XZAC9$W/_=I;G21!3_]:2QJ+&L[CI\8  "-X
MD3<_]U*6!3_]/9-T:&639W)A;6UA<I-R=6QEDV%P<&QI962387233CN.H8V1X
M-S_W;&5TE@4__71H99-T<F%V97)S86R386-T:6]N<Y-F;W*35)-I;I-T:&63X
M871T<FEB=71EDV1E9FEN:71I;VZ3<V5C=&EO;HZAC9%,/^MO9I8%/_U2DV)EX
MDVYU;6)E<F5DDV9R;VV3,)-T;Y-K+3$[CJ&-D3<_]V9O<I8%/_TH:3TP.Y-IX
M/&L[DVDK*RF.H8V13#_K>VEFE@4__2AT:&63:71HDW1R879E<G-A;)-A8W1IX
M;VZ3<W!E8VEF:65RDVAA<Y-N;Y- <F5V;W)D97(ICJ&-D78_TV]R9&5R6VE=X
ME@4__3V3<W1A=&EC3W)D97(H5"D[CJ&-D6$_WV5L<V66!3_]:6:3*"AT:&63X
M97AP<F5S<VEO;I-A<W-O8VEA=&5DDW=I=&B30')E=F]R9&5R*9,]/9,P*8ZAX
MC9%V/]-O<F1E<EMI798%/_T]DW-T871I8T]R9&5R*%0I.XZAC9%A/]]E;'-EX
ME@4__6EFDRAS=&%T:6-/<F1E<BA4*9,]/9-03U-43U)$15(ICJ&-D78_TV]RX
M9&5R6VE=E@4__3V34%)%3U)$15([CJ&-D6$_WV5L<V6.H8V1=C_3;W)D97);X
M:5V6!3_]/9-03U-43U)$15([CJ&-D5%_Z&EFE@4__2AT:&63:71HDW1R879EX
M<G-A;)-A8W1I;VZ3<W!E8VEF:65RDVAA<Y-N;Y- <F5V9&ER96-T:6]N*8ZAX
MC9%V/]-D:7)E8W1I;VZ6!3_]/9-S=&%T:6-$:7)E8W1I;VXH5"D[CJ&-D6$_X
MWV5L<V66!3_]:6:3*"AT:&6397AP<F5S<VEO;I-A<V]C:6%T9623=VET:)- X
M<F5V9&ER96-T:6]N*9,]/9,P*8ZAC9%V/]-D:7)E8W1I;VZ6!3_]/9-S=&%TX
M:6-$:7)E8W1I;VXH5"D[CJ&-D6$_WV5L<V66!3_]:6:3*'-T871I8T1I<F5CX
M=&EO;BA4*9,]/9-,14945$]224=(5"F.H8V1=C_39&ER96-T:6]NE@4__3V3X
M4DE'2%143TQ%1E0[CJ&-D6$_WV5L<V6.H8V1=C_39&ER96-T:6]NE@4__3V3X
M3$5&5%1/4DE'2%0[CJ&-D4P_ZWV.H8V1-S_W9F]RE@4__2AI/3 [DVD\:SN3X
M:2LK*8ZAC9%,/^MI9I8%/_TH;W)D97);:5V3/9-04D5/4D1%4BF.H8V183_?X
M97AE8W5T998%/_UT:&63:71HDW1R879E<G-A;)-A8W1I;VX[CJ&-D3<_]VYUX
M;6)E<I8%/_UT:&638VAI;&1R96Z3;V:33I-F<F]MDVQE9G23=&^3<FEG:'2.X
MH8V147_H=VET:)8%/_UI;G1E9V5R<Y-F<F]MDS"3=&^3:BTQ.XZAC9$W/_=IX
M9I8%/_TH9&ER96-T:6]NDST]DTQ%1E143U))1TA4*8ZAC9%,/^MF;W*6!3_]X
M*&D],#N3:3QJ.Y-I*RLID0I_^G!D5')A=BAT:&63:71HDV-H:6QDDV]FDTXLX
M5"D[CJ&-D4P_ZV5L<V6.H8V13#_K9F]RE@4__2AI/6HM,3N3:3X],#N3:2TMX
M*9$*?_IP9%1R878H=&AEDVET:)-C:&EL9)-O9I-.+%0I.XZAC9$W/_=F;W*6X
M!3_]*&D],#N3:3QK.Y-I*RLICJ&-D4P_ZVEFE@4__2AO<F1E<EMI79,]DU!/X
M4U1/4D1%4BF.H8V183_?97AE8W5T998%/_UT:&63:71HDW1R879E<G-A;)-AX
M8W1I;VX[CJ&-D3'_^GV.CHZ,BP   #$                             X
M                     8)EH )R  "-H/VU  "-C9$G@ #:0I$+O_A44D&1X
M_K'(5D524T%,D0/JJ%-%34%.5$E#4Y( TMLAUC0YCHZ@ BT  (V@_?8  (V1X
M)X  RG9O:621!3_]9&]4<F%V97)S86QS*"F.I P  (V1,?_Z>VEN=)$%/_UIX
M+&L[CJ&-D3<_]W!A<G-E7W1R965?;F]D99$%/_UR.XZ?&   C9$W/_=RE@4_X
M_3V3=&AEDW)O;W23;V:3=&AEDW!A<G-EDW1R964[CJ&-D3<_]VN6!3_]/9-TX
M:&63;G5M8F5RDV]FDW1R879E<G-A;',[CJ&-D3<_]VYU;6)E<I8%/_UT:&63X
M=')A=F5R<V%L<Y-F<F]MDS"3=&^3:RTQ+)-A8V-O<F1I;F>3=&^.H8V11O_NX
M=&AEE@4__6]R9&5RDV]FDV%P<&5A<F%N8V63;V:3=&AE:7*3<W!E8VEF:6-AX
M=&EO;G,[CJ&-D3<_]V9O<I8%/_TH:3TP.Y-I/&L[DVDK*RF.H8V13#_K:6:6X
M!3_]*"%I<T1I<V%B;&5D*'1H99-I=&B3=')A=F5R<V%L*2F.H8V16__B<&14X
M<F%V*'(L=&AEE@4__6ET:)-T<F%V97)S86PI.XZAC9$Q__I]CHZ.C(L    RX
M                                                  &)2Z "<@  X
MC:#]M0  C8V1)X  VD.1"[_X3$E35)8#ZJA/1I-215-%4IO^L<A614235Y"LX
M<D]21%.304Y$DU)%4T52F%9%1)-&24Q%DTY!3453D1#="=8U,(Z.H (M  "-X
MH/WX  "-C9$G@ #G0XZ12;E+3&ES=)8(ZS%O9I-R97-E<G:;_W*P9623=YAOX
M<F1SDV%N9)-R97-E<G:89623#&QECI\6  "-D4FY2VYA;65SCI\:8B.-D2> X
M -94:&66 ^JH3WB3<F5S97)VFJQR9623=YAO<F1SDV%R99-A<Y-F;VQL;YAWX
M<SJ.I Z  )]W__B-C8V?DR9KC8V1+8  W$#89HZ.I Y__XV-D2V  -Q V&>.X
MCJ&-C9$M@ #<0&%T=')I8G5T97..CJ&-C9$M@ ! 875T;VEN:(Z.H8V-D2V X
M $!A=71O<WENCHZAC8V1+8  0&1I<V%B;&6.CJ&-C9$M@ ! 98Z.H8V-D2V X
M $!ICHZAC8V1+8  0&QE9G1T;W)I9VATCHZAC8V1+8  0&V.CJ&-C9$M@ ! X
M<&]S=&]R9&5RCHZAC8V1+8  0'!R96]R9&5RCHZAC8V1+8  0')E=F1I<F5CX
M=&EO;HZ.H8V-D2V  $!R979O<F1E<HZ.H8V-D2V  $!R:6=H='1O;&5F=(Z.X
MH8V-D2V  $!W87)NCHZ.CHZ?<?_XH:&-D2>  -94:&66!:-S9F]L;&^:K')WX
M:6YGDPQL99-N86UE<Y-I;I-T:&638W5R<F5NF'239&ER96-T;W)YDV%R99-RX
M97-E<G:896239F]RDW5S99-BF'F.H8V1)X  3W@ZCJ&?(/_^C8V-G^HF98V-X
MD2V  -QO>&]U="YHCHV2 /,(<M8H97AA8W1L>98#ZJAW:&5NDW5S:6YGD]PMX
M:)/6;W!T:6]N*8Z.I Y__XV-D2V  -QO>&]U="YYCHZAC8V1+8  ;WAO=70NX
M;(Z-D@#S"'+6*&5X86-T;'F6 ^JH=VAE;I-U<VEN9Y-E>&%C=&QYDV]N99-9X
M+0QL92F.CJ&-C9$M@ #<;WAO=70P+FS6+)8#ZJC<;WAO=70Q+FS6+)/<;WAOX
M=70R+FS6+(V-D]<ZE@'__CJ3.HZ.CHV2 /,(<M8H=VAE;I8#ZJAU<VEN9Y-MX
M;W)EDW1H86Z3;VYEDTPM#&QE*8Z.CHZ.GQK__HZ.C(L    S            X
M                                      &+4* "<@  C:#]M0  C8V1X
M)X  VD21"[_X4U5-34%2D?\%5EF6 ^JH3T:30T]-34%.1"U,24Y%DT]05$E/X
M3E.1<F^FUC4QCHZ@ BT  (V@_?@  (V-D2>  .=$CI%*G)]3=6UM87)YE@:?X
MO&]FDV-O;6UA;F0M;&EN99-O<'1I;VYSCI\:8B.-D2>  -94:&66 ^JH3WB3X
M8V]M;6%N9)-L:6YEDW1A:Y"L<F5SDW1H99-F;W)M.HZD#H  H8V1.1_TW&]XX
ME@/JJ-AFD]EO<'1I;VZ3V&>3V5DM#&QED]9;W"U'UEV3V4PM#&QED]AFD]9;X
MW"U'UEV3V4PM#&QED]AGCJ&AC9$G@ #65&AEE@/JJ-PM1Y/686YNFJQR=6YCX
M:6%T;W*386YDDW1H99/9;W!T:6]NUG.387)EDV1E<V-R:6*04XYE9)-A<Y-FX
M;VQL;YAW<SJ.J1B  (V-C9$G@ #<+4>.CI$YN9;65&AEE@.0:PQL96YA;663X
M=VAI8YJL<FB39F]L;&^8=W.3:7.3=&AA=)-O9I-ADV=E;F5R:6.3*&DN92Z;X
M!1K,;F]N+4QE>"F33"T,;&4NF%1H:7..H8V11-_L;W!T:6]NE@-<IVESDW5SX
M9623=VAE;I-T:&633WB3=7-E<I-P<F5F97)SDV&3<V-A;FYE<I-H86YD+7=RX
M:71T96Z3:6Z30Y-O<HZAC9%$W^Q#*RLND05LBD5X8V5P=)8#^^%F;W*3871TX
M<FEB=71EDW)E9F5R96YC99-S96-T:6]N<RR1!  O=&AEDTPM#&QEDVV0K')UX
M<W238V]N9F]R;8ZAC9%$W^QT;Y8%:"=#+T,K*Y-S>6Z:K')T87@ND0FQ751HX
M99/<<F5T=7)ND]9R97-E<G:89623=YAO<F23:7.3<F5C;V=N:7IE9)-I;I-AX
M;IAYCJ&-D43?[&-O;IJL<G1E>'26 ^JH;W1H97*3=&AA;I-C;VUM96Z8='.3X
M86YDDW-T<FEN9Y-L:71E<F%L<RZ1!3C@4V5EDV%P<)!3CF5N9&EXDT$NCJ:-X
MC8V1)X  W"U#CHZ1.;F6UE!R:6Z:K')TE@/JJ'1H99-/>)-C;W"8>7)I9VB8X
M=)-S=&%T96UE;IATDV%N9)-D:7-C;&%I;65R+HZFC8V-D2>  -PM28Z.D3FYX
MEM9'96YE<F%T998#ZJAC;Y!3CF1EDV9O<I-#*RN3;W*304Y322])4T^30Y-CX
M;VUP:6QA=&EO;BZ.IHV-C9$G@ #<+5..CI$YN9;64W1R:7"6!/0_3W@M<W"0X
M4XYE8VD,8Y-C;VYS=')U8W1SDV9R;VV3=&AEDUDM#&QEDV%N9)-,+0QL92ASX
M*9-A;F23<&QA8V63=&AECJ&-D43?['!U<F66 ^JH69'_!59A8V.386YDDW!UX
M<F633&5XDW)E<W5L='.3;VZ3W&]X;W5T*BXJUBZ1!3C@4V5EDW-E8W1I;VZ3X
M,3,N,RZ.IHV-C9$G@ #<+56.CI$YN9;64VAOD*QR=Y8#ZJAT:&639F]R;9-OX
M9I-T:&633WB38V]M;6%N9)-L:6YE+HZFC8V-D2>  -PM5HZ.D3FYEM90<FENX
MFJQR=)8#ZJAT:&63=IAE<G-I;VZ3;IAU;9ABD%..97(NCJ:-C8V1)X  W"UHX
MCHZ1.;F6UE!R;YI3CF1U8V66!+^;86Z33WB3:&5A9&5RDPQL99/<;WAO=70NX
M:)/6=&^38IAED]PC:6YC;'5D9=9DDVENDV&38V^89&63<V5C=&EO;HZAC9%$X
MW^PH8II3CF5TE:QR=Y-E96Z6!+AUW"789I/686YDD]PEV&?6*9-I;I-T:&63X
M62T,;&63;W*33"T,;&4H<RDND0>B2%1H:7.3<)AE<FUI='.3;VYE+7-T97".X
MH8V11-_L8V]M<&EL871I;VZ6 Q8F;V:3=&AEDW!A<G-E<I-A;F23<V-A;FYEX
M<BAS*2Z1!/(*5VAE;I-T:&ESDV]P=&EO;I-I<Y-N;W23=7-E9"R.H8V11-_LX
M3WB6!%@$<&QA8V5SDW1H99-H96%D97*3:6YF;W)M871I;VZ3:6Z396%CD*QRX
M:)-O=71P=723#&QEDW)A=&AE<I-T:&%NDVENDV&.H8V11-_L<V5P87)A=&66X
M ^JH:&5A9&5RDPQL92Z1!3C@4V5EDW-E8W1I;VZ3,3(N,RZ.IHV-C9$G@ #<X
M+6Z.CI$YN9;61V5N97)A=&66 R6C86Z397:;_UCD86QU871O<I-T:&%TDV1EX
M=&5R;6EN97.386Z397:886QU871I;VZ3;W)D97*386YDDV.5K')H96.3:W.1X
M R6C9F]RCJ&-D43?[&-Y8VQE<RR1 Q:28G5TE@+AC61OFE..97.3;F]TDV5XX
M96-U=&63=&AEDV-OF&1EDW1H872397:1_UCD86QU871E<Y-A='1R:6)U=&63X
M:6YS=&%N8V5S+HZAC9%$W^Q39666 ^JH<V5C=&EO;I,Q,RXT+HZFC8V-D2> X
M -PM=8Z.D3FYEM9'96YE<F%T998#YK%A;I-E=I'_6.1A;'5A=&]RDW1H8723X
M<')I;I"L<G1SDW!A<G-E+71R9663;65M;W)Y+75S86=EDW-T871I<W1I8W.3X
M9F]RCJ&-D43?[&5A8Y"L<FB6 ^JH:6YP=70ND04XX%-E99-S96-T:6]NDS$SX
M+C8NCJ:-C8V1)X  W"UAUTZ.CI%$8RS64V5TE@,<>]=.D01=7]9A<Y-T:&63X
M9V5N97)A=&5DDV5VD?]8Y&%L=6%T;W(G<Y-D969A=6QTDW-T<G5C='5R92UAX
M;&EG;FUE;I"L<G23<VEZ92Z1!/0F0GF.H8V11-_L9&5F875L="R6 ^JH=&AEX
MDV1E9F%U;'23<W1R=6-T=7)E+6%L:6=N;65ND*QR=)-S:7IEDVESDS0ND04XX
MX%-E99-S96-T:6]NDS$S+C(NCHZ.C(L    T                        X
M                          &.^* "<@  C:#]M0  C8V1)X  VD21"[_XX
M4U5-34%2D?\%5EF6 ^JH3T:30T]-34%.1"U,24Y%DT]05$E/3E.1<F^FUC4RX
MCHZ@ BT  (V@_?8  (V-C9$G@ #<+5G784Z.CI%*CBW65VAE<F66!/3NUTZ1X
M!C72UFESDV%NDVENFJQR=&5G97*386YDD]=AD]9I<Y-O;F63;V:3=&AEDV%LX
M<&AA8I!3CF5T:6.38YAH87)A8W1E<G.3W&[6+(ZD#H  C9%$W^S<8]8LE@5%X
M!&]RFP3_O]QRUBR38Y"L<FAA;F=EF'1H99AD969A=6QTF'-I>F68;V:89&%TX
M89AS=')U8W1U<F68UV&8UFENF'1H99AG96YE<F%T962.H8V11-_L97:1_UCDX
M86QU871O<I8%TP]T;Y-S:7IED]=.D0% Y-8ND0KR%E=H96Z3<W5CD*QR:)-AX
MDV1A=&&3<W1R=6-T=7)EDVESDV5X8V5E9&5D+)$&32ET:&6.H8V11-_L9V5NX
M97)A=&5DE@1>XF5VD?]8Y&%L=6%T;W*3:7-S=65SDV%NDV5R<F]RDVUE<W-AX
M9V638V%L;&EN9Y-F;W*3=7-EDV]FDV&3W"U9UV%.CJ&-D43?[-9O<'1I;VXNX
MD04SZE1H998#V\9E"V5C='.3;V:3=&AED]PM6==A3I$%'*K6;W!T:6]N<Y-FX
M;W*3=&AEDW:;_UCD87)I;W5SDW:886QU97.3;V:3UV&3UF%R98ZAC9%$W^QAX
M<Y$#ZJAF;VQL;Y"L<G=S.HZ?&(  C8V-D43?[-QNCHZ14.RU+5ENUTZ;!'LNX
MUF-A=7-E<Y8#.DIA;&QOD%..8V%T:6]NDV]FD]=.F-9BD*QR>71E<Y-F;W*3X
M<&%R<V4M=')E99-N;Y!3CF1E<Y-A;F23871T<FEB=71ECJ&-D5ZY<6EN<W1AX
M;F-E<RZ.J1.  (V-C9%$W^S<8XZ.D5#LM==.D00<Z]9I<Y8"W =T:&63;6%XX
M:6V:K')U;9-NF'5MF&*:4XYE<I-O9I-N;VXM<F^8;W23;F^89&5SDVENDW1HX
M99-P87)S99-T<F5E+I$$WJK<+5ECUTZ.H8V17KEQUF-A=7-E<Y8%*8%A;&QOX
MFE..8V%T:6]NDV]FD]=.D09J9=PJE@8LS7-I>F5O9BAV;VEDDRHIE@4I@=9BX
MD*QR>71E<Y-F;W*3<)AO:6Z0K')T97)SDW1OCJ&-D5ZY<6.0K')H:6QDD0/JX
MJ&YOD%..9&5S+HZFC8V-D43?[-QRCHZ14.RUUTZ1!7MRUFESE@0ZCG1H99-MX
M87AI;9JL<G5MDVZ8=6V88I!3CF5RDV]FDV%T=')I8G5T99-I;G-T86YC97.3X
M:6Z3=&AEDW!A<G-EDW1R964NCJ&-D5ZY<==.D04KC-9BD*QR>71E<Y8#ZJAAX
M<F6386QL;Y!3CF-A=&5DDV9O<I-T:&ES+HZD&(  C9%$W^Q39666 ^JH<V5CX
M=&EO;G.3,3,N-9-A;F23,3,N-BZ.H8V-C9$G@ #<+5E9CHZ1/^9CUD5N86)LX
M998$A3IT:&639V5N97)A=&5DDV5VD?]8Y&%L=6%T;W*3=&^3=6YD97)S=&%NX
M9)-T:&63<V%M99/<+5G784Z1!<8>UF]P=&EO;G..J0Z  (V11-_L87.6 ^JHX
M9&^04XYE<Y-/>)-I='-E;&8ND04XX%-E99-S96-T:6]NDS$S+C4NCJ&-C8V1X
M)X  W"U8UV%.CHZ12HXMUE=H97)EE@22&-=.D072_-9I<Y-A;I-I;IJL<G1EX
M9V5RDV%N9)/789/6:7.386Z386QP:&%BD%..971I8Y-CF&AA<F%C=&5R+)$$X
MN_-CF&AA;F=EDW1H98ZFC9%$W^QD969A=6QTE@5AU7-I>F63;V:33W@G<Y-DX
M871ADW-T<G5C='5R99/789/6=&^3<VEZ99/73I$!0.36+I$)GF=7:&5NDW-UX
M8Y"L<FB389-D871ACJ:-D43?['-T<G5C='5R998$I.AI<Y-E>&-E961E9"R1X
M!--X3WB3:7-S=65SDV%NDV5R<F]RDVUE<W-A9V638V%L;&EN9Y-F;W*3=7-EX
MDV]FDV&.IHV11-_LW"U8UV%.D04KC-9O<'1I;VXNCHZ.C(L    U        X
M                                          &7N: "<@  C:#]M0  X
MC8V1)X  VE)%1D5214Y#15.2 2E]"-8U,XZ.H (M  "-H/WX  "-D2>  .=2X
M969E<F5N8V5SCI\:8B.-C8V1)X  UEM*;VAN<V]ND0/JJ#<U78Z.D@"+_"Y3X
M=&5P:&5NE@/Y?D,NDTIO:&YS;VXLD0/],]E9EO\9F6%CD?]F9F,ZD06!KUF3X
M9726!$#809"S,FYO=&AE<I-#;VUP:6QE<I-#;VTMCJ0.@ "-D@"+_"YP:6QEX
M<M8LD0F+P$-O;7!U=&EN9Y8(:XA38VEE;F-EDU21_P5696.0K')H;FEC86R3X
M4F5PD%..;W)TDTYO+I,S,BR.H8V2 (O\+D&1_P565"94D0-JJ$)E;&R6 VK(X
M3&%BD%..;W)A=&]R:65S+)L#A%M-=7)R89"L<GF32&EL;"R83F5WDTIE<G-EX
M>9'_!58LF#$Y-S4NCJ&-D@"+_"Y297!R:6Z0K')T9626!H4K87.34%,Q.C$UX
MDVEND]E53DE8D0:7.U!REO]F9F^39W*386UM97(G<Y$&E]A-86YU86S6+(ZAX
MC9( B_PN57-E;FEXE@/JJ$%S<V^04XYC:6%T:6]N+),Q.3@V+HZI&(  C8V-X
MD2>  %M,97-KD0/JJ#<U78Z.D@"+_"Y-+D4NE@-8H4QE<VN386YDDT4NDU-CX
MD*QR:&UI9'0LD0-UUME,EO]F9F5X>T&1 ZS:3)-E>&ECDV%LE@.L_$&0LS)NX
M86QY>F5RDT=E;BV.H8V2 (O\+F5RD?]F9F%T;W+6+)$(!!%#;VUP=71I;F>6X
M!S(O4V-I96YC99-4D?\%5F5CD*QR:&YI8V%LDU)E<)!3CF]R=)-.;RZ3,SDLX
MCJ&-D@"+_"Y!D?\%5E0F5)$$ #Y"96QLE@0 0TQA8I!3CF]R871O<FEE<RR;X
M! 6J375R<F&0K')YDTAI;&QS+)A.97>32F5R<V5YD?\%5BR83V,MCJ&-D@"+X
M_"YT;V*04XYE<I8#U& Q.3<U+I-297!R:6Z0K')T962387.34%,Q.C$VDVENX
MD]E53DE8D00>M5!REO]F9F^39W*386UM97(G<XZAC9( B_PN36%N=6%LUBR6X
M ^JH57-E;FEXDT%S<V^04XYC:6%T:6]N+),Q.3@V+HZFC8V-D2>  %M+4I$#X
MZJ@X.%V.CI( B_PN0G)I86Z6 ZFM5RZ32V5R;FEG:&%NDV%N9)-$96YN:7.3X
M32Z34FET8Y"L<FAI92R1 [:LV51H99$#]WI#D0/W:U!RD?]F9F\MCJ&-D@"+X
M_"YG<I;_9F9A;6UI;F>;!#,U3)-A;F=U86=E+)@R;F28160NE@/JJ-90<F5NX
MD*QR=&EC92U(86QL+),Q.3@X+HZFC8V-D2>  %M7D?\%5F%I=&61 ^JH.#1=X
MCHZ2 (O\+E=I;&QI86V6!>4/32Z35Y'_!59A:71EDV%N9)-'97)H87)DDT=OX
MD%..;W,LD09CJ-E#;VUP:6QE<I$&!*U#;VXMCJ&-D@"+_"YS=')U8W1I;V[6X
M+)8#ZJA3<')I;F=E<BU6D?\%5F5R;&%G+),Q.3@T+HZFC8V-D2>  %M!:&^1X
M ^JH.#9=CHZ2 (O\+D%L9G)E9)8'@L=6+I-!:&\LFPAHSU)AD*QR=FF34V5TX
M:&DLF&%N9)-*90MR97F31"Z356QL;6%N+(ZAC9( B_PNV4-O;7!I;&5R<SJ1X
M!EOO4')I;F-I<&QE<RR6!,RI5)O_&9EED?]F9F-H;FEQ=65S+)-A;F21!*WXX
M5)AOD?]F9F]L<]8LD021FT%D9&ES;VXMCJ&-D@"+_"Y7EO\%5F5S;&5YDRR1X
M ^JH,3DX-BZ.IHV-C9$G@ !;2F%Z896L<GF397)ID0/JJ#<U78Z.D@"+_"Y-X
M+IL#%_I*87IAE:QR>9-E<FDLE@-"'%<N1BZ83V=D96XLDV%N9)A7+D,NF%)OX
M=6YD<RR3V51H99$#<8Y);G1R:6XMCJ&-D@"+_"YS:6.6 S9_17APF_]F9F]NX
M96YT:6%LDT-O;7!L97AI='F3;V:3=&AEDT-I<IAC=6QA<FET>9-0<IAO8FQEX
M;9-F;W*.H8V2 (O\+D&0LS)T=')I8G5T99$$&E%'<I'_9F9A;6UA<G/6+)$#X
MU/Y#;VUMFJQR=6YI8V%T:6]N<Y8#SY-O9I-T:&6309A#32R35I'_!59O;"Z.X
MH8V2 (O\+C$X+)8#ZJA.;RZ3,3(LDW!P+I,V.3<M-S V+)-$96-E;9"L<F*0X
M4XYE<I,Q.3<U+HZFC8V-D2>  %M,;W)H;Y$#ZJ@X.%V.CI( B_PN4&EE<G)EX
ME@/A841E<F%N<V%R="R; ^,\36%R=&ENDTIO=7)D86XLF&%N9)-"97)N:&%RX
M9)-,;W)H;RR.H8V2 (O\+ME!D+,R='1R:6)U=&6;!C"\1W*1_V9F86UM87)SX
M.I$)87=$90QN:71I;VYS+)8&L!U3>7-T96US+)-A;F280FEB;&DMCJ&-D@"+X
M_"YOEO]F9F=RDV%P:'G6+)L'0)A,96-T=7)EE@:5STYO=&5SDVENDT-O;7!UX
M=&5RDU-C:65N8V4LF'8NDS,R,RR.H8V2 (O\+E-P<FEN9V5RE@/JJ%:1_P56X
M97)L86<LDS$Y.#@NCJ:-C8V1)X  6TMND*QR=71HD0/JJ#8X78Z.D@"+_"Y$X
M;VYA;&26!"3812Z32VZ0K')U=&@LD00S9-E396UA;G1I8W.6!&BQ;V:30V]NX
M=&5X="U&D?\9F7*6_V9F99-ED01HL4R386YG=6%G97..H8V2 (O\+M9-871HX
M96UA=&EC86R6 L%B4WES=&5M<Y-4:&5O<GF6_P56+)L"_-96DV]L+I8"P6(RX
M+)A.;RZ3,BR8<' NDS$R-RTQ-#4LCJ&-D@"+_"XQ.38X+HZ.CHR+    -@  X
M                                               !GAF@ G(  (V@X
M_;4  * "+0  C:#^ ?=YC9\('=V-D2>  .=);F1E>(Z.H '^"(>-C8V-H/X?X
M]WF-D2>  -Q V&;6+)8#ZJ@X+),YCJ0.@ "-D2>  -Q V&?6+)8#ZJ@X+),YX
MCJ&-D3N  "AA<Y8%LD)A='1R:6)U=&639&4,;FET:6]NDW1E<FUI+8ZAC9%/X
M@ !N871O<BDLD0/JJ#$PCJ&-D2>  -Q 871T<FEB=71E<]8LD0/JJ#:.H8V1X
M)X  W$!A=71O:6YHUBR6 ^JH,C8LDS(WCJ&-D2>  -Q 875T;W-Y;M8LE@/JX
MJ#(V+),R-XZAC9$G@ #<0&1I<V%B;&76+)$#ZJ@R,8ZAC9$G@ #<0&76+)$#X
MZJ@Q,(ZAC9$G@ #<0&G6+)$#ZJ@Q,(ZAC9$G@ #<0&QE9G1T;W)I9VATUBR1X
M ^JH,C&.H8V1)X  W$!MUBR1 ^JH,3".H8V1)X  W$!P;W-T;W)D97+6+)$#X
MZJ@R,8ZAC9$G@ #<0'!R96]R9&5RUBR1 ^JH,C&.H8V1)X  W$!R979D:7)EX
M8W1I;V[6+)$#ZJ@R,HZAC9$G@ #<0')E=F]R9&5RUBR1 ^JH,C*.H8V1)X  X
MW$!R:6=H='1O;&5F=-8LD0/JJ#(QCJ&-D2>  -Q =V%R;M8LD0/JJ#(WCJ&-X
MD2>  -PD)-8LE@8\S=PD,=8LD]PD,M8LDRXN+BR3*%F1_P5686-CD07%^7!SX
M975D;Y"L<G:1_UCD87)I+8ZAC9%/@ !A8FQE<RDLD0/JJ#$WCJ&-D2>  -QOX
M>&]U="XJUBR1 ^JH,CF.H8V1)X  W&]X;W5T/RYLUBR1 ^JH,CF.GQB  (V1X
M)X  86QI9VYM96Z5K')TFP/JJ&-O;G-T86Z3="R8,S&.H8V1)X  86V0K')BX
M:6=U;W5SE@7 CF9O<FV3;V:3W')E='5R;I/6;V:3=&\MCJ&-D4^  &N0K')EX
M;BR1 ^JH,32.H8V1)X  871T<FEB=71ECJ&-D3N  &EN:&5R:71E9"R1 ^JHX
MVSF.H8V1.X  UG-Y;I"L<G1H97-I>F5D+)$#ZJC;.8ZAC9$G@ #6871T<FEBX
M=71EE@50W2AA<Y-BD%..96QO;F=I;F>3=&^389-S>6TMCJ&-D4^  &*04XYOX
M;"DLD0/JJ-LWCJ&-D2>  -9A='1R:6)U=&66 ^JH9&5C;&%R871I;VXLD]LVX
MCJ&-D2>  -9A='1R:6)U=&66 ^JH9&4,;FET:6]N+)/;.8ZAC9$[@ #69&5PX
MD%..96YD96YC>98#ZJAP87)TDV]F+)/;.8Z.CHV-H/X?]WF-D@$0  #697:1X
M_UCD86QU871I;VZ6 ^JH<&%R=)-O9BR3VSF.I Z  (V2 1   -9E>'!L:6-IX
M=)8#ZJAM;Y!3CF1E+),Q,(ZAC9(!$   :6UP;&EC:726 ^JH;6^04XYD92R3X
M,3&.H8V2 1   &UI>&5DE@/JJ&UOD%..9&4LDS$QCJ&-D@$0  !T97)M:6YAX
M=&EO;I8#ZJAO9BR3VS$PCJ&-D@#\  #6871T<FEB=71EE@/JJ&1E#&YI=&EOX
M;I-M;Y!3CF1E<RR3,3".H8V2 /P  &%T=')I8G5T99$#ZJAG<F%M;6%RCJ&-X
MD@$0  !C;&%S<Y8%5;!O9I-!FJQR1W.386-C97!T96238IAYDT]X+(ZAC9(!X
M)   ,3*.H8V2 1   &5X96-U=&EO;I8#,:QS97%U96YC99-N;W2397AP;&ECX
M:72.H8V2 20  &EN+)$#ZJ@Q-XZAC9( _   871T<FEB=71EE@/JJ&EN<W1AX
M;F-E+)/;-XZAC9(!$   UG-O;'9I;F>6 ^JH86XLD]LQ,8ZAC9( _   UF%TX
M=')I8G5T998#R?EI;G-T86YC99,H87.38I!3CF5L;VYG:6YGDW1OCJ&-D@$DX
M  !AE@/JJ&YOD%..9&4I+)/;-XZAC9( _   UF%T=')I8G5T99$#ZJAI;G-TX
M86YC97..H8V2 1   ')E861YE@/JJ'-E=)-O9BR3VS$WCJ&-D@#\  #6871TX
M<FEB=71EE@/JJ&^04XYC8W5R<F5N8V4LD]LWCJ&-D@$0  #69&5PD%..96YDX
M965SE@/JJ&]FDV%N+),Q,(ZAC9(!$   9&5PD%..96YD96Z0K')T<Y8#ZJAOX
M9I-A;BR3,3".H8V2 1   &EN:&5R:71E9"R1 ^JHVSB.H8V2 1   -9S>6Z0X
MK')T:&5S:7IE9"R1 ^JHVSB.H8V2 /P  -9A='1R:6)U=&66 ^JH;Y!3CF-CX
M=7)R96YC99,LDSB.H8V2 /P  &%T=')I8G5T998#ZJAR969E<F5N8V4LD]LQX
M,(ZAC9( _   UF%T=')I8G5T998#ZJAR969E<F5N8V63<V5C=&EO;BR3VSC6X
M+)/;,3*.H8V2 /P  -9A='1R:6)U=&66!F$7<F5F97)E;F-EDW-E8W1I;VZ3X
M9&5L:6TMCJ&-D@$D  !I=&5R<RR1 ^JH,3*.GQB  (V2 /P  &-I<F-U;&%RX
ME@/JJ&=R86UM87(LD]LQ-8ZAC9( _   UF-OD%..9&66 ^JH9V5N97)A=&EOX
M;BR3,3B.H8V2 /P  &-O;6UA;F0M;&EN998#ZJAO<'1I;VYS+),U,8ZAC9( X
M_   8V]M;6%N9"UL:6YEE@/JJ'-Y;I"L<G1A>"R3-3&.H8V2 /P  &-O;6UEX
M;I"L<G1S+)$#ZJ@VCJ&-D@#\  !C;W"0K')YE@/JJ')U;&4LD]LR-HZ.CHZ.X
MCI\>  "-D@#DH 36-32.CHR+    -P                              X
M                   !IKJ@ G(  (V@_;4  (V-D2>  -I)3D1%6)(!4VU)X
MUC4UCHZ@ BT  (V-C8V@_?8  (V1)X  8WEC;&66 ]/:*&ENDV%NDV%T=')IX
M8G5T9623<&%R<V63=')E92DLCJ0.@ "-D4^  -LQ-8ZAC9$G@ #68WEC;&66X
M ^JH9&5T96-T:6]N+),Q-8ZI%S,SC9$G@ !D96-L87)A=&EO;HZAC9$[@ !AX
M='1R:6)U=&4LD0/JJ-LVCJ&-D2>  -9D96-O<F%T:6]N+)$#ZJC;,3>.H8V1X
M)X  UF1E#&YE9"R6 ^JH871T<FEB=71EDV^04XYC8W5R<F5N8V4LDS$PCJ&-X
MD2>  &1E#&YI=&EO;HZAC9$[@ !A='1R:6)U=&4LD0/JJ-LYCJ&-D2>  -9DX
M90QN:71I;VZ6 ^JH;6^04XYD99-A;FZ0K')U;F-I871O<BR3VS$PCJ&-D2> X
M -9D97"04XYE;F1E92R1 ^JHVS$PCJ&-D2>  -9D97"04XYE;F1E;F-YE@/JX
MJ&5X<')E<W-I;VXLD]LQ,(ZAC9$G@ #69&5PD%..96YD96YC>98%\7!P87)TX
MDRAO9I-A;I-A='1R:6)U=&6.H8V13X  9&4,;FET:6]N*2R1 ^JHVSF.H8V1X
M)X  UF1E<)!3CF5N9&5ND*QR="R1 ^JHVS$PCJ&-D2>  -9D97"54XYE;F1SX
MFP/JJ'5PDV]N+)@Q,(ZAC9$G@ !D>6YA;6ECFP/JJ'1R896L<G:397)S86R8X
M;6^04XYD:0QE<BR8VS(RCJ:-D2>  -9E=I'_6.1A;'5A=&EO;I8#ZJAE>'!RX
M97-S:6]N+)/;,3".H8V1)X  UF5VD?]8Y&%L=6%T:6]NE@*<<'!A<G23*&]FX
MDV%NDV%T=')I8G5T99-D968MCJ&-D4^  &EN:71I;VXI+)$#ZJC;.8ZAC9$GX
M@ #697AA;7!L98ZAC9$[@ !+;I"L<G5T:"=SE@/JJ&-L87-S:6-A;"R3,S:.X
MH8V1.X  =I"L<F5R>98#ZJAE87-YD?\%5BR3,S2.H8V1)X  97AE8W5T:6]NX
ME@3RF'-E<75E;F-EDVYO=)-E>'!L:6-I=)-I;HZAC9%/@ !A='1R:6)U=&66X
M ^JH9W)A;6UA<G,LDS$WCJ&-D2>  &5X<&QI8VETE@/JJ&UOD%..9&6386YNX
MD*QR=6YC:6%T;W(LDS$P+)/;,3".H8V1)X  UF5X<&QI8VETE@3\EVUOD%..X
M9&63871T<FEB=71EDV1E#&YI=&EO;BR.H8V13X  VS$PCJ:-D2>  -8,;&61X
M ^JH;F%M97..H8V1.X  3WB6 ^JH;W5T<'5T+),R.8ZAC9$G@  ,;F%LE@/JX
MJ&1E8V]R871I;VXLD]LQ-RR1!(  ,3B.IHV1)X  UF=L;V)A;)$#ZJAVD?]8X
MY&%R:6%B;&5SCJ&-D3N  ')E9F5R96YC998#ZJAT;Y-#)W,LDS$XCJ:-D2> X
M &AE861E<I8#ZJ@,;&63W&]X;W5T+FC6+),S,(Z.CHV-H/WV  "-D@#\  !HX
M;VUEE@/JJ')U;&4LD]LYCJD8*JN-D@#\  #6:6UP;&EC:726 ^JH;6^04XYDX
M99-A;FZ0K')U;F-I871O<BR3VS$QUBR3,3&.I Z  (V2 /P  &EM<&QI8VETX
ME@1Q56UOD%..9&63871T<FEB=71EDV1E#&YI=&EO;BR.H8V2 20  -LQ,8ZAX
MC9( _   UFEN:&5R:71E9)8#ZJAA='1R:6)U=&4LD]LYCJ&-D@#\  #6:6YHX
M97)I=&5DE@/JJ&%T=')I8G5T99-OD%..8V-U<G)E;F-E+)/;.(ZAC9( _   X
MUFEN<W1A;F-ECJ&-D@$0  !A='1R:6)U=&4LD0/JJ-LWCJ:-D@#\  #62VZ0X
MK')U=&@G<Y8#ZJAC;&%S<VEC86R397AA;7!L92R3,S:.IHV2 /P  $PM#&QEX
M+)$#ZJC;-8ZAC9( _   UDQ!3%(H,2F6 IQP<')O<)!3CF5R=)JL<GF3<')EX
M<V5R=IAE9)-BF'F33W@MCJ&-D@$D  !P<F5P<F^04XYC97-S:6YG+)$#ZJ@QX
M-HZAC9( _   ;&5F="UH86YDE@/JJ'-I9&4LDS>.H8V2 /P  $Q(4Y8#ZJ@HX
M;&5F="UH86YDDW-I9&4I+),WCJ&-D@#\  !L;Y!3CF]KD?]8Y&%H96%DE@/JX
MJ&)U"V5R+)/;,3:.IHV2 /P  -9M86-R;W,LD0/JJ#(SCJ&-D@#\  !M86-RX
M;W.6 IQP9F]R8FED9&5NDV9O<I/<<F5T=7)ND]9O9I-Y>6QE>"R.H8V2 20 X
M #$RCJ&-D@#\  !M:7AE9)8#ZJAM;Y!3CF1EDV%N;I"L<G5N8VEA=&]R+),QX
M,2R3VS$QCJ&-D@#\  #6;6EX9626 IQP;6^04XYD99-A='1R:6)U=&639&4,X
M;FET:6]N+)$"WTC;,3&.H8V2 /P  -9M;Y!3CF1ECJ&-D@$0  !A='1R:6)UX
M=&66 ^JH9&4,;FET:6]N+),Q,(ZAC9( _   ;6^04XYD99$#ZJAA;FZ0K')UX
M;F-I871O<HZAC9(!$   W$!EE@/JJ-8H97AP;&EC:70I+),Q,(ZAC9(!$   X
MW$!IE@/JJ-8H:6UP;&EC:70I+),Q,"R3,3&.H8V2 1   -Q ;98#ZJC6*&UIX
M>&5D*2R3,3 LDS$QCJ&-D@$0  !D90QN:71I;VXLD0/JJ-LQ,(ZAC9(!$   X
MUG1R896L<G:397)S86PLD0/JJ-LR,(ZFC9( _   UF^04XYC8W5R<F5N8V6.X
MH8V2 1   &%T=')I8G5T92R6 ^JHVS?6+),XCJ&-D@#\  !O<'1I;VYSCJ&-X
MD@$0  !C;VUM86YD+6QI;F4LD0/JJ#4QCJ:-D@#\  !P87)E;I"L<G26 ^JHX
M<G5L92R3VSF.CHZ.CHZ,BP   #@                                 X
M                 :\5H )R  "-H/VU  "-C9$G@ #:24Y$15B2 5-M2=8UX
M-HZ.H (M  "-C8V-H/WV  "-D2>  '"04XYO<W1D96-O<F%T:6]N+)$#ZJC;X
M,3B.I Z  (V1)X  UG"04XYO<W1D96-O<F%T:6]NFP/JJ'1R896L<G:397)SX
M86PLF-LQ.(ZAC9$G@ #6<'-E=61OD*QR=I'_6.1A<FEA8FQE<XZAC9$[@ !RX
M969E<F5N8V5SE@/JJ'1ODUF1_P5686-C)W,LDS$WCJD8*JN-D2>  ')E861YX
ME@4HZ'-E=),H;V:3871T<FEB=71EDVEN<W1A;F-E<RDLCJ&-D4^  -LQ-XZAX
MC9$G@ #6<F5F97)E;F-ECJ&-D3N  &%T=')I8G5T92R1 ^JHVS$PCJ&-D2> X
M -QR971U<FZ.H8V1.X  UF]FE@/JJ'EY;&5XDVV0K')U<W238I!3CF6397APX
M;&EC:70LDS$RCJ&-D2>  -QR971U<FZ1 ^JHUG-T871E;65ND*QR='..H8V1X
M.X  ;&5X:6-A;)8"G'!R=6QE<Y-A<W-OD%..8VEA=&5DDW=I=&@LD0+?2-LQX
M,HZAC9$G@ #64DA3E@/JJ"AR:6=HD*QR="UH86YDDW-I9&4I+),WCJ&-D2> X
M ')I9VB0K')T+6AA;F26 ^JH<VED92R3-XZAC9$G@ !R=6QE+)$#ZJC;-XZAX
MC9$[@ #6:&]M92R1 ^JHVSF.H8V1.X  UG!A<F5ND*QR="R1 ^JHVSF.H8V1X
M.X  W')E='5R;M9E9)8#ZJAT;VN0K')E;I-A<Y-A+)/;-XZAC9$G@ #6<G5LX
M97.6 ^JH<V5C=&EO;I-O9I-ADUF1_P5686-CDPQL92R3VSF.IHV1)X  UG-IX
M9&66 ^JH90ME8W1S+),Q.(ZAC9$G@ !S;VQV:6YGE@/JJ"AA;I-A='1R:6)UX
M=&63:6YS=&%N8V4I+)/;,3&.H8V1)X  UG-Y;F.0K')H<F]N:7IA=&EO;HZAX
MC9$[@ !/>)8#ZJAA;F2369'_!59A8V.3<W1A8Y"L<FLLDS$V+),S,8ZAC9$GX
M@ !S>6Z0K')T:&5S:7IE9)8#ZJAA='1R:6)U=&4LD]LYCJ&-D2>  -9S>6Z0X
MK')T:&5S:7IE9)8"])EA='1R:6)U=&63;Y!3CF-C=7)R96YC92R1 R7/VSB.X
MIHV1)X  UG1O:Y"L<F5NCJ&-D3N  &EN:&5R:71E9)8#ZJAA='1R:6)U=&5SX
MDV]FDV$LDS$RCJ&-D3N  '-Y;I"L<G1H97-I>F5DE@/JJ&%T=')I8G5T97.3X
M;V:382R3,3*.H8V1)X  =')AE:QR=I-E<G-A;(ZAC9$[@ !PD%..;W-T9&5CX
M;W)A=&EO;BR1 ^JHVS$XCJ&-D2>  -9T<F&5K')VDV5R<V%LE@/JJ&%C=&EOX
M;BR3VS(RCJ&-D2>  -9T<F&5K')VDV5R<V%LE@/JJ&%C=&EO;I-S<)!3CF5CX
M:0QC871I;VXLD]LR,HZAC9$G@ #6=')AE:QR=I-E<G-A;)8#ZJAA8W1I;VZ3X
M<W"04XYE8VD,97(LD]LR,(ZAC9$G@ #6=')AE:QR=I-E<G-A;)8"HZEM;Y!3X
MCF1EDV%N;I"L<G5N8VEA=&]R+)8"Y0_;,C#6+)/;,C*.H8V1)X  UG1R896LX
M<G:397)S86R1 ^JH;6^04XYD:0QE<HZ.CHV-H/WV  "-D@$0  !D>6YA;6ECX
M+)$#ZJC;,C*.I Z  (V2 /P  -9T<F&5K')VDV5R<V%LE@/JJ'-PD%..96-IX
M#&-A=&EO;BR3VS(QCJ&-D@#\  #6=')AE:QR=I-E<G-A;)8#ZJAS<)!3CF5CX
M:0QE<BR3VS(QCJ&-D@#\  #6=')AE:QR=I-E<G-A;)8#ZJAS<)!3CF5C:0QEX
M<I-S97%U96YC92R3VS(QCI\8@ "-D@#\  #662T,;&4LD0/JJ-LUCJ&-D@#\X
M  #<>7EL96YGUBR1 ^JH,3>.H8V2 /P  -QY>71E>'36+)$#ZJ@Q-XZ.CHZ.X
MCHSX  &WW0&#DL <.P     #Z )R   !K8    D .?,\&O(B5@ 11ZX "@  X
M  9C;6)X,3#S-QKR(E8 #F9F  H    &8VUB>#$P\S'?AK54  P    ,    X
M!F-M='0Q,O,PPM9.H  ,    #     9C;6)X,3+S+WUH(=, #     P    &X
M8VUS;#$R\RZ;NXA   P    ,    !F-M=&DQ,O,M(2(LF@ ,    "@    9CX
M;7-Y,3#S++?A9Z, #     P    &8VUM:3$R\RM8JU$+  P    ,    !6-MX
M<C$R\R0A(BR:  KS,P *    !F-M<WDQ,/,B2_%@>0 *\S, "@    5C;7(QX
M,/,?W^H\>  *    "@    9C;71T,3#S&4OQ8'D "@    H    %8VUR,3#SX
M#7Q[60< "     @    $8VUR./,(V9.@4@ '    !P    1C;7(W^0 !O?<"X
'W]_?W]_?WP                                                  X
                                                             X
end
@eof
set `sum $sumopt <oxDistG1.04/docs/oxURM.dvi`; if test $1 -ne 36138
then
	echo ERROR: oxDistG1.04/docs/oxURM.dvi checksum is $1 should be 36138
fi
set `wc -lwc <oxDistG1.04/docs/oxURM.dvi`
if test $1$2$3 != 83166114532
then
	echo ERROR: wc results of oxDistG1.04/docs/oxURM.dvi are $* should be 83 166 114532
fi

chmod 755 oxDistG1.04/docs/oxURM.dvi

if test -f oxDistG1.04/docs/oxURM.ps
then
	echo Ok to overwrite existing file oxDistG1.04/docs/oxURM.ps\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/docs/oxURM.ps
	if test -f oxDistG1.04/docs/oxURM.ps
	then
		echo Error: could not remove oxDistG1.04/docs/oxURM.ps, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/docs/oxURM.ps
sed 's/^@//' >oxDistG1.04/docs/oxURM.ps <<'@EOF'
%!PS-Adobe-2.0
%%Creator: dvips 5.519 Copyright 1986, 1993 Radical Eye Software
%%Title: manonly.dvi
%%CreationDate: Sun Nov 14 02:00:43 1993
%%Pages: 57
%%PageOrder: Ascend
%%BoundingBox: 0 0 612 792
%%EndComments
%DVIPSCommandLine: dvips -o manonly.ps manonly.dvi
%DVIPSSource:  TeX output 1993.11.14:0200
%%BeginProcSet: tex.pro
/TeXDict 250 dict def TeXDict begin /N{def}def /B{bind def}N /S{exch}N
/X{S N}B /TR{translate}N /isls false N /vsize 11 72 mul N /hsize 8.5 72
mul N /landplus90{false}def /@rigin{isls{[0 landplus90{1 -1}{-1 1}
ifelse 0 0 0]concat}if 72 Resolution div 72 VResolution div neg scale
isls{landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div
hsize mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul
TR matrix currentmatrix dup dup 4 get round 4 exch put dup dup 5 get
round 5 exch put setmatrix}N /@landscape{/isls true N}B /@manualfeed{
statusdict /manualfeed true put}B /@copies{/#copies X}B /FMat[1 0 0 -1 0
0]N /FBB[0 0 0 0]N /nn 0 N /IE 0 N /ctr 0 N /df-tail{/nn 8 dict N nn
begin /FontType 3 N /FontMatrix fntrx N /FontBBox FBB N string /base X
array /BitMaps X /BuildChar{CharBuilder}N /Encoding IE N end dup{/foo
setfont}2 array copy cvx N load 0 nn put /ctr 0 N[}B /df{/sf 1 N /fntrx
FMat N df-tail}B /dfs{div /sf X /fntrx[sf 0 0 sf neg 0 0]N df-tail}B /E{
pop nn dup definefont setfont}B /ch-width{ch-data dup length 5 sub get}
B /ch-height{ch-data dup length 4 sub get}B /ch-xoff{128 ch-data dup
length 3 sub get sub}B /ch-yoff{ch-data dup length 2 sub get 127 sub}B
/ch-dx{ch-data dup length 1 sub get}B /ch-image{ch-data dup type
/stringtype ne{ctr get /ctr ctr 1 add N}if}B /id 0 N /rw 0 N /rc 0 N /gp
0 N /cp 0 N /G 0 N /sf 0 N /CharBuilder{save 3 1 roll S dup /base get 2
index get S /BitMaps get S get /ch-data X pop /ctr 0 N ch-dx 0 ch-xoff
ch-yoff ch-height sub ch-xoff ch-width add ch-yoff setcachedevice
ch-width ch-height true[1 0 0 -1 -.1 ch-xoff sub ch-yoff .1 add]{
ch-image}imagemask restore}B /D{/cc X dup type /stringtype ne{]}if nn
/base get cc ctr put nn /BitMaps get S ctr S sf 1 ne{dup dup length 1
sub dup 2 index S get sf div put}if put /ctr ctr 1 add N}B /I{cc 1 add D
}B /bop{userdict /bop-hook known{bop-hook}if /SI save N @rigin 0 0
moveto /V matrix currentmatrix dup 1 get dup mul exch 0 get dup mul add
@.99 lt{/QV}{/RV}ifelse load def pop pop}N /eop{SI restore showpage
userdict /eop-hook known{eop-hook}if}N /@start{userdict /start-hook
known{start-hook}if pop /VResolution X /Resolution X 1000 div /DVImag X
/IE 256 array N 0 1 255{IE S 1 string dup 0 3 index put cvn put}for
65781.76 div /vsize X 65781.76 div /hsize X}N /p{show}N /RMat[1 0 0 -1 0
0]N /BDot 260 string N /rulex 0 N /ruley 0 N /v{/ruley X /rulex X V}B /V
{}B /RV statusdict begin /product where{pop product dup length 7 ge{0 7
getinterval dup(Display)eq exch 0 4 getinterval(NeXT)eq or}{pop false}
ifelse}{false}ifelse end{{gsave TR -.1 -.1 TR 1 1 scale rulex ruley
false RMat{BDot}imagemask grestore}}{{gsave TR -.1 -.1 TR rulex ruley
scale 1 1 false RMat{BDot}imagemask grestore}}ifelse B /QV{gsave
transform round exch round exch itransform moveto rulex 0 rlineto 0
ruley neg rlineto rulex neg 0 rlineto fill grestore}B /a{moveto}B /delta
0 N /tail{dup /delta X 0 rmoveto}B /M{S p delta add tail}B /b{S p tail}
B /c{-4 M}B /d{-3 M}B /e{-2 M}B /f{-1 M}B /g{0 M}B /h{1 M}B /i{2 M}B /j{
3 M}B /k{4 M}B /w{0 rmoveto}B /l{p -4 w}B /m{p -3 w}B /n{p -2 w}B /o{p
-1 w}B /q{p 1 w}B /r{p 2 w}B /s{p 3 w}B /t{p 4 w}B /x{0 S rmoveto}B /y{
3 2 roll p a}B /bos{/SS save N}B /eos{SS restore}B end
%%EndProcSet
TeXDict begin 40258431 52099146 1000 300 300
(/home/grad2/bischoff/oxDevelop/oxman/manonly.dvi) @start
/Fa 80 126 df<60F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0600000000060F0F06004197798
16>33 D<6030F078F078F078F078F078F078F078F078E038E038E0380D0C7C9916>I<03
87000387000387000387000387000387007FFFC0FFFFE0FFFFE0070E00070E00070E000F
1E000E1C000E1C000E1C00FFFFE0FFFFE07FFFC01C38001C38001C38001C38001C38001C
380013197F9816>I<3801807C0380FE0780FE0700EE0700EE0F00EE0E00EE1E00FE1C00
FE3C007C380038380000780000700000F00000E00000E00001E00001C00003C000038000
0383800787C0070FE00F0EE00E0EE01E0EE01C0EE01C0EE03C0FE03807C018038013207F
9C16>37 D<03C00007E0000FE0001EF0001C70001C70001C70001CF7E01CE7E01DE7E01F
C7000F8F000F0E001F0E003F1E007F9C00F3BC00E3F800E1F800E1F1C0E0F1C0F1F9C07F
FFC03F9F801F0F0013197F9816>I<183C3E1E0E0E0E1E1C3C78F060070D799816>I<00E0
01E007C007000F001E003C0038007800700070007000F000E000E000E000E000E000E000
E000F000700070007000780038003C001E000F00070007C001E000E00B217A9C16>I<E0
00F0007C001C001E000F000780038003C001C001C001C001E000E000E000E000E000E000
E000E001E001C001C001C003C0038007800F001E001C007C00F000E0000B217C9C16>I<
01C00001C00001C00001C00071C700F9CF807FFF001FFC0007F00007F0001FFC007FFF00
F9CF8071C70001C00001C00001C00001C00011127E9516>I<01C00001C00001C00001C0
0001C00001C00001C00001C000FFFF80FFFF80FFFF8001C00001C00001C00001C00001C0
0001C00001C00001C00011137E9516>I<387C7E7E3E0E1E3C7CF860070B798416>I<FFFF
80FFFF80FFFF8011037E8D16>I<70F8F8F8700505788416>I<0001800003800007800007
00000F00000E00001E00001C00003C0000380000780000700000F00000E00001E00001C0
0001C00003C0000380000780000700000F00000E00001E00001C00003C00003800007800
00700000F00000E00000E0000011207E9C16>I<03E0000FF8001FFC001E3C00380E0078
0F00700700700700E00380E00380E00380E00380E00380E00380E00380E00380F0078070
0700700700780F003C1E001E3C001FFC000FF80003E00011197E9816>I<018003800780
07801F807F80FF8073800380038003800380038003800380038003800380038003800380
03807FF87FFC7FF80E197C9816>I<07E0001FF8007FFE00783F00F00F00F00780F00380
F00380000380000380000780000700000F00001E00003C0000780000F00003E000078000
0F00001E03803C03807FFF80FFFF807FFF8011197E9816>I<07E0001FFC007FFE00781F
00780F00780700000700000F00000F00003E0007FC0007F80007FC00001E000007000007
80000380000380F00380F00780F00700F81F007FFE003FFC0007E00011197E9816>I<00
7C0000FC0000DC0001DC00039C00039C00071C000F1C000E1C001E1C003C1C00381C0078
1C00F01C00FFFFE0FFFFE0FFFFE0001C00001C00001C00001C00001C0001FFC001FFC001
FFC013197F9816>I<3FFE003FFE003FFE00380000380000380000380000380000380000
3800003FF0003FFC003FFE003C0F00300700000780000380600380F00380F00780F00F00
F81F007FFE001FF80007E00011197E9816>I<07F0001FFC003FFE007C1F00F00780E003
80E00380E003807007007C1F001FFC0007F0001FFC003C1E00700700F00780E00380E003
80E00380F007807007007C1F003FFE001FFC0007F00011197E9816>56
D<03E0000FF8003FFC007C1E00780F00F00700E00700E00780E00780E00380F00780F007
80780F803FFF803FFB800FE380000780000700300F00780E00781E00787C007FF8003FE0
000F800011197E9816>I<70F8F8F870000000000000000070F8F8F8700512789116>I<38
7C7C7C380000000000000000387C7C7C3C1C3C38F8F0600618799116>I<000380000780
001F80003E0000FC0003F00007E0001F80003E0000FC0000F00000FC00003E00001F8000
07E00003F00000FC00003E00001F8000078000038011157E9616>I<7FFF00FFFF80FFFF
80000000000000000000000000000000FFFF80FFFF807FFF00110B7E9116>I<E00000F0
0000FC00003E00001F800007E00003F00000FC00003E00001F80000780001F80003E0000
FC0003F00007E0001F80003E0000FC0000F00000E0000011157E9616>I<0FE03FF87FFC
F01EF00EF00E601E007C00F801F003E003C0038003800380038003000000000000000000
03000780078003000F197D9816>I<00F80003FE000FFF001F0F803E3F803C7F8078FFC0
71E7C0F1C3C0E3C3C0E381C0E381C0E381C0E381C0E381C0E3C3C0F1C38071E78078FF00
3C7E003E3C001F03C00FFFC003FF0000FC0012197E9816>I<00E00001F00001F00001B0
0001B00003B80003B80003B800031800071C00071C00071C00071C00071C000E0E000E0E
000FFE000FFE001FFF001C07001C07001C07007F1FC0FF1FE07F1FC013197F9816>I<7F
F800FFFE007FFF001C0F001C07801C03801C03801C03801C07801C07001FFF001FFE001F
FE001C1F001C03801C03C01C01C01C01C01C01C01C01C01C03C01C07807FFF80FFFF007F
FC0012197F9816>I<01F18007FF800FFF801F0F803C0780780780780380700380F00000
E00000E00000E00000E00000E00000E00000E00000F000007003807803807803803C0780
1F0F000FFE0007FC0001F00011197E9816>I<7FF800FFFE007FFF001C0F001C07801C03
C01C01C01C01C01C01E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C01
C01C01C01C03C01C07801C0F807FFF00FFFE007FF8001319809816>I<7FFFC0FFFFC07F
FFC01C01C01C01C01C01C01C01C01C00001C00001C1C001C1C001FFC001FFC001FFC001C
1C001C1C001C00001C00E01C00E01C00E01C00E01C00E07FFFE0FFFFE07FFFE013197F98
16>I<FFFFE0FFFFE0FFFFE01C00E01C00E01C00E01C00E01C00001C00001C1C001C1C00
1FFC001FFC001FFC001C1C001C1C001C00001C00001C00001C00001C00001C0000FF8000
FFC000FF800013197F9816>I<03E30007FF001FFF003E1F003C0F00780F007807007007
00F00000E00000E00000E00000E00000E03F80E07FC0E03F80F00700700700780F00780F
003C0F003E1F001FFF0007FF0003E70012197E9816>I<7F1FC0FFBFE07F1FC01C07001C
07001C07001C07001C07001C07001C07001FFF001FFF001FFF001C07001C07001C07001C
07001C07001C07001C07001C07001C07007F1FC0FFBFE07F1FC013197F9816>I<FFFEFF
FEFFFE038003800380038003800380038003800380038003800380038003800380038003
8003800380FFFEFFFEFFFE0F197D9816>I<FFC000FFC000FFC0001C00001C00001C0000
1C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C0040
1C00E01C00E01C00E01C00E0FFFFE0FFFFE0FFFFE013197F9816>76
D<7E1FC0FF3FE07F1FC01D07001D87001D87001D87001DC7001DC7001CC7001CC7001CE7
001CE7001CE7001C67001C67001C77001C77001C37001C37001C37001C17007F1F00FF9F
007F0F0013197F9816>78 D<1FFC003FFE007FFF00780F00F00780E00380E00380E00380
E00380E00380E00380E00380E00380E00380E00380E00380E00380E00380E00380F00780
F00780780F007FFF003FFE001FFC0011197E9816>I<7FF800FFFE007FFF001C0F801C03
801C03C01C01C01C01C01C01C01C03C01C03801C0F801FFF001FFE001FF8001C00001C00
001C00001C00001C00001C00001C00007F0000FF80007F000012197F9816>I<7FE000FF
F8007FFC001C1E001C0F001C07001C07001C07001C07001C0F001C1E001FFC001FF8001F
FC001C3E001C0E001C0E001C0E001C0E001C0E201C0E701C0E707F0FF0FF87E07F03C014
197F9816>82 D<07E3001FFF007FFF00781F00F00F00E00700E00700E00000F000007800
007F80001FF00007FC0000FE00000F00000780000380000380E00380E00380F00780F80F
00FFFE00FFFC00C7F00011197E9816>I<7FFFE0FFFFE0FFFFE0E0E0E0E0E0E0E0E0E0E0
E0E000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000
E00000E00000E00000E00007FC000FFE0007FC0013197F9816>I<FE0FE0FF1FE0FE0FE0
3803801C07001C07001C07001C07000E0E000E0E000E0E000E0E00060C00071C00071C00
071C00071C0003180003B80003B80003B80001B00001F00001F00000E00013197F9816>
86 D<FE0FE0FF1FE0FE0FE01C07001C07000E0E000E0E00071C00071C00071C0003B800
03B80001F00001F00000E00000E00000E00000E00000E00000E00000E00000E00003F800
07FC0003F80013197F9816>89 D<7FFF80FFFF80FFFF80E00700E00F00E01E00E01C0000
3C0000780000700000F00001E00001C00003C0000780000700000F00001E03801C03803C
0380780380700380FFFF80FFFF80FFFF8011197E9816>I<FFF0FFF0FFF0E000E000E000
E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000
E000E000E000E000E000FFF0FFF0FFF00C20789C16>I<E00000E00000F0000070000078
00003800003C00001C00001E00000E00000F000007000007800003800003C00001C00001
C00001E00000E00000F000007000007800003800003C00001C00001E00000E00000F0000
070000078000038000018011207E9C16>I<FFF0FFF0FFF0007000700070007000700070
007000700070007000700070007000700070007000700070007000700070007000700070
00700070FFF0FFF0FFF00C207F9C16>I<FFFF80FFFF80FFFF8011037E7E16>95
D<1FE0007FF8007FFC00783C00301E00000E00000E0003FE001FFE007E0E00F00E00E00E
00E00E00F01E00F83E007FFFE03FE7E00F83E013127E9116>97 D<7E0000FE00007E0000
0E00000E00000E00000E00000E3E000EFF800FFFC00F83E00F01E00E00F00E00F00E0070
0E00700E00700E00700E00F00F00E00F01E00F83C00FFFC00EFF00063C001419809816>
I<03F80FFE1FFE3C1E780C7000F000E000E000E000E000F000700778073E0F1FFE0FFC03
F010127D9116>I<003F00007F00003F0000070000070000070000070003C7000FF7003F
FF003C1F00780F00F00700F00700E00700E00700E00700E00700F00700F00F00781F007C
3F003FFFE01FF7F007C7E014197F9816>I<07E00FF81FFC3C3E780E700FF007FFFFFFFF
FFFFE000F000700778073E1F1FFE0FFC03F010127D9116>I<001F00007F8000FF8001E7
8001C30001C00001C0007FFF00FFFF00FFFF0001C00001C00001C00001C00001C00001C0
0001C00001C00001C00001C00001C00001C0003FFE007FFF003FFE0011197F9816>I<03
E3C00FFFE01FFFE01E3CC03C1E00380E00380E00380E003C1E001E3C001FFC001FF8003B
E0003800003800001FFC001FFF003FFFC07803C0F001E0E000E0E000E0E000E0F001E07C
07C03FFF800FFE0003F800131C7F9116>I<7E0000FE00007E00000E00000E00000E0000
0E00000E3C000EFF000FFF800F87800F03800F03800E03800E03800E03800E03800E0380
0E03800E03800E03800E03807FC7F0FFE7F87FC7F01519809816>I<018003C003C00180
00000000000000007FC07FC07FC001C001C001C001C001C001C001C001C001C001C001C0
01C07FFFFFFF7FFF101A7D9916>I<003000780078003000000000000000001FF81FF81F
F80038003800380038003800380038003800380038003800380038003800380038003800
3800386078F0F0FFE07FC03F800D237E9916>I<7E0000FE00007E00000E00000E00000E
00000E00000E7FE00E7FE00E7FE00E0F000E1E000E3C000E78000EF0000FF8000FF8000F
BC000F1E000E0E000E0F000E07807F87F0FFCFF07F87F01419809816>I<FFC000FFC000
FFC00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C000
01C00001C00001C00001C00001C00001C00001C00001C000FFFF80FFFF80FFFF8011197E
9816>I<F9C380FFEFC0FFFFE03E7CE03C78E03870E03870E03870E03870E03870E03870
E03870E03870E03870E03870E0FE7CF8FE7CF8FE7CF81512809116>I<7E3C00FEFF007F
FF800F87800F03800F03800E03800E03800E03800E03800E03800E03800E03800E03800E
03807FC7F0FFE7F87FC7F01512809116>I<03E0000FF8001FFC003C1E00780F00700700
E00380E00380E00380E00380E00380F00780700700780F003C1E001FFC000FF80003E000
11127E9116>I<7E3E00FEFF807FFFC00F83E00F01E00E00F00E00F00E00700E00700E00
700E00700E00F00F00E00F01E00F83C00FFFC00EFF000E3C000E00000E00000E00000E00
000E00000E00007FC000FFE0007FC000141B809116>I<FF0FC0FF3FE0FF7FE007F04007
E00007C000078000078000070000070000070000070000070000070000070000FFFC00FF
FC00FFFC0013127F9116>114 D<0FEC3FFC7FFCF03CE01CE01CF0007F801FF007FC003E
E00EE00EF00EF81EFFFCFFF8C7E00F127D9116>I<030000070000070000070000070000
7FFF00FFFF00FFFF00070000070000070000070000070000070000070000070100070380
07038007078007878003FF0003FE0000F80011177F9616>I<7E1F80FE3F807E1F800E03
800E03800E03800E03800E03800E03800E03800E03800E03800E03800E07800F0F800FFF
F007FFF803E3F01512809116>I<7F1FC0FF1FE07F1FC01C07001E0F000E0E000E0E000E
0E00071C00071C00071C00071C0003B80003B80003B80001F00001F00000E00013127F91
16>I<FF1FE0FFBFE0FF1FE038038038038038038038038038E38019F30019F30019B300
1DB7001DB7001DB7001DB7000F1E000F1E000F1E0013127F9116>I<7F1FC07F3FC07F1F
C00F1C00073C0003B80003F00001F00000E00001E00001F00003B800073C00071C000E0E
007F1FC0FF3FE07F1FC013127F9116>I<7F1FC0FF9FE07F1FC01C07000E07000E0E000E
0E00070E00071C00071C00039C00039C0003980001B80001B80000F00000F00000F00000
E00000E00000E00001C00079C0007BC0007F80003F00003C0000131B7F9116>I<3FFFC0
7FFFC07FFFC0700780700F00701E00003C0000F80001F00003E00007C0000F00001E01C0
3C01C07801C0FFFFC0FFFFC0FFFFC012127F9116>I<001F80007F8001FF8001E00001C0
0001C00001C00001C00001C00001C00001C00001C00001C00003C0007F8000FF0000FF00
007F800003C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001E0
0001FF80007F80001F8011207E9C16>I<E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0E0
E0E0E0E0E0E0E0E0E0E0E0E0E00320779C16>I<FC0000FF0000FFC00003C00001C00001
C00001C00001C00001C00001C00001C00001C00001C00001E00000FF00007F80007F8000
FF0001E00001C00001C00001C00001C00001C00001C00001C00001C00001C00003C000FF
C000FF0000FC000011207E9C16>I E /Fb 57 123 df<0001FF0000001FFFC000007F80
F00000FE00F80003FC01FC0003F803FC0007F003FC0007F003FC0007F003FC0007F001F8
0007F000F00007F000000007F000000007F000000007F0000000FFFFFFFC00FFFFFFFC00
FFFFFFFC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007
F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F0
01FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001
FC007FFF1FFFC07FFF1FFFC07FFF1FFFC0222A7FA926>12 D<1C007F00FF80FF80FFC0FF
C0FFC07FC01CC000C000C001C0018001800380070006000E001C00380030000A157BA913
>39 D<00030007001E003C007800F800F001E003E007C007C00F800F801F801F003F003F
003E003E007E007E007E007C00FC00FC00FC00FC00FC00FC00FC00FC00FC00FC00FC00FC
00FC00FC007C007E007E007E003E003E003F003F001F001F800F800F8007C007C003E001
E000F000F80078003C001E00070003103C7AAC1B>I<C000E00078003C001E001F000F00
078007C003E003E001F001F001F800F800FC00FC007C007C007E007E007E003E003F003F
003F003F003F003F003F003F003F003F003F003F003F003F003E007E007E007E007C007C
00FC00FC00F801F801F001F003E003E007C007800F001F001E003C007800E000C000103C
7CAC1B>I<1C007F00FF80FF80FFC0FFC0FFC07FC01CC000C000C001C001800180038007
0006000E001C00380030000A157B8813>44 D<FFFF80FFFF80FFFF80FFFF80FFFF80FFFF
8011067F9017>I<1C007F00FF80FF80FF80FF80FF807F001C0009097B8813>I<003F8000
01FFF00007E0FC000FC07E001F803F001F803F003F001F803F001F807F001FC07F001FC0
7F001FC07F001FC0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0
FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE0FF001FE07F001FC0
7F001FC07F001FC07F001FC03F001F803F001F801F803F001F803F000FC07E0007E0FC00
01FFF000003F80001B277DA622>48 D<000E00001E00007E0007FE00FFFE00FFFE00F8FE
0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE
0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE
0000FE0000FE0000FE0000FE0000FE007FFFFE7FFFFE7FFFFE17277BA622>I<00FF8000
03FFF0000FFFFC003F03FF007C00FF807C007FC0FE007FC0FF003FE0FF003FE0FF003FE0
FF001FE07E001FE03C003FE000003FE000003FC000003FC000007F8000007F800000FF00
0001FE000001FC000003F0000007E000000FC000001F0000003E0000007C00E0007800E0
00F000E001E001C0038001C0070001C00FFFFFC01FFFFFC03FFFFFC07FFFFFC0FFFFFF80
FFFFFF80FFFFFF801B277DA622>I<007F800003FFF00007FFFC001F81FE001F00FF003F
80FF003F807F803FC07F803F807F803F807F801F007F800000FF800000FF000000FF0000
01FE000003F8000007F00000FFC00000FFF0000001FC000000FF0000007F8000007FC000
003FC000003FE000003FE000003FE03C003FE07E003FE0FF003FE0FF003FE0FF003FC0FF
007FC0FE007F807C00FF803F01FF001FFFFC0007FFF00000FF80001B277DA622>I<0000
0E0000001E0000003E0000007E000000FE000000FE000001FE000003FE0000077E00000E
7E00000E7E00001C7E0000387E0000707E0000E07E0000E07E0001C07E0003807E000700
7E000E007E000E007E001C007E0038007E0070007E00E0007E00FFFFFFF8FFFFFFF8FFFF
FFF80000FE000000FE000000FE000000FE000000FE000000FE000000FE000000FE00007F
FFF8007FFFF8007FFFF81D277EA622>I<0C0003000F803F000FFFFE000FFFFE000FFFFC
000FFFF8000FFFE0000FFFC0000FFE00000E0000000E0000000E0000000E0000000E0000
000E0000000E7FC0000FFFF8000F80FE000E007F000C003F8000003F8000001FC000001F
C000001FE000001FE018001FE07E001FE0FE001FE0FE001FE0FE001FE0FE001FE0FE001F
C078003FC078003F803C007F001F01FE000FFFFC0003FFF00000FF80001B277DA622>I<
0007F000003FFC0000FFFF0001FC0F0007F01F800FE03F800FC03F801FC03F803F803F80
3F801F007F8000007F0000007F0000007F000000FF000000FF0FC000FF3FF800FF70FE00
FFE03F00FFC03F80FF801FC0FF801FC0FF801FC0FF001FE0FF001FE0FF001FE0FF001FE0
7F001FE07F001FE07F001FE07F001FE03F801FC03F801FC01F803F800FC03F8007E0FF00
03FFFC0000FFF000003FC0001B277DA622>I<380000003E0000003FFFFFF03FFFFFF03F
FFFFF07FFFFFE07FFFFFC07FFFFFC07FFFFF8070000F0070001E0070003C00E0003800E0
007800E000F0000001E0000003C0000003C0000007800000078000000F0000001F000000
1F0000001F0000003F0000003F0000003E0000007E0000007E0000007E0000007E000000
FE000000FE000000FE000000FE000000FE000000FE000000FE000000FE000000FE000000
3800001C297CA822>I<007F800001FFF00007FFF8000FE0FE001FC07E003F803F007F00
3F807F003F80FF001FC0FF001FC0FF001FC0FF001FC0FF001FE0FF001FE0FF001FE0FF00
1FE07F003FE07F003FE07F003FE03F807FE01F80FFE00FE1DFE003FF9FE0007E1FE00000
1FE000001FC000001FC000001FC000003FC01F003F803F803F803F807F003F807F003F80
FE003F01FC001E03F8000FFFE00007FF800001FE00001B277DA622>57
D<1C007F00FF80FF80FF80FF80FF807F001C000000000000000000000000000000000000
001C007F00FF80FF80FF80FF80FF807F001C00091B7B9A13>I<000003800000000007C0
0000000007C0000000000FE0000000000FE0000000000FE0000000001FF0000000001FF0
000000003FF8000000003FF8000000003FF80000000073FC0000000073FC00000000F3FE
00000000E1FE00000000E1FE00000001C0FF00000001C0FF00000003C0FF80000003807F
80000007807FC0000007003FC0000007003FC000000E003FE000000E001FE000001E001F
F000001C000FF000001FFFFFF000003FFFFFF800003FFFFFF80000780007FC0000700003
FC0000700003FC0000E00001FE0000E00001FE0001E00001FF0001C00000FF0001C00000
FF00FFFE001FFFFEFFFE001FFFFEFFFE001FFFFE2F297EA834>65
D<00003FF001800003FFFE0780000FFFFF8F80003FF007FF8000FF8001FF8001FE00007F
8007FC00003F8007F800001F800FF000000F801FE000000F803FE0000007803FC0000007
807FC0000003807FC0000003807FC000000380FF8000000000FF8000000000FF80000000
00FF8000000000FF8000000000FF8000000000FF8000000000FF8000000000FF80000000
00FF8000000000FF80000000007FC0000000007FC0000003807FC0000003803FC0000003
803FE0000003801FE0000007800FF00000070007F800000F0007FC00001E0001FE00003C
0000FF8000F800003FF007F000000FFFFFC0000003FFFF000000003FF8000029297CA832
>67 D<FFFFFFF80000FFFFFFFF8000FFFFFFFFE00003FC001FF80003FC0007FC0003FC00
01FE0003FC0000FF0003FC00007F8003FC00003FC003FC00001FC003FC00001FE003FC00
001FE003FC00000FF003FC00000FF003FC00000FF003FC00000FF003FC00000FF803FC00
000FF803FC00000FF803FC00000FF803FC00000FF803FC00000FF803FC00000FF803FC00
000FF803FC00000FF803FC00000FF803FC00000FF003FC00000FF003FC00000FF003FC00
001FE003FC00001FE003FC00001FC003FC00003FC003FC00007F8003FC00007F0003FC00
01FE0003FC0003FC0003FC001FF800FFFFFFFFE000FFFFFFFF8000FFFFFFFC00002D297D
A835>I<FFFFFFFFE0FFFFFFFFE0FFFFFFFFE003FC001FE003FC0007F003FC0001F003FC
0001F003FC0000F003FC00007003FC00007003FC00007003FC01C07803FC01C03803FC01
C03803FC01C03803FC03C00003FC03C00003FC0FC00003FFFFC00003FFFFC00003FFFFC0
0003FC0FC00003FC03C00003FC03C00003FC01C00E03FC01C00E03FC01C00E03FC01C01C
03FC00001C03FC00001C03FC00001C03FC00003C03FC00003803FC00007803FC0000F803
FC0001F803FC0003F803FC001FF8FFFFFFFFF0FFFFFFFFF0FFFFFFFFF027297DA82D>I<
00007FE003000003FFFC0F00001FFFFF1F00007FF00FFF0000FF8001FF0003FE0000FF00
07FC00007F000FF800003F000FF000001F001FE000001F003FE000000F003FC000000F00
7FC0000007007FC0000007007FC000000700FF8000000000FF8000000000FF8000000000
FF8000000000FF8000000000FF8000000000FF8000000000FF8000000000FF8000000000
FF8001FFFFF8FF8001FFFFF87FC001FFFFF87FC00000FF007FC00000FF003FC00000FF00
3FE00000FF001FE00000FF000FF00000FF000FF80000FF0007FC0000FF0003FE0001FF00
00FF8001FF00007FF007FF00001FFFFFBF000003FFFE0F0000007FF003002D297CA836>
71 D<FFFFFCFFFFFCFFFFFC01FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE00
01FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE00
01FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE0001FE00
01FE0001FE0001FE00FFFFFCFFFFFCFFFFFC16297EA81A>73 D<FFFFFC0000FFFFFC0000
FFFFFC000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003
FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC
00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00
000003FC0001C003FC0001C003FC0001C003FC0001C003FC0003C003FC00038003FC0003
8003FC00078003FC00078003FC000F8003FC000F8003FC001F8003FC007F8003FC01FF00
FFFFFFFF00FFFFFFFF00FFFFFFFF0022297DA829>76 D<FFFE0000001FFFC0FFFE000000
1FFFC0FFFF0000003FFFC003FF0000003FF00003FF0000003FF00003BF80000077F00003
BF80000077F000039FC00000E7F000039FC00000E7F000038FE00001C7F000038FE00001
C7F0000387F0000387F0000387F0000387F0000387F0000387F0000383F8000707F00003
83F8000707F0000381FC000E07F0000381FC000E07F0000380FE001C07F0000380FE001C
07F0000380FF003807F00003807F003807F00003807F003807F00003803F807007F00003
803F807007F00003801FC0E007F00003801FC0E007F00003800FE1C007F00003800FE1C0
07F00003800FE1C007F000038007F38007F000038007F38007F000038003FF0007F00003
8003FF0007F000038001FE0007F000038001FE0007F000038000FC0007F000038000FC00
07F000FFFE00FC01FFFFC0FFFE007801FFFFC0FFFE007801FFFFC03A297DA841>I<0000
FFE000000007FFFC0000003FC07F8000007F001FC00001FC0007F00003F80003F80007F0
0001FC000FF00001FE001FE00000FF001FE00000FF003FC000007F803FC000007F807FC0
00007FC07F8000003FC07F8000003FC07F8000003FC0FF8000003FE0FF8000003FE0FF80
00003FE0FF8000003FE0FF8000003FE0FF8000003FE0FF8000003FE0FF8000003FE0FF80
00003FE0FF8000003FE07F8000003FC07FC000007FC07FC000007FC03FC000007F803FC0
00007F801FE00000FF001FE00000FF000FF00001FE0007F00001FC0003F80003F80001FC
0007F00000FF001FE000003FC07F8000000FFFFE00000000FFE000002B297CA834>79
D<FFFFFFF800FFFFFFFF00FFFFFFFFC003FC003FE003FC000FF003FC0007F803FC0007FC
03FC0003FC03FC0003FE03FC0003FE03FC0003FE03FC0003FE03FC0003FE03FC0003FE03
FC0003FE03FC0003FC03FC0007FC03FC0007F803FC000FF003FC003FE003FFFFFF8003FF
FFFE0003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00
000003FC00000003FC00000003FC00000003FC00000003FC00000003FC00000003FC0000
0003FC00000003FC000000FFFFF00000FFFFF00000FFFFF0000027297DA82F>I<FFFFFF
E00000FFFFFFFE0000FFFFFFFF800003FC007FE00003FC000FF00003FC0007F80003FC00
07FC0003FC0003FC0003FC0003FE0003FC0003FE0003FC0003FE0003FC0003FE0003FC00
03FE0003FC0003FE0003FC0003FC0003FC0007F80003FC0007F80003FC001FE00003FC00
7FC00003FFFFFE000003FFFFF0000003FC01FC000003FC007F000003FC007F800003FC00
3FC00003FC003FC00003FC001FE00003FC001FE00003FC001FE00003FC001FE00003FC00
1FF00003FC001FF00003FC001FF00003FC001FF00003FC001FF00703FC001FF80703FC00
0FF80703FC000FFC0FFFFFF007FE1EFFFFF001FFFCFFFFF0003FF030297DA834>82
D<007F806003FFF0E00FFFFFE01F807FE03F001FE07E0007E07E0003E07C0003E0FC0001
E0FC0001E0FC0000E0FE0000E0FE0000E0FF000000FFC000007FFE00007FFFE0003FFFFC
003FFFFF001FFFFF8007FFFFC003FFFFE000FFFFF00007FFF000007FF000000FF8000007
F8000003F8E00003F8E00001F8E00001F8E00001F8F00001F8F00001F0F80003F0FC0003
E0FF0007E0FFE01FC0FFFFFF00E0FFFE00C01FF0001D297CA826>I<7FFFFFFFFFC07FFF
FFFFFFC07FFFFFFFFFC07F803FC03FC07E003FC007C078003FC003C078003FC003C07000
3FC001C0F0003FC001E0F0003FC001E0E0003FC000E0E0003FC000E0E0003FC000E0E000
3FC000E0E0003FC000E000003FC0000000003FC0000000003FC0000000003FC000000000
3FC0000000003FC0000000003FC0000000003FC0000000003FC0000000003FC000000000
3FC0000000003FC0000000003FC0000000003FC0000000003FC0000000003FC000000000
3FC0000000003FC0000000003FC0000000003FC0000000003FC0000000003FC00000007F
FFFFE000007FFFFFE000007FFFFFE0002B287EA730>I<FFFFF0003FFF80FFFFF0003FFF
80FFFFF0003FFF8003FF000001E00001FF000003C00000FF8000038000007FC000078000
007FE0000F0000003FE0000E0000001FF0001E0000001FF8003C0000000FF80038000000
07FC007800000007FE00F000000003FE00E000000001FF01E000000001FF83C000000000
FF8380000000007FC780000000007FEF00000000003FEE00000000001FFE00000000000F
FC00000000000FF8000000000007F8000000000007F8000000000007F8000000000007F8
000000000007F8000000000007F8000000000007F8000000000007F8000000000007F800
0000000007F8000000000007F8000000000007F8000000000007F8000000000007F80000
000001FFFFE000000001FFFFE000000001FFFFE0000031297FA834>89
D<01FF800007FFF0000F81FC001FC0FE001FC07F001FC07F001FC03F800F803F8000003F
8000003F8000003F80000FFF8000FFFF8007FC3F801FE03F803F803F807F803F807F003F
80FE003F80FE003F80FE003F80FE007F80FF007F807F00FFC03F83DFFC0FFF0FFC01FC03
FC1E1B7E9A21>97 D<FFE0000000FFE0000000FFE00000000FE00000000FE00000000FE0
0000000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE000
00000FE00000000FE00000000FE1FE00000FE7FF80000FFE07E0000FF803F8000FF001FC
000FE000FE000FE000FE000FE0007F000FE0007F000FE0007F800FE0007F800FE0007F80
0FE0007F800FE0007F800FE0007F800FE0007F800FE0007F800FE0007F800FE0007F000F
E000FF000FE000FE000FF000FE000FF001FC000FF803F8000F9E07E0000F0FFF80000E01
FC0000212A7EA926>I<001FF80000FFFE0003F01F000FE03F801FC03F803F803F803F80
3F807F801F007F000000FF000000FF000000FF000000FF000000FF000000FF000000FF00
0000FF000000FF0000007F0000007F8000003F8001C03FC001C01FC003C00FE0078003F0
1F0000FFFC00001FE0001A1B7E9A1F>I<00003FF80000003FF80000003FF800000003F8
00000003F800000003F800000003F800000003F800000003F800000003F800000003F800
000003F800000003F800000003F800000003F800001FE3F80000FFFBF80003F03FF8000F
E00FF8001FC007F8003F8003F8003F8003F8007F8003F8007F0003F800FF0003F800FF00
03F800FF0003F800FF0003F800FF0003F800FF0003F800FF0003F800FF0003F800FF0003
F8007F0003F8007F0003F8003F8003F8003F8007F8001FC00FF8000FE01FF80003F03FFF
8000FFF3FF80003FC3FF80212A7EA926>I<003FE00001FFF80003F07E000FE03F001FC0
1F803F800FC03F800FC07F000FC07F0007E0FF0007E0FF0007E0FF0007E0FFFFFFE0FFFF
FFE0FF000000FF000000FF000000FF0000007F0000007F8000003F8000E03F8001E01FC0
01C00FE003C003F81F8000FFFE00001FF0001B1B7E9A20>I<0007F0003FFC00FE3E01FC
7F03F87F03F87F07F07F07F03E07F00007F00007F00007F00007F00007F00007F000FFFF
C0FFFFC0FFFFC007F00007F00007F00007F00007F00007F00007F00007F00007F00007F0
0007F00007F00007F00007F00007F00007F00007F00007F00007F00007F00007F0007FFF
807FFF807FFF80182A7EA915>I<00FF81F003FFE7FC0FC1FE7C1F80FC7C3F80FE7C3F00
7E107F007F007F007F007F007F007F007F007F007F007F007F003F007E003F80FE001F80
FC000FC1F8001FFFE00018FF8000380000003C0000003C0000003E0000003FFFF8003FFF
FF001FFFFFC00FFFFFE007FFFFF01FFFFFF07E0007F87C0001F8F80001F8F80000F8F800
00F8F80000F8FC0001F87E0003F03F0007E00FC01F8003FFFE00007FF0001E287E9A22>
I<FFE0000000FFE0000000FFE00000000FE00000000FE00000000FE00000000FE0000000
0FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000F
E00000000FE07F00000FE1FFC0000FE787E0000FEE07F0000FFC03F8000FF803F8000FF0
03F8000FF003F8000FF003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003
F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8
000FE003F8000FE003F8000FE003F800FFFE3FFF80FFFE3FFF80FFFE3FFF80212A7DA926
>I<07001FC01FE03FE03FE03FE01FE01FC007000000000000000000000000000000FFE0
FFE0FFE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE0
0FE00FE00FE00FE00FE0FFFEFFFEFFFE0F2B7DAA14>I<000700001FC0003FE0003FE000
3FE0003FE0003FE0001FC000070000000000000000000000000000000000000000000001
FFE001FFE001FFE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE000
0FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE000
0FE0000FE0000FE0000FE0000FE0000FE0000FE07C0FE0FE0FE0FE1FC0FE1FC0FE1F807C
3F003FFC000FF000133784AA15>I<FFE00000FFE00000FFE000000FE000000FE000000F
E000000FE000000FE000000FE000000FE000000FE000000FE000000FE000000FE000000F
E000000FE01FFC0FE01FFC0FE01FFC0FE007C00FE00F800FE01E000FE07C000FE0F8000F
E1F0000FE3E0000FE7C0000FEFE0000FFFF0000FFFF0000FFFF8000FF3FC000FE1FE000F
C0FE000FC0FF000FC07F800FC03F800FC03FC00FC01FE00FC00FF0FFFC3FFEFFFC3FFEFF
FC3FFE1F2A7EA924>I<FFE0FFE0FFE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE0
0FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE00FE0
0FE00FE00FE00FE00FE00FE00FE00FE0FFFEFFFEFFFE0F2A7DA914>I<FFC07F800FF000
FFC1FFE03FFC00FFC783F0F07E000FCE03F9C07F000FDC01FB803F000FF801FF003F800F
F001FE003F800FF001FE003F800FF001FE003F800FE001FC003F800FE001FC003F800FE0
01FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001
FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC003F800FE001FC
003F800FE001FC003F800FE001FC003F80FFFE1FFFC3FFF8FFFE1FFFC3FFF8FFFE1FFFC3
FFF8351B7D9A3A>I<FFC07F0000FFC1FFC000FFC787E0000FCE07F0000FDC03F8000FF8
03F8000FF003F8000FF003F8000FF003F8000FE003F8000FE003F8000FE003F8000FE003
F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8
000FE003F8000FE003F8000FE003F8000FE003F800FFFE3FFF80FFFE3FFF80FFFE3FFF80
211B7D9A26>I<003FE00001FFFC0003F07E000FC01F801F800FC03F800FE03F0007E07F
0007F07F0007F07F0007F0FF0007F8FF0007F8FF0007F8FF0007F8FF0007F8FF0007F8FF
0007F8FF0007F87F0007F07F0007F03F800FE03F800FE01F800FC00FC01F8007F07F0001
FFFC00003FE0001D1B7E9A22>I<FFE1FE0000FFE7FF8000FFFE07E0000FF803F8000FF0
01FC000FE001FE000FE000FE000FE000FF000FE000FF000FE0007F800FE0007F800FE000
7F800FE0007F800FE0007F800FE0007F800FE0007F800FE0007F800FE0007F800FE000FF
000FE000FF000FE000FE000FF001FE000FF003FC000FF803F8000FFE0FE0000FEFFF8000
0FE1FC00000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000F
E00000000FE00000000FE0000000FFFE000000FFFE000000FFFE00000021277E9A26>I<
001FC0380000FFF0780003F83CF8000FE01FF8001FE00FF8003FC007F8003F8007F8007F
8003F8007F8003F800FF0003F800FF0003F800FF0003F800FF0003F800FF0003F800FF00
03F800FF0003F800FF0003F800FF0003F8007F8003F8007F8003F8003F8003F8003FC007
F8001FC00FF8000FE01FF80003F07FF80000FFF3F800003FC3F800000003F800000003F8
00000003F800000003F800000003F800000003F800000003F800000003F800000003F800
00003FFF8000003FFF8000003FFF8021277E9A24>I<FFC1F0FFC7FCFFCE3E0FDC7F0FD8
7F0FF87F0FF07F0FF03E0FF0000FE0000FE0000FE0000FE0000FE0000FE0000FE0000FE0
000FE0000FE0000FE0000FE0000FE0000FE0000FE000FFFF00FFFF00FFFF00181B7E9A1C
>I<03FE300FFFF03E03F07800F07000F0F00070F00070F80070FC0000FFE000FFFE007F
FFC03FFFE01FFFF007FFF800FFFC0003FC0000FCE0007CE0003CF0003CF0003CF80078FC
0078FF01F0F7FFC0C1FF00161B7E9A1B>I<00700000700000700000700000F00000F000
00F00001F00003F00003F00007F0001FFFF0FFFFF0FFFFF007F00007F00007F00007F000
07F00007F00007F00007F00007F00007F00007F00007F00007F00007F03807F03807F038
07F03807F03807F03807F03803F87001F8F000FFE0001F8015267FA51B>I<FFE03FF800
FFE03FF800FFE03FF8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000F
E003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE003F8000FE0
03F8000FE003F8000FE003F8000FE003F8000FE003F8000FE007F8000FE007F8000FE00F
F80007E01FF80003F03BFF8001FFF3FF80003FC3FF80211B7D9A26>I<FFFE03FF80FFFE
03FF80FFFE03FF8007F000700007F000700007F800F00003F800E00003FC01E00001FC01
C00001FC01C00000FE03800000FE038000007F070000007F070000007F8F0000003F8E00
00003FDE0000001FDC0000001FDC0000000FF80000000FF80000000FF800000007F00000
0007F000000003E000000003E000000001C00000211B7F9A24>I<FFFE7FFC0FFEFFFE7F
FC0FFEFFFE7FFC0FFE0FE007E000E007F003F001C007F003F001C007F807F803C003F807
F8038003F807F8038001FC0EFC070001FC0EFC070001FE1EFC0F0000FE1C7E0E0000FE1C
7E0E0000FF383F1E00007F383F1C00007F783F3C00003FF01FB800003FF01FB800003FF0
1FF800001FE00FF000001FE00FF000000FC007E000000FC007E000000FC007E000000780
03C00000078003C0002F1B7F9A32>I<FFFC0FFF00FFFC0FFF00FFFC0FFF0007F003C000
03F807800001FC07800000FE0F000000FF1E0000007F3C0000003FF80000001FF0000000
0FF00000000FF000000007F000000007F80000000FFC0000001FFE0000001EFE0000003C
7F000000783F800000F01FC00001E01FE00001C00FE00003C007F000FFF01FFF80FFF01F
FF80FFF01FFF80211B7F9A24>I<FFFE03FF80FFFE03FF80FFFE03FF8007F000700007F0
00700007F800F00003F800E00003FC01E00001FC01C00001FC01C00000FE03800000FE03
8000007F070000007F070000007F8F0000003F8E0000003FDE0000001FDC0000001FDC00
00000FF80000000FF80000000FF800000007F000000007F000000003E000000003E00000
0001C000000001C000000003800000000380000038078000007C07000000FE0F000000FE
0E000000FE1E000000FE3C0000007C780000003FE00000000FC000000021277F9A24>I<
3FFFFF803FFFFF803F00FF803C00FF003801FE007803FC007807FC007007F800700FF000
701FE000001FE000003FC000007F800000FF800000FF000001FE038003FC038003FC0380
07F803800FF007801FF007801FE007003FC00F007F801F00FF807F00FFFFFF00FFFFFF00
191B7E9A1F>I E /Fc 3 104 df<03F0000FFC001FFE003FFF007FFF807FFF80FFFFC0FF
FFC0FFFFC0FFFFC0FFFFC0FFFFC0FFFFC0FFFFC07FFF807FFF803FFF001FFE000FFC0003
F00012147D9519>15 D<000F0038007000E001C001C001C001C001C001C001C001C001C0
01C001C001C001C001C001C001C001C0038007001E00F0001E000700038001C001C001C0
01C001C001C001C001C001C001C001C001C001C001C001C001C001C000E000700038000F
10317CA419>102 D<F0001E000700038001C001C001C001C001C001C001C001C001C001
C001C001C001C001C001C001C001C000E000700038000F0038007000E001C001C001C001
C001C001C001C001C001C001C001C001C001C001C001C001C001C0038007001E00F00010
317CA419>I E /Fd 70 126 df<2008F01EF01EF01EF01EF01EF01EF01EF01E701C701C
701C701C701C600C0F0F7B9E1A>34 D<01818003C3C003C3C003C3C003C3C003C3C003C3
C07FFFF0FFFFF8FFFFF8FFFFF80787800787800787800F8F800F8F800F0F000F0F000F0F
00FFFFF8FFFFF8FFFFF87FFFF01E1E001E1E001E1E001E1E001E1E001E1E000C0C00151E
7E9D1A>I<00600000E00000E00000E00000E00003FC000FFF001FFF803EE7C078E1C0F0
E1E0E0E0E0E0E1E0E0E1E0E0E0C0F0E00078E0003FE0001FF8000FFE0001FF0000EF8000
E3C000E1C060E1E0F0E0E0F0E0E0F0E0E0E0E1E0F0E1C078E3C03EEF801FFF000FFE0003
F80000E00000E00000E00000600013277DA21A>I<3C00C07E01E07E03E0FF03E0E703C0
E707C0E707C0E70780E70F80E70F80E71F00FF1F007E1E007E3E003C3E00003C00007C00
007C0000F80000F80000F00001F00001F00001E00003E00003E00003C1E007C3F007C3F0
0F87F80F87380F07381F07381F07381E07383E07F83E03F03C03F01801E015277EA21A>
I<1C3C3E1E0E0E0E0E1E1C3C38F8F0E0070F779D1A>39 D<0038007800F801E003C00780
0F001E001C003C0038007800700070007000F000E000E000E000E000E000E000E000E000
F000700070007000780038003C001C001E000F00078003C001E000F8007800380D2878A2
1A>I<6000F00078003C001E000F00078003C001C001E000E000F0007000700070007800
380038003800380038003800380038007800700070007000F000E001E001C003C007800F
001E003C007800F00060000D287CA21A>I<00E00000E00000E00000E00040E040F0E1E0
F8E3E07EEFC01FFF0007FC0003F80007FC001FFF007EEFC0F8E3E0F0E1E040E04000E000
00E00000E00000E00013157D991A>I<0030000078000078000078000078000078000078
000078000078007FFFF0FFFFF8FFFFF87FFFF00078000078000078000078000078000078
0000780000780000300015167E991A>I<3C7E7F7F7F3F070F0E3EFCF8E0080D77851A>I<
7FFFC0FFFFE0FFFFE07FFFC013047D901A>I<78FCFCFCFC78060676851A>I<01F00007FC
000FFE001F1F001C07003803803803807001C07001C07001C0E000E0E000E0E000E0E000
E0E000E0E000E0E000E0E000E0E000E0F001E07001C07001C07803C03803803C07801C07
001F1F000FFE0007FC0001F000131E7D9D1A>48 D<00C001C003C003C007C00FC07FC0FD
C079C001C001C001C001C001C001C001C001C001C001C001C001C001C001C001C001C001
C001C07FFF7FFF7FFF101E7B9D1A>I<07F8000FFE001FFF003C0F807803C0F001C0E001
E0F000E0F000E06000E00000E00000E00001E00001C00003C0000780000F00000E00003E
00007C0000F80001E00003C0000780000F00001E00E03C00E07FFFE0FFFFE07FFFE0131E
7D9D1A>I<78FCFCFCFC7800000000000000000078FCFCFCFC78061576941A>58
D<3C7E7E7E7E3C0000000000000000003C7C7E7E7E3E0E1E1C3CF8F0E0071C77941A>I<
7FFFF0FFFFF8FFFFF87FFFF00000000000000000000000007FFFF0FFFFF8FFFFF87FFFF0
150C7E941A>61 D<07FC001FFF007FFF807C07C0F001E0F000E0F000E06001E00007C000
0F80001F00003C0000780000F00000E00000E00000E00000E00000E00000E00000C00000
000000000000000000000000000000C00001E00001E00000C000131E7D9D1A>63
D<007E0001FF8003FFC007C3E00F00E01E0FF03C3FF0387FF07879F870F0F8F0E078E1E0
78E1C038E1C038E1C038E1C038E1C038E1C038E1E078F0E07070F0F07879E0387FE03C3F
C01E0F000F003807C1F803FFF801FFE0007F80151E7E9D1A>I<003800007C00007C0000
6C0000EE0000EE0000EE0000C60000C60001C70001C70001C70001C70003838003838003
83800383800701C00701C007FFC007FFC00FFFE00E00E00E00E00E00E00E00E01C00707F
01FCFF83FE7F01FC171E7F9D1A>I<00FE3803FFB807FFF80F83F81E00F81C00783C0078
780038700038700038F00000E00000E00000E00000E00000E00000E00000E00000E00000
F000007000387000387800383C00781C00701E00F00F83E007FFC003FF8000FE00151E7E
9D1A>67 D<7FFE00FFFF007FFF801C07C01C01E01C00F01C00701C00781C00381C00381C
003C1C001C1C001C1C001C1C001C1C001C1C001C1C001C1C001C1C003C1C00381C00381C
00781C00701C00F01C01E01C07C07FFFC0FFFF007FFE00161E7F9D1A>I<FFFFF8FFFFF8
FFFFF81C00381C00381C00381C00381C00001C00001C00001C0E001C0E001C0E001FFE00
1FFE001FFE001C0E001C0E001C0E001C00001C00001C00001C001C1C001C1C001C1C001C
1C001CFFFFFCFFFFFCFFFFFC161E7E9D1A>I<7FFFFCFFFFFC7FFFFC0E001C0E001C0E00
1C0E001C0E00000E00000E00000E03800E03800E03800FFF800FFF800FFF800E03800E03
800E03800E00000E00000E00000E00000E00000E00000E00000E00007FE000FFE0007FE0
00161E7F9D1A>I<01F8E003FEE007FFE00F0FE01E03E03C01E03801E07800E07000E070
00E0F00000E00000E00000E00000E00000E00000E00FF8E00FF8E00FF8F000E07000E070
01E07801E03801E03C03E01E03E00F0FE007FFE003FEE001F8E0151E7E9D1A>I<FFFF80
FFFF80FFFF8001C00001C00001C00001C00001C00001C00001C00001C00001C00001C000
01C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C000
01C00001C000FFFF80FFFF80FFFF80111E7C9D1A>73 D<7F03F8FF87FC7F03F81C01E01C
03C01C03801C07801C0F001C1E001C1C001C3C001C78001CF0001CF8001DFC001FFC001F
9E001F0E001F0F001E07001C07801C03801C03C01C01E01C01E01C00F01C00707F00FCFF
81FE7F00FC171E7F9D1A>75 D<7FE000FFF0007FE0000E00000E00000E00000E00000E00
000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00
000E00000E00000E001C0E001C0E001C0E001C0E001C7FFFFCFFFFFC7FFFFC161E7F9D1A
>I<7E003F00FF007F807F007F001D80DC001D80DC001D80DC001DC1DC001DC1DC001CC1
9C001CC19C001CE39C001CE39C001C631C001C771C001C771C001C361C001C361C001C3E
1C001C1C1C001C1C1C001C001C001C001C001C001C001C001C001C001C001C001C001C00
1C007F007F00FF80FF807F007F00191E809D1A>I<FE03FEFF03FEFF03FE1D80701D8070
1DC0701CC0701CC0701CE0701CE0701C60701C70701C70701C30701C38701C38701C1870
1C1C701C1C701C0C701C0E701C0E701C06701C06701C07701C03701C0370FF81F0FF81F0
FF80F0171E7F9D1A>I<0FFE003FFF807FFFC07C07C07001C0F001E0E000E0E000E0E000
E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000E0E000
E0E000E0E000E0F001E0F001E07001C07C07C07FFFC03FFF800FFE00131E7D9D1A>I<FF
FE00FFFF80FFFFC01C03E01C00F01C00701C00781C00381C00381C00381C00381C00781C
00701C00F01C03E01FFFC01FFF801FFE001C00001C00001C00001C00001C00001C00001C
00001C00001C0000FF8000FF8000FF8000151E7E9D1A>I<FFFC00FFFF00FFFF801C07C0
1C01E01C00F01C00701C00701C00701C00701C00F01C01E01C07C01FFF801FFF001FFF80
1C07C01C01E01C00E01C00E01C00E01C00E01C00E01C00E21C00E71C00E71C00E7FF80FF
FF807EFF803C181E7F9D1A>82 D<07F1C01FFDC03FFFC07C1FC07007C0F003C0E001C0E0
01C0E001C0E00000F000007800003F00001FF8000FFE0001FF00000F800003C00001C000
01E00000E06000E0E000E0E000E0F001E0F003C0FE0780FFFF80FFFE00E3FC00131E7D9D
1A>I<7FFFFEFFFFFEFFFFFEE0380EE0380EE0380EE0380E003800003800003800003800
003800003800003800003800003800003800003800003800003800003800003800003800
00380000380000380000380003FF8003FF8003FF80171E7F9D1A>I<FF83FEFF83FEFF83
FE1C00701C00701C00701C00701C00701C00701C00701C00701C00701C00701C00701C00
701C00701C00701C00701C00701C00701C00701C00701C00701E00F00E00E00F01E007C7
C003FF8001FF00007C00171E7F9D1A>I<FF01FEFF01FEFF01FE1C00701C00701C00701E
00F00E00E00E00E00E00E00701C00701C00701C00701C003838003838003838003838001
C70001C70001C70001C70000C60000EE0000EE0000EE00006C00007C00007C0000380017
1E7F9D1A>I<7F87F87F87F87F87F80F01C007038007838003870003C70001CE0001EE00
00FC0000FC00007800007800007800007C00007C0000FE0000EE0001CF0001C700038780
0383800703C00701C00E00E00E00E07F01FCFF83FE7F01FC171E7F9D1A>88
D<FF01FEFF01FEFF01FE1C00700E00E00E00E00701C00701C00783C003838003C78001C7
0001C70000EE0000EE00007C00007C000038000038000038000038000038000038000038
0000380000380000380001FF0001FF0001FF00171E7F9D1A>I<3FFFF87FFFF87FFFF870
00707000F07001E07001C00003C0000780000F00000E00001E00003C0000380000780000
F00000E00001E00003C0000380000780000F00001E00381C00383C0038780038700038FF
FFF8FFFFF8FFFFF8151E7E9D1A>I<FFF8FFF8FFF8E000E000E000E000E000E000E000E0
00E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E0
00E000E000E000E000E000E000E000FFF8FFF8FFF80D2776A21A>I<FFF8FFF8FFF80038
003800380038003800380038003800380038003800380038003800380038003800380038
00380038003800380038003800380038003800380038003800380038FFF8FFF8FFF80D27
7EA21A>93 D<7FFFC0FFFFE0FFFFE07FFFC013047D7E1A>95 D<1FF0003FFC007FFE0078
1F0030078000038000038000FF8007FF801FFF803F83807C0380F00380E00380E00380E0
0380F007807C1F803FFFFC1FFDFC07F0FC16157D941A>97 D<FE0000FE0000FE00000E00
000E00000E00000E00000E00000E00000E3F000EFFC00FFFE00FE1F00F80700F00780F00
380E003C0E001C0E001C0E001C0E001C0E001C0F003C0F00380F00780F80F00FC3E00FFF
C00EFF80067E00161E7F9D1A>I<01FF8007FFC00FFFE01F01E03C00C0780000700000F0
0000E00000E00000E00000E00000E00000F000007000007800703C00701F01F00FFFE007
FFC001FF0014157D941A>I<001FC0001FC0001FC00001C00001C00001C00001C00001C0
0001C001F9C007FDC00FFFC01F0FC03C07C07803C07003C0F001C0E001C0E001C0E001C0
E001C0E001C0F003C07003C07807C03807C03E1FC01FFFFC0FFDFC03F1FC161E7E9D1A>
I<01FC0007FF000FFF801F07C03C01E07800E07000F0F00070E00070FFFFF0FFFFF0FFFF
F0E00000F000007000007800703C00701F01F00FFFE007FFC001FF0014157D941A>I<00
0FF0001FF8003FF800787800F03000E00000E00000E00000E0007FFFF0FFFFF0FFFFF000
E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000
E00000E00000E0003FFF807FFFC03FFF80151E7F9D1A>I<01F8FC07FFFE0FFFFE1F0F8C
1C03803C03C03801C03801C03801C03C03C01C03801F0F801FFF003FFE0039F800380000
3C00001C00001FFF801FFFF03FFFF87C00FC70001CF0001EE0000EE0000EE0000EF0001E
78003C3F01F81FFFF00FFFE001FF0017217F941A>I<FE0000FE0000FE00000E00000E00
000E00000E00000E00000E00000E3F000EFF800FFFC00FE1E00F80E00F00E00F00E00E00
E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E0FFE3FEFFE7
FEFFE3FE171E7F9D1A>I<00C00001E00001E00000C00000000000000000000000000000
00000000007FE0007FE0007FE00000E00000E00000E00000E00000E00000E00000E00000
E00000E00000E00000E00000E00000E00000E00000E0007FFF80FFFFC07FFF80121F7C9E
1A>I<FE0000FE0000FE00000E00000E00000E00000E00000E00000E00000E0FFC0E1FFE
0E0FFC0E03C00E07800E0F000E1E000E3C000E78000EFC000FFC000FDE000F8F000E0780
0E03C00E03C00E01E00E00F0FFE3FEFFE3FFFFE3FE181E7F9D1A>107
D<FFE000FFE000FFE00000E00000E00000E00000E00000E00000E00000E00000E00000E0
0000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E0
0000E00000E00000E000FFFFE0FFFFE0FFFFE0131E7D9D1A>I<7DF1F000FFFBF8007FFF
FC001F1F1C001E1E1C001E1E1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C
1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C001C1C1C007F1F1F00FF9F9F807F1F
1F00191580941A>I<FE3F00FEFF80FFFFC00FE1E00F80E00F00E00F00E00E00E00E00E0
0E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E0FFE3FEFFE7FEFFE3FE
17157F941A>I<01F00007FC001FFF003E0F803C07807803C07001C0E000E0E000E0E000
E0E000E0E000E0E000E0F001E07001C07803C03C07803E0F801FFF0007FC0001F0001315
7D941A>I<FE3F00FEFFC0FFFFE00FE1F00F80700F00780F00380E003C0E001C0E001C0E
001C0E001C0E001C0F003C0F00380F00780F80F00FC3E00FFFC00EFF800E7E000E00000E
00000E00000E00000E00000E00000E00000E0000FFE000FFE000FFE00016207F941A>I<
7F87F0FF9FFC7FBFFC03FC3C03F01803E00003E00003C00003C000038000038000038000
0380000380000380000380000380000380007FFF00FFFF007FFF0016157E941A>114
D<0FFB803FFF807FFF80F80F80E00380E00380E00380F800007FC0003FFC000FFF00007F
800007C06001C0E001C0F001C0F003C0FC0F80FFFF00FFFE00E7F80012157C941A>I<00
C00001C00001C00001C00001C00001C00001C0007FFFE0FFFFE0FFFFE001C00001C00001
C00001C00001C00001C00001C00001C00001C00001C00001C07001C07001C07001C0F001
E1E000FFE0007FC0003F00141C7F9B1A>I<FE0FE0FE0FE0FE0FE00E00E00E00E00E00E0
0E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E00E01E00E01E00F07E0
07FFFE03FFFE01FCFE17157F941A>I<7F83FCFFC7FE7F83FC0E00E00E00E00E00E00701
C00701C00701C003838003838003838001C70001C70001C70000EE0000EE0000EE00007C
00007C0000380017157F941A>I<FF83FEFFC7FEFF83FE3800383800381C00701C00701C
00701C38701C7C701C7C700E6CE00E6CE00EEEE00EEEE00EEEE00EC6E006C6C007C7C007
C7C003838017157F941A>I<7FC7F87FCFFC7FC7F80703C003838003C70001EF0000FE00
007C00007800003800007C0000EE0001EE0001C7000383800783C00F01C07FC7FCFFC7FE
7FC7FC17157F941A>I<7FC3FCFFC7FE7FC3FC0E00E00E00E00700E00701C00781C00381
C003838003C38001C38001C70000E70000E70000E600006600006E00003C00003C00003C
0000380000380000380000700000700030700078E00071E0007FC0003F80001E00001720
7F941A>I<7FFFF0FFFFF0FFFFF0E001E0E003C0E00780000F00001E00003C0000780000
F00001E00003C0000780000F00381E00383C0038780038FFFFF8FFFFF8FFFFF815157E94
1A>I<0007E0001FE0003FE0007C0000F00000E00000E00000E00000E00000E00000E000
00E00000E00000E00000E00000E00001E00007C000FF8000FF0000FF800007C00001E000
00E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000F000
007C00003FE0001FE00007E013277DA21A>I<7C0000FF0000FF800007C00001E00000E0
0000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00000F000007C
00003FE0001FE0003FE0007C0000F00000E00000E00000E00000E00000E00000E00000E0
0000E00000E00000E00000E00001E00007C000FF8000FF00007C000013277DA21A>125
D E /Fe 46 123 df<007E0001C1800301800703C00E03C00E01800E00000E00000E0000
0E00000E0000FFFFC00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C0
0E01C00E01C00E01C00E01C00E01C00E01C00E01C07F87F8151D809C17>12
D<6060F0F0F8F86868080808080808101010102020404080800D0C7F9C15>34
D<004000800100020006000C000C0018001800300030007000600060006000E000E000E0
00E000E000E000E000E000E000E000E000E000600060006000700030003000180018000C
000C00060002000100008000400A2A7D9E10>40 D<800040002000100018000C000C0006
00060003000300038001800180018001C001C001C001C001C001C001C001C001C001C001
C001C0018001800180038003000300060006000C000C00180010002000400080000A2A7E
9E10>I<0006000000060000000600000006000000060000000600000006000000060000
0006000000060000000600000006000000060000FFFFFFE0FFFFFFE00006000000060000
000600000006000000060000000600000006000000060000000600000006000000060000
00060000000600001B1C7E9720>43 D<60F0F0701010101020204080040C7C830C>I<FF
E0FFE00B0280890E>I<60F0F06004047C830C>I<60F0F0600000000000000000000060F0
F06004127C910C>58 D<000600000006000000060000000F0000000F0000000F00000017
800000178000001780000023C0000023C0000023C0000041E0000041E0000041E0000080
F0000080F0000180F8000100780001FFF80003007C0002003C0002003C0006003E000400
1E0004001E000C001F001E001F00FF80FFF01C1D7F9C1F>65 D<FFFFC00F00F00F00380F
003C0F001C0F001E0F001E0F001E0F001E0F001C0F003C0F00780F01F00FFFE00F00780F
003C0F001E0F000E0F000F0F000F0F000F0F000F0F000F0F001E0F001E0F003C0F0078FF
FFE0181C7E9B1D>I<001F808000E0618001801980070007800E0003801C0003801C0001
8038000180780000807800008070000080F0000000F0000000F0000000F0000000F00000
00F0000000F0000000F0000000700000807800008078000080380000801C0001001C0001
000E000200070004000180080000E03000001FC000191E7E9C1E>I<FFFFF80F00780F00
180F00080F00080F000C0F00040F00040F02040F02000F02000F02000F06000FFE000F06
000F02000F02000F02000F02000F00000F00000F00000F00000F00000F00000F00000F80
00FFF800161C7E9B1B>70 D<001F808000E0618001801980070007800E0003801C000380
1C00018038000180780000807800008070000080F0000000F0000000F0000000F0000000
F0000000F0000000F000FFF0F0000F80700007807800078078000780380007801C000780
1C0007800E00078007000B800180118000E06080001F80001C1E7E9C21>I<FFF3FFC00F
003C000F003C000F003C000F003C000F003C000F003C000F003C000F003C000F003C000F
003C000F003C000F003C000FFFFC000F003C000F003C000F003C000F003C000F003C000F
003C000F003C000F003C000F003C000F003C000F003C000F003C000F003C00FFF3FFC01A
1C7E9B1F>I<FFF00F000F000F000F000F000F000F000F000F000F000F000F000F000F00
0F000F000F000F000F000F000F000F000F000F000F000F00FFF00C1C7F9B0F>I<FFF800
0F80000F00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F0000
0F00000F00000F00000F00000F00000F00080F00080F00080F00180F00180F00100F0030
0F00700F01F0FFFFF0151C7E9B1A>76 D<003F800000E0E0000380380007001C000E000E
001C0007003C00078038000380780003C0780003C0700001C0F00001E0F00001E0F00001
E0F00001E0F00001E0F00001E0F00001E0F00001E0700001C0780003C0780003C0380003
803C0007801C0007000E000E0007001C000380380000E0E000003F80001B1E7E9C20>79
D<07E0801C1980300580700380600180E00180E00080E00080E00080F00000F800007C00
007FC0003FF8001FFE0007FF0000FF80000F800007C00003C00001C08001C08001C08001
C0C00180C00180E00300D00200CC0C0083F800121E7E9C17>83 D<7FFFFFC0700F01C060
0F00C0400F0040400F0040C00F0020800F0020800F0020800F0020000F0000000F000000
0F0000000F0000000F0000000F0000000F0000000F0000000F0000000F0000000F000000
0F0000000F0000000F0000000F0000000F0000000F0000001F800003FFFC001B1C7F9B1E
>I<FFF007FC0F8001E00780008007C0018003C0010003E0020001F0020000F0040000F8
040000780800007C1800003C1000001E2000001F2000000F4000000FC000000780000007
800000078000000780000007800000078000000780000007800000078000000780000007
8000007FF8001E1C809B1F>89 D<08081010202040404040808080808080B0B0F8F87878
30300D0C7A9C15>92 D<1FC000307000783800781C00301C00001C00001C0001FC000F1C
00381C00701C00601C00E01C40E01C40E01C40603C40304E801F870012127E9115>97
D<FC00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C7C
001D86001E03001C01801C01C01C00C01C00E01C00E01C00E01C00E01C00E01C00E01C00
C01C01C01C01801E030019060010F800131D7F9C17>I<07E00C301878307870306000E0
00E000E000E000E000E00060007004300418080C3007C00E127E9112>I<003F00000700
00070000070000070000070000070000070000070000070000070003E7000C1700180F00
300700700700600700E00700E00700E00700E00700E00700E00700600700700700300700
180F000C370007C7E0131D7E9C17>I<03E00C301818300C700E6006E006FFFEE000E000
E000E00060007002300218040C1803E00F127F9112>I<00F8018C071E061E0E0C0E000E
000E000E000E000E00FFE00E000E000E000E000E000E000E000E000E000E000E000E000E
000E000E000E007FE00F1D809C0D>I<00038003C4C00C38C01C3880181800381C00381C
00381C00381C001818001C38000C300013C0001000003000001800001FF8001FFF001FFF
803003806001C0C000C0C000C0C000C06001803003001C0E0007F800121C7F9215>I<FC
00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C00001C7C001C
87001D03001E03801C03801C03801C03801C03801C03801C03801C03801C03801C03801C
03801C03801C03801C0380FF9FF0141D7F9C17>I<18003C003C00180000000000000000
00000000000000FC001C001C001C001C001C001C001C001C001C001C001C001C001C001C
001C001C00FF80091D7F9C0C>I<FC00001C00001C00001C00001C00001C00001C00001C
00001C00001C00001C00001C3FC01C0F001C0C001C08001C10001C20001C40001CE0001D
E0001E70001C78001C38001C3C001C1C001C0E001C0F001C0F80FF9FE0131D7F9C16>
107 D<FC001C001C001C001C001C001C001C001C001C001C001C001C001C001C001C001C
001C001C001C001C001C001C001C001C001C001C001C00FF80091D7F9C0C>I<FC7E07E0
001C838838001D019018001E01E01C001C01C01C001C01C01C001C01C01C001C01C01C00
1C01C01C001C01C01C001C01C01C001C01C01C001C01C01C001C01C01C001C01C01C001C
01C01C001C01C01C00FF8FF8FF8021127F9124>I<FC7C001C87001D03001E03801C0380
1C03801C03801C03801C03801C03801C03801C03801C03801C03801C03801C03801C0380
FF9FF014127F9117>I<03F0000E1C00180600300300700380600180E001C0E001C0E001
C0E001C0E001C0E001C06001807003803003001806000E1C0003F00012127F9115>I<FC
7C001D86001E03001C01801C01C01C00C01C00E01C00E01C00E01C00E01C00E01C00E01C
01C01C01C01C01801E03001D06001CF8001C00001C00001C00001C00001C00001C00001C
0000FF8000131A7F9117>I<FCE01D301E781E781C301C001C001C001C001C001C001C00
1C001C001C001C001C00FFC00D127F9110>114 D<1F9030704030C010C010E010F8007F
803FE00FF000F880388018C018C018E010D0608FC00D127F9110>I<0400040004000400
0C000C001C003C00FFE01C001C001C001C001C001C001C001C001C001C101C101C101C10
1C100C100E2003C00C1A7F9910>I<FC1F801C03801C03801C03801C03801C03801C0380
1C03801C03801C03801C03801C03801C03801C03801C07800C07800E1B8003E3F014127F
9117>I<FF07E03C03801C01001C01000E02000E02000704000704000704000388000388
0003D80001D00001D00000E00000E00000E00000400013127F9116>I<FF3FCFE03C0F03
801C0701801C0701001C0B01000E0B82000E0B82000E1182000711C4000711C4000720C4
0003A0E80003A0E80003C0680001C0700001C0700001803000008020001B127F911E>I<
7F8FF00F03800F030007020003840001C80001D80000F00000700000780000F800009C00
010E00020E000607000403801E07C0FF0FF81512809116>I<FF07E03C03801C01001C01
000E02000E020007040007040007040003880003880003D80001D00001D00000E00000E0
0000E000004000004000008000008000F08000F10000F300006600003C0000131A7F9116
>I<7FFC70386038407040F040E041C003C0038007000F040E041C043C0C380870087038
FFF80E127F9112>I E /Ff 4 53 df<0C001C00EC000C000C000C000C000C000C000C00
0C000C000C000C000C000C000C000C00FFC00A137D9211>49 D<1F0060C06060F070F030
603000700070006000C001C00180020004000810101020207FE0FFE00C137E9211>I<0F
C030707038703870380038003000E00FC0007000380018001C601CF01CF018E03860701F
C00E137F9211>I<006000E000E00160026006600C600860106020606060C060FFFC0060
006000600060006003FC0E137F9211>I E /Fg 52 124 df<00000FC0F8000030718E00
00E0F31E0000C0F71E0001C0660C0001800E000003800E000003800E000003800E000007
001C000007001C000007001C000007001C000007001C0000FFFFFFC0000E003800000E00
3800000E003800000E003800001C007000001C007000001C007000001C007000001C0070
00001C00E000003800E000003800E000003800E000003800E000003801C000007001C000
007001C000007001C000007001C000006003800000E003800000E003800000E003000000
C003000001C0070000718E060000F19E0C0000F31E180000620C3000003C07C00000272D
82A21E>11 D<00000FE0000030180000E01C0001C03C0001803C00038038000380000003
80000007000000070000000700000007000000070000000E000000FFFFE0000E00E0000E
00E0000E01C0001C01C0001C01C0001C01C0001C0380001C038000380380003803800038
070000380700003807000070070800700E1000700E1000700E1000700E2000E0062000E0
03C000E0000000E0000000C0000001C0000001C0000071800000F1800000F30000006200
00003C0000001E2D82A21B>I<0C1E3F3F1D02020204040810204080080F75A20F>39
D<0E1E1E1E1E02020404080810204080070F7D840F>44 D<FFF0FFF0FFE00C037C8B11>
I<70F8F8F0E005057A840F>I<000FC000106000603800801800801C01001C02201E0210
1E04101E04101E04101E08203C08203C0840380840780880F00700E00001C00003000006
0000180000200000C0000100000200000400100800301000202000605F80C063FFC040FF
80807F00801E0017227CA019>50 D<07000F800F800F000E000000000000000000000000
00000000000000000000007000F800F800F000E00009157A940F>58
D<0000030000000300000007000000070000000F0000000F0000001F0000002F0000002F
0000004F0000004F80000087800000878000010780000207800002078000040780000407
800008078000080780001007800030078000200780007FFF80004007C0008007C0008003
C0010003C0030003C0020003C0040003C0040003C00C0003C03C0007C0FF003FFC1E237D
A224>65 D<00FFFFE0000F0038000F001C000F001E001E000E001E000F001E000F001E00
0F003C000E003C001E003C001E003C003C00780078007800F0007801E00078078000FFFF
8000F001E000F000F000F0007801E0007801E0003801E0003C01E0003C03C0007803C000
7803C0007803C000F0078000F0078001E0078003C0078007000F801E00FFFFF00020227D
A122>I<00007F00800003808100000E00630000380027000070001F0000E0000E0001C0
000E000380000E000700000E000F000004000E000004001E000004003C000004003C0000
0800780000000078000000007800000000F000000000F000000000F000000000F0000000
00F000000000E000000000E000002000E000002000E000004000E000004000F000008000
70000080007000010000380002000018000400001C0008000006003000000381C0000000
FE000000212479A223>I<00FFFFF000000F003C00000F000E00000F000700001E000380
001E000380001E0001C0001E0001C0003C0001C0003C0001E0003C0001E0003C0001E000
780001E000780001E000780001E000780001E000F00003C000F00003C000F00003C000F0
0003C001E000078001E000078001E000070001E0000F0003C0000E0003C0001C0003C000
3C0003C00038000780007000078000E000078001C00007800700000F801C0000FFFFF000
0023227DA125>I<00FFFFFF80000F000780000F000180000F000180001E000180001E00
0180001E000100001E000100003C000100003C000100003C010100003C01000000780200
000078020000007806000000780E000000FFFC000000F00C000000F00C000000F00C0000
01E008000001E008000001E008040001E000080003C000080003C000080003C000100003
C000100007800020000780006000078000C000078001C0000F8007C000FFFFFF80002122
7DA121>I<00FFFFFF000F000F000F0003000F0003001E0003001E0003001E0002001E00
02003C0002003C0002003C0102003C010000780200007802000078060000780E0000FFFC
0000F00C0000F00C0000F00C0001E0080001E0080001E0080001E0000003C0000003C000
0003C0000003C00000078000000780000007800000078000000F800000FFFC000020227D
A120>I<00007F00800003808100000E00630000380027000070001F0000E0000E0001C0
000E000380000E000700000E000F000004000E000004001E000004003C000004003C0000
0800780000000078000000007800000000F000000000F000000000F000000000F0000000
00F0003FFC00E00001E000E00001E000E00001E000E00003C000E00003C000F00003C000
700003C0007000078000380007800018000F80001C0013800006002300000381C1000000
FE000000212479A226>I<00FFF87FFC000F000780000F000780000F000780001E000F00
001E000F00001E000F00001E000F00003C001E00003C001E00003C001E00003C001E0000
78003C000078003C000078003C000078003C0000FFFFF80000F000780000F000780000F0
00780001E000F00001E000F00001E000F00001E000F00003C001E00003C001E00003C001
E00003C001E000078003C000078003C000078003C000078003C0000F8007C000FFF87FFC
0026227DA124>I<00FFF8000F00000F00000F00001E00001E00001E00001E00003C0000
3C00003C00003C0000780000780000780000780000F00000F00000F00000F00001E00001
E00001E00001E00003C00003C00003C00003C0000780000780000780000780000F8000FF
F80015227DA113>I<00FFFC00000F8000000F0000000F0000001E0000001E0000001E00
00001E0000003C0000003C0000003C0000003C0000007800000078000000780000007800
0000F0000000F0000000F0000000F0000001E0000001E0000001E0002001E0002003C000
4003C0004003C0008003C0008007800180078001000780030007800F000F803E00FFFFFE
001B227DA11F>76 D<00FF800007FC000F80000F80000F80001780000F80001780001780
002F000013C0002F000013C0004F000013C0008F000023C0009E000023C0011E000023C0
011E000023C0021E000043C0043C000043C0043C000043C0083C000041E0083C000081E0
1078000081E02078000081E02078000081E04078000101E040F0000101E080F0000101E1
00F0000101E100F0000200F201E0000200F201E0000200F401E0000200F801E0000400F8
03C0000400F003C0000400F003C0000C00E003C0001E00C007C000FFC0C07FFC002E227D
A12C>I<00FF000FFC000F8001E0000F800180000FC000800013C001000013C001000011
E001000011E001000021E002000020F002000020F002000020F002000040780400004078
0400004078040000403C040000803C080000803E080000801E080000801E080001001F10
0001000F100001000F10000100079000020007A000020007A000020003E000020003E000
040003C000040001C000040001C0000C0001C0001E00008000FFC000800026227DA124>
I<00FFFFE0000F0038000F001E000F000E001E0007001E0007001E0007001E0007003C00
0F003C000F003C000F003C001E0078001E0078003C00780078007800E000F003C000FFFE
0000F0000000F0000001E0000001E0000001E0000001E0000003C0000003C0000003C000
0003C00000078000000780000007800000078000000F800000FFF8000020227DA121>80
D<00FFFFC0000F0070000F003C000F001C001E000E001E000E001E000F001E000F003C00
1E003C001E003C001E003C003C0078003800780070007801E00078078000FFFC0000F00E
0000F0070000F0038001E003C001E003C001E003C001E003C003C0078003C0078003C007
8003C0078007800F0007800F0107800F01078007020F800702FFF8038C000000F020237D
A124>82 D<0001F020000E0C40001802C0003001C0006001C000E0018000C0018001C001
8001C0018003C0010003C0010003C0000003C0000003E0000001F8000001FF000000FFE0
00007FF000001FF8000003FC0000007C0000003C0000001E0000001E0000001E0020001C
0020001C0020001C00200018006000380060003000700060007000C000C8018000C60700
0081FC00001B247DA21B>I<1FFFFFF81E03C0381803C0183003C0182007801820078018
4007801040078010400F0010800F0010800F0010000F0000001E0000001E0000001E0000
001E0000003C0000003C0000003C0000003C000000780000007800000078000000780000
00F0000000F0000000F0000000F0000001E0000001E0000001E0000001E0000003E00000
FFFF00001D2277A123>I<3FFE03FF03C0007803C0006003C00020078000400780004007
800040078000400F0000800F0000800F0000800F0000801E0001001E0001001E0001001E
0001003C0002003C0002003C0002003C0002007800040078000400780004007800040070
000800F0000800F00010007000100070002000700040003000400038018000180200000E
0C000003F00000202377A124>I<007FF81FF8000FC007C000078003000007C002000003
C004000003C008000003E010000001E030000001E020000001F040000000F080000000F1
00000000FA000000007C000000007C000000007C000000003C000000003C000000007E00
0000009E000000011E000000031F000000060F000000040F000000080F80000010078000
002007C000004007C00000C003C000018003E000010001E000070001E0001F0003F000FF
C01FFE0025227EA124>88 D<FFF001FF1F8000780F0000600F0000400F8000C007800080
0780010007C0020003C0060003C0040003E0080001E0100001E0200001F0600000F04000
00F0800000F9000000FB0000007A0000007C000000780000007800000078000000780000
00F0000000F0000000F0000000F0000001E0000001E0000001E0000001E0000003E00000
3FFC0000202276A124>I<00F8C00185C00705C00E03800E03801C03803C038038070078
0700780700780700F00E00F00E00F00E00F00E10F01C20701C20703C20305C40308C400F
078014157B9419>97 D<03C03F8003800380038007000700070007000E000E000E000E00
1C001CF81D0C1E0E3C0638073807380F700F700F700F700FE01EE01EE01EE03CE038E038
607060E031C01F0010237BA216>I<007E0001C1000301800703800E07801C07803C0000
380000780000780000780000F00000F00000F00000F00000F00100700100700200300C00
1830000FC00011157B9416>I<00003C0003F80000380000380000380000700000700000
700000700000E00000E00000E00000E00001C000F9C00185C00705C00E03800E03801C03
803C0380380700780700780700780700F00E00F00E00F00E00F00E10F01C20701C20703C
20305C40308C400F078016237BA219>I<00F803840E021C023C0238027804F018FFE0F0
00F000E000E000E000E000E002E0026004701830600F800F157A9416>I<00003E000047
0000CF00018F000186000380000380000380000700000700000700000700000700000E00
00FFF0000E00000E00000E00001C00001C00001C00001C00001C00003800003800003800
00380000380000700000700000700000700000700000E00000E00000E00000E00000C000
01C00001C000718000F18000F300006200003C0000182D82A20F>I<001F180030B800E0
B801C07001C0700380700780700700E00F00E00F00E00F00E01E01C01E01C01E01C01E01
C01E03800E03800E0780060B8006170001E700000700000700000E00000E00000E00701C
00F01800F0300060E0003F8000151F7E9416>I<00F0000FE00000E00000E00000E00001
C00001C00001C00001C000038000038000038000038000070000071F0007218007C0C00F
00E00F00E00E00E00E00E01C01C01C01C01C01C01C01C038038038038038038038070470
0708700E08700E10700610E006206003C016237DA219>I<00C001E001C001C000000000
0000000000000000000000001C002300430043008700870087000E000E001C001C001C00
380038003840708070807080710032001C000B217BA00F>I<00F0000FE00000E00000E0
0000E00001C00001C00001C00001C0000380000380000380000380000700000701E00702
10070C700E10F00E10F00E20600E40001D80001E00001FC0001C7000383800383800381C
00381C20703840703840703840701880E01880600F0014237DA216>107
D<01E01FC001C001C001C0038003800380038007000700070007000E000E000E000E001C
001C001C001C0038003800380038007000700070007100E200E200E200E200640038000B
237CA20C>I<1C0F80F8002610C10C004760660600878078070087807807008700700700
87007007000E00E00E000E00E00E000E00E00E000E00E00E001C01C01C001C01C01C001C
01C01C001C01C03820380380384038038070403803807080380380308070070031003003
001E0023157B9428>I<1C0F002631C04740C08780E08780E08700E08700E00E01C00E01
C00E01C00E01C01C03801C03801C03801C0704380708380E08380E103806107006203003
C016157B941B>I<007E0001C3000381800701C00E01C01C01E03C01E03801E07801E078
01E07801E0F003C0F003C0F00380F00780700700700E00700C0030180018700007C00013
157B9419>I<01C1F002621804741C08780C08700E08700E08701E00E01E00E01E00E01E
00E01E01C03C01C03C01C03C01C07803807003807003C0E003C1C0072380071E00070000
0700000E00000E00000E00000E00001C00001C00001C0000FFC000171F7F9419>I<00F8
400184C00705C00E03800E03801C03803C0380380700780700780700780700F00E00F00E
00F00E00F00E00F01C00701C00703C00305C0030B8000F38000038000038000070000070
0000700000700000E00000E00000E0000FFE00121F7B9416>I<1C1F002620804741C087
83C08703C08701808700000E00000E00000E00000E00001C00001C00001C00001C000038
000038000038000038000070000030000012157B9415>I<00FC00018300020080040180
0C03800C03000C00000F00000FF00007FC0003FE00003E00000F00000700700700F00600
F00600E004004008002030001FC00011157D9414>I<00C001C001C001C001C003800380
038003800700FFF8070007000E000E000E000E001C001C001C001C003800380038003810
702070207040708031001E000D1F7C9E10>I<1E00602300E04380E04381C08381C08701
C08701C00703800E03800E03800E03801C07001C07001C07001C07081C0E10180E101C0E
101C1E200C262007C3C015157B941A>I<1E03802307C04387C04383C08381C08700C087
00C00700800E00800E00800E00801C01001C01001C01001C02001C02001C04001C08001C
08000C300003C00012157B9416>I<03C1E0046210083470103CF02038F0203860203800
00700000700000700000700000E00000E00000E00000E02061C040F1C040F1C080E2C100
446200383C0014157D9416>120 D<1E00302300704380704380E08380E08700E08700E0
0701C00E01C00E01C00E01C01C03801C03801C03801C03801C07001C07001C07001C0F00
0C3E0003CE00000E00000E00001C00601C00F03800F03000E0600080C0004380003E0000
141F7B9418>I<01E02003F06007F8C0041F800801000802000004000008000010000020
000040000080000100000200000400800801001003003F060061FC0040F8008070001315
7D9414>I<FFFFFC16017C8C19>I E /Fh 4 53 df<03000700FF00070007000700070007
000700070007000700070007000700070007000700070007007FF00C157E9412>49
D<0F8030E040708030C038E0384038003800700070006000C00180030006000C08080810
183FF07FF0FFF00D157E9412>I<0FE030306018701C701C001C00180038006007E00030
0018000C000E000EE00EE00EC00C401830300FE00F157F9412>I<00300030007000F001
F001700270047008701870107020704070C070FFFE0070007000700070007003FE0F157F
9412>I E /Fi 8 116 df<70F8F8F87005057C840E>58 D<0000001800000078000001E0
0000078000001E00000078000003E000000F8000003C000000F0000003C000000F000000
3C000000F0000000F00000003C0000000F00000003C0000000F00000003C0000000F8000
0003E0000000780000001E0000000780000001E000000078000000181D1C7C9926>60
D<C0000000F00000003C0000000F00000003C0000000F00000003E0000000F80000001E0
000000780000001E0000000780000001E00000007800000078000001E00000078000001E
00000078000001E000000F8000003E000000F0000003C000000F0000003C000000F00000
00C00000001D1C7C9926>62 D<007FC003FF0007C000780007C000600005E000200009E0
00400009E000400008F000400008F000400010F800800010780080001078008000103C00
8000203C010000203E010000201E010000201E010000400F020000400F020000400F0200
00400782000080078400008007C400008003C400008003C400010001E800010001E80001
0001F800010000F800020000F0000200007000020000700006000070000F00002000FFE0
00200028227EA127>78 D<007FFFE0000007803C000007800E000007800700000F000780
000F000380000F0003C0000F0003C0001E000780001E000780001E000780001E000F0000
3C001E00003C003C00003C007000003C01C000007FFE00000078078000007801C0000078
01E00000F000F00000F000F00000F000F00000F000F00001E001E00001E001E00001E001
E00001E001E00003C003C00003C003C04003C003C04003C001C08007C001C080FFFC00E3
000000003C0022237EA125>82 D<00786001C4E00302E00601C00E01C01C01C03C01C038
0380780380780380780380F00700F00700F00700F00708F00E10700E10701E1030262018
C6200F01C015157E941A>97 D<003E0000C1800380C00700E00E00E01C00F03C00F03C00
F07800F07800F07800F0F001E0F001E0F001C0F003C0700380700700700600381C001C38
0007E00014157E9417>111 D<007E000081000300800201800603800603000600000700
0007F80003FE0001FF00003F00000780000380700380F00300F00300E002004004003018
000FE00011157E9417>115 D E /Fj 56 123 df<000FF000007FFC0001F80E0003E01F
0007C03F000F803F000F803F000F801E000F800C000F8000000F8000000F8000000F8000
00FFFFFF00FFFFFF000F801F000F801F000F801F000F801F000F801F000F801F000F801F
000F801F000F801F000F801F000F801F000F801F000F801F000F801F000F801F000F801F
000F801F000F801F007FF0FFE07FF0FFE01B237FA21F>12 D<387CFEFFFF7F3B03030706
060C1C18702008117CA210>39 D<387CFEFFFF7F3B03030706060C1C18702008117C8610
>44 D<FFFCFFFCFFFCFFFC0E047F8C13>I<387CFEFEFE7C3807077C8610>I<00FE0007FF
C00F83E01F01F03E00F83E00F87C007C7C007C7C007CFC007CFC007EFC007EFC007EFC00
7EFC007EFC007EFC007EFC007EFC007EFC007EFC007EFC007EFC007E7C007C7C007C7C00
7C3E00F83E00F81F01F00F83E007FFC000FE0017207E9F1C>48 D<00180000780001F800
FFF800FFF80001F80001F80001F80001F80001F80001F80001F80001F80001F80001F800
01F80001F80001F80001F80001F80001F80001F80001F80001F80001F80001F80001F800
01F80001F80001F8007FFFE07FFFE013207C9F1C>I<03FC000FFF003C1FC07007E07C07
F0FE03F0FE03F8FE03F8FE01F87C01F83803F80003F80003F00003F00007E00007C0000F
80001F00003E0000380000700000E01801C0180380180700180E00380FFFF01FFFF03FFF
F07FFFF0FFFFF0FFFFF015207D9F1C>I<00FE0007FFC00F07E01E03F03F03F03F81F83F
81F83F81F81F03F81F03F00003F00003E00007C0001F8001FE0001FF000007C00001F000
01F80000FC0000FC3C00FE7E00FEFF00FEFF00FEFF00FEFF00FC7E01FC7801F81E07F00F
FFC001FE0017207E9F1C>I<0000E00001E00003E00003E00007E0000FE0001FE0001FE0
0037E00077E000E7E001C7E00187E00307E00707E00E07E00C07E01807E03807E07007E0
E007E0FFFFFEFFFFFE0007E00007E00007E00007E00007E00007E00007E000FFFE00FFFE
17207E9F1C>I<1000201E01E01FFFC01FFF801FFF001FFE001FF8001BC0001800001800
0018000018000019FC001FFF001E0FC01807E01803E00003F00003F00003F80003F83803
F87C03F8FE03F8FE03F8FC03F0FC03F07007E03007C01C1F800FFF0003F80015207D9F1C
>I<001F8000FFE003F07007C0F00F01F81F01F83E01F83E01F87E00F07C00007C0000FC
0800FC7FC0FCFFE0FD80F0FF00F8FE007CFE007CFC007EFC007EFC007EFC007E7C007E7C
007E7C007E3C007C3E007C1E00F80F00F00783E003FFC000FF0017207E9F1C>I<600000
7800007FFFFE7FFFFE7FFFFC7FFFF87FFFF87FFFF0E00060E000C0C00180C00300C00300
000600000C00001C0000180000380000780000780000F00000F00000F00001F00001F000
01F00003F00003F00003F00003F00003F00003F00003F00001E00017227DA11C>I<00FE
0003FFC00703E00E00F01C00F01C00783C00783E00783F00783F80783FE0F01FF9E01FFF
C00FFF8007FFC003FFE007FFF01E7FF83C1FFC7807FC7801FEF000FEF0003EF0001EF000
1EF0001CF8001C7800383C00381F01F00FFFC001FF0017207E9F1C>I<01FE0007FF800F
83E01E01F03E00F07C00F87C0078FC007CFC007CFC007CFC007EFC007EFC007EFC007E7C
00FE7C00FE3E01FE1E037E0FFE7E07FC7E00207E00007C00007C1E007C3F00F83F00F83F
00F03F01E01E03C01C0F800FFE0003F80017207E9F1C>I<387CFEFEFE7C380000000000
000000387CFEFEFE7C3807167C9510>I<000070000000007000000000F800000000F800
000000F800000001FC00000001FC00000003FE00000003FE00000003FE00000006FF0000
00067F0000000E7F8000000C3F8000000C3F800000183FC00000181FC00000381FE00000
300FE00000300FE00000600FF000006007F00000E007F80000FFFFF80000FFFFF8000180
01FC00018001FC00038001FE00030000FE00030000FE000600007F000600007F00FFE00F
FFF8FFE00FFFF825227EA12A>65 D<FFFFFF8000FFFFFFE00007F001F80007F000FC0007
F0007E0007F0007E0007F0007F0007F0007F0007F0007F0007F0007F0007F0007F0007F0
007E0007F000FE0007F000FC0007F003F80007FFFFF00007FFFFF00007F001FC0007F000
7E0007F0003F0007F0003F8007F0001F8007F0001FC007F0001FC007F0001FC007F0001F
C007F0001FC007F0001FC007F0003F8007F0003F8007F0007F0007F001FE00FFFFFFF800
FFFFFFC00022227EA128>I<0003FE0080001FFF818000FF01E38001F8003F8003E0001F
8007C0000F800F800007801F800007803F000003803F000003807F000001807E00000180
7E00000180FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE
00000000FE000000007E000000007E000001807F000001803F000001803F000003801F80
0003000F8000030007C000060003F0000C0001F800380000FF00F000001FFFC0000003FE
000021227DA128>I<FFFFFF8000FFFFFFF00007F003FC0007F0007E0007F0003F0007F0
001F8007F0000FC007F00007E007F00007E007F00007F007F00003F007F00003F007F000
03F007F00003F807F00003F807F00003F807F00003F807F00003F807F00003F807F00003
F807F00003F807F00003F807F00003F007F00003F007F00003F007F00007E007F00007E0
07F0000FC007F0001F8007F0003F0007F0007E0007F003FC00FFFFFFF000FFFFFF800025
227EA12B>I<FFFFFFFCFFFFFFFC07F000FC07F0003C07F0001C07F0000C07F0000E07F0
000E07F0000607F0180607F0180607F0180607F0180007F0380007F0780007FFF80007FF
F80007F0780007F0380007F0180007F0180007F0180307F0180307F0000307F0000607F0
000607F0000607F0000E07F0000E07F0001E07F0003E07F001FCFFFFFFFCFFFFFFFC2022
7EA125>I<FFFFFFF8FFFFFFF807F001F807F0007807F0003807F0001807F0001C07F000
1C07F0000C07F0000C07F0180C07F0180C07F0180007F0180007F0380007F0780007FFF8
0007FFF80007F0780007F0380007F0180007F0180007F0180007F0180007F0000007F000
0007F0000007F0000007F0000007F0000007F0000007F00000FFFFE000FFFFE0001E227E
A123>I<0003FE0040001FFFC0C0007F00F1C001F8003FC003F0000FC007C00007C00FC0
0003C01F800003C03F000001C03F000001C07F000000C07E000000C07E000000C0FE0000
0000FE00000000FE00000000FE00000000FE00000000FE00000000FE00000000FE000FFF
FC7E000FFFFC7F00001FC07F00001FC03F00001FC03F00001FC01F80001FC00FC0001FC0
07E0001FC003F0001FC001FC003FC0007F80E7C0001FFFC3C00003FF00C026227DA12C>
I<FFFFE0FFFFE003F80003F80003F80003F80003F80003F80003F80003F80003F80003F8
0003F80003F80003F80003F80003F80003F80003F80003F80003F80003F80003F80003F8
0003F80003F80003F80003F80003F80003F80003F80003F800FFFFE0FFFFE013227FA115
>73 D<FFFFE000FFFFE00007F0000007F0000007F0000007F0000007F0000007F0000007
F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007
F0000007F0000007F0000007F0000007F0001807F0001807F0001807F0001807F0003807
F0003807F0007007F0007007F000F007F001F007F007F0FFFFFFF0FFFFFFF01D227EA122
>76 D<FFF000000FFFFFF800001FFF07F800001FE006FC000037E006FC000037E006FC00
0037E0067E000067E0067E000067E0063F0000C7E0063F0000C7E0061F800187E0061F80
0187E0060FC00307E0060FC00307E0060FC00307E00607E00607E00607E00607E00603F0
0C07E00603F00C07E00601F81807E00601F81807E00601F81807E00600FC3007E00600FC
3007E006007E6007E006007E6007E006003FC007E006003FC007E006001F8007E006001F
8007E006001F8007E006000F0007E0FFF00F00FFFFFFF00600FFFF30227EA135>I<0007
FC0000003FFF800000FC07E00003F001F80007E000FC000FC0007E001F80003F001F8000
3F003F00001F803F00001F807F00001FC07E00000FC07E00000FC0FE00000FE0FE00000F
E0FE00000FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE0FE00000FE0
7E00000FC07F00001FC07F00001FC03F00001F803F80003F801F80003F000FC0007E0007
E000FC0003F001F80000FC07E000003FFF80000007FC000023227DA12A>79
D<FFFFFF00FFFFFFE007F007F007F001FC07F000FC07F0007E07F0007E07F0007F07F000
7F07F0007F07F0007F07F0007F07F0007E07F0007E07F000FC07F001FC07F007F007FFFF
E007FFFF0007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F000
0007F0000007F0000007F0000007F0000007F00000FFFF8000FFFF800020227EA126>I<
FFFFFE0000FFFFFFC00007F007F00007F001F80007F000FC0007F0007E0007F0007F0007
F0007F0007F0007F0007F0007F0007F0007F0007F0007F0007F0007E0007F000FC0007F0
01F80007F007F00007FFFFC00007FFFF800007F00FE00007F007F00007F003F80007F001
FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC0007F001FC
0007F001FC0607F000FE0607F000FF0CFFFF803FF8FFFF800FF027227EA12A>82
D<01FC0407FF8C1F03FC3C007C7C003C78001C78001CF8000CF8000CFC000CFC0000FF00
00FFE0007FFF007FFFC03FFFF01FFFF80FFFFC03FFFE003FFE0003FF00007F00003F0000
3FC0001FC0001FC0001FE0001EE0001EF0003CFC003CFF00F8C7FFE080FF8018227DA11F
>I<7FFFFFFF807FFFFFFF807E03F80F807803F807807003F803806003F80180E003F801
C0E003F801C0C003F800C0C003F800C0C003F800C0C003F800C00003F800000003F80000
0003F800000003F800000003F800000003F800000003F800000003F800000003F8000000
03F800000003F800000003F800000003F800000003F800000003F800000003F800000003
F800000003F800000003F800000003F8000003FFFFF80003FFFFF80022227EA127>I<FF
FF803FFCFFFF803FFC07F000018007F000018007F000018007F000018007F000018007F0
00018007F000018007F000018007F000018007F000018007F000018007F000018007F000
018007F000018007F000018007F000018007F000018007F000018007F000018007F00001
8007F000018007F000018007F000018007F000018003F000030003F800030001F8000600
00FC000E00007E001C00003F80F800000FFFE0000001FF000026227EA12B>I<07FC001F
FF803F07C03F03E03F01E03F01F01E01F00001F00001F0003FF003FDF01FC1F03F01F07E
01F0FC01F0FC01F0FC01F0FC01F07E02F07E0CF81FF87F07E03F18167E951B>97
D<FF000000FF0000001F0000001F0000001F0000001F0000001F0000001F0000001F0000
001F0000001F0000001F0000001F0000001F0FE0001F3FF8001FF07C001F801E001F001F
001F000F801F000F801F000FC01F000FC01F000FC01F000FC01F000FC01F000FC01F000F
C01F000FC01F000F801F001F801F801F001FC03E001EE07C001C3FF800180FC0001A237E
A21F>I<00FF8007FFE00F83F01F03F03E03F07E03F07C01E07C0000FC0000FC0000FC00
00FC0000FC0000FC00007C00007E00007E00003E00301F00600FC0E007FF8000FE001416
7E9519>I<0001FE000001FE0000003E0000003E0000003E0000003E0000003E0000003E
0000003E0000003E0000003E0000003E0000003E0001FC3E0007FFBE000F81FE001F007E
003E003E007E003E007C003E00FC003E00FC003E00FC003E00FC003E00FC003E00FC003E
00FC003E00FC003E007C003E007C003E003E007E001E00FE000F83BE0007FF3FC001FC3F
C01A237EA21F>I<00FE0007FF800F87C01E01E03E01F07C00F07C00F8FC00F8FC00F8FF
FFF8FFFFF8FC0000FC0000FC00007C00007C00007E00003E00181F00300FC07003FFC000
FF0015167E951A>I<003F8000FFC001E3E003C7E007C7E00F87E00F83C00F80000F8000
0F80000F80000F80000F8000FFFC00FFFC000F80000F80000F80000F80000F80000F8000
0F80000F80000F80000F80000F80000F80000F80000F80000F80000F80000F80000F8000
7FF8007FF80013237FA211>I<03FC1E0FFF7F1F0F8F3E07CF3C03C07C03E07C03E07C03
E07C03E07C03E03C03C03E07C01F0F801FFF0013FC003000003000003800003FFF801FFF
F00FFFF81FFFFC3800FC70003EF0001EF0001EF0001EF0001E78003C7C007C3F01F80FFF
E001FF0018217E951C>I<FF000000FF0000001F0000001F0000001F0000001F0000001F
0000001F0000001F0000001F0000001F0000001F0000001F0000001F07E0001F1FF8001F
307C001F403C001F803E001F803E001F003E001F003E001F003E001F003E001F003E001F
003E001F003E001F003E001F003E001F003E001F003E001F003E001F003E001F003E00FF
E1FFC0FFE1FFC01A237EA21F>I<1C003F007F007F007F003F001C000000000000000000
000000000000FF00FF001F001F001F001F001F001F001F001F001F001F001F001F001F00
1F001F001F001F001F00FFE0FFE00B247EA310>I<FF000000FF0000001F0000001F0000
001F0000001F0000001F0000001F0000001F0000001F0000001F0000001F0000001F0000
001F00FF801F00FF801F0038001F0060001F01C0001F0380001F0700001F0E00001F1C00
001F7E00001FFF00001FCF00001F0F80001F07C0001F03E0001F01E0001F01F0001F00F8
001F007C001F003C00FFE0FFC0FFE0FFC01A237EA21E>107 D<FF00FF001F001F001F00
1F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F00
1F001F001F001F001F001F001F001F001F001F00FFE0FFE00B237EA210>I<FF07F007F0
00FF1FFC1FFC001F303E303E001F403E403E001F801F801F001F801F801F001F001F001F
001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F
001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F001F
001F001F001F00FFE0FFE0FFE0FFE0FFE0FFE02B167E9530>I<FF07E000FF1FF8001F30
7C001F403C001F803E001F803E001F003E001F003E001F003E001F003E001F003E001F00
3E001F003E001F003E001F003E001F003E001F003E001F003E001F003E001F003E00FFE1
FFC0FFE1FFC01A167E951F>I<00FE0007FFC00F83E01E00F03E00F87C007C7C007C7C00
7CFC007EFC007EFC007EFC007EFC007EFC007EFC007E7C007C7C007C3E00F81F01F00F83
E007FFC000FE0017167E951C>I<FF0FE000FF3FF8001FF07C001F803E001F001F001F00
1F801F001F801F000FC01F000FC01F000FC01F000FC01F000FC01F000FC01F000FC01F00
0FC01F001F801F001F801F803F001FC03E001FE0FC001F3FF8001F0FC0001F0000001F00
00001F0000001F0000001F0000001F0000001F0000001F000000FFE00000FFE000001A20
7E951F>I<FE1F00FE3FC01E67E01EC7E01E87E01E87E01F83C01F00001F00001F00001F
00001F00001F00001F00001F00001F00001F00001F00001F00001F0000FFF000FFF00013
167E9517>114 D<0FF3003FFF00781F00600700E00300E00300F00300FC00007FE0007F
F8003FFE000FFF0001FF00000F80C00780C00380E00380E00380F00700FC0E00EFFC00C7
F00011167E9516>I<0180000180000180000180000380000380000780000780000F8000
3F8000FFFF00FFFF000F80000F80000F80000F80000F80000F80000F80000F80000F8000
0F80000F80000F81800F81800F81800F81800F81800F830007C30003FE0000F80011207F
9F16>I<FF01FE00FF01FE001F003E001F003E001F003E001F003E001F003E001F003E00
1F003E001F003E001F003E001F003E001F003E001F003E001F003E001F003E001F003E00
1F007E001F00FE000F81BE0007FF3FC001FC3FC01A167E951F>I<FFE01FE0FFE01FE00F
8006000F8006000FC00E0007C00C0007E01C0003E0180003E0180001F0300001F0300000
F8600000F86000007CC000007CC000007FC000003F8000003F8000001F0000001F000000
0E0000000E00001B167F951E>I<FFE7FF07F8FFE7FF07F81F007800C00F807801800F80
7C01800F807C018007C07E030007C0DE030007E0DE070003E0DF060003E18F060001F18F
0C0001F38F8C0001FB079C0000FB07D80000FE03D800007E03F000007E03F000007C01F0
00003C01E000003800E000001800C00025167F9528>I<FFE07FC0FFE07FC00F801C0007
C0380003E0700003F0600001F8C00000F98000007F8000003F0000001F0000001F800000
3FC0000037C0000063E00000C1F00001C0F8000380FC0007007E000E003E00FF80FFE0FF
80FFE01B167F951E>I<FFE01FE0FFE01FE00F8006000F8006000FC00E0007C00C0007E0
1C0003E0180003E0180001F0300001F0300000F8600000F86000007CC000007CC000007F
C000003F8000003F8000001F0000001F0000000E0000000E0000000C0000000C00000018
000078180000FC380000FC300000FC60000069C000007F8000001F0000001B207F951E>
I<7FFFF07FFFF07C03E07007C0600FC0E01F80C01F00C03E00C07E0000FC0000F80001F0
0003F03007E03007C0300F80701F80703F00603E00E07C03E0FFFFE0FFFFE014167E9519
>I E /Fk 35 91 df<FFE0FFE00B027D8B10>45 D<003F0000E1800180C00300E0070060
0E00700E00701E00701C00703C00703C00703C00703800F07800F07800F07800F07800F0
7800F0F001E0F001E0F001E0F001E0F001E0F003C0F003C0F00380E00380E00780700700
700E00700E00381C001C700007C00014227CA018>48 D<0004000C007C079C001C001C00
380038003800380038003800700070007000700070007000E000E000E000E000E000E001
C001C001C001C001C001C003C003C0FFFE0F217CA018>I<001FC000607000803801003C
02003C04001E04001E0F001E0F801E0F801E0F003E06003C00003C0000780000780000F0
0001E00001C0000380000700000E0000180000300000600000C000018010030010040010
0800201000203FFFE07FFFC0FFFFC017217EA018>I<001F8000E0E00100700200780400
780780780F80780F80780700F80000F00000F00001E00001C0000380000E0000FC000007
000003800003C00001E00001E00001E00001F03001F07803E0F803E0F803E0F003C08007
C0400780400F00200E00183C0007E00015227DA018>I<0000400000C00001C00001C000
03C00005C0000F80000B8000138000238000438000C38000870001070002070006070004
0700080700100E00300E00200E00400E00800E00FFFFF8001C00001C00001C00001C0000
1C00001C00003800003C0007FFC015217DA018>I<00800801E03801FFF001FFE001FF80
017E00010000020000020000020000020000020000023E0004C3800501C00600C00400E0
0000E00000F00000F00000F00000F00000F07000F0F801E0F001E0E001E08001C0400380
400780400700200C0018380007E00015227DA018>I<0007C000183000601000C0380180
780380780700700E00000E00001C00001C00003C00003C7C003987007A03807C01807C01
C07801C0F801E0F801E0F001E0F001E0F001E0F001E0F003C0F003C0E003C0E003807007
00700700300E00381C001C300007C00015227CA018>I<1000003800003FFFF03FFFE03F
FFE060004040008040010080020080020000040000080000100000200000200000400000
C00000C0000180000180000380000300000700000700000F00000F00000E00001E00001E
00001E00001E00003C00003C00003C0000180000142379A118>I<001F800060E0008030
0100180200180600180400180C00180E00180E00180F00300F806007C0C007F18003FE00
00FC0000FF00033F80060FC00C07E01803E03000E06000E0600070C00060C00060C00060
C00040C000C06000806001003002001C1C0007E00015227DA018>I<003F0000E1800180
C00300E00700600E00701E00701C00703C00703C00703C00703C00F07800F07800F07800
F03801F03801F03801F01C03E00C05E00619E003E1E00001C00003C00003800003800007
00600600F00E00F01C00E0380080700040C0003F000014227CA018>I<060F1F1F0E0000
0000000000000000003078F8787008157C940E>I<0000040000000006000000000E0000
00001E000000001E000000003E000000003F000000004F000000004F000000008F000000
008F000000010F0000000107800000020780000002078000000407800000040780000008
07C000000803C000001003C000001003C000002003C000003FFFE000004001E000004001
E000008001E000008001E000010001E000010000F000020000F000060000F000040000F0
000C0000F0003E0001F800FF800FFF8021237EA225>65 D<03FFFFE0003E0078003C003C
003C001E003C001F003C000F003C000F0078000F0078001F0078001F0078001F0078003E
0078003C00F0007800F001F000F007C000FFFFC000F001F000F000F801E0007801E0007C
01E0003C01E0003E01E0003E01E0003E03C0003C03C0007C03C0007C03C000F803C000F0
03C001E0078003C007C00F80FFFFFC0020227EA123>I<0001FC02000F0306003C008C00
70005C00E0003C01C0003C0380001C0700001C0F0000181E0000181E0000083E0000083C
0000087C0000087C000000F8000000F8000000F8000000F8000000F8000000F0000000F0
000000F0000000F0000020F0000020F0000040F80000407800004078000080380001003C
0001001C0002000E000C000700100001C0E000003F00001F247AA223>I<03FFFFC00000
3E00F000003C003C00003C001E00003C000E00003C000F00003C00078000780007800078
00078000780007C000780003C000780003C000780007C000F00007C000F00007C000F000
07C000F00007C000F00007C000F00007C001E0000F8001E0000F8001E0000F8001E0000F
0001E0001F0001E0001E0003C0001E0003C0003C0003C000780003C000700003C000E000
03C001C000078007800007C01E0000FFFFF8000022227EA125>I<03FFFFFF003E001F00
3C000E003C0006003C0002003C0002003C00020078000200780002007800020078020200
7802000078060000F0040000F0040000F01C0000FFFC0000F01C0000F00C0001E0080001
E0080001E0080001E0080201E0000401E0000403C0000403C0000803C0000803C0001803
C0001003C00030078000F007C003E0FFFFFFE020227EA121>I<03FFFFFF003E001F003C
000E003C0006003C0002003C0002003C0002007800020078000200780002007802020078
02000078060000F0040000F0040000F01C0000FFFC0000F01C0000F00C0001E0080001E0
080001E0080001E0080001E0000001E0000003C0000003C0000003C0000003C0000003C0
000003C0000007C0000007C00000FFFE000020227EA120>I<0000FE0100070183001C00
460070002E00E0001E01C0001E0380000E0780000E0F00000C1E00000C1E0000043E0000
043C0000047C0000047C000000F8000000F8000000F8000000F8000000F8000000F00000
00F0003FFFF00001F0F00000F0F00000F0F00000F0F80001E0780001E0780001E0380001
E01C0001E00E0003E0060004C0038008C001E07040003F800020247AA226>I<03FFE0FF
F8003E000F80003C000F00003C000F00003C000F00003C000F00003C000F000078001E00
0078001E000078001E000078001E000078001E000078001E0000F0003C0000F0003C0000
F0003C0000FFFFFC0000F0003C0000F0003C0001E000780001E000780001E000780001E0
00780001E000780001E000780003C000F00003C000F00003C000F00003C000F00003C000
F00003C000F000078001E00007C001F000FFFC3FFF0025227EA125>I<03FFF0003E0000
3C00003C00003C00003C00003C0000780000780000780000780000780000780000F00000
F00000F00000F00000F00000F00001E00001E00001E00001E00001E00001E00003C00003
C00003C00003C00003C00003C00007800007C000FFFC0014227EA112>I<03FFF000003E
0000003C0000003C0000003C0000003C0000003C00000078000000780000007800000078
0000007800000078000000F0000000F0000000F0000000F0000000F0000000F0000001E0
000001E0000001E0000001E0002001E0002001E0004003C0004003C0004003C000C003C0
008003C0018003C003800780078007C01F00FFFFFF001B227EA11E>76
D<03FE00000FF8003E00001F80002F00001F00002F00002F00002F00002F00002F00004F
00002F00004F00004780009E00004780009E00004780011E00004780011E00004780021E
000043C0041E000083C0043C000083C0083C000083C0083C000083C0103C000081E0103C
000081E0203C000101E02078000101E04078000101E04078000100F08078000100F08078
000100F10078000200F100F0000200F200F00002007C00F00002007C00F00002007800F0
0006007800F00006007001E0001F003001F000FFE0203FFF002D227EA12D>I<03FE001F
F8003E0003C0003F000180002F000100002F80010000278001000027C001000043C00200
0043C002000041E002000041E002000040F002000040F002000080780400008078040000
803C040000803C040000801E040000801E040001000F080001000F080001000F88000100
078800010007C800010003C800020003D000020001F000020001F000020000F000020000
F000060000700006000060001F00002000FFE000200025227EA125>I<0001FC00000E07
00003801C0007000E001E000F003C00078078000780700003C0F00003C1E00003C1E0000
3E3C00003E3C00003E7C00003E7C00003EF800003EF800003EF800003EF800003EF80000
3EF800007CF000007CF000007CF00000F8F00000F8F80000F0F80001F0780001E0780003
C0780007803C0007001C000E000E001C000700780003C1E000007F00001F247AA226>I<
03FFFFC0003E00F0003C0078003C003C003C003E003C001E003C003E0078003E0078003E
0078003E0078003E0078003C0078007C00F0007800F000F000F001E000F0078000FFFE00
00F0000001E0000001E0000001E0000001E0000001E0000001E0000003C0000003C00000
03C0000003C0000003C0000003C000000780000007C00000FFFC00001F227EA121>I<03
FFFF0000003E01E000003C007800003C003C00003C003C00003C003E00003C003E000078
003E000078003E000078003E000078003E000078007C00007800780000F000F00000F001
E00000F007800000FFFC000000F00C000000F007000001E007000001E003800001E00380
0001E003C00001E003C00001E003C00003C007C00003C007C00003C007C00003C007C000
03C007C04003C007C080078007C08007C003E100FFFC01E3000000007C0022237EA124>
82 D<000FC0800030318000C00B0001800700038007000300030007000300070003000E
0002000E0002000F0002000F0000000F0000000F80000007E0000007FE000003FFC00001
FFE000007FF000000FF8000000F8000000780000003C0000003C0000003C0020003C0040
0038004000380040003800600030006000700060006000F000C000E8018000C607000081
FC000019247DA21B>I<1FFFFFFE3C03E03E3803C00C3003C0042003C0046003C0044003
C00440078004C007800480078004800780040007800000078000000F0000000F0000000F
0000000F0000000F0000000F0000001E0000001E0000001E0000001E0000001E0000001E
0000003C0000003C0000003C0000003C0000003C0000003C0000007C000000FC00003FFF
F0001F227AA123>I<FFF807FE0F8000F00F0000600F0000400F0000400F0000400F0000
401E0000801E0000801E0000801E0000801E0000801E0000803C0001003C0001003C0001
003C0001003C0001003C0001007800020078000200780002007800020078000200780004
007800040078000400780008007800080038001000380020001C0040000E008000070300
0000FC00001F2378A125>I<FFF8007FE00FC0001F000F80000E000780000C0007800008
000780001000078000100007C000200003C000200003C000400003C000400003C0008000
01E000800001E001000001E003000001E002000001F004000000F004000000F008000000
F008000000F010000000F81000000078200000007820000000784000000078C00000007C
800000003D000000003D000000003E000000003E000000001C000000001C000000001800
0000001800000023237AA125>I<FFF83FFC03FF1F8007E000F80F0003C000700F0003C0
00200F0003C000600F8003E00040078001E00040078003E00080078003E00080078005E0
0100078005E00100078009E0020007C009F0020003C010F0040003C010F0040003C020F0
080003C020F0080003C040F0100003C040F0100001E08078200001E08078200001E10078
400001E10078400001E20078800001E20078800001E40079000000F4003D000000F8003E
000000F8003E000000F8003C000000F0003C000000F0003C000000E00038000000600018
000000400010000030237AA132>I<03FFE01FF8003F800FC0001F000700001F00060000
0F000400000F80080000078010000007C020000003C060000003E040000001E080000001
F100000000F200000000FC000000007C000000007C000000003C000000003E000000005E
000000009F000000010F000000030F80000002078000000407C000000803C000001003E0
00002001E000006001F000004000F000008000F80001000078000300007C001F8000FC00
FFE007FFC025227FA125>I<FFF8003FE00FC0001F000F80000C00078000080007C00010
0003C000100003E000200001E000400001F000800000F001800000F001000000F8020000
0078040000007C0C0000003C080000003E100000001E200000001F400000001FC0000000
0F800000000F000000000F000000000F000000000F000000000E000000001E000000001E
000000001E000000001E000000001E000000001C000000003C000000003E00000007FFE0
000023227AA125>I<01FFFFF803F000F003C001E0038003C0030003C00600078004000F
0004001E000C001E0008003C00080078000000F0000000F0000001E0000003C0000007C0
0000078000000F0000001E0000003E0000003C00000078004000F0004001F0004001E000
8003C00080078000800F8001800F0001001E0003003C0007007C001F0078007E00FFFFFE
001D227DA11E>I E /Fl 1 14 df<0001FE0000000FFFC000003E01F00000F0003C0001
C0000E00038000070007000003800E000001C00C000000C01C000000E038000000703000
0000303000000030700000003860000000186000000018E00000001CC00000000CC00000
000CC00000000CC00000000CC00000000CC00000000CC00000000CC00000000CC0000000
0CE00000001C600000001860000000187000000038300000003030000000303800000070
1C000000E00C000000C00E000001C00700000380038000070001C0000E0000F0003C0000
3E01F000000FFFC0000001FE0000262B7DA02D>13 D E /Fm 25
122 df<001F83E000F06E3001C078780380F8780300F030070070000700700007007000
07007000070070000700700007007000FFFFFF8007007000070070000700700007007000
070070000700700007007000070070000700700007007000070070000700700007007000
07007000070070000700700007007000070070007FE3FF001D20809F1B>11
D<70F8FCFC74040404080810102040060E7C840D>44 D<70F8F8F87005057C840D>46
D<018003800F80F380038003800380038003800380038003800380038003800380038003
80038003800380038003800380038003800380038007C0FFFE0F1E7C9D17>49
D<03F0000C1C00100E00200700400780800780F007C0F803C0F803C0F803C02007C00007
C0000780000780000F00000E00001C0000380000700000600000C0000180000300000600
400C00401800401000803FFF807FFF80FFFF80121E7E9D17>I<03F0000C1C00100E0020
0F00780F80780780780780380F80000F80000F00000F00000E00001C0000380003F00000
3C00000E00000F000007800007800007C02007C0F807C0F807C0F807C0F0078040078040
0F00200E001C3C0003F000121F7E9D17>I<000600000600000E00000E00001E00002E00
002E00004E00008E00008E00010E00020E00020E00040E00080E00080E00100E00200E00
200E00400E00C00E00FFFFF0000E00000E00000E00000E00000E00000E00000E0000FFE0
141E7F9D17>I<03F0000E18001C0C00380600380700700700700380F00380F00380F003
C0F003C0F003C0F003C0F003C07007C07007C03807C0180BC00E13C003E3C00003800003
80000380000700300700780600780E00700C002018001070000FC000121F7E9D17>57
D<FFFFE0000F80380007801E0007801F0007800F0007800F8007800F8007800F8007800F
8007800F8007800F0007801F0007801E0007803C0007FFF00007803C0007801E0007800F
0007800F8007800780078007C0078007C0078007C0078007C0078007C00780078007800F
8007800F0007801F000F803C00FFFFF0001A1F7E9E20>66 D<FFFC0FFC0FC003E0078001
800780010007800200078004000780080007801000078020000780400007808000078100
000783000007878000078F80000793C0000791E00007A1E00007C0F0000780F000078078
0007803C0007803C0007801E0007801E0007800F000780078007800780078007C00FC007
E0FFFC3FFC1E1F7E9E23>75 D<FF80001FF80F80001F800780001F0005C0002F0005C000
2F0005C0002F0004E0004F0004E0004F000470008F000470008F000470008F000438010F
000438010F000438010F00041C020F00041C020F00041C020F00040E040F00040E040F00
040E040F000407080F000407080F000407080F000403900F000403900F000401E00F0004
01E00F000401E00F000E00C00F001F00C01F80FFE0C1FFF8251F7E9E2A>77
D<FF803FF807C007C007C0038005E0010005E0010004F001000478010004780100043C01
00043C0100041E0100040F0100040F010004078100040781000403C1000401E1000401E1
000400F1000400F1000400790004003D0004003D0004001F0004001F0004000F00040007
00040007000E0003001F000300FFE001001D1F7E9E22>I<0E0000FE00000E00000E0000
0E00000E00000E00000E00000E00000E00000E00000E00000E3E000EC3800F01C00F00E0
0E00E00E00700E00700E00780E00780E00780E00780E00780E00780E00700E00700E00E0
0F00E00D01C00CC300083E0015207F9F19>98 D<03F80E0C1C1E381E380C70007000F000
F000F000F000F000F00070007000380138011C020E0C03F010147E9314>I<03F0000E1C
001C0E00380700380700700700700380F00380F00380FFFF80F00000F00000F000007000
007000003800801800800C010007060001F80011147F9314>101
D<0E0000FE00000E00000E00000E00000E00000E00000E00000E00000E00000E00000E00
000E3E000E43000E81800F01C00F01C00E01C00E01C00E01C00E01C00E01C00E01C00E01
C00E01C00E01C00E01C00E01C00E01C00E01C00E01C0FFE7FC16207F9F19>104
D<1C001E003E001E001C000000000000000000000000000E007E000E000E000E000E000E
000E000E000E000E000E000E000E000E000E000E000E000E00FFC00A1F809E0C>I<0E1F
01F000FE618618000E81C81C000F00F00E000F00F00E000E00E00E000E00E00E000E00E0
0E000E00E00E000E00E00E000E00E00E000E00E00E000E00E00E000E00E00E000E00E00E
000E00E00E000E00E00E000E00E00E000E00E00E00FFE7FE7FE023147F9326>109
D<01F800070E001C03803801C03801C07000E07000E0F000F0F000F0F000F0F000F0F000
F0F000F07000E07000E03801C03801C01C0380070E0001F80014147F9317>111
D<0E78FE8C0F1E0F1E0F0C0E000E000E000E000E000E000E000E000E000E000E000E000E
000E00FFE00F147F9312>114 D<1F9030704030C010C010C010E00078007F803FE00FF0
0070803880188018C018C018E030D0608F800D147E9312>I<020002000200060006000E
000E003E00FFF80E000E000E000E000E000E000E000E000E000E000E000E080E080E080E
080E080610031001E00D1C7F9B12>I<0E01C0FE1FC00E01C00E01C00E01C00E01C00E01
C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E01C00E03C00603C0030D
C001F1FC16147F9319>I<FF83F81E01E01C00C00E00800E00800E008007010007010003
820003820003820001C40001C40001EC0000E80000E80000700000700000700000200015
147F9318>I<FF83F81E01E01C00C00E00800E00800E0080070100070100038200038200
03820001C40001C40001EC0000E80000E800007000007000007000002000002000004000
004000004000F08000F08000F100006200003C0000151D7F9318>121
D E /Fn 79 125 df<001F83E000706E3000C07C780180F8780380F07807007000070070
0007007000070070000700700007007000070070000700700007007000FFFFFFC0070070
000700700007007000070070000700700007007000070070000700700007007000070070
000700700007007000070070000700700007007000070070000700700007007000070078
007FE3FF801D2380A21C>11 D<001FC0000070200000C010000180380003807800070078
000700300007000000070000000700000007000000070000000700000007000000FFFFF8
000700780007003800070038000700380007003800070038000700380007003800070038
000700380007003800070038000700380007003800070038000700380007003800070038
00070038007FE1FF80192380A21B>I<001FD8000070380000C078000180780003807800
070038000700380007003800070038000700380007003800070038000700380007003800
FFFFF8000700380007003800070038000700380007003800070038000700380007003800
070038000700380007003800070038000700380007003800070038000700380007003800
07003800070038007FF3FF80192380A21B>I<000FC07F00007031C08000E00B00400180
1E00E003803E01E007003C01E007001C00C007001C000007001C000007001C000007001C
000007001C000007001C000007001C0000FFFFFFFFE007001C01E007001C00E007001C00
E007001C00E007001C00E007001C00E007001C00E007001C00E007001C00E007001C00E0
07001C00E007001C00E007001C00E007001C00E007001C00E007001C00E007001C00E007
001C00E007001C00E07FF1FFCFFE272380A229>I<7038F87CFC7EFC7E743A0402040204
0204020804080410081008201040200F0F7EA218>34 D<003C000000006200000000C200
000001810000000181000000038100000003810000000381000000038100000003820000
0003820000000384000000038800000001C800000001D000000001E003FF8001C0007C00
00E000380001E000300001F0002000027000400004700040000838008000183C00800030
1C010000701E020000700E020000F007040000F007880000F003880000F001D00100F000
E0010078007003003800B802003C031C04000E0C0E0C0003F003F00021257EA326>38
D<70F8FCFC7404040404080810102040060F7CA20E>I<00200040008001000300060004
000C000C00180018003000300030007000600060006000E000E000E000E000E000E000E0
00E000E000E000E000E000E000E0006000600060007000300030003000180018000C000C
0004000600030001000080004000200B327CA413>I<800040002000100018000C000400
060006000300030001800180018001C000C000C000C000E000E000E000E000E000E000E0
00E000E000E000E000E000E000E000C000C000C001C00180018001800300030006000600
04000C00180010002000400080000B327DA413>I<000180000001800000018000000180
000001800000018000000180000001800000018000000180000001800000018000000180
00000180000001800000018000FFFFFFFEFFFFFFFE000180000001800000018000000180
000001800000018000000180000001800000018000000180000001800000018000000180
000001800000018000000180001F227D9C26>43 D<70F8FCFC7404040404080810102040
060F7C840E>I<FFE0FFE00B027F8B10>I<70F8F8F87005057C840E>I<00018000018000
0380000300000300000700000600000600000E00000C00000C00001C0000180000180000
180000380000300000300000700000600000600000E00000C00000C00001C00001800001
80000380000300000300000700000600000600000E00000C00000C00000C00001C000018
0000180000380000300000300000700000600000600000E00000C00000C0000011317DA4
18>I<01F000071C000C06001803003803803803807001C07001C07001C07001C0F001E0
F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0F001E0
F001E07001C07001C07001C07803C03803803803801C07000C0600071C0001F00013227E
A018>I<008003800F80F380038003800380038003800380038003800380038003800380
03800380038003800380038003800380038003800380038003800380038007C0FFFE0F21
7CA018>I<03F0000C1C001007002007804003C04003C08003E0F003E0F801E0F801E0F8
01E02003E00003E00003C00003C0000780000700000E00001C0000180000300000600000
C0000180000100000200200400200800201800603000403FFFC07FFFC0FFFFC013217EA0
18>I<03F8000C1E001007002007804007C07807C07803C07807C03807C0000780000780
000700000F00000E0000380003F000001C00000F000007800007800003C00003C00003E0
2003E07003E0F803E0F803E0F003C04003C0400780200780100F000C1C0003F00013227E
A018>I<000200000600000E00000E00001E00001E00002E00004E00004E00008E00008E
00010E00020E00020E00040E00040E00080E00100E00100E00200E00200E00400E00800E
00FFFFF8000E00000E00000E00000E00000E00000E00000E00001F0001FFF015217FA018
>I<1000801E07001FFF001FFE001FF80013E00010000010000010000010000010000010
000010F800130E001407001803801003800001C00001C00001E00001E00001E00001E070
01E0F001E0F001E0E001C08001C04003C04003802007001006000C1C0003F00013227EA0
18>I<007E0001C1000300800601C00E03C01C03C0180180380000380000780000700000
700000F0F800F30C00F40600F40300F80380F801C0F001C0F001E0F001E0F001E0F001E0
F001E07001E07001E07001E03801C03801C01803801C03000C0600070C0001F00013227E
A018>I<4000006000007FFFE07FFFC07FFFC0400080C001008001008002008002000004
0000080000080000100000300000200000600000600000600000E00000C00000C00001C0
0001C00001C00001C00003C00003C00003C00003C00003C00003C00003C00003C0000180
0013237DA118>I<01F800060E000803001001802001802000C06000C06000C06000C070
00C07801803E01003F02001FC4000FF80003F80003FC00067F00083F80100F803007C060
01C06000E0C000E0C00060C00060C00060C000606000406000C03000801803000E0E0003
F00013227EA018>I<01F000060C000C0600180700380380700380700380F001C0F001C0
F001C0F001E0F001E0F001E0F001E0F001E07001E07003E03803E01805E00C05E00619E0
03E1E00001C00001C00001C0000380000380300300780700780600700C00201800103000
0FC00013227EA018>I<70F8F8F870000000000000000000000070F8F8F87005157C940E>
I<70F8F8F870000000000000000000000070F8F8F87808080808101010204040051F7C94
0E>I<0001800000018000000180000003C0000003C0000003C0000005E0000005E00000
0DF0000008F0000008F0000010F800001078000010780000203C0000203C0000203C0000
401E0000401E0000401E0000800F0000800F0000FFFF000100078001000780030007C002
0003C0020003C0040003E0040001E0040001E00C0000F00C0000F03E0001F8FF800FFF20
237EA225>65 D<FFFFF8000F800E0007800780078003C0078003E0078001E0078001F007
8001F0078001F0078001F0078001F0078001E0078003E0078007C007800F8007803E0007
FFFE0007800780078003C0078001E0078001F0078000F0078000F8078000F8078000F807
8000F8078000F8078000F8078001F0078001F0078003E0078007C00F800F00FFFFFC001D
227EA123>I<0007E0100038183000E0063001C00170038000F0070000F00E0000701E00
00701C0000303C0000303C0000307C0000107800001078000010F8000000F8000000F800
0000F8000000F8000000F8000000F8000000F800000078000000780000107C0000103C00
00103C0000101C0000201E0000200E000040070000400380008001C0010000E002000038
1C000007E0001C247DA223>I<FFFFF0000F801E0007800700078003C0078001C0078000
E0078000F007800078078000780780007C0780003C0780003C0780003C0780003E078000
3E0780003E0780003E0780003E0780003E0780003E0780003E0780003E0780003C078000
3C0780007C0780007807800078078000F0078000E0078001E0078003C0078007000F801E
00FFFFF8001F227EA125>I<FFFFFFC00F8007C0078001C0078000C00780004007800040
078000600780002007800020078000200780202007802000078020000780200007806000
0780E00007FFE0000780E000078060000780200007802000078020000780200807800008
07800008078000100780001007800010078000300780003007800070078000E00F8003E0
FFFFFFE01D227EA121>I<FFFFFFC00F8007C0078001C0078000C0078000400780004007
800060078000200780002007800020078020200780200007802000078020000780600007
80E00007FFE0000780E00007806000078020000780200007802000078020000780000007
800000078000000780000007800000078000000780000007800000078000000FC00000FF
FE00001B227EA120>I<0007F008003C0C1800E0021801C001B8038000F8070000780F00
00381E0000381E0000183C0000183C0000187C0000087800000878000008F8000000F800
0000F8000000F8000000F8000000F8000000F8000000F8001FFF780000F8780000787C00
00783C0000783C0000781E0000781E0000780F00007807000078038000B801C000B800E0
0318003C0C080007F00020247DA226>I<FFFC3FFF0FC003F0078001E0078001E0078001
E0078001E0078001E0078001E0078001E0078001E0078001E0078001E0078001E0078001
E0078001E0078001E007FFFFE0078001E0078001E0078001E0078001E0078001E0078001
E0078001E0078001E0078001E0078001E0078001E0078001E0078001E0078001E0078001
E00FC003F0FFFC3FFF20227EA125>I<FFFC0FC007800780078007800780078007800780
078007800780078007800780078007800780078007800780078007800780078007800780
07800780078007800FC0FFFC0E227EA112>I<03FFF0001F00000F00000F00000F00000F
00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F00000F
00000F00000F00000F00000F00000F00000F00000F00000F00700F00F80F00F80F00F80E
00F01E00401C0020380018700007C00014237EA119>I<FFFC03FF000FC000F800078000
600007800040000780008000078001000007800200000780040000078008000007801000
0007802000000780400000078080000007818000000783C000000787E000000789E00000
0788F000000790F0000007A078000007C03C000007803C000007801E000007800F000007
800F00000780078000078007C000078003C000078001E000078001E000078000F0000780
00F8000FC000FC00FFFC07FF8021227EA126>I<FFFE00000FC000000780000007800000
078000000780000007800000078000000780000007800000078000000780000007800000
078000000780000007800000078000000780000007800000078000000780000007800000
078000800780008007800080078000800780018007800180078001000780030007800300
07800F000F803F00FFFFFF0019227EA11E>I<FFC00003FF0FC00003F007C00003E005E0
0005E005E00005E004F00009E004F00009E004F00009E004780011E004780011E0047800
11E0043C0021E0043C0021E0043C0021E0041E0041E0041E0041E0040F0081E0040F0081
E0040F0081E004078101E004078101E004078101E00403C201E00403C201E00401E401E0
0401E401E00401E401E00400F801E00400F801E00400F801E004007001E00E007001E01F
007003F0FFE0203FFF28227EA12D>I<FF8007FF07C000F807C0007005E0002004F00020
04F0002004780020047C0020043C0020041E0020041F0020040F00200407802004078020
0403C0200401E0200401E0200400F0200400F8200400782004003C2004003E2004001E20
04000F2004000F20040007A0040003E0040003E0040001E0040001E0040000E00E000060
1F000060FFE0002020227EA125>I<000FE00000783C0000E00E0003C00780078003C00F
0001E00E0000E01E0000F03C0000783C0000787C00007C7C00007C7800003C7800003CF8
00003EF800003EF800003EF800003EF800003EF800003EF800003EF800003EF800003E78
00003C7C00007C7C00007C3C0000783E0000F81E0000F00F0001E00F0001E0078003C003
C0078000E00E0000783C00000FE0001F247DA226>I<FFFFF0000F803C0007800F000780
0780078007C0078003C0078003E0078003E0078003E0078003E0078003E0078003E00780
03C0078007C00780078007800F0007803C0007FFF0000780000007800000078000000780
000007800000078000000780000007800000078000000780000007800000078000000780
0000078000000FC00000FFFC00001B227EA121>I<FFFFE000000F803C000007800E0000
0780078000078007C000078003C000078003E000078003E000078003E000078003E00007
8003E000078003C000078007C000078007800007800E000007803C000007FFE000000780
700000078038000007801C000007801E000007800E000007800F000007800F000007800F
000007800F000007800F800007800F800007800F800007800F808007800FC080078007C0
800FC003C100FFFC01E2000000007C0021237EA124>82 D<03F0200C0C601802603001E0
7000E0600060E00060E00060E00020E00020E00020F00000F000007800007F00003FF000
1FFE000FFF0003FF80003FC00007E00001E00000F00000F0000070800070800070800070
800070C00060C00060E000C0F000C0C80180C6070081FC0014247DA21B>I<7FFFFFF878
07807860078018400780084007800840078008C007800C80078004800780048007800480
078004000780000007800000078000000780000007800000078000000780000007800000
078000000780000007800000078000000780000007800000078000000780000007800000
078000000780000007800000078000000FC00003FFFF001E227EA123>I<FFFC07FF0FC0
00F807800070078000200780002007800020078000200780002007800020078000200780
002007800020078000200780002007800020078000200780002007800020078000200780
00200780002007800020078000200780002007800020078000200380004003C0004003C0
004001C0008000E000800060010000300600001C08000003F00020237EA125>I<FFF000
7FC01F80001F000F00000C000780000C000780000800078000080003C000100003C00010
0003E000300001E000200001E000200000F000400000F000400000F00040000078008000
0078008000007C018000003C010000003C010000001E020000001E020000001F02000000
0F040000000F040000000F8C0000000788000000078800000003D000000003D000000003
F000000001E000000001E000000000C000000000C000000000C0000022237FA125>I<FF
F03FFC03FE1F8007E000F80F0003C000700F0003C000200F0003C00020078001E0004007
8001E00040078001E0004003C002F0008003C002F0008003C002F0008001E00478010001
E00478010001E00478010000F0083C020000F0083C020000F0083C020000F8183E060000
78101E04000078101E0400007C101E0400003C200F0800003C200F0800003C200F080000
1E40079000001E40079000001E40079000000F8003E000000F8003E000000F8003E00000
070001C00000070001C00000070001C0000003000180000002000080002F237FA132>I<
FFF0007FC01F80001F000F80000C00078000080007C000180003E000100001E000200001
F000200000F000400000F800C000007C008000003C010000003E010000001E020000001F
040000000F84000000078800000007D800000003D000000003E000000001E000000001E0
00000001E000000001E000000001E000000001E000000001E000000001E000000001E000
000001E000000001E000000001E000000003E00000003FFF000022227FA125>89
D<FEFEC0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0
C0C0C0C0C0C0C0C0C0C0C0C0FEFE07317BA40E>91 D<0804100820102010402040208040
804080408040B85CFC7EFC7E7C3E381C0F0F7AA218>I<FEFE0606060606060606060606
06060606060606060606060606060606060606060606060606060606060606060606FEFE
07317FA40E>I<0FE0001838003C0C003C0E0018070000070000070000070000FF0007C7
001E07003C0700780700700700F00708F00708F00708F00F087817083C23900FC1E01515
7E9418>97 D<0E0000FE00001E00000E00000E00000E00000E00000E00000E00000E0000
0E00000E00000E00000E00000E1F000E61C00E80600F00300E00380E003C0E001C0E001E
0E001E0E001E0E001E0E001E0E001E0E001E0E001C0E003C0E00380F00700C80600C41C0
083F0017237FA21B>I<01FE000703000C07801C0780380300780000700000F00000F000
00F00000F00000F00000F00000F000007000007800403800401C00800C010007060001F8
0012157E9416>I<0000E0000FE00001E00000E00000E00000E00000E00000E00000E000
00E00000E00000E00000E00000E001F8E00704E00C02E01C01E03800E07800E07000E0F0
00E0F000E0F000E0F000E0F000E0F000E0F000E07000E07800E03800E01801E00C02E007
0CF001F0FE17237EA21B>I<01FC000707000C03801C01C03801C07801E07000E0F000E0
FFFFE0F00000F00000F00000F00000F000007000007800203800201C00400E0080070300
00FC0013157F9416>I<003C00C6018F038F030F07000700070007000700070007000700
0700FFF80700070007000700070007000700070007000700070007000700070007000700
0700070007807FF8102380A20F>I<00007001F198071E180E0E181C07001C07003C0780
3C07803C07803C07801C07001C07000E0E000F1C0019F000100000100000180000180000
1FFE000FFFC00FFFE03800F0600030400018C00018C00018C000186000306000303800E0
0E038003FE0015217F9518>I<0E0000FE00001E00000E00000E00000E00000E00000E00
000E00000E00000E00000E00000E00000E00000E1F800E60C00E80E00F00700F00700E00
700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00
700E00700E0070FFE7FF18237FA21B>I<1C001E003E001E001C00000000000000000000
000000000000000E00FE001E000E000E000E000E000E000E000E000E000E000E000E000E
000E000E000E000E000E00FFC00A227FA10E>I<01C003E003E003E001C0000000000000
0000000000000000000001E00FE001E000E000E000E000E000E000E000E000E000E000E0
00E000E000E000E000E000E000E000E000E000E000E000E000E060E0F0C0F18061803E00
0B2C82A10F>I<0E0000FE00001E00000E00000E00000E00000E00000E00000E00000E00
000E00000E00000E00000E00000E03FC0E01F00E01C00E01800E02000E04000E08000E10
000E38000EF8000F1C000E1E000E0E000E07000E07800E03C00E01C00E01E00E00F00E00
F8FFE3FE17237FA21A>I<0E00FE001E000E000E000E000E000E000E000E000E000E000E
000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E000E
000E000E000E00FFE00B237FA20E>I<0E1FC07F00FE60E183801E807201C00F003C00E0
0F003C00E00E003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E
003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E003800E00E00
3800E00E003800E0FFE3FF8FFE27157F942A>I<0E1F80FE60C01E80E00F00700F00700E
00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E
00700E00700E0070FFE7FF18157F941B>I<01FC000707000C01801800C03800E0700070
700070F00078F00078F00078F00078F00078F00078F000787000707800F03800E01C01C0
0E038007070001FC0015157F9418>I<0E1F00FE61C00E80600F00700E00380E003C0E00
1C0E001E0E001E0E001E0E001E0E001E0E001E0E001E0E003C0E003C0E00380F00700E80
E00E41C00E3F000E00000E00000E00000E00000E00000E00000E00000E00000E0000FFE0
00171F7F941B>I<01F8200704600E02601C01603801E07800E07800E0F000E0F000E0F0
00E0F000E0F000E0F000E0F000E07000E07800E03801E01C01E00C02E0070CE001F0E000
00E00000E00000E00000E00000E00000E00000E00000E00000E0000FFE171F7E941A>I<
0E3CFE461E8F0F0F0F060F000E000E000E000E000E000E000E000E000E000E000E000E00
0E000F00FFF010157F9413>I<0F8830786018C018C008C008E008F0007F803FE00FF001
F8003C801C800C800CC00CC008E018D0308FC00E157E9413>I<02000200020002000600
060006000E001E003E00FFF80E000E000E000E000E000E000E000E000E000E000E000E04
0E040E040E040E040E040708030801F00E1F7F9E13>I<0E0070FE07F01E00F00E00700E
00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E00700E
00F00E00F006017003827800FC7F18157F941B>I<FFC1FE1E00780E00300E00200E0020
07004007004003808003808003808001C10001C10000E20000E20000E200007400007400
00380000380000380000100017157F941A>I<FF8FF8FF1E01E03C1C01C0180E01C0180E
01E0100E01E01007026020070270200702702003843040038438400384384001C8188001
C81C8001C81C8000F00D0000F00F0000F00F0000600600006006000060060020157F9423
>I<FF83FE1F01F00E00C007008003810003830001C20000E40000780000780000380000
3C00004E00008E000187000103800201C00401E00C00E03E01F0FF03FE17157F941A>I<
FFC1FE1E00780E00300E00200E002007004007004003808003808003808001C10001C100
00E20000E20000E200007400007400003800003800003800001000001000002000002000
002000004000F04000F08000F180004300003C0000171F7F941A>I<3FFFC03803803007
80200700600E00401C00403C0040380000700000E00001E00001C0000380400700400F00
400E00C01C0080380080780180700780FFFF8012157F9416>I<FFFFFFFFFFFF3001808C
31>124 D E /Fo 51 123 df<00001FFC00000001FFFF00000007FFFFC000001FF807E0
00007FC007F00000FF000FF00001FF000FF00001FE000FF00003FC001FF80003FC000FF0
0003FC000FF00003FC0007E00003FC0001800003FC0000000003FC0000000003FC000000
0003FC0000000003FC00FFF800FFFFFFFFF800FFFFFFFFF800FFFFFFFFF80003FC0007F8
0003FC0007F80003FC0007F80003FC0007F80003FC0007F80003FC0007F80003FC0007F8
0003FC0007F80003FC0007F80003FC0007F80003FC0007F80003FC0007F80003FC0007F8
0003FC0007F80003FC0007F80003FC0007F80003FC0007F80003FC0007F80003FC0007F8
0003FC0007F80003FC0007F80003FC0007F80003FC0007F80003FC0007F80003FC0007F8
0003FC0007F8007FFFE0FFFFC07FFFE0FFFFC07FFFE0FFFFC02A327FB12E>12
D<FFFFF0FFFFF0FFFFF0FFFFF0FFFFF0FFFFF0FFFFF014077F921B>45
D<000FFC0000007FFF800001FFFFE00003FC0FF00007F003F8000FE001FC000FE001FC00
1FC000FE003FC000FF003FC000FF003F80007F007F80007F807F80007F807F80007F807F
80007F80FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF80
007FC0FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF80007FC0FF8000
7FC0FF80007FC0FF80007FC07F80007F807F80007F807F80007F807F80007F803F80007F
003FC000FF003FC000FF001FC000FE001FE001FE000FE001FC0007F807F80003FC0FF000
01FFFFE000007FFF8000000FFC0000222E7DAD29>48 D<0001E0000003E000000FE00000
7FE0001FFFE000FFFFE000FFBFE000E03FE000003FE000003FE000003FE000003FE00000
3FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE00000
3FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE00000
3FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE00000
3FE000003FE000003FE000003FE0007FFFFFF07FFFFFF07FFFFFF01C2E7AAD29>I<003F
F00001FFFE0007FFFF801FC07FE03F003FF07C001FF87F000FFCFF8007FEFFC007FEFFC0
03FFFFC003FFFFC003FFFFC003FF7F8003FF3F0003FF000003FF000003FF000007FE0000
07FE000007FC00000FF800001FF800001FF000003FE000007F8000007F000000FE000001
FC000003F0000007E000000FC007001F8007003E0007007C000F00F8000E01F0000E01E0
001E03FFFFFE07FFFFFE0FFFFFFE1FFFFFFE3FFFFFFE7FFFFFFCFFFFFFFCFFFFFFFCFFFF
FFFC202E7CAD29>I<000FFC0000007FFF800001F01FE00003C00FF00007800FF8000FE0
07FC001FF007FE001FF807FE001FF807FE001FF807FE001FF807FE001FF807FE000FF007
FE0007E007FC0001800FFC0000000FF80000000FF80000001FF00000003FE00000007F80
00001FFE0000001FFC0000001FFF800000001FF00000000FF800000007FE00000003FF00
000003FF00000001FF80000001FF800E0001FFC03F8001FFC07FC001FFC0FFE001FFC0FF
E001FFC0FFE001FFC0FFE001FFC0FFE001FF80FFE003FF807FC003FF007F0007FE003F00
0FFC001FE01FF80007FFFFE00001FFFF8000001FFC0000222E7DAD29>I<000000780000
0000F800000001F800000003F800000007F800000007F80000000FF80000001FF8000000
3FF80000007FF800000077F8000000F7F8000001E7F8000003C7F800000787F800000707
F800000F07F800001E07F800003C07F800007807F800007007F80000F007F80001E007F8
0003C007F800078007F8000F0007F8000F0007F8001E0007F8003C0007F800780007F800
F00007F800FFFFFFFFF0FFFFFFFFF0FFFFFFFFF000000FF80000000FF80000000FF80000
000FF80000000FF80000000FF80000000FF80000000FF80000000FF800000FFFFFF0000F
FFFFF0000FFFFFF0242E7EAD29>I<0C0000380FC003F80FFFFFF80FFFFFF00FFFFFE00F
FFFFC00FFFFF800FFFFF000FFFFC000FFFF0000FFF00000F0000000F0000000F0000000F
0000000F0000000F0000000F0000000F1FF8000FFFFF000FFFFFC00FF01FE00F800FF00F
0007F80E0007FC000003FE000003FE000003FE000003FF000003FF1E0003FF7F8003FFFF
8003FFFFC003FFFFC003FFFFC003FFFF8003FEFF8003FE7F0007FC7C0007FC3C000FF81E
001FF00FC07FE007FFFF8001FFFE00003FE000202E7CAD29>I<00007F80000007FFF000
001FC07800007F001C0000FE001E0001FC007E0003F800FF0007F001FF000FF001FF001F
E001FF001FE001FF003FE000FE003FE0007C007FC00000007FC00000007FC00000007FC0
000000FFC3FF8000FFC7FFE000FFCFBFF000FFDC03FC00FFF803FE00FFF001FF00FFF000
FF00FFE000FF80FFE000FF80FFE000FFC0FFC000FFC0FFC000FFC0FFC000FFC0FFC000FF
C07FC000FFC07FC000FFC07FC000FFC07FC000FFC03FC000FFC03FC000FF801FE000FF80
1FE000FF000FE001FF000FF001FE0007F803FC0001FC0FF80000FFFFE000003FFF800000
07FC0000222E7DAD29>I<38000000003E000000003FFFFFFFC03FFFFFFFC03FFFFFFFC0
3FFFFFFF807FFFFFFF007FFFFFFE007FFFFFFC007FFFFFF8007FFFFFF800780001F00070
0003E000700007C000F0000F8000E0000F0000E0001F0000E0003E000000007C00000000
F800000000F800000001F000000003F000000003F000000007E000000007E00000000FE0
0000000FE00000000FE00000001FE00000001FC00000001FC00000003FC00000003FC000
00003FC00000003FC00000003FC00000007FC00000007FC00000007FC00000007FC00000
007FC00000007FC00000007FC00000007FC00000007FC00000003F800000001F00000022
307BAF29>I<0007FC0000003FFF800000F80FE00001E003F00003C001F80007C000FC00
0F8000FC000F80007E001F80007E001F80007E001FC0007E001FE0007E001FF0007E001F
F800FE001FFE00FC001FFF81FC000FFFE3F8000FFFFFF00007FFFFC00003FFFF800003FF
FFC00000FFFFF000007FFFF80001FFFFFC0007F7FFFE000FE1FFFF001FC0FFFF803F803F
FF807F000FFF807E0003FFC0FE0000FFC0FC00007FC0FC00003FC0FC00001FC0FC00000F
C0FC00000FC0FC00000F80FE00000F807E00001F807F00001F003F80003E001FC0007C00
0FF803F80003FFFFE00000FFFF8000001FFC0000222E7DAD29>I<000FFC0000007FFF00
0001FC0FC00007F807F0000FF003F8001FE001FC003FE001FC003FC001FE007FC000FF00
7FC000FF00FFC000FF00FFC000FF80FFC000FF80FFC000FF80FFC000FF80FFC000FFC0FF
C000FFC0FFC000FFC0FFC000FFC07FC001FFC07FC001FFC07FC001FFC03FE003FFC01FE0
03FFC01FF007FFC00FF80EFFC003FF7CFFC001FFF8FFC0007FF0FFC0000000FF80000000
FF80000000FF80000000FF800F8001FF001FC001FF003FE001FE003FE001FE003FE003FC
003FE003F8003FC007F8001F800FF0001E001FE0000F807F800007FFFE000001FFF80000
007FC00000222E7DAD29>I<1F003F807FC0FFE0FFE0FFE0FFE0FFE07FC03F801F000000
0000000000000000000000000000000000001F003F807FC0FFE0FFE0FFE0FFE0FFE07FC0
3F801F000B207A9F17>I<0000007C0000000000007C000000000000FE000000000000FE
000000000000FE000000000001FF000000000001FF000000000003FF800000000003FF80
0000000007FFC00000000007FFC00000000007FFC0000000000FFFE0000000000F7FE000
0000001F7FF0000000001E3FF0000000001E3FF0000000003E3FF8000000003C1FF80000
00007C1FFC00000000780FFC00000000780FFC00000000F80FFE00000000F007FE000000
01F007FF00000001E003FF00000001E003FF00000003E003FF80000003C001FF80000007
C001FFC00000078000FFC00000078000FFC000000FFFFFFFE000000FFFFFFFE000001FFF
FFFFF000001E00003FF000001E00003FF000003C00003FF800003C00001FF800007C0000
1FFC00007800000FFC00007800000FFC0000F0000007FE0000F0000007FE0001F0000007
FF0003F8000003FF00FFFFC001FFFFFEFFFFC001FFFFFEFFFFC001FFFFFE37317DB03E>
65 D<FFFFFFFFF80000FFFFFFFFFF0000FFFFFFFFFFE00000FF80003FF00000FF80000F
F80000FF800007FC0000FF800007FE0000FF800003FF0000FF800003FF0000FF800001FF
8000FF800001FF8000FF800001FF8000FF800001FF8000FF800001FF8000FF800001FF80
00FF800003FF0000FF800003FF0000FF800007FF0000FF800007FE0000FF80000FFC0000
FF80001FF80000FF8000FFE00000FFFFFFFF800000FFFFFFFF000000FFFFFFFFE00000FF
80001FF80000FF800007FC0000FF800003FF0000FF800001FF0000FF800001FF8000FF80
0000FFC000FF800000FFC000FF800000FFE000FF800000FFE000FF800000FFE000FF8000
00FFE000FF800000FFE000FF800000FFE000FF800000FFE000FF800000FFC000FF800001
FFC000FF800001FF8000FF800003FF8000FF800007FF0000FF80000FFE0000FF80003FFC
00FFFFFFFFFFF000FFFFFFFFFFC000FFFFFFFFFE000033317EB03B>I<000003FF800380
00003FFFF007800001FFFFFC0F800007FF007F1F80001FF8000FFF80007FE00003FF8000
FFC00001FF8001FF000000FF8003FE0000007F8007FE0000003F800FFC0000001F801FF8
0000001F801FF80000000F803FF80000000F803FF00000000F803FF000000007807FF000
000007807FF000000007807FE00000000000FFE00000000000FFE00000000000FFE00000
000000FFE00000000000FFE00000000000FFE00000000000FFE00000000000FFE0000000
0000FFE00000000000FFE00000000000FFE000000000007FE000000000007FF000000000
007FF000000003803FF000000003803FF000000003803FF800000003801FF80000000780
1FF800000007000FFC0000000F0007FE0000000E0003FF0000001E0001FF0000003C0000
FFC000007800007FE00001F000001FF80003E0000007FF003F80000001FFFFFE00000000
3FFFF80000000003FF80000031317BB03C>I<FFFFFFFFF00000FFFFFFFFFF0000FFFFFF
FFFFC00000FFC000FFF00000FFC0000FFC0000FFC00007FE0000FFC00001FF0000FFC000
00FF8000FFC000007FC000FFC000003FE000FFC000003FE000FFC000001FF000FFC00000
1FF000FFC000001FF800FFC000000FF800FFC000000FFC00FFC000000FFC00FFC000000F
FC00FFC000000FFC00FFC000000FFE00FFC000000FFE00FFC000000FFE00FFC000000FFE
00FFC000000FFE00FFC000000FFE00FFC000000FFE00FFC000000FFE00FFC000000FFE00
FFC000000FFE00FFC000000FFE00FFC000000FFC00FFC000000FFC00FFC000000FFC00FF
C000000FFC00FFC000000FF800FFC000001FF800FFC000001FF800FFC000001FF000FFC0
00003FE000FFC000003FE000FFC000007FC000FFC00000FF8000FFC00001FF0000FFC000
03FE0000FFC0000FFC0000FFC0007FF000FFFFFFFFFFE000FFFFFFFFFF0000FFFFFFFFF0
000037317EB03F>I<FFFFFFFFFFF000FFFFFFFFFFF000FFFFFFFFFFF00000FFC0003FF0
0000FFC00007F80000FFC00003F80000FFC00000F80000FFC00000F80000FFC000007800
00FFC00000780000FFC00000380000FFC00000380000FFC00000380000FFC000001C0000
FFC007001C0000FFC007001C0000FFC007001C0000FFC00700000000FFC00700000000FF
C00F00000000FFC01F00000000FFC03F00000000FFFFFF00000000FFFFFF00000000FFFF
FF00000000FFC03F00000000FFC01F00000000FFC00F00000000FFC00700000000FFC007
00000000FFC00700038000FFC00700038000FFC00700038000FFC00000070000FFC00000
070000FFC00000070000FFC00000070000FFC000000F0000FFC000000F0000FFC000001E
0000FFC000001E0000FFC000003E0000FFC000007E0000FFC00000FE0000FFC00003FE00
00FFC0001FFE00FFFFFFFFFFFC00FFFFFFFFFFFC00FFFFFFFFFFFC0031317EB036>I<FF
FFFFFFFFF0FFFFFFFFFFF0FFFFFFFFFFF000FFC0003FF000FFC00007F800FFC00003F800
FFC00000F800FFC00000F800FFC000007800FFC000007800FFC000003800FFC000003800
FFC000003800FFC000001C00FFC000001C00FFC007001C00FFC007001C00FFC007000000
FFC007000000FFC007000000FFC00F000000FFC01F000000FFC03F000000FFFFFF000000
FFFFFF000000FFFFFF000000FFC03F000000FFC01F000000FFC00F000000FFC007000000
FFC007000000FFC007000000FFC007000000FFC007000000FFC000000000FFC000000000
FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000
FFC000000000FFC000000000FFC000000000FFC0000000FFFFFFF00000FFFFFFF00000FF
FFFFF000002E317EB034>I<FFFFFFC0FFFFFFC0FFFFFFC000FFC00000FFC00000FFC000
00FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC000
00FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC000
00FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC000
00FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC00000FFC000
00FFC00000FFC00000FFC00000FFC000FFFFFFC0FFFFFFC0FFFFFFC01A317EB01F>73
D<FFFFFFF00000FFFFFFF00000FFFFFFF0000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000007000FFC000007000FFC000007000FFC00000F000FFC00000F000FFC00000
E000FFC00000E000FFC00001E000FFC00001E000FFC00003E000FFC00003E000FFC00007
E000FFC0000FE000FFC0001FE000FFC0007FC000FFC003FFC0FFFFFFFFFFC0FFFFFFFFFF
C0FFFFFFFFFFC02C317EB032>76 D<FFFF8000000001FFFF80FFFFC000000003FFFF80FF
FFE000000007FFFF8000FFE000000007FF800000EFF00000000EFF800000EFF00000000E
FF800000EFF00000000EFF800000E7F80000001CFF800000E7F80000001CFF800000E3FC
00000038FF800000E3FC00000038FF800000E1FE00000070FF800000E1FE00000070FF80
0000E0FF000000E0FF800000E0FF000000E0FF800000E07F800001C0FF800000E07F8000
01C0FF800000E03FC0000380FF800000E03FC0000380FF800000E03FC0000380FF800000
E01FE0000700FF800000E01FE0000700FF800000E00FF0000E00FF800000E00FF0000E00
FF800000E007F8001C00FF800000E007F8001C00FF800000E003FC003800FF800000E003
FC003800FF800000E001FE007000FF800000E001FE007000FF800000E000FF00E000FF80
0000E000FF00E000FF800000E000FF00E000FF800000E0007F81C000FF800000E0007F81
C000FF800000E0003FC38000FF800000E0003FC38000FF800000E0001FE70000FF800000
E0001FE70000FF800000E0000FFE0000FF800000E0000FFE0000FF800000E00007FC0000
FF800000E00007FC0000FF800000E00007FC0000FF800000E00003F80000FF800001F000
03F80000FF8000FFFFE001F000FFFFFF80FFFFE001F000FFFFFF80FFFFE000E000FFFFFF
8049317EB04E>I<00000FFE0000000000FFFFE000000007FFFFFC0000001FFC07FF0000
003FE000FF800000FF80003FE00001FF00001FF00003FE00000FF80007FC000007FC0007
FC000007FC000FF8000003FE001FF8000003FF001FF0000001FF003FF0000001FF803FF0
000001FF803FF0000001FF807FE0000000FFC07FE0000000FFC07FE0000000FFC0FFE000
0000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE00000
00FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000FFE0FFE0000000
FFE07FE0000000FFC07FE0000000FFC07FF0000001FFC07FF0000001FFC03FF0000001FF
803FF0000001FF801FF8000003FF001FF8000003FF000FFC000007FE000FFC000007FE00
07FE00000FFC0003FF00001FF80001FF80003FF00000FFC0007FE000003FE000FF800000
1FFC07FF00000007FFFFFC00000000FFFFE0000000000FFE00000033317BB03E>79
D<FFFFFFFFE000FFFFFFFFFE00FFFFFFFFFF8000FFC001FFE000FFC0003FF000FFC0001F
F800FFC0000FFC00FFC0000FFC00FFC00007FE00FFC00007FE00FFC00007FF00FFC00007
FF00FFC00007FF00FFC00007FF00FFC00007FF00FFC00007FF00FFC00007FF00FFC00007
FE00FFC00007FE00FFC0000FFC00FFC0000FFC00FFC0001FF800FFC0003FF000FFC001FF
E000FFFFFFFF8000FFFFFFFE0000FFFFFFE00000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC000000000FFC000000000FFC00000
0000FFC000000000FFC000000000FFC000000000FFC0000000FFFFFFC00000FFFFFFC000
00FFFFFFC0000030317EB038>I<FFFFFFFFC0000000FFFFFFFFFC000000FFFFFFFFFF80
000000FFC001FFE0000000FFC0003FF0000000FFC0000FFC000000FFC00007FC000000FF
C00007FE000000FFC00003FF000000FFC00003FF000000FFC00003FF800000FFC00003FF
800000FFC00003FF800000FFC00003FF800000FFC00003FF800000FFC00003FF800000FF
C00003FF000000FFC00003FF000000FFC00007FE000000FFC00007FC000000FFC0000FFC
000000FFC0003FF0000000FFC001FFE0000000FFFFFFFF80000000FFFFFFFC00000000FF
FFFFFE00000000FFC007FF80000000FFC000FFC0000000FFC0007FE0000000FFC0003FE0
000000FFC0003FF0000000FFC0001FF8000000FFC0001FF8000000FFC0001FF8000000FF
C0001FF8000000FFC0001FF8000000FFC0001FFC000000FFC0001FFC000000FFC0001FFC
000000FFC0001FFC000000FFC0001FFC004000FFC0001FFC00E000FFC0001FFE00E000FF
C0000FFE01E000FFC0000FFF01C000FFC00007FF87C0FFFFFFC003FFFF80FFFFFFC000FF
FF00FFFFFFC0001FFC003B317EB03E>82 D<001FF0038000FFFF078003FFFFCF8007F00F
FF801FC001FF801F80007F803F00003F807F00001F807E00000F807E00000F80FE000007
80FE00000780FF00000380FF00000380FF80000380FFC0000000FFE0000000FFFC000000
7FFFE000007FFFFE00003FFFFFC0003FFFFFF0001FFFFFFC000FFFFFFE0007FFFFFF0001
FFFFFF00007FFFFF80001FFFFFC00000FFFFC0000007FFC0000000FFE00000007FE00000
003FE00000001FE0E000001FE0E000000FE0E000000FE0E000000FE0F000000FE0F00000
0FC0F800000FC0F800001F80FC00001F80FF00003F00FFC0007E00FFFC01FC00F9FFFFF8
00F03FFFE000E007FF000023317BB02E>I<3FFFFFFFFFFF003FFFFFFFFFFF003FFFFFFF
FFFF003FE00FFC01FF007F000FFC003F807E000FFC001F807C000FFC000F8078000FFC00
078078000FFC00078070000FFC00038070000FFC00038070000FFC00038070000FFC0003
80E0000FFC0001C0E0000FFC0001C0E0000FFC0001C0E0000FFC0001C000000FFC000000
00000FFC00000000000FFC00000000000FFC00000000000FFC00000000000FFC00000000
000FFC00000000000FFC00000000000FFC00000000000FFC00000000000FFC0000000000
0FFC00000000000FFC00000000000FFC00000000000FFC00000000000FFC00000000000F
FC00000000000FFC00000000000FFC00000000000FFC00000000000FFC00000000000FFC
00000000000FFC00000000000FFC00000000000FFC00000000000FFC00000000000FFC00
000000000FFC000000007FFFFFFF8000007FFFFFFF8000007FFFFFFF800032307DAF39>
I<FFFFFFC003FFFFC0FFFFFFC003FFFFC0FFFFFFC003FFFFC000FFC0000007E00000FFC0
000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C0
0000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0
000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C0
0000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0
000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C0
0000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0
000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C00000FFC0000003C0
0000FFC0000007C000007FC00000078000007FE00000078000003FE000000F8000003FE0
00000F0000001FF000001E0000000FF800003E00000007FC0000FC00000003FF0003F800
000000FFE01FE0000000007FFFFFC0000000000FFFFF000000000000FFF00000003A317E
B03F>I<007FF8000003FFFF00000FFFFFC0001FE01FF0001FF007F8001FF007FC001FF0
03FC001FF001FE000FE001FE0007C001FE00010001FE00000001FE00000001FE000001FF
FE00003FFFFE0001FFF1FE0007FE01FE001FF001FE003FE001FE007FC001FE007F8001FE
00FF8001FE00FF0001FE00FF0001FE00FF0001FE00FF8003FE00FF8007FE007FC00FFE00
3FF03EFF001FFFF87FF807FFF03FF800FF801FF825207E9F28>97
D<01F8000000FFF8000000FFF8000000FFF80000000FF800000007F800000007F8000000
07F800000007F800000007F800000007F800000007F800000007F800000007F800000007
F800000007F800000007F800000007F800000007F80FF00007F87FFE0007F9FFFF8007FF
E03FE007FF000FF007FE0007F807FC0007F807F80003FC07F80003FE07F80003FE07F800
01FE07F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80001
FF07F80001FF07F80001FF07F80001FF07F80001FE07F80003FE07F80003FC07FC0003FC
07FC0007F807FE000FF007FF801FE007E7E07FC007C1FFFF8007807FFE0007001FE00028
327EB12E>I<0007FF00007FFFE001FFFFF803FC03FC07F807FC0FF007FC1FE007FC3FC0
07FC3FC003F87FC001F07F800040FF800000FF800000FF800000FF800000FF800000FF80
0000FF800000FF800000FF800000FF8000007FC000007FC000003FC0000E3FE0000E1FE0
001E0FF0003C07F8007803FF01F001FFFFE0007FFF800007FC001F207D9F25>I<000000
07E0000003FFE0000003FFE0000003FFE00000003FE00000001FE00000001FE00000001F
E00000001FE00000001FE00000001FE00000001FE00000001FE00000001FE00000001FE0
0000001FE00000001FE00000001FE0000FF81FE0007FFF1FE001FFFFDFE003FE03FFE00F
F800FFE01FF0007FE01FE0003FE03FC0001FE03FC0001FE07FC0001FE07F80001FE0FF80
001FE0FF80001FE0FF80001FE0FF80001FE0FF80001FE0FF80001FE0FF80001FE0FF8000
1FE0FF80001FE0FF80001FE07F80001FE07FC0001FE07FC0001FE03FC0003FE01FE0007F
E01FE000FFE00FF001FFE007FC07DFF001FFFF9FFF007FFE1FFF000FF01FFF28327DB12E
>I<000FFE0000007FFFC00001FFFFE00003FE0FF00007F801F8000FF000FC001FE000FE
003FC0007F003FC0007F007FC0003F007F80003F807F80003F80FF80003F80FF80003F80
FFFFFFFF80FFFFFFFF80FFFFFFFF80FF80000000FF80000000FF800000007F800000007F
800000007FC00000003FC00003803FE00003801FE00007800FF0000F0007F8003E0003FF
01FC0000FFFFF800003FFFE0000007FF000021207E9F26>I<0000FF000007FFC0001FFF
F0007FC7F000FF0FF801FF0FF801FE0FF803FE0FF803FC0FF803FC07F003FC01C003FC00
0003FC000003FC000003FC000003FC000003FC000003FC0000FFFFF800FFFFF800FFFFF8
0003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC00
0003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC00
0003FC000003FC000003FC000003FC000003FC000003FC000003FC000003FC00007FFFF0
007FFFF0007FFFF0001D327EB119>I<001FF007E000FFFE3FF003FFFFFFF807F83FF1F8
0FE00FE1F81FE00FF1F81FC007F0603FC007F8003FC007F8003FC007F8003FC007F8003F
C007F8003FC007F8003FC007F8001FC007F0001FE00FF0000FE00FE00007F83FC00007FF
FF80000EFFFE00000E1FF000000E000000001E000000001E000000001F000000001F8000
00001FFFFFC0000FFFFFF8000FFFFFFE0007FFFFFF8007FFFFFFC007FFFFFFE01FFFFFFF
E03F00007FE07E00000FF0FE000007F0FC000003F0FC000003F0FC000003F0FE000007F0
7E000007E07F00000FE03FC0003FC01FF801FF8007FFFFFE0000FFFFF000001FFF800025
2F7E9F29>I<01F800000000FFF800000000FFF800000000FFF8000000000FF800000000
07F80000000007F80000000007F80000000007F80000000007F80000000007F800000000
07F80000000007F80000000007F80000000007F80000000007F80000000007F800000000
07F80000000007F807F8000007F83FFF000007F87FFF800007F9F03FC00007FBC01FE000
07FF801FE00007FF000FF00007FE000FF00007FC000FF00007FC000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
07F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF000
FFFFC1FFFF80FFFFC1FFFF80FFFFC1FFFF8029327DB12E>I<03C0000FF0001FF8001FF8
001FF8001FFC001FF8001FF8001FF8000FF00003C0000000000000000000000000000000
0000000000000000000001F800FFF800FFF800FFF8000FF80007F80007F80007F80007F8
0007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F8
0007F80007F80007F80007F80007F80007F80007F80007F800FFFF80FFFF80FFFF801133
7DB217>I<01F800FFF800FFF800FFF8000FF80007F80007F80007F80007F80007F80007
F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007
F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007
F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007
F800FFFFC0FFFFC0FFFFC012327DB117>108 D<03F007F8000FF000FFF03FFF007FFE00
FFF07FFF80FFFF00FFF1F03FC3E07F800FF3C01FE7803FC007F7801FEF003FC007F7000F
FE001FE007FE000FFC001FE007FC000FF8001FE007FC000FF8001FE007F8000FF0001FE0
07F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000F
F0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE0
07F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000F
F0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE007F8000FF0001FE0
FFFFC1FFFF83FFFFFFFFC1FFFF83FFFFFFFFC1FFFF83FFFF40207D9F45>I<03F007F800
00FFF03FFF0000FFF07FFF8000FFF1F03FC0000FF3C01FE00007F7801FE00007F7000FF0
0007FE000FF00007FC000FF00007FC000FF00007F8000FF00007F8000FF00007F8000FF0
0007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF0
0007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF0
0007F8000FF00007F8000FF00007F8000FF00007F8000FF000FFFFC1FFFF80FFFFC1FFFF
80FFFFC1FFFF8029207D9F2E>I<0007FE0000003FFFC00000FFFFF00003FC03FC0007F0
00FE000FE0007F001FC0003F803FC0003FC03FC0003FC07F80001FE07F80001FE07F8000
1FE0FF80001FF0FF80001FF0FF80001FF0FF80001FF0FF80001FF0FF80001FF0FF80001F
F0FF80001FF07F80001FE07F80001FE07F80001FE03FC0003FC03FC0003FC01FE0007F80
0FE0007F0007F801FE0003FE07FC0001FFFFF800003FFFC0000007FE000024207E9F29>
I<01F80FF000FFF87FFE00FFF9FFFF80FFFFE07FE00FFF001FF007FE000FF807FC0007F8
07F80007FC07F80003FE07F80003FE07F80003FE07F80001FF07F80001FF07F80001FF07
F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80001FF07F80003FF07F8
0003FE07F80003FE07F80003FC07FC0007FC07FC000FF807FE000FF007FF801FE007FFE0
7FC007F9FFFF8007F87FFE0007F81FE00007F800000007F800000007F800000007F80000
0007F800000007F800000007F800000007F800000007F800000007F800000007F8000000
FFFFC00000FFFFC00000FFFFC00000282E7E9F2E>I<03F03F00FFF0FFC0FFF1FFF0FFF3
C7F00FF78FF807F70FF807FE0FF807FE0FF807FC07F007FC03E007FC008007FC000007F8
000007F8000007F8000007F8000007F8000007F8000007F8000007F8000007F8000007F8
000007F8000007F8000007F8000007F8000007F8000007F8000007F80000FFFFE000FFFF
E000FFFFE0001D207E9F22>114 D<00FF870007FFEF001FFFFF003F007F007C001F007C
000F00F8000F00F8000700FC000700FC000700FF000000FFF800007FFFC0007FFFF0003F
FFFC001FFFFE0007FFFF0001FFFF80001FFF800000FFC000001FC0E0000FC0E0000FC0F0
0007C0F00007C0F80007C0FC000F80FE001F80FF803F00FFFFFE00F3FFF800E07FC0001A
207D9F21>I<00380000380000380000380000380000780000780000780000F80000F800
01F80003F80007F8001FF800FFFFFEFFFFFEFFFFFE07F80007F80007F80007F80007F800
07F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F80007F807
07F80707F80707F80707F80707F80707F80707FC0F03FC0E03FE1E01FFFC007FF8000FE0
182E7EAD20>I<01F80003F000FFF801FFF000FFF801FFF000FFF801FFF0000FF8001FF0
0007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF0
0007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF0
0007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF00007F8000FF0
0007F8001FF00007F8001FF00007F8003FF00007F8007FF00003FC00FFF00003FE03EFF8
0001FFFFCFFF80007FFF0FFF80000FFC0FFF8029207D9F2E>I<FFFF801FFEFFFF801FFE
FFFF801FFE07F80003E007F80001C007FC0003C003FC00038003FE00078001FE00070001
FF000F0000FF000E0000FF801E00007F801C00007FC03C00003FC03800003FE03800001F
E07000001FE07000000FF0E000000FF0E000000FF9E0000007F9C0000007FFC0000003FF
80000003FF80000001FF00000001FF00000000FE00000000FE000000007C000000007C00
00000038000027207E9F2C>I<FFFF0FFFF01FFEFFFF0FFFF01FFEFFFF0FFFF01FFE0FF0
007E0003F00FF8007F0001E007F8007F0001C007F8003F8003C003FC003F80038003FC00
7FC0038003FE007FC0078001FE00FFC0070001FF00EFE00F0000FF00EFE00E0000FF01C7
F00E00007F81C7F01C00007F83C7F01C00007FC383F83C00003FC383F83800003FC701FC
3800001FE701FC7000001FEF01FC7000001FFE00FEF000000FFE00FEE000000FFC007FE0
000007FC007FC0000007FC007FC0000007F8003FC0000003F8003F80000003F0001F8000
0001F0001F00000001E0000F00000000E0000E000037207E9F3C>I<FFFF00FFFCFFFF00
FFFCFFFF00FFFC07F8001F8003FC001E0001FE003C0000FF00780000FF80F000007FC1E0
00003FC1E000001FE3C000000FF780000007FF00000007FE00000003FE00000001FE0000
0000FF00000001FF80000001FFC0000003FFE00000079FF000000F0FF000001E07F80000
3C03FC00007801FE0000F001FF0001E000FF8001E0007FC007E0003FC0FFF801FFFEFFF8
01FFFEFFF801FFFE27207E9F2C>I<FFFF801FFEFFFF801FFEFFFF801FFE07F80003E007
F80001C007FC0003C003FC00038003FE00078001FE00070001FF000F0000FF000E0000FF
801E00007F801C00007FC03C00003FC03800003FE03800001FE07000001FE07000000FF0
E000000FF0E000000FF9E0000007F9C0000007FFC0000003FF80000003FF80000001FF00
000001FF00000000FE00000000FE000000007C000000007C000000003800000000380000
000070000000007000000000F000003C00E000007E01E00000FF01C00000FF03800000FF
07800000FF0F0000007A3E0000007FFC0000003FF80000000FC0000000272E7E9F2C>I<
3FFFFFFC3FFFFFFC3FFFFFFC3FC00FF83E001FF03C003FF038003FE078007FC07800FF80
7001FF807003FF007003FE007007FC00000FFC00001FF800001FF000003FE000007FE00E
00FFC00E00FF800E01FF000E03FF000E07FE001E07FC001E0FF8001C1FF0003C3FF0007C
3FE000FC7FC007FCFFFFFFFCFFFFFFFCFFFFFFFC1F207E9F25>I
E end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 300dpi
TeXDict begin

%%EndSetup
%%Page: 0 1
0 0 bop 909 506 a Fo(Ox:)519 567 y Fn(An)16 b(A)o(ttribute-Grammar)d
(Compiling)i(System)681 627 y(based)i(on)f(Y)l(acc,)g(Lex,)f(and)i(C:)
549 741 y Fo(User)28 b(Reference)e(Man)n(ual)773 851
y Fm(b)o(y)16 b(Kurt)f(M.)f(Bisc)o(ho\013)784 908 y(No)o(v)o(em)o(b)q
(er)h(14,)f(1993)683 963 y(c)670 964 y Fl(\015)p Fm(1992,)g(1993)g
(Kurt)h(M.)g(Bisc)o(ho\013)p eop
%%Page: 1 2
1 1 bop 164 162 a Fk(CONTENTS)1318 b Fn(1)164 315 y Fo(Con)n(ten)n(ts)
164 424 y Fj(1)45 b(Ov)n(erview)18 b(of)g(Use)1115 b(4)164
533 y(2)45 b(Preliminary)1224 b(5)164 642 y(3)45 b(A)n(ttribute)18
b(declarations)973 b(6)237 703 y Fn(3.1)50 b(Seman)o(tics)15
b(of)h(attribute)g(declarations)43 b Fi(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f
(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)69 b Fn(7)164 811 y Fj(4)45
b(Rules)18 b(and)h(attribute)f(o)r(ccurrences)730 b(7)164
920 y(5)45 b(A)n(ttribute)18 b(de\014nitions)1013 b(8)237
981 y Fn(5.1)50 b(Inherited)15 b(vs.)22 b(syn)o(thesized)14
b(attributes)32 b Fi(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)69 b Fn(8)237 1041 y(5.2)50 b(A)o(ttribute)15
b(reference)g(sections)h(in)g(the)g(Y-\014le)43 b Fi(:)25
b(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)69 b Fn(9)349
1101 y(5.2.1)56 b(Explicit)15 b(mo)q(de)25 b Fi(:)g(:)f(:)h(:)f(:)g(:)h
(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(10)349 1161 y(5.2.2)56 b(Implicit)13 b(mo)q(de)26
b Fi(:)f(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)
h(:)f(:)h(:)f(:)h(:)f(:)44 b Fn(11)349 1221 y(5.2.3)56
b(Mixed)15 b(mo)q(de)22 b Fi(:)i(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)
h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(11)237 1282 y(5.3)50 b(A)o(ttribute)15 b(reference)g(sections)h
(in)g(the)g(L-\014le\(s\))32 b Fi(:)24 b(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)
h(:)f(:)44 b Fn(12)349 1342 y(5.3.1)56 b(Generalit)o(y)15
b(of)i(Ox)43 b Fi(:)25 b(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)
f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fn(12)349 1402 y(5.3.2)56
b(Ox)16 b(adaptation)i(to)f(Lex's)e(line-orien)o(ted)g(syn)o(tax)45
b Fi(:)24 b(:)h(:)f(:)h(:)f(:)44 b Fn(13)349 1462 y(5.3.3)56
b(Resolution)16 b(of)h(am)o(biguit)o(y)d(regarding)j(tok)o(en)f
(returned)35 b Fi(:)25 b(:)f(:)44 b Fn(14)237 1522 y(5.4)50
b(Cycles)36 b Fi(:)24 b(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g
(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)
44 b Fn(15)164 1631 y Fj(6)h(T)-5 b(ranslation)19 b(in)n(to)f(C)i(co)r
(de)909 b(15)164 1740 y(7)45 b(T)-5 b(emp)r(oral)17 b(b)r(eha)n(vior)h
(of)g(Ox-generated)f(ev)m(aluators)348 b(15)237 1800
y Fn(7.1)50 b(Stac)o(k)16 b(op)q(erations)51 b Fi(:)25
b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g
(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fn(15)237 1861 y(7.2)50
b(Placemen)o(t)14 b(of)j(generated)f(co)q(de)23 b Fi(:)h(:)h(:)f(:)h(:)
f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(16)237 1921 y(7.3)50 b(Decoration)17 b(and)g(the)f(ready)g(set)d
Fi(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)44 b Fn(17)164 2030 y Fj(8)h(Programming)16
b(st)n(yle)1022 b(17)164 2139 y(9)45 b(P)n(ostdecoration)19
b(tra)n(v)n(ersals)872 b(18)237 2199 y Fn(9.1)50 b(Example:)20
b(in\014x)c(to)g(pre\014x)g(translation)31 b Fi(:)24
b(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(18)237 2259 y(9.2)50 b(General)16 b(description)27
b Fi(:)d(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)
g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fn(21)349 2319 y(9.2.1)56
b(T)l(ra)o(v)o(ersal)16 b(sp)q(eci\014cations)24 b Fi(:)h(:)f(:)h(:)f
(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(21)349 2380 y(9.2.2)56 b(T)l(ra)o(v)o(ersal)16 b(action)g(sp)q
(eci\014cations)32 b Fi(:)25 b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)44 b Fn(22)p eop
%%Page: 2 3
2 2 bop 164 162 a Fk(CONTENTS)1318 b Fn(2)164 307 y Fj(10)17
b(Ox)h(macros)1227 b(23)237 367 y Fn(10.1)26 b(Macro)17
b(de\014nitions)33 b Fi(:)25 b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(23)237 428 y(10.2)26 b(Macro)17 b(uses)12 b Fi(:)25
b(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h
(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fn(24)237
488 y(10.3)26 b(Example)e Fi(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)
f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h
(:)f(:)44 b Fn(24)164 597 y Fj(11)17 b(Automatic)g(generation)h(of)h
(cop)n(y)f(rules)624 b(25)237 657 y Fn(11.1)26 b(Example)e
Fi(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h
(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(27)164 766 y Fj(12)17 b(File-lev)n(el)f(organization)i(of)h(Ox)f
(ev)m(aluators)527 b(29)237 826 y Fn(12.1)26 b(Con)o(v)o(en)o(tions)16
b(of)h(naming)e(Ox)h(output)h(\014les)38 b Fi(:)24 b(:)h(:)f(:)h(:)f(:)
g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fn(29)237 886 y(12.2)26
b(Review:)20 b(com)o(bining)15 b(the)h(outputs)h(of)f(Y)l(acc)g(and)h
(Lex)64 b Fi(:)25 b(:)f(:)h(:)f(:)h(:)f(:)44 b Fn(29)237
946 y(12.3)26 b(Com)o(bined)15 b(use)h(of)h(Ox,)e(Y)l(acc,)g(and)i(Lex)
59 b Fi(:)25 b(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(30)237 1007 y(12.4)26 b(T)o(ypical)15 b(command)g(sequences)30
b Fi(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)44 b Fn(30)164 1116 y Fj(13)17 b(Command-line)f(options)i
(and)h(other)f(p)r(oin)n(ts)511 b(30)237 1176 y Fn(13.1)26
b(Error)17 b(reco)o(v)o(ery)h Fi(:)25 b(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g
(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)
44 b Fn(31)237 1236 y(13.2)26 b(Memory)15 b(alignmen)o(t)38
b Fi(:)24 b(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f
(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fn(31)237 1296 y(13.3)26
b(Stripping)16 b(Ox)g(constructs)47 b Fi(:)25 b(:)f(:)g(:)h(:)f(:)h(:)f
(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(31)237 1356 y(13.4)26 b(Prev)o(en)o(ting)15 b(execution)g(of)i
(attribute)f(de\014nition)g(co)q(de)j Fi(:)24 b(:)h(:)f(:)h(:)f(:)h(:)f
(:)44 b Fn(32)237 1417 y(13.5)26 b(Con)o(trol)17 b(of)f(storage)i(allo)
q(cation)e(in)g(the)g(generated)g(ev)m(aluator)28 b Fi(:)c(:)h(:)f(:)44
b Fn(32)237 1477 y(13.6)26 b(P)o(arse)17 b(tree)e(statistics)25
b Fi(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)
g(:)h(:)f(:)h(:)f(:)h(:)f(:)44 b Fn(33)237 1537 y(13.7)26
b(Adjusting)16 b(the)g(sizes)g(of)h(Ox's)e(data)i(structures)31
b Fi(:)24 b(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(34)164 1646 y Fj(14)17 b(Example:)22 b(an)d(in)n(teger)f
(calculator)732 b(34)164 1755 y(15)17 b(Example:)22 b(a)d(binary)f(n)n
(um)n(b)r(er)g(translator)568 b(36)164 1864 y(16)17 b(Example:)22
b(translation)c(to)h(p)r(ost\014x)f(and)h(pre\014x)452
b(40)164 1973 y(A)31 b(Using)19 b(Ox)f(with)h(non-Lex)e(lexical)g
(analyzers)497 b(43)237 2033 y Fn(A.1)37 b(Default)16
b(con)o(text-sensitivit)o(y)e(of)j(L-\014le)f(prepro)q(cessing)49
b Fi(:)25 b(:)f(:)h(:)f(:)h(:)f(:)44 b Fn(43)237 2093
y(A.2)37 b(Ox-prepro)q(cessing)17 b(of)f(C-co)q(ded)i(lexical)c
(analyzers)43 b Fi(:)24 b(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)44
b Fn(43)349 2153 y(A.2.1)f(Example)22 b Fi(:)i(:)h(:)f(:)h(:)f(:)h(:)f
(:)g(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)h(:)f(:)g(:)h(:)f(:)h(:)f(:)h(:)
f(:)44 b Fn(43)164 2262 y Fj(B)33 b(T)-5 b(ra)n(v)n(ersal)19
b(seman)n(tics)1010 b(47)164 2371 y(C)33 b(List)18 b(of)h(reserv)n(ed)e
(w)n(ords)j(and)f(reserv)n(ed)f(\014le)f(names)355 b(50)p
eop
%%Page: 3 4
3 3 bop 164 162 a Fk(CONTENTS)1318 b Fn(3)164 307 y Fj(D)30
b(Summary)16 b(of)j(command-line)c(options)633 b(51)p
eop
%%Page: 4 5
4 4 bop 164 162 a Fk(1)49 b(O)o(VER)-5 b(VIEW)15 b(OF)h(USE)1048
b Fn(4)164 315 y Fo(1)83 b(Ov)n(erview)25 b(of)j(Use)164
425 y Fn(Lex)11 b(and)h(Y)l(acc)f(are)g(p)q(o)o(w)o(erful)g(and)h
(widely-used)e(to)q(ols)j(for)e(the)g(automatic)g(generation)164
485 y(of)j(language)h(recognizers.)20 b(Lex)13 b(accepts)h(a)g(set)g
(of)g(user-written)f(regular)h(expressions)164 545 y(and)22
b(writes)g(a)g(C)f(program)h(that)g(p)q(erforms)f(lexical)f(analysis)i
(according)g(to)g(those)164 606 y(expressions.)i(Y)l(acc)17
b(translates)g(user-written)g(grammar)f(rules)h(in)o(to)g(C)g(source)h
(co)q(de)164 666 y(for)13 b(a)g(syn)o(tax)f(analyzer.)20
b(While)12 b(they)g(a\013ord)i(\\ho)q(oks")g(for)f(execution)f(of)h
(hand-co)q(ded)164 726 y(C-language)22 b(seman)o(tic)c(actions,)j(Lex)f
(and)h(Y)l(acc)e(pro)o(vide)h(little)e(other)i(facilit)o(y)f(for)164
786 y(automatic)c(implem)o(en)o(tation)e(of)k(language)g(seman)o(tics.)
237 846 y(A)o(ttributed)e(parse)h(trees)f(are)h(often)g(used)g(as)g
(data)h(structures)f(in)f(ev)m(aluators)i(for)164 907
y(languages.)35 b(Often)20 b(the)h(language)g(implem)o(en)o(te)o(r)d
(hand-crafts)j(co)q(de)g(for)g(building,)164 967 y(tra)o(v)o(ersing,)12
b(and)i(ev)m(aluating)f(attributes)f(of)h(parse)g(trees,)g(and)g(for)g
(parse-tree-related)164 1027 y(memory)j(managemen)o(t.)26
b(A)18 b(Y)l(acc)g(sp)q(eci\014cation)g(de\014nes)h(a)g(con)o
(text-free)e(language)164 1087 y(and)h(a)g(mapping)f(from)f(the)h(set)h
(of)f(legal)g(sen)o(tences)g(to)h(the)f(set)g(of)h(parse)g(trees,)f
(but)164 1147 y(co)q(de)f(for)h(parse-tree)f(managemen)o(t)e(is)i(not)h
(generated)f(automatically)e(b)o(y)i(Y)l(acc.)237 1207
y(The)23 b(Ox)430 1189 y Fh(1)473 1207 y Fn(user)g(can)f(sp)q(ecify)g
(a)i(language)f(using)g(the)g(familiar)e(languages)j(of)164
1268 y(Lex)14 b(and)h(Y)l(acc,)f(or)h(tak)o(e)f(an)h(existing)e(Lex/Y)l
(acc)h(sp)q(eci\014cation,)h(and)g(add)g(seman)o(tics)164
1328 y(to)k(the)e(language)j(b)o(y)d(augmen)o(ting)g(the)h(sp)q
(eci\014cation)g(\014les)g(with)g(declarations)g(and)164
1388 y(de\014nitions)e(of)h(t)o(yp)q(ed)e(attributes)i(of)f(parse-tree)
g(no)q(des.)237 1448 y(That)h(sp)q(eci\014cation)e(constitutes)h(an)g
Fg(attribute)i(gr)n(ammar)5 b Fn(,)15 b(and)h(from)f(it)g(Ox)h(can)164
1508 y(automatically)c(generate)h(an)h Fg(evaluator)20
b Fn(written)13 b(in)g(Y)l(acc,)g(Lex,)g(and)h(C.)f(F)l(or)h(a)g(giv)o
(en)164 1569 y(input,)f(the)g(ev)m(aluator)h(builds)f(a)g(parse)h
(tree,)f(determines)e(an)i(order)h(of)f(ev)m(aluation)h(for)164
1629 y(attributes)j(of)h(the)f(tree,)f(and)i(p)q(erforms,)e(for)h(eac)o
(h)g(attribute,)g(the)g(seman)o(tic)e(action)164 1689
y(required)c(to)i(ev)m(aluate)e(it.)20 b(This)12 b(parse)h(tree)e(is)h
(managed)g(indep)q(enden)o(tly)f(of)h(an)o(y)g(trees)164
1749 y(managed)18 b(b)o(y)g(hand-written)h(C)g(co)q(de,)g(but)g
(information)f(ma)o(y)f(b)q(e)h(mo)o(v)o(ed)f(b)q(et)o(w)o(een)164
1809 y(the)f(ev)m(aluator-managed)h(tree)e(and)i(an)o(y)f(global)h
(data)g(structure.)237 1870 y(Additionally)l(,)c(the)i(Ox)g(user)g(can)
g(easily)f(sp)q(ecify)g(parse-tree)h(tra)o(v)o(ersals)f(that)i(are)164
1930 y(p)q(erformed)k(after)i(ev)m(aluation)f(of)h(the)f(tree's)g
(attributes)g(and)h(that)g(refer)f(to)h(those)164 1990
y(attributes.)38 b(Suc)o(h)21 b(tra)o(v)o(ersals)h(greatly)f(simplify)e
(tasks)k(suc)o(h)e(as)i(co)q(de)f(generation)164 2050
y(and)17 b(the)f(gathering)h(of)f(compilation)f(statistics.)237
2110 y(The)k(language)h(designer)f(is)g(freed)f(from)g(the)g(tedious)h
(and)h(error-prone)f(details)164 2171 y(of)24 b(writing)g(co)q(de)g
(for)g(parse-tree)g(managemen)o(t.)42 b(Ox-generated)23
b(ev)m(aluators)i(use)164 2231 y(memory-m)o(anageme)o(n)o(t)16
b(tec)o(hniques)i(that)h(bring)g(large)g(time-e\016cienc)o(y)d(gains)k
(o)o(v)o(er)p 164 2274 648 2 v 220 2305 a Ff(1)239 2320
y Fe(The)13 b(name)f(\\Ox")h(originated)g(as)g(a)g(homophone)e(for)i
(an)g(acron)o(ym)f(for)h(\\An)g(A)o(ttribute)h(Gram-)164
2370 y(mar)f(Compiling)d(System".)18 b(It)c(w)o(as)g(noticed)h(later)f
(that)g(ev)o(ery)h(y)o(ak)f(is)f(an)h(o)o(x)g(and)g(that)g(Ox)g(gener-)
164 2420 y(alizes)g(the)g(function)g(of)f(Y)m(acc.)p
eop
%%Page: 5 6
5 5 bop 164 162 a Fk(2)49 b(PRELIMINAR)l(Y)1166 b Fn(5)164
307 y(hand-built)15 b(ev)m(aluators)g(that)h(use)e(the)h(common)d(tec)o
(hnique)h(of)j(calling)d Fd(malloc)g Fn(once)164 367
y(for)i(eac)o(h)f(parse-tree)g(no)q(de.)21 b(Also,)15
b(Ox)f(pro)o(vides)g(securit)o(y)f(b)o(y)h(testing)g(the)g
(de\014nition)164 428 y(for)j(consistency)f(and)i(completeness,)c(and)k
(the)f(Ox-generated)f(ev)m(aluator)i(p)q(erforms)164
488 y(tests)24 b(to)g(ensure)g(that)g(a)g(circular)f(de\014nition)g
(has)h(not)h(prev)o(en)o(ted)d(ev)m(aluation)i(of)164
548 y(attributes.)237 608 y(Ox)17 b(is)f(a)i(prepro)q(cessor)f(that)g
(accepts)g(t)o(w)o(o)g(or)g(more)e(\014les,)h(and)i(translates)f(these)
164 668 y(in)o(to)e(\014les)g(suitable)g(for)h(input)f(to)h(Lex)895
650 y Fh(2)930 668 y Fn(and)g(Y)l(acc.)k(With)15 b(few)h(exceptions,)e
(all)h(Lex-)164 729 y(input/Y)l(acc-input)i(pairs)g(of)h(\014les)f
(that)g(constitute)g(recognizers)g(or)g(translators)i(are)164
789 y(legal)14 b(inputs)h(to)g(Ox.)20 b(Th)o(us)15 b(m)o(uc)o(h)d
(existing)i(soft)o(w)o(are)g(is)h(amenable)e(to)i(mo)q(di\014cation)164
849 y(using)21 b(Ox,)f(and)h(implem)o(en)o(tations)d(that)i(use)h(Ox)f
(can)g(b)q(e)h(con)o(v)o(erted)e(step)o(wise)g(b)o(y)164
909 y(hand)i(to)g(\\pure")h(Lex/Y)l(acc)e(implem)o(en)n(tations.)32
b(This)21 b(mak)o(es)e(Ox)h(w)o(ell-suited)g(to)164 969
y(language)g(designers,)g(exp)q(erimen)o(ters,)d(and)j(implem)o(en)o
(ter)o(s)d(already)j(familiar)d(with)164 1029 y(Lex,)f(Y)l(acc,)f(and)i
(C.)164 1196 y Fo(2)83 b(Preliminary)164 1305 y Fn(It)17
b(is)h(assumed)g(that)g(the)g(reader)f(is)h(familiar)e(with)i(the)f
(use)h(of)h(Y)l(acc)e([Johnson)g(75)q(],)164 1366 y(Lex)f([Lesk)g(75)q
(],)g(and)h(C)f([KR)g(88)q(];)f(Ox)h(syn)o(tactic)g(constructs)h(are)f
(describ)q(ed)g(mainly)164 1426 y(as)g(augmen)o(tations)f(of)g(the)g
(languages)i(accepted)d(b)o(y)h(those)h(to)q(ols.)1437
1408 y Fh(3)1478 1426 y Fn(Prior)g(acquain-)164 1486
y(tance)i(with)g(the)g(basic)h(ideas)f(of)h(attribute)f(grammars)f
(\(for)h(instance,)g(as)h(found)g(in)164 1546 y([W)l(aite)c(84)q(])h
(or)h([Aho)e(86)q(]\))h(is)g(helpful.)237 1606 y(An)h(Ox)f(input)g(sp)q
(eci\014cation)h(consists)g(of)g(at)g(least)g(t)o(w)o(o)f(\014les:)22
b(a)17 b(syn)o(tactic)f(sp)q(ec-)164 1667 y(i\014cation)j(\(whic)o(h)f
(resem)o(bles)f(a)i(Y)l(acc)g(input)g(sp)q(eci\014cation)g(and)g(is)g
(called)f(a)i Fg(Y-\014le)p Fn(\))164 1727 y(that)f(Ox)g(translates)g
(in)o(to)g(a)g(Y)l(acc)g(input)f(sp)q(eci\014cation,)h(and)h(one)f(or)g
(more)f(lexical)164 1787 y(sp)q(eci\014cations)c(\(whic)o(h)f(resem)o
(ble)e(Lex)j(input)g(sp)q(eci\014cations)g(and)h(are)f(called)e
Fg(L-\014le)p Fn(s\))164 1847 y(that)j(Ox)f(translates)h(in)o(to)e(Lex)
i(input)f(sp)q(eci\014cations.)20 b(Usually)14 b(there)g(is)g(exactly)f
(one)164 1907 y(L-\014le,)21 b(but)f(an)g(ev)m(aluator)h(that)f(uses)g
(more)f(than)i(one)f(lexical)e(analyzer)i([Lesk)c(75])164
1967 y(ma)o(y)i(b)q(e)h(constructed)g(b)o(y)f(submitting)g(to)i(Ox)e
(more)g(than)i(one)f(L-\014le.)30 b(This)20 b(man-)164
2028 y(ual)h(presen)o(ts)f(descriptions)g(of)h(the)g(Ox-sp)q(eci\014c)e
(constructs)i(that)h(ma)o(y)d(app)q(ear)i(in)164 2088
y(these)f(\014les,)h(as)g(w)o(ell)f(as)h(p)q(ertinen)o(t)e(underlying)h
(concepts.)34 b(These)21 b(constructs)g(are)164 2148
y(illustrated)15 b(mainly)f(b)o(y)i(using)h(fragmen)o(ts)e(of)i(three)e
(examples)f(of)j(Ox)f(input)g(sp)q(eci\014-)p 164 2192
648 2 v 220 2222 a Ff(2)239 2237 y Fe(The)11 b(general)f(descriptions)i
(in)e(this)h(man)o(ual)d(assume)i(the)h(use)g(of)f(a)g(Lex-based)i
(lexical)d(analyzer.)164 2287 y(It)i(is)f(p)q(ossible,)h(ho)o(w)o(ev)o
(er,)g(to)f(use)i(Ox)e(with)h(lexical)e(analyzers)i(hand-written)g(in)f
(C:)g(details)g(are)h(giv)o(en)164 2337 y(separately)j(\(in)g(app)q
(endix)g(A\).)220 2372 y Ff(3)239 2387 y Fe(\\Y)m(acc",)e(\\Lex",)g
(and)g(\\C")g(can,)h(in)f(this)h(man)o(ual,)d(b)q(e)j(tak)o(en)g(to)f
(mean)f(\\Y)m(acc)i(or)g(Bison",)f(\\Lex)164 2437 y(or)i(Flex",)f(and)h
(\\C)f(or)h(C++",)g(resp)q(ectiv)o(ely)m(.)p eop
%%Page: 6 7
6 6 bop 164 162 a Fk(3)49 b(A)l(TTRIBUTE)15 b(DECLARA)l(TIONS)814
b Fn(6)164 307 y(cations,)16 b(the)g(complete)e(texts)i(of)g(whic)o(h)g
(app)q(ear)h(in)f(sections)g(14,)h(15,)f(and)h(16.)237
367 y(Within)24 b(Ox-sp)q(eci\014c)g(constructs,)j(C-st)o(yle)d(and)i
(C++-st)o(yle)e(commen)n(ts)e(ma)o(y)164 428 y(app)q(ear)27
b(an)o(ywhere)e(whitespace)g(ma)o(y)g(app)q(ear.)51 b(The)25
b(global)h(iden)o(ti\014ers)f(of)h(Ox-)164 488 y(generated)c(C)h(co)q
(de,)g(lik)o(e)e(those)h(generated)g(b)o(y)g(Y)l(acc)g(and)g(Lex,)i
(are)e(pre\014xed)f(b)o(y)164 548 y Fd(yy)p Fn(,)e(so)i(the)e(Ox)g
(user)h(can)g(a)o(v)o(oid)f(name)g(con\015icts)g(in)g(the)h(generated)f
(ev)m(aluator)h(b)o(y)164 608 y(abstaining)d(from)e(the)h(use)g(of)h
(global)g(iden)o(ti\014ers)d(that)j(b)q(egin)g(with)f
Fd(yy)p Fn(.)164 775 y Fo(3)83 b(A)n(ttribute)27 b(declarations)164
884 y Fn(As)17 b(describ)q(ed)f(in)h([Johnson)g(75)q(],)g(the)g
(declarations)g(section)f(of)i(a)f(Y)l(acc)g(input)g(sp)q(ec-)164
944 y(i\014cation)g(is)h(the)g(part)g(that)g(precedes)f(the)g(\014rst)i
Fd(\045\045)e Fn(mark,)f(and)i(in)g(it)f(the)h(user)f(ma)o(y)164
1004 y(declare)c(the)h(start)g(sym)o(b)q(ol,)f(tok)o(ens,)h(asso)q
(ciativities,)f(unions,)i(C)f(co)q(de)g(sections,)g(etc.)164
1065 y(The)h(Y-\014le)f(con)o(tains)h(suc)o(h)f(a)i(declarations)f
(section,)f(and)h(in)g(it)f(are)h(p)q(ermitted)e(all)i(of)164
1125 y(the)g(constructs)g(of)g(Y)l(acc)g(declarations)g(sections,)f(as)
i(w)o(ell)d(as)j(Ox)30 b Fg(attribute)17 b(de)n(clar)n(a-)164
1185 y(tions)t Fn(.)29 b(An)18 b(attribute)h(declaration)f(consists)h
(of)g(the)g(reserv)o(ed)e(w)o(ord)i Fd(@attribute)o(s)164
1245 y Fn(follo)o(w)o(ed)13 b(b)o(y)g Fc(f)p Fn(,)h(an)g(attribute)f
(declaration)g(list,)g Fc(g)p Fn(,)h(and)g(a)g(list)f(of)h(grammar)e
(sym)o(b)q(ols.)237 1305 y(Supp)q(ose)23 b(that)g(a)f(grammar)f(has)i
(a)f(sym)o(b)q(ol)f Fd(bitlist)f Fn(and)j(the)e(follo)o(wing)h(at-)164
1366 y(tribute)16 b(declaration:)292 1467 y Fd(@attribute)o(s)23
b({float)g(value;)h(int)g(scale,leng)o(th;)o(})f(bitlist)164
1569 y Fn(Then)c(the)g(Ox-generated)h(ev)m(aluator,)g(when)f(building)g
(a)g(parse-tree)h(no)q(de)g(lab)q(eled)164 1629 y Fd(bitlist)p
Fn(,)10 b(allo)q(cates)i(storage)h(for)f(a)g(\015oat)h(named)e
Fd(value)f Fn(and)j(in)o(tegers)e(named)g Fd(scale)164
1689 y Fn(and)17 b Fd(length)p Fn(.)237 1750 y(An)g(attribute)f
(declaration)h(list)f(\(in)g(the)h(previous)g(example,)d(the)j(part)g
(b)q(et)o(w)o(een)164 1810 y(curly)23 b(braces\))h(resem)o(bles)e(a)i
(C)h(structure)f(declaration)g(list.)44 b(Digit)24 b(strings)g(and)164
1870 y(C-st)o(yle)d(iden)o(ti\014ers,)g(as)h(w)o(ell)e(as)i(the)f
(follo)o(wing)g(c)o(haracters)h(and)g(reserv)o(ed)e(w)o(ords,)164
1930 y(arranged)d(according)g(to)f(C)h(syn)o(tax,)e(are)i(legal)f(in)f
(attribute)h(declaration)g(lists:)369 2032 y Fd(*)25
b(:)h(;)f(,)g(char)f(short)g(int)h(long)f(float)g(double)472
2092 y(signed)f(unsigned)g(struct)g(union)h(enum)164
2194 y Fn(Note)15 b(that)i(curly)e(braces)h(ma)o(y)e(not)i(app)q(ear)h
(inside)e(\(and)i(so)f(structures)g(and)g(unions)164
2254 y(ma)o(y)21 b(not)h(b)q(e)g(declared)g(inside\))f(attribute)h
(declaration)g(lists.)38 b(Despite)22 b(this,)h(an)o(y)164
2314 y(fundamen)o(tal)12 b(or)h(deriv)o(ed)f(t)o(yp)q(e)g(p)q(ermitted)
f(in)i(a)h(C)f(program)g(ma)o(y)e(b)q(e)j(used)f(as)h(an)f(at-)164
2374 y(tribute)f(t)o(yp)q(e)h(sp)q(eci\014er:)19 b(Y)l(acc)12
b(input)h(sp)q(eci\014cations)g(often)h(con)o(tain)e(C)i(co)q(de)f
(sections)164 2434 y(b)q(et)o(w)o(een)i Fd(\045)p Fc(f)h
Fn(and)h Fd(\045)p Fc(g)p Fn(,)f(and)h(these)f(are)h(also)g(p)q
(ermitted)d(in)i(Ox)g(input)g(sp)q(eci\014cations.)p
eop
%%Page: 7 8
7 7 bop 164 162 a Fk(4)49 b(R)o(ULES)16 b(AND)g(A)l(TTRIBUTE)f
(OCCURRENCES)523 b Fn(7)164 307 y(An)o(y)12 b(t)o(yp)q(e)h(name)f(giv)o
(en)g(meaning)g(b)o(y)g(using)i Fd(struct)p Fn(,)d Fd(union)p
Fn(,)g Fd(typedef)p Fn(,)g(or)i Fd(#define)164 367 y
Fn(in)j(a)h(previous)f(C)g(co)q(de)g(section)g(ma)o(y)f(b)q(e)h(used)h
(as)g(an)f(attribute)g(t)o(yp)q(e)g(sp)q(eci\014er.)237
428 y(The)h(list)e(of)i(grammar)e(sym)o(b)q(ols)g(follo)o(wing)i
Fc(g)f Fn(is)g(a)h(p)q(ossibly)g(empt)o(y)d(list)i(of)h(Y)l(acc)164
488 y(tok)o(ens)c(\(including)g(c)o(haracter)g(constan)o(ts\))i(and)f
(non)o(terminals,)e(mem)o(b)q(ers)f(of)j(the)g(list)164
548 y(b)q(eing)i(separated)h(b)o(y)f(whitespace.)237
608 y(All)10 b(uses)h(of)g(the)f(Y)l(acc)h(reserv)o(ed)e(w)o(ords)i
Fd(\045token)p Fn(,)f Fd(\045left)p Fn(,)f Fd(\045right)p
Fn(,)h(and)h Fd(\045nonassoc)164 668 y Fn(m)o(ust)k(precede)g(all)h(of)
g(the)g(attribute)g(declarations.)164 813 y Fb(3.1)70
b(Seman)n(tics)21 b(of)i(attribute)f(declarations)164
905 y Fn(An)15 b(attribute)g(declaration)h(informs)e(Ox)h(that)h(eac)o
(h)f(sym)o(b)q(ol)g(in)g(the)g(grammar)f(sym-)164 965
y(b)q(ol)23 b(list)e(has)i(attributes)g(of)f(the)g(names)g(and)h(t)o
(yp)q(es)f(app)q(earing)h(in)f(the)g(attribute)164 1025
y(declaration)17 b(list.)24 b(If)17 b Fi(a)g Fn(app)q(ears)i(in)e(the)g
(attribute)g(declaration)g(list)g(and)h Fi(s)g Fn(app)q(ears)164
1086 y(in)13 b(the)g(grammar)f(sym)o(b)q(ol)g(list,)h(then)g
Fi(a)h Fn(is)f(said)h(to)f Fg(b)n(elong)20 b Fn(to)14
b Fi(s)f Fn(or)h(to)g(b)q(e)f(an)h(attribute)164 1146
y(of)20 b Fi(s)p Fn(.)32 b(Eac)o(h)20 b(grammar)e(sym)o(b)q(ol)g(has)j
(its)e(o)o(wn)h(attribute)g(name)e(space.)32 b(When)20
b(the)164 1206 y(ev)m(aluator)i(creates)e(a)i(no)q(de)f(lab)q(eled)g(b)
o(y)g(one)g(of)g(the)g(listed)f(sym)o(b)q(ols,)h(it)g(allo)q(cates)164
1266 y(storage)i(of)e(the)h(sp)q(eci\014ed)f(t)o(yp)q(e)g(for)h(eac)o
(h)f(of)h(the)f(named)g(attributes.)37 b(A)21 b(storage)164
1326 y(lo)q(cation)e(so)g(allo)q(cated)g(is)f(called)g(an)h
Fg(attribute)h(instanc)n(e)k Fn(\(concisely)l(,)17 b(an)i
Fg(instanc)n(e)t Fn(\))164 1387 y(in)d(the)g(parse)h(tree.)j(Instances)
c(ma)o(y)f(b)q(e)h(said)h(to)f Fg(b)n(elong)23 b Fn(to)16
b(no)q(des.)164 1553 y Fo(4)83 b(Rules)26 b(and)h(attribute)h(o)r
(ccurrences)164 1663 y Fn(Y)l(acc)16 b(grammar)e(rules)i(\(pro)q
(ductions\),)h(and)g(the)f(ob)s(jects)g(of)g Fd(return)e
Fn(statemen)o(ts)h(in)164 1723 y(Lex)g(actions)g(\(eac)o(h)f(suc)o(h)g
(ob)s(ject)h(b)q(eing)g(a)g(tok)o(en\),)f(are)h(here)f(referred)g(to)h
(generically)164 1783 y(as)i Fg(rules)t Fn(.)k(Since)15
b(Ox)h(accepts)g(the)g(constructs)g(of)g(Y)l(acc)g(and)g(Lex,)g(and)g
(passes)h(these)164 1843 y(unc)o(hanged,)g(the)g(corresp)q(onding)h
(constructs)f(of)g(Ox)g(input)f(sp)q(eci\014cations)h(are)g(also)164
1903 y(called)k Fg(rules)t Fn(.)38 b(Eac)o(h)22 b(rule)f(is)g(view)o
(ed)f(as)j(a)f(sequence)e(of)j(grammar)d(sym)o(b)q(ols,)h(the)164
1964 y(ob)s(ject)10 b(of)i(eac)o(h)e Fd(return)f Fn(statemen)o(t)h(in)g
(a)i(Lex)f(action)g(b)q(eing)g(a)g(sequence)f(consisting)i(of)164
2024 y(a)g(single)f(grammar)f(sym)o(b)q(ol.)18 b(The)12
b(leftmost)e(sym)o(b)q(ol)g(of)i(a)f(rule)g(is)h(called)e(the)h
Fg(left-hand)164 2084 y(side)20 b Fn(\()p Fg(LHS)6 b
Fn(\).)17 b(The)f Fg(right-hand)j(side)h Fn(\()p Fg(RHS)6
b Fn(\))17 b(comprises)e(the)h(rule's)g(other)g(sym)o(b)q(ols.)164
2144 y(A)24 b(sym)o(b)q(ol's)f(p)q(osition)h(in)g(a)h(rule)f(together)g
(with)g(an)h(attribute)f(of)h(that)f(sym)o(b)q(ol)164
2204 y(constitute)17 b(an)g Fg(attribute)j(o)n(c)n(curr)n(enc)n(e)g
Fn(\(concisely)l(,)c(an)h Fg(o)n(c)n(curr)n(enc)n(e)t
Fn(\))g(in)g(that)g(rule.)23 b(If)164 2264 y(the)18 b(attribute)f(in)h
(question)g(is)g Fi(a)p Fn(,)f(the)h(o)q(ccurrence)f(is)h(said)g(to)h
(b)q(e)f(an)g Fg(o)n(c)n(curr)n(enc)n(e)h(of)164 2325
y Fi(a)p Fn(.)i(Supp)q(osing)c(the)f Fd(@attributes)d
Fn(declaration)j(of)g(section)g(3)h(and)g(the)f(rule:)292
2426 y Fd(num)127 b(:)179 b(bitlist)23 b(DOT)127 b(bitlist)p
eop
%%Page: 8 9
8 8 bop 164 162 a Fk(5)49 b(A)l(TTRIBUTE)15 b(DEFINITIONS)880
b Fn(8)164 307 y(the)23 b(attribute)h(o)q(ccurrence)f
Fd(scale)e Fn(of)j(the)g(leftmost)e(app)q(earance)i(of)g
Fd(bitlist)d Fn(is)164 367 y(denoted)j(in)f(Ox)g(co)q(de)h(as)g
Fd(bitlist.0.)o(sca)o(le)o Fn(,)e(while)h(the)g(attribute)h(o)q
(ccurrence)164 428 y Fd(scale)12 b Fn(of)h(the)h(righ)o(tmost)e(app)q
(earance)i(of)g Fd(bitlist)d Fn(is)i(denoted)h Fd(bitlist.1.)o(sc)o
(ale)o Fn(.)237 488 y(In)19 b(general,)g(attribute)g(o)q(ccurrences)g
(are)g(named)f(b)o(y)h(a)g(grammar)f(sym)o(b)q(ol,)g(fol-)164
548 y(lo)o(w)o(ed)13 b(b)o(y)h(a)h(p)q(erio)q(d,)f(follo)o(w)o(ed)g
(optionally)g(b)o(y)f(a)i(non-negativ)o(e)f(decimal)e(in)o(teger)h(and)
164 608 y(another)20 b(p)q(erio)q(d,)g(follo)o(w)o(ed)f(b)o(y)f(the)h
(name)g(of)g(an)h(attribute)f(of)h(that)g(sym)o(b)q(ol.)29
b(The)164 668 y(in)o(teger)12 b(and)i(the)f(second)h(p)q(erio)q(d)f
(are)h(needed)e(only)h(when)h(a)f(giv)o(en)g(grammar)e(sym)o(b)q(ol)164
729 y(app)q(ears)k(more)e(than)i(once)f(in)g(the)g(rule,)g(in)g(whic)o
(h)f(case)i(those)f(distinct)g(app)q(earances)164 789
y(are)h(n)o(um)o(b)q(ered)f(from)g(left)g(to)i(righ)o(t)f(with)g
(consecutiv)o(e)f(increasing)h(in)o(tegers)f(starting)164
849 y(with)i Fd(0)p Fn(.)21 b(F)l(or)16 b(a)h(sym)o(b)q(ol)e
Fd(X)h Fn(with)g(an)h(attribute)f Fd(a)p Fn(,)f Fd(X.a)g
Fn(is)h(a)h(synon)o(ym)e(for)h Fd(X.0.a)p Fn(.)237 909
y(A)k(giv)o(en)e(rule)i(and)g(an)g(attribute)g(o)q(ccurrence)f(in)g
(that)i(rule)e(constitute)g(an)h Fg(at-)164 969 y(tribute)e(o)n(c)n
(curr)n(enc)n(e)i Fn(in)c(the)g(grammar.)164 1136 y Fo(5)83
b(A)n(ttribute)27 b(de\014nitions)164 1245 y Fn(F)l(or)20
b(eac)o(h)g(rule,)g(the)g(Ox)g(user)g(ma)o(y)f(pro)o(vide)h(an)g
Fg(attribute)i(r)n(efer)n(enc)n(e)g(se)n(ction)t Fn(,)f(de-)164
1305 y(limited)15 b(b)o(y)j Fd(@)p Fc(f)g Fn(and)g Fd(@)p
Fc(g)p Fn(,)g(and)h(optionally)f(con)o(taining)g(de\014nitions)g(of)g
(attribute)g(o)q(c-)164 1366 y(currences)i(of)h(the)f(giv)o(en)g(rule.)
34 b(A)o(ttribute)19 b(o)q(ccurrences)h(ma)o(y)g(b)q(e)g(de\014ned)h
(therein)164 1426 y(in)16 b(terms)f(of)i(the)g(rule's)f(other)g
(attribute)h(o)q(ccurrences)f(and)h(C)g(co)q(de)g(suc)o(h)f(as)i
(global)164 1486 y(v)m(ariables,)e(constan)o(ts,)g(macros,)f(and)i
(function)f(calls.)164 1630 y Fb(5.1)70 b(Inherited)21
b(vs.)31 b(syn)n(thesized)22 b(attributes)164 1723 y
Fn(An)16 b(attribute)g(o)q(ccurrence)f Fi(o)i Fn(in)f(a)h(rule)e
Fi(R)i Fn(is)f Fg(synthesize)n(d)22 b Fn(if)15 b(and)i(only)f(if)224
1824 y(1.)24 b Fi(o)17 b Fn(is)f(on)g(the)g(LHS)h(of)f
Fi(R)h Fn(and)g(the)f(attribute)g(reference)f(section)g(of)i
Fi(R)g Fn(con)o(tains)286 1885 y(a)g(de\014nition)e(of)i
Fi(o)p Fn(,)f(or)224 1986 y(2.)24 b Fi(o)16 b Fn(is)g(on)g(the)g(RHS)f
(of)i Fi(R)f Fn(and)g(the)g(attribute)g(reference)e(section)h(of)h
Fi(R)h Fn(con)o(tains)286 2047 y(no)g(de\014nition)e(of)i
Fi(o)p Fn(.)237 2148 y(An)f(attribute)g(o)q(ccurrence)g
Fi(o)g Fn(in)g(a)h(rule)e Fi(R)i Fn(is)f Fg(inherite)n(d)22
b Fn(if)15 b(and)i(only)f(if)224 2250 y(1.)24 b Fi(o)17
b Fn(is)f(on)g(the)g(LHS)h(of)f Fi(R)h Fn(and)g(the)f(attribute)g
(reference)f(section)g(of)i Fi(R)g Fn(con)o(tains)286
2310 y(no)g(de\014nition)e(of)i Fi(o)p Fn(,)f(or)224
2412 y(2.)24 b Fi(o)16 b Fn(is)g(on)g(the)g(RHS)f(of)i
Fi(R)f Fn(and)g(the)g(attribute)g(reference)e(section)h(of)h
Fi(R)h Fn(con)o(tains)286 2472 y(a)g(de\014nition)e(of)i
Fi(o)p Fn(.)p eop
%%Page: 9 10
9 9 bop 164 162 a Fk(5)49 b(A)l(TTRIBUTE)15 b(DEFINITIONS)880
b Fn(9)237 307 y(An)18 b(error)f(message)g(is)h(issued)g(if)f(an)h
(attribute)f(is)h(found)g(to)h(ha)o(v)o(e)d(b)q(oth)j(syn)o(the-)164
367 y(sized)c(and)h(inherited)e(o)q(ccurrences)i(in)f(the)g(grammar.)20
b(An)15 b(attribute)g(is)h Fg(synthesize)n(d)164 428
y Fn(if)23 b(and)h(only)g(if)f(it)g(has)i(at)f(least)f(one)h(o)q
(ccurrence,)g(and)h(its)e(ev)o(ery)f(o)q(ccurrence)h(is)164
488 y(syn)o(thesized.)c(An)c(attribute)f(is)g Fg(inherite)n(d)20
b Fn(if)14 b(and)h(only)g(if)f(it)g(has)h(at)g(least)g(one)f(o)q(ccur-)
164 548 y(rence,)k(and)g(its)h(ev)o(ery)d(o)q(ccurrence)i(is)g
(inherited.)27 b(It)17 b(follo)o(ws)i(from)e(the)h(ab)q(o)o(v)o(e)g
(that)164 608 y(the)c(grammar's)f(start)i(sym)o(b)q(ol)e(ma)o(y)g(ha)o
(v)o(e)h(only)g(syn)o(thesized)f(attributes.)21 b(Referring)164
668 y(to)e(returned)f(tok)o(ens)g(as)h(rules)f(emphasizes)f(the)h
(equal)g(status)h(of)g(tok)o(ens)f(and)h(non-)164 729
y(terminals,)e(inasm)o(uc)o(h)g(as)i(eac)o(h)f(kind)g(of)h(sym)o(b)q
(ol)e(\(except)h(the)g(start)h(sym)o(b)q(ol\))e(ma)o(y)164
789 y(ha)o(v)o(e)d(b)q(oth)h(syn)o(thesized)e(and)i(inherited)e
(attributes.)20 b(Since)14 b(eac)o(h)g(sym)o(b)q(ol)f(has)i(a)g(dis-)
164 849 y(tinct)j(name)g(space)i(\(section)e(3.1\),)i(same-named)d
(attributes)i(of)h(di\013eren)o(t)e(sym)o(b)q(ols)164
909 y(are)h(di\013eren)o(t)f(attributes,)h(and)h(ma)o(y)d(di\013er)i
(as)g(to)h(whether)e(they)h(are)g(inherited)f(or)164
969 y(syn)o(thesized.)237 1029 y(F)l(or)e(eac)o(h)f(parse-tree)g(no)q
(de)h(except)f(the)g(ro)q(ot)i(no)q(de,)e(t)o(w)o(o)h(rules)f(of)h(the)
f(Ox)g(input)164 1090 y(sp)q(eci\014cation)21 b(are)h(of)g(particular)f
(in)o(terest.)36 b(The)22 b Fg(home)g(rule)k Fn(is)21
b(the)h(rule)e(applied)164 1150 y(at)i(the)g(no)q(de,)h(i.e.,)e(the)h
(rule)f(whose)i(LHS)f(is)f(the)h(lab)q(el)f(of)h(the)g(giv)o(en)f(no)q
(de,)i(and)164 1210 y(whose)c(RHS)g(sym)o(b)q(ols)e(are)i(the)g(lab)q
(els)f(of)h(the)g(c)o(hildren)e(of)i(the)f(no)q(de.)30
b(The)19 b Fg(p)n(ar)n(ent)164 1270 y(rule)24 b Fn(is)19
b(the)g(rule)g(applied)f(at)i(the)f(no)q(de's)h(paren)o(t.)31
b(The)19 b(attribute)g(de\014nition)g(of)h(a)164 1330
y(syn)o(thesized)c(attribute)h(instance)g(of)h(a)g(giv)o(en)e(no)q(de)i
(is)g(asso)q(ciated)g(with)f(the)g(no)q(de's)164 1391
y(home)i(rule)g(\(i.e.,)f(it)h(app)q(ears)i(in)f(the)f(attribute)h
(reference)e(section)h(for)h(that)g(rule\),)164 1451
y(and)d(de\014nitions)g(of)g(inherited)e(attribute)h(instances)h(are)g
(similarly)c(asso)q(ciated)18 b(with)164 1511 y(the)e(paren)o(t)g
(rule.)237 1571 y(In)i(a)g(legal)g(input)g(sp)q(eci\014cation,)g(eac)o
(h)f(attribute)h(of)g(a)h(sym)o(b)q(ol)e(app)q(earing)i(in)f(a)164
1631 y(rule)e(is)g(either)g(syn)o(thesized)f(or)i(inherited,)e(but)i
(not)g(b)q(oth,)g(so)h(the)e(de\014nitions)g(of)h(all)164
1692 y(attributes)f(\\\014t)h(together")g(completely)c(and)k(without)f
(con)o(tradiction.)164 1836 y Fb(5.2)70 b(A)n(ttribute)21
b(reference)g(sections)h(in)g(the)g(Y-\014le)164 1928
y Fn(The)c Fg(rules)i(se)n(ction)j Fn(of)c(a)g(Y)l(acc)f(\014le)g
(follo)o(ws)g(the)g(\014rst)h Fd(\045\045)f Fn(mark)f([Johnson)g(75)q
(],)h(and)164 1989 y(con)o(tains)g(the)h(pro)q(ductions)g(\(rules\))f
(of)g(the)g(grammar.)26 b(As)19 b(men)o(tioned)d(ab)q(o)o(v)o(e,)i(the)
164 2049 y(Ox)i(user)h(ma)o(y)e(augmen)o(t)g(eac)o(h)h(rule)g(b)o(y)g
(an)h(attribute)f(reference)f(section,)i(eac)o(h)f(of)164
2109 y(whic)o(h)d(is)g(delimited)d(b)o(y)j Fd(@)p Fc(f)g
Fn(and)h Fd(@)p Fc(g)p Fn(,)f(and)h(whic)o(h)f(con)o(tains)h(zero)f(or)
h(more)e Fg(attribute)164 2169 y(de\014nitions)t Fn(.)58
b(When)18 b(presen)o(t,)g(the)h(attribute)f(reference)f(section)h(is)g
(the)g(last)h(item)164 2229 y(\(other)c(than)h(a)g(terminating)e
(semicolon\))g(in)h(a)g(rule.)1180 2211 y Fh(4)1221 2229
y Fn(Conceptually)l(,)f(an)i(attribute)164 2290 y(de\014nition)g(has)g
(a)h Fg(dep)n(endency)h(p)n(art)36 b Fn(and)17 b(an)g
Fg(evaluation)h(p)n(art)5 b Fn(,)31 b(but)16 b(syn)o(tactically)l(,)p
164 2333 648 2 v 220 2364 a Ff(4)239 2379 y Fe(Th)o(us)c(it)f(do)q(es)i
(not)f(precede)i(an)o(y)d(Y)m(acc)i(action)e(or)h(the)g(Y)m(acc)h
(reserv)o(ed)h(w)o(ord)d Fa(\045prec)g Fe(in)h(the)g(rule,)164
2429 y(and)i(an)o(y)f(follo)o(wing)e(iden)o(ti\014er)k(m)o(ust)d(b)q(e)
j(the)f(LHS)g(of)g(the)g(next)h(rule.)p eop
%%Page: 10 11
10 10 bop 164 162 a Fk(5)49 b(A)l(TTRIBUTE)15 b(DEFINITIONS)855
b Fn(10)164 307 y(the)19 b(parts)h(ma)o(y)e(b)q(e)i(com)o(bined)d(or)j
(separate.)31 b(There)19 b(are)h(three)f(mo)q(des)f(of)i(expres-)164
367 y(sion)14 b(of)h(attribute)e(de\014nitions,)h(and)h(di\013eren)o(t)
e(mo)q(des)h(ma)o(y)e(b)q(e)i(used)g(within)g(a)g(single)164
428 y(attribute)20 b(reference)f(section.)33 b(Eac)o(h)20
b(attribute)h(de\014nition)f(b)q(egins)g(with)h(a)f Fg(de\014ni-)164
488 y(tion)f(mo)n(de)f(annunciator)24 b Fn(\()p Fd(@e)p
Fn(,)17 b Fd(@i)p Fn(,)g(or)h Fd(@m)p Fn(,\))e(and)j(is)e(terminated)f
(b)o(y)h(another)h(mo)q(de)164 548 y(ann)o(unciator)f(or)f(b)o(y)32
b Fd(@)p Fc(g)p Fn(.)164 678 y Fj(5.2.1)55 b(Explicit)17
b(mo)r(de)164 760 y Fn(In)h(this,)g(the)f(most)h(p)q(o)o(w)o(erful)f
(and)i(most)e(v)o(erb)q(ose)h(attribute)g(de\014nition)g(mo)q(de,)35
b(an)164 810 y(attribute)14 b(de\014nition)g(tak)o(es)g(the)g(form)f
(of)h Fd(@e)g Fn(\(mnemonic)d(for)j Fg(explicit)21 b
Fn(\))14 b(follo)o(w)o(ed)f(b)o(y)164 859 y(a)19 b Fg(dep)n(endency)j
(expr)n(ession)h Fn(\(whic)o(h)18 b(expresses)g(the)h(dep)q(endency)f
(part)i(of)f(the)g(de\014-)164 909 y(nition\))c(follo)o(w)o(ed)f(b)o(y)
h(an)h Fg(evaluation)j(expr)n(ession)g Fn(\(whic)o(h)c(expresses)g(the)
g(ev)m(aluation)164 959 y(part\).)20 b(In)12 b(the)g(follo)o(wing)g
(example,)e(the)i(attribute)g(reference)f(section)g(con)o(tains)i
(three)164 1009 y(attribute)j(de\014nitions,)f(eac)o(h)h(expressed)g
(in)g(the)g(explicit)e(mo)q(de:)273 1100 y Fa(num)108
b(:)153 b(bitlist)20 b(DOT)108 b(bitlist)447 1150 y(@{)22
b(@e)f(num.value)f(:)i(bitlist.0.value)c(bitlist.1.value;)578
1200 y(@num.value@)i(=)h(@bitlist.0.value@)d(+)k(@bitlist.1.value@)c(;)
513 1250 y(@e)j(bitlist.0.scale)e(:)i(;)578 1299 y(@bitlist.0.scale@)d
(=)k(0)f(;)513 1349 y(@e)g(bitlist.1.scale)e(:)i(bitlist.1.length)e(;)
578 1399 y(@bitlist.1.scale@)f(=)k(-@bitlist.1.lengt)o(h@)d(;)447
1449 y(@})447 1499 y(;)237 1600 y Fn(A)f(dep)q(endency)g(expression)g
(mak)o(es)f(explicit)g(the)h(constrain)o(ts)h(on)g(the)f(order)h(of)164
1661 y(execution)e(of)i(ev)m(aluation)f(expressions)g(and)h(is)f(a)g
(non-empt)o(y)f(list)h(of)g(attribute)g(o)q(c-)164 1721
y(currences)f(of)g(the)h(rule,)f(follo)o(w)o(ed)f(b)o(y)h(a)h(colon,)g
(follo)o(w)o(ed)e(b)o(y)h(a)h(p)q(ossibly)g(empt)o(y)e(list)164
1781 y(of)21 b(attribute)f(o)q(ccurrences)g(and)h(a)g(terminating)e
(semicolon.)33 b(The)20 b(o)q(ccurrences)h(to)164 1841
y(the)e(left)f(of)h(the)g(colon)g(are)g(said)g(to)g Fg(dep)n(end)i(up)n
(on)h Fn(\(hence)d(are)g(called)37 b Fg(dep)n(endents)164
1901 y Fn(of)s(\))16 b(those)g(to)g(the)f(righ)o(t,)g(and)h(are)f(the)h
(o)q(ccurrences)f Fg(de\014ne)n(d)21 b Fn(in)15 b(the)h(giv)o(en)e
(attribute)164 1962 y(de\014nition.)21 b(The)15 b(o)q(ccurrences)h(to)g
(the)f(righ)o(t)h(are)f(called)g Fg(dep)n(ende)n(es)21
b Fn(of)16 b(those)g(on)g(the)164 2022 y(left.)21 b(An)c(ev)m(aluation)
g(expression)f(is)g(basically)g(a)h(C)g(co)q(de)g(fragmen)o(t)e(that)i
(ma)o(y)e(con-)164 2082 y(tain)j Fg(attribute)h(r)n(efer)n(enc)n(es)t
Fn(,)36 b(eac)o(h)17 b(of)h(whic)o(h)f(is)h(an)g(attribute)g(o)q
(ccurrence)e(enclosed)164 2142 y(within)g Fd(@)g Fn(sym)o(b)q(ols.)21
b(A)o(ttribute)15 b(references)g(b)q(eha)o(v)o(e)h(as)h(C)g(v)m
(ariables,)f(and)h(all)f(of)h(the)164 2202 y(usual)i(C)g(op)q(erators,)
h(suc)o(h)e(as)h(those)g(for)g(arithmetic,)d(logical,)i(and)h(p)q(oin)o
(ter)g(op)q(era-)164 2263 y(tions,)14 b(ma)o(y)e(b)q(e)i(applied)f(to)h
(them,)e(as)i(in)g(a)g(C)g(program.)20 b(The)13 b(ev)m(aluation)h
(expression)164 2323 y(imme)o(diately)f(follo)o(ws)j(the)g(semicolon)e
(of)j(the)f(dep)q(endency)f(expression.)237 2383 y(The)21
b(Ox-generated)g(ev)m(aluator)h(c)o(ho)q(oses)g(an)f(ev)m(aluation)h
(order)f(suc)o(h)g(that)g(the)164 2443 y(ev)m(aluation)16
b(expressions)f(for)h(all)f(of)h(the)f(dep)q(endees)g(in)g(the)h
(de\014nition)f(are)g(executed)p eop
%%Page: 11 12
11 11 bop 164 162 a Fk(5)49 b(A)l(TTRIBUTE)15 b(DEFINITIONS)855
b Fn(11)164 307 y(b)q(efore)13 b(those)h(of)f(the)g(dep)q(enden)o(ts.)
20 b(Usually)12 b(there)g(is)h(a)h(single)e(dep)q(enden)o(t)h(in)f(a)i
(giv)o(en)164 367 y(attribute)21 b(de\014nition,)i(but)e(in)h(some)e
(cases,)j(co)q(de)f(ma)o(y)e(b)q(e)i(made)f(more)f(compact)164
428 y(b)o(y)e(placing)f(more)g(than)i(one)f(attribute)g(o)q(ccurrence)g
(in)f(a)i(dep)q(enden)o(t)f(list,)f(thereb)o(y)164 488
y(com)o(bining)g(the)i(de\014nitions)g(of)g(those)h(in)f(the)g(list.)29
b(The)19 b(ev)m(aluation)g(expression)g(is)164 548 y(executed)10
b(on)j(b)q(ehalf)f(of)g(the)g(dep)q(enden)o(ts)f Fg(taken)k(as)e(a)h
(set)5 b Fn(,)12 b(rather)g(than)h(once)e(for)h(eac)o(h)164
608 y(dep)q(enden)o(t.)28 b(This)19 b(is)g(kno)o(wn)g(as)g
Fg(solving)25 b Fn(the)19 b(attribute)f(instances)h(corresp)q(onding)
164 668 y(to)e(the)f(o)q(ccurrences)f(in)h(that)h(set.)164
798 y Fj(5.2.2)55 b(Implicit)16 b(mo)r(de)164 880 y Fn(The)i
Fg(implicit)h(mo)n(de)t Fn(,)36 b(whic)o(h)17 b(is)h(the)f(usual)i(mo)q
(de)e(of)h(expressing)g(attribute)f(de\014ni-)164 930
y(tions,)g(syn)o(tactically)e(com)o(bines)f(the)j(dep)q(endency)f(part)
h(with)g(the)f(ev)m(aluation)h(part.)164 980 y(The)f(follo)o(wing)g(Ox)
g(co)q(de)h(is)f(equiv)m(alen)o(t)e(to)j(that)g(of)f(the)g(preceding)g
(example.)273 1071 y Fa(num)108 b(:)153 b(bitlist)20
b(DOT)108 b(bitlist)447 1121 y(@{)22 b(@i)f(@num.value@)f(=)h
(@bitlist.0.value@)d(+)k(@bitlist.1.value@)o(;)513 1171
y(@i)f(@bitlist.0.scale@)d(=)k(0;)513 1221 y(@i)f(@bitlist.1.scale@)d
(=)44 b(-@bitlist.1.leng)o(th@;)447 1270 y(@})447 1320
y(;)164 1422 y Fn(In)20 b(this)g(mo)q(de,)g(an)h(attribute)e
(de\014nition)h(tak)o(es)g(the)g(form)f(of)i Fd(@i)39
b Fn(follo)o(w)o(ed)20 b(b)o(y)f(an)164 1482 y(ev)m(aluation)13
b(expression.)20 b(The)13 b(mo)q(de)g(ann)o(unciator)g
Fd(@i)26 b Fn(informs)12 b(Ox)h(that)g(the)g(de\014ni-)164
1542 y(tion)i(has)h(a)f(single)g(dep)q(enden)o(t,)f(namely)f(the)i
(\014rst)g(attribute)g(o)q(ccurrence)f(referenced)164
1602 y(in)k(the)h(ev)m(aluation)g(expression.)28 b(The)19
b(dep)q(endees)f(in)h(the)f(de\014nition)g(consist)h(of)g(all)164
1663 y Fg(other)j Fn(attribute)15 b(o)q(ccurrences)h(referenced)f(in)h
(the)g(ev)m(aluation)g(expression.)164 1793 y Fj(5.2.3)55
b(Mixed)18 b(mo)r(de)164 1885 y Fg(Mixe)n(d)h(mo)n(de)39
b Fn(attribute)17 b(de\014nitions)h(are)g(announced)g(b)o(y)g(the)f
(reserv)o(ed)g(w)o(ord)36 b Fd(@m)p Fn(.)164 1945 y(There)21
b(follo)o(w)g(one)h(or)g(more)e(dep)q(enden)o(ts,)i(a)g(semicolon,)f
(and)h(an)g(ev)m(aluation)f(ex-)164 2005 y(pression.)38
b(The)22 b(o)q(ccurrences)g(referenced)e(in)i(the)f(ev)m(aluation)h
(expression,)h(except)164 2066 y(those)d(that)h(also)f(app)q(ear)h(b)q
(et)o(w)o(een)e Fd(@m)g Fn(and)h(the)g(semicolon,)f(are)g(tak)o(en)h
(to)g(b)q(e)g(the)164 2126 y(dep)q(endees)g(in)g(the)g(de\014nition.)33
b(Th)o(us)21 b(the)f(dep)q(enden)o(ts)g(are)g(giv)o(en)g(explicitly)d
(and)164 2186 y(the)i(dep)q(endees)g(implicitly)-5 b(.)28
b(The)20 b(co)q(de)g(in)f(the)g(follo)o(wing)g(example)e(has)k(the)e
(same)164 2246 y(meaning)c(as)i(that)g(in)f(the)g(previous)g(t)o(w)o
(o.)p eop
%%Page: 12 13
12 12 bop 164 162 a Fk(5)49 b(A)l(TTRIBUTE)15 b(DEFINITIONS)855
b Fn(12)273 307 y Fa(num)108 b(:)153 b(bitlist)20 b(DOT)108
b(bitlist)447 357 y(@{)22 b(@m)f(num.value)f(;)578 407
y(@num.value@)g(=)h(@bitlist.0.value@)d(+)k(@bitlist.1.value@)o(;)513
457 y(@i)f(@bitlist.1.scale@)d(=)k(-)f(@bitlist.1.length@;)513
506 y(@m)g(bitlist.0.scale)e(;)i(@bitlist.0.scale@)e(=)i(0;)447
556 y(@})447 606 y(;)164 750 y Fb(5.3)70 b(A)n(ttribute)21
b(reference)g(sections)h(in)g(the)g(L-\014le\(s\))164
843 y Fn(De\014nitions)14 b(of)g(inherited)e(attributes)i(of)g(tok)o
(ens)g(are)g(asso)q(ciated)h(with)e(rules)h(app)q(ear-)164
903 y(ing)e(in)g(the)h(Y-\014le,)f(while)f(their)h(syn)o(thesized)f
(attributes)h(are)h(de\014ned)f(in)g(the)g(L-\014le\(s\).)164
963 y(Ox)19 b(pro)q(cesses)h(the)f(Y-\014le)f(b)q(efore)i(pro)q
(cessing)g(the)f(L-\014le\(s\).)30 b(If)19 b(a)h(giv)o(en)e(attribute)
164 1023 y(o)q(ccurrence)d(of)h(a)g(tok)o(en)f(is)g(not)h(de\014ned)g
(in)f(the)g(Y-\014le,)g(then)g(the)h(attribute)f(is)g(tak)o(en)164
1084 y(to)i(b)q(e)f(syn)o(thesized.)237 1144 y(Lexical)h(rules)g(are)h
(asso)q(ciated)h(with)e Fd(return)f Fn(statemen)o(ts)g(in)i(Lex)f
(actions.)26 b(Af-)164 1204 y(ter)19 b(the)h(terminating)e(semicolon)g
(of)i(eac)o(h)f(suc)o(h)h(statemen)o(t,)e(there)i(ma)o(y)e(app)q(ear)j
(a)164 1264 y(p)q(ossibly)16 b(empt)o(y)e Fg(attribute)k(r)n(efer)n
(enc)n(e)f(se)n(ction)t Fn(,)f(delimited)d(b)o(y)i Fd(@)p
Fc(f)h Fn(and)g Fd(@)p Fc(g)p Fn(,)f(in)h(whic)o(h)164
1324 y(are)g(de\014ned)g(all)g(of)h(the)f(syn)o(thesized)f(attributes)h
(of)g(the)g Fd(return)p Fn(ed)e(tok)o(en.)237 1385 y(Note)20
b(that)g(eac)o(h)g(p)q(oin)o(t)g(of)h Fd(return)d Fn(of)i
Fd(yylex)f Fn(m)o(ust)f(b)q(e)j Fg(explicit)26 b Fn(in)20
b(the)g(sense)164 1445 y(that)c(the)f(text)f(m)o(ust)g(b)q(ear)i(the)f
(C)h(reserv)o(ed)e(w)o(ord)h Fd(return)p Fn(.)k(In)c(particular,)g
Fd(return)p Fn(s)164 1505 y(m)o(ust)f(not)h(b)q(e)h(done)f(within)g(C)g
(macros,)f(unless)i(the)e(L-\014le)i(is)f(passed)h(through)g(the)f(C)
164 1565 y(prepro)q(cessor)g(prior)e(to)h(pro)q(cessing)h(b)o(y)e(Ox.)
20 b(Guaran)o(teeing)14 b(this)g(prop)q(ert)o(y)g(of)g
Fd(yylex)164 1625 y Fn(is)i(the)g(resp)q(onsibilit)o(y)f(of)i(the)f(Ox)
f(user|it)h(is)g(not)h(c)o(hec)o(k)o(ed)d(b)o(y)h(Ox.)164
1755 y Fj(5.3.1)55 b(Generalit)n(y)17 b(of)i(Ox)164 1837
y Fn(The)14 b(class)h(of)f(attribute)g(grammars)f(accepted)h(b)o(y)f
(Ox)h(is)g(restricted)f(only)i(as)f(follo)o(ws:)164 1887
y(syn)o(thesized)e(attributes)h(of)g(tok)o(ens)g(do)h(not)f(ha)o(v)o(e)
g(dep)q(endees.)20 b(A)o(ttribute)11 b(de\014nitions)164
1937 y(in)22 b(the)g(L-\014le\(s\))h(can)f(th)o(us)g(b)q(e)h(written)f
(more)f(simply)f(than)j(in)f(the)g(Y-\014le:)32 b(eac)o(h)164
1987 y(attribute)18 b(o)q(ccurrence)f(is)i(de\014ned)f(b)o(y)f
(referring)h(to)g(it)g(in)g(C)h(co)q(de,)f(exactly)f(once)h(in)164
2036 y(the)g(attribute)h(reference)d(section)j(asso)q(ciated)g(with)f
(the)h Fd(return)d Fn(statemen)o(t,)h(as)i(in)164 2086
y(the)d(follo)o(wing)g(example)e(\(wherein)h Fd(CONST)p
Fn('s)g(only)h(syn)o(thesized)f(attribute)h(is)g Fd(val)p
Fn(\):)273 2178 y Fa([0-9]+)64 b(return\(CONST\);)19
b(@{)i(sscanf\(yytext,"\045d",)o(&@CON)o(ST.va)o(l@\);)d(@})164
2279 y Fn(Th)o(us)f(mo)q(de)e(declarations)i(and)g(dep)q(endency)f
(expressions)g(are)h(unnecessary)f(in)g(the)164 2339
y(L-\014le\(s\).)p eop
%%Page: 13 14
13 13 bop 164 162 a Fk(5)49 b(A)l(TTRIBUTE)15 b(DEFINITIONS)855
b Fn(13)164 307 y Fj(5.3.2)55 b(Ox)19 b(adaptation)g(to)f(Lex's)f
(line-orien)n(ted)f(syn)n(tax)164 400 y Fn(When)e(Ox)f(is)g(pro)q
(cessing)h(the)g(L-\014le)f(and)h(has)h(recognized)e(a)g(rule)g
(\(i.e.,)f(the)i(ob)s(ject)f(of)164 460 y(a)19 b Fd(return)d
Fn(statemen)o(t\),)g(if)i(the)g Fd(return)p Fn(ed)e(tok)o(en)i(has)h
(syn)o(thesized)e(attributes,)h(Ox)164 520 y(lo)q(oks)c(for)g(an)h
(attribute)e(reference)f(section)h(follo)o(wing)h(the)f
Fd(return)f Fn(statemen)o(t.)18 b(Ox's)164 580 y(rules)11
b(for)h(recognizing)f(attribute)g(reference)e(sections)j(in)f(the)g
(L-\014le)g(are)h(adapted)g(from)164 640 y(the)h(w)o(a)o(y)g(Lex)h
(actions)g(are)f(terminated:)18 b(Ox)13 b(giv)o(es)g(up)h(lo)q(oking)g
(for)g(an)g(attribute)f(ref-)164 700 y(erence)e(section)i(when)f(it)h
(pairs)f(the)h(righ)o(tmost)e(righ)o(t)i(curly)e(brace)i(in)f(the)g
(action)h(with)164 761 y(the)h(leftmost)f(left)g(curly)g(brace,)h(or)h
(when)f(it)g(encoun)o(ters)g(a)g(newline)f(unprotected)h(b)o(y)164
821 y(curly)h(braces.)22 b(Newlines)14 b(are)j(insigni\014can)o(t)e
(inside)h(attribute)g(reference)e(sections.)237 881 y(Examples)20
b(of)h(correct)f(and)i(incorrect)e(syn)o(tax)h(are)g(sho)o(wn)h(b)q
(elo)o(w.)35 b(All)20 b(of)h(the)164 941 y(correct)16
b(forms)f(sho)o(wn)i(are)f(seman)o(tically)e(equiv)m(alen)o(t)g(to)j
(one)f(another.)237 1055 y Fc(\017)24 b Fn(incorrect)15
b(\(attribute)h(reference)f(section)h(app)q(ears)i(to)f(the)f(righ)o(t)
g(of)h(the)f(righ)o(t-)286 1116 y(most)f(curly)h(brace\):)286
1238 y Fd([a-zA-Z]+)22 b({)k(count\(\);)c(return)i(ID;)g(})h(@{)g
(@ID.name@)e(=)i(id\(\);)f(@})237 1361 y Fc(\017)g Fn(incorrect)d
(\(attribute)h(reference)e(section)i(not)h(part)g(of)f(rule,)h(since)e
(the)h(Lex)286 1421 y(action)16 b(is)g(terminated)f(b)o(y)g(an)i
(unprotected)f(newline\):)286 1543 y Fd([a-zA-Z]+)22
b(count\(\);)h(return)g(ID;)542 1603 y(@{)i(@ID.name@)d(=)k(id\(\);)e
(@})237 1726 y Fc(\017)g Fn(correct:)286 1848 y Fd([a-zA-Z]+)e({)k
(count\(\);)c(return)i(ID;)50 b(@{)25 b(@ID.name@)d(=)j(id\(\);)f(@})h
(})237 1971 y Fc(\017)f Fn(correct:)286 2093 y Fd([a-zA-Z]+)e(return)i
(ID;)g(@{)h(count\(\);)e(@ID.name@)f(=)j(id\(\);)f(@})237
2216 y Fc(\017)g Fn(correct:)286 2338 y Fd([a-zA-Z]+)e({)k(count\(\);)c
(return)i(ID;)594 2398 y(@{)g(@ID.name@)f(=)i(id\(\);)f(@})542
2458 y(})p eop
%%Page: 14 15
14 14 bop 164 162 a Fk(5)49 b(A)l(TTRIBUTE)15 b(DEFINITIONS)855
b Fn(14)237 307 y Fc(\017)24 b Fn(correct:)286 430 y
Fd([a-zA-Z]+)e(count\(\);)h(return)g(ID;)51 b(@{)1132
490 y(@ID.name@)22 b(=)j(id\(\);)1081 550 y(@})164 680
y Fj(5.3.3)55 b(Resolution)18 b(of)g(am)n(biguit)n(y)g(regarding)g(tok)
n(en)g(returned)164 772 y Fn(A)e(sligh)o(t)f(di\016cult)o(y)g(arises)h
(in)g(rules)g(lik)o(e)292 874 y Fd(return\(yyt)o(ext)o([0])o(\);)164
976 y Fn(and)292 1077 y Fd(return\(con)o(d)23 b(?)i(TOKEN1)e(:)j
(TOKEN2\);)164 1179 y Fn(for)13 b(whic)o(h)g(Ox)f(cannot)i(determine)c
(at)j(ev)m(aluator-generation)h(time)d(whic)o(h)i(tok)o(en)f(will)164
1239 y(b)q(e)k Fd(return)p Fn(ed.)237 1289 y(In)h(the)g(\014rst)h
(case,)f(wherein)f(no)i(declared)e(tok)o(en)h(or)h(c)o(haracter)f
(constan)o(t)g(is)g(rec-)164 1339 y(ognized)j(in)g(the)g
Fd(return)p Fn(ed)e(expression,)j(Ox)f(assumes)g(that)g(the)g(tok)o(en)
g Fd(return)p Fn(ed)164 1389 y(has)d(no)g(attributes,)e(and)i(issues)g
(a)f(w)o(arning)h(lik)o(e:)273 1480 y Fa(ox:)k(scan.l:)f(warning:)h
(line)g(8:)g(ambiguous)f(form)h(of)g(return)g(of)g(token.)317
1530 y(unknown)f(node)h(type--assuming)e(no)i(attributes.)237
1621 y Fn(In)f(the)f(second)h(case,)g(wherein)f(more)f(than)j(one)e
(declared)g(tok)o(en)g(or)h(c)o(haracter)164 1671 y(constan)o(t)g(is)f
(recognized,)g(the)g(no)q(de)h(app)q(ended)g(to)g(the)f(tree)g(during)h
(ev)m(aluation)f(is)164 1721 y(of)c(the)f(t)o(yp)q(e)h(of)g(the)f
(declared)g(tok)o(en)g(or)h(c)o(haracter)f(constan)o(t)h(app)q(earing)h
Fg(leftmost)k Fn(in)164 1771 y(the)c(expression.)21 b(Ox)16
b(issues)g(a)h(w)o(arning)f(lik)o(e:)273 1862 y Fa(ox:)21
b(scan.l:)f(warning:)h(line)g(8:)g(ambiguous)f(form)h(of)g(return)g(of)
g(token.)317 1912 y(multiple)f(tokens)g(in)i(object)e(of)i(return)e
(statement.)164 2013 y Fn(The)k(ab)q(o)o(v)o(e)f(w)o(arnings)h(should)g
(b)q(e)g(tak)o(en)f(seriously)l(,)i(b)q(ecause)f(the)f(conditions)h(of)
164 2074 y(whic)o(h)16 b(they)h(w)o(arn)g(can)g(result)g(in)g(the)f
(generated)h(ev)m(aluator)h(attempting)e(to)h(access)164
2134 y(attribute)h(instances)g(that)h(are)g(nonexisten)o(t)e(or)i(of)g
(the)f(wrong)i(t)o(yp)q(e.)27 b(These)18 b(kinds)164
2194 y(of)g(w)o(arnings)g(are)f(most)g(often)g(seen)g(when)h(\014rst)g
(con)o(v)o(erting)e(an)i(existing)e(Y)l(acc/Lex)164 2254
y(translator)h(to)g(Ox.)237 2314 y(A)12 b(condition)f(causing)h(one)g
(of)h(the)e(ab)q(o)o(v)o(e-describ)q(ed)h(w)o(arnings)g(ma)o(y)e(b)q(e)
i(tolerated)164 2375 y(if)j(the)f(Ox)h(user)g(v)o(eri\014es)f(that)i
(for)f(the)g(rule)g(\(i.e.,)e(ob)s(ject)h(of)i(the)f
Fd(return)e Fn(statemen)o(t\))164 2435 y(in)j(question:)p
eop
%%Page: 15 16
15 15 bop 164 162 a Fk(6)49 b(TRANSLA)l(TION)15 b(INTO)h(C)k(CODE)777
b Fn(15)237 307 y Fc(\017)24 b Fn(all)14 b(of)h(the)f(tok)o(ens)g(that)
h(can)f(b)q(e)h Fd(return)p Fn(ed)d(for)j(the)f(rule)g(are)g(con)o
(tained)g(in)g(the)286 367 y(grammar-sym)o(b)q(ol)f(list)j(\(section)g
(3\))g(of)h(a)g(single)e(attribute)h(declaration.)237
467 y Fc(\017)24 b Fn(no)f(tok)o(en)f(that)g(can)h(b)q(e)g
Fd(return)p Fn(ed)c(for)k(the)f(rule)g(app)q(ears)h(in)f(a)h(grammar-)
286 527 y(sym)o(b)q(ol)15 b(list)g(of)i(an)g(attribute)f(declaration.)
164 671 y Fb(5.4)70 b(Cycles)164 763 y Fn(It)18 b(is)g(easy)h(to)f
(write)g(an)h(attribute)f(grammar)f(suc)o(h)h(that)h(some)e(attribute)h
(instance)164 823 y(of)24 b(some)e(parse)i(tree)f(has)h(a)f(c)o(hain)g
(of)h(dep)q(endencies)f(that)g(leads)h(bac)o(k)f(to)g(itself.)164
883 y(Suc)o(h)14 b(a)g(grammar)f(is)h(called)f Fg(cir)n(cular)5
b Fn(,)14 b(and)h(suc)o(h)e(a)i(c)o(hain)f(of)g(dep)q(endencies)f(is)h
(called)164 944 y(a)21 b Fg(cycle)t Fn(.)35 b(F)l(or)20
b(suc)o(h)g(a)h(tree,)f(there)g(is)g(an)h(attribute)f(instance)g(that)h
(the)f(ev)m(aluator)164 1004 y(cannot)g(b)q(egin)f(to)h(solv)o(e)e(un)o
(til)g(that)i(instance)f(has)g(already)g(b)q(een)h(solv)o(ed.)29
b(A)19 b(cycle)164 1064 y(also)k(mak)o(es)e(it)h(imp)q(ossible)f(to)i
(solv)o(e)f(an)o(y)g(attribute)g(instance)g(that)h(has)h(a)e(c)o(hain)
164 1124 y(of)d(dep)q(endencies)f(leading)g(to)i(an)f(instance)f(in)o
(v)o(olv)o(ed)f(in)h(the)h(cycle.)27 b(Circularit)o(y)17
b(is)164 1184 y(usually)k(not)h(in)o(tended)e(b)o(y)h(the)g(ev)m
(aluator)g(designer.)36 b(A)21 b(general)g(circularit)o(y)e(test)164
1245 y(p)q(erformed)g(at)i(ev)m(aluator-generation)h(time)d(w)o(ould)h
(require)g(exp)q(onen)o(tial)g(running)164 1305 y(time)d(for)j(some)e
(inputs)i([Jaza)o(y)o(eri)14 b(75)q(].)30 b(P)o(olynomial-time)16
b(tests)k(for)f(sp)q(ecial)g(kinds)164 1365 y(of)h(non-circularit)o(y)e
(are)i(kno)o(wn,)g(but)g(the)f(presen)o(t)g(v)o(ersion)g(of)h(Ox)f
(deals)h(with)f(the)164 1425 y(problem)c(b)o(y)g(c)o(hec)o(king)g(for)h
(cycles)f(at)i(ev)m(aluation)f(time.)164 1590 y Fo(6)83
b(T)-7 b(ranslation)27 b(in)n(to)g(C)h(co)r(de)164 1700
y Fn(Ox)18 b(translates)g(attribute)g(declarations)g(in)o(to)f(C)i
(structure)e(declarations,)h(with)g(the)164 1760 y(attribute)e(names)f
(app)q(earing)i(as)g(structure)f(mem)o(b)q(ers.)237 1820
y(The)22 b(ev)m(aluation)h(expression)f(of)h(eac)o(h)e(attribute)h
(de\014nition)g(is)g(copied)g(v)o(erba-)164 1881 y(tim)e(in)o(to)i
(Ox's)g(output,)i(except)d(that)i(attribute)f(references)e(are)j
(translated)f(in)o(to)164 1941 y(paren)o(thesized)15
b(references)g(to)i(C)f(v)m(ariables.)164 2106 y Fo(7)83
b(T)-7 b(emp)r(oral)30 b(b)r(eha)n(vior)g(of)h(Ox-generated)f(ev)-5
b(al-)288 2197 y(uators)164 2322 y Fb(7.1)70 b(Stac)n(k)23
b(op)r(erations)164 2414 y Fn(Inasm)o(uc)o(h)16 b(as)i(an)h(ordinary)f
(Y)l(acc/Lex)f(recognizer)g(emplo)o(ys)f(an)i(LR)g(parsing)h(algo-)164
2474 y(rithm)10 b([Aho)16 b(86],)c(eac)o(h)f(input)g(en)o(tails)g(a)h
(sequence)e(of)i(lo)q(ok)m(aheads,)i(shifts,)e(and)g(reduc-)p
eop
%%Page: 16 17
16 16 bop 164 162 a Fk(7)49 b(TEMPORAL)17 b(BEHA)-5 b(VIOR)13
b(OF)j(O)o(X)5 b(-GENERA)l(TED)16 b(EV)-5 b(ALUA)l(TORS)64
b Fn(16)164 307 y(tions,)19 b(and)h(a)f(stac)o(k)g(of)g(parser)h
(states)f(is)g(main)o(tained.)27 b(F)l(rom)18 b(ordinary)h(Y)l(acc/Lex)
164 367 y(source,)k(Ox)f(generates)g(an)h(ev)m(aluator)f(whose)h
Fd(yyparse)d Fn(go)q(es)j(through)g(the)f(same)164 428
y(sequence)e(of)h(lo)q(ok)m(aheads,)i(shifts,)f(and)g(reductions)e(as)i
(do)q(es)g(the)e Fd(yyparse)f Fn(of)i(the)164 488 y(ordinary)16
b(Y)l(acc/Lex)g(recognizer.)237 548 y(The)i(Ox-generated)g(ev)m
(aluator,)g(in)g(building)f(a)i(parse)f(tree,)f(main)o(tains)g(a)h
(stac)o(k)164 608 y(of)h(subtrees.)27 b(The)19 b(op)q(erations)g(on)g
(the)f(stac)o(k)g(of)h(subtrees)f(are)h(sync)o(hronized)e(with)164
668 y(the)j(op)q(erations)h Fd(yyparse)c Fn(p)q(erforms)i(on)h(its)g
(stac)o(k)g(of)g(parser)g(states,)h(except)d(that)164
729 y(op)q(erations)i(in)o(v)o(olving)c(the)j(\\mark)o(er)e(non)o
(terminals")g(\(see)h([Johnson)f(75)q(]\))h(inserted)164
789 y(in)o(to)e(the)g(grammar)f(b)o(y)g(Y)l(acc)h(are)g(ignored.)237
849 y(The)24 b(ev)m(aluator)g(main)o(tains)f(its)g(stac)o(k)h(of)g
(subtrees)g(as)g(follo)o(ws.)44 b(Lo)q(ok)m(aheads)164
909 y(coincide)22 b(with)g(calls)h(to)g Fd(yylex)p Fn(.)39
b(Just)23 b(b)q(efore)g(a)g Fd(return)e Fn(is)i(executed)e(in)i(a)g
(Lex)164 969 y(action,)15 b(an)g(image)e(of)i(a)g(leaf)f(no)q(de)i(is)e
(created)g(in)g(the)h(ev)m(aluator's)g Fg(lo)n(okahe)n(ad)h(bu\013er)5
b Fn(,)164 1029 y(and)18 b(its)e(syn)o(thesized)g(attribute)h
(instances)g(are)g(solv)o(ed)g(and)g(placed)g(in)g(that)g(bu\013er.)164
1090 y(A)o(t)e(eac)o(h)h(shift,)g(a)h(leaf)e(no)q(de)i(is)f(created)g
(from)f(the)h(image)f(in)h(the)g(lo)q(ok)m(ahead)i(bu\013er,)164
1150 y(and)j(the)g(subtree)f(consisting)h(of)g(that)g(leaf)g(no)q(de)g
(is)g(pushed)g(on)o(to)g(the)f(stac)o(k.)35 b(A)o(t)164
1210 y(eac)o(h)17 b(reduction,)g(zero)g(or)h(more)f(subtrees)g(are)h(p)
q(opp)q(ed)g(from)f(the)g(stac)o(k,)g(and)i(their)164
1270 y(ro)q(ots)g(b)q(ecome)e(the)h(c)o(hildren)e(of)j(a)f
(newly-created)f(no)q(de,)i(yielding)e(a)h(new)h(subtree.)164
1330 y(The)c(ro)q(ot)g(of)g(the)g(new)f(subtree)h(is)f(giv)o(en)g(a)h
(lab)q(el)f(to)h(indicate)f(the)g(pro)q(duction)i(b)q(eing)164
1391 y(applied)21 b(at)i(the)e(no)q(de,)j(and)e(the)g(new)g(subtree)g
(is)g(pushed)g(on)o(to)g(the)g(stac)o(k.)38 b(The)164
1451 y(parse)22 b(tree)f(is)g(completed)e(up)q(on)k(end)e(of)h(input)f
(together)h(with)f(reduction)g(to)h(the)164 1511 y(start)17
b(sym)o(b)q(ol.)164 1655 y Fb(7.2)70 b(Placemen)n(t)20
b(of)j(generated)g(co)r(de)164 1748 y Fn(Co)q(de)18 b(for)g(parse-tree)
g(managemen)o(t)d(and)k(attribute)e(ev)m(aluation)h(is)f(placed)g(in)h
(Y)l(acc)164 1808 y(and)e(Lex)g(actions)g(in)g(Ox's)f(output.)22
b(If)15 b(a)i(giv)o(en)d(rule)i(in)f(the)h(Y-\014le)f(has)h(an)h
(ordinary)164 1868 y(Y)l(acc)c(action,)h(the)f(Ox-generated)h(co)q(de)g
(is)f(placed)g Fg(after)20 b Fn(an)o(y)13 b(programmer-supplied)164
1928 y(C)21 b(co)q(de)g(con)o(tained)g(in)g(the)f(action.)36
b(If)21 b(a)g(giv)o(en)f(rule)g(in)h(the)g(Y-\014le)f(lac)o(ks)g(a)i(Y)
l(acc)164 1989 y(action,)15 b(an)h(action)f(is)g(created,)g(and)h(the)f
(Ox-generated)g(co)q(de)h(is)f(placed)g(there.)20 b(The)164
2049 y(actions)c(so)g(created)f(are)g(in)o(tro)q(duced)g(only)h(at)f
(the)h Fg(ends)k Fn(of)c(rules,)e(so)i(Y)l(acc)f(do)q(es)h(not)164
2109 y(create)d(a)g(mark)o(er)f(non)o(terminal)f(for)j(the)f(action,)g
(and)h(the)f(LALR\(1\))h(prop)q(ert)o(y)g(of)f(the)164
2169 y(grammar)i(is)h(una\013ected.)237 2229 y(When)j(an)g(attribute)g
(reference)e(section)i(in)g(an)g(L-\014le)g(con)o(tains)g
(de\014nitions)g(for)164 2290 y(more)14 b(than)i(one)g(attribute)f(o)q
(ccurrence,)f(co)q(de)i(for)f(impleme)o(n)o(ti)o(ng)e(those)j
(de\014nitions)164 2350 y(is)e(executed)f(in)i(the)f(same)f(order)i(in)
f(whic)o(h)g(the)g(de\014nitions)g(app)q(ear)i(in)e(that)h(section.)237
2410 y(F)l(or)27 b(the)f(attribute)g(o)q(ccurrences)g(de\014ned)g(in)g
(the)g(Y-\014le,)i(Ox)e(and)h(the)f(Ox-)164 2470 y(generated)14
b(ev)m(aluator)h(p)q(erform)e(analyses)h(to)h(determine)c(when)k(to)f
(execute)f(the)h(co)q(de)p eop
%%Page: 17 18
17 17 bop 164 162 a Fk(8)49 b(PR)o(OGRAMMING)15 b(STYLE)920
b Fn(17)164 307 y(segmen)o(t)13 b(that)i(ev)m(aluates)g(a)h(giv)o(en)e
(attribute.)20 b(The)15 b(order)g(of)g(execution)f(of)h(the)g(co)q(de)
164 367 y(segmen)o(ts)c(asso)q(ciated)j(with)f(the)f(de\014nitions)h
(in)f(a)i(giv)o(en)e(attribute)g(reference)f(section)164
428 y(is)18 b(determined)e(b)o(y)i(the)g(dep)q(endencies)f(of)h(the)g
(de\014nitions,)g(and)h(is)f(not)h(necessarily)164 488
y(related)d(to)g(the)g(order)h(of)f(app)q(earance)h(of)g(the)f
(de\014nitions.)237 548 y(Some)i(attribute)h(o)q(ccurrences,)g(for)g
(example)e(those)i(that)h(ha)o(v)o(e)e(no)i(dep)q(endees,)164
608 y(are)i(ev)m(aluated)h(as)g(part)g(of)f(the)h(Y)l(acc)e(action)i
(executed)e(up)q(on)i(reduction)f(b)o(y)g(the)164 668
y(asso)q(ciated)14 b(pro)q(duction.)21 b(De\014nitions)14
b(of)f(suc)o(h)g(o)q(ccurrences)g(are)h(allo)o(w)o(ed)e(to)i(con)o
(tain)164 729 y(references)f(to)i(the)f(Y)l(acc)g(pseudo)o(v)m
(ariables)h Fd($$)p Fn(,)f Fd($1)p Fn(,)f Fd($2)p Fn(,)h(etc.)20
b(If)14 b(Ox)g(determines)e(that)164 789 y(a)k(giv)o(en)f(attribute)g
(o)q(ccurrence)g(cannot)i(b)q(e)f(ev)m(aluated)f(at)h(reduction)g
(time,)d(and)j(the)164 849 y(de\014nition)g(refers)f(to)i(suc)o(h)f(a)h
(pseudo)o(v)m(ariable,)e(Ox)h(issues)h(an)f(error)h(message.)164
993 y Fb(7.3)70 b(Decoration)22 b(and)h(the)g(ready)g(set)164
1086 y Fn(The)18 b(Ox-generated)h(ev)m(aluator)g(main)o(tains)e(a)h
(set)h(of)g(attribute)f(instances)g(that)h(are)164 1146
y(ready)i(to)g(b)q(e)g(solv)o(ed,)g(i.e.,)e(those)j(whose)f(ev)o(ery)e
(dep)q(endee)i(has)g(b)q(een)g(solv)o(ed,)g(but)164 1206
y(whic)o(h)e(ha)o(v)o(e)h(not)g(themselv)o(es)d(b)q(een)j(solv)o(ed.)33
b(During)20 b(parsing)h(of)f(the)g(input,)g(it)g(is)164
1266 y(p)q(ossible)12 b(to)g(remo)o(v)o(e)d(an)j(attribute)f(instance)g
(from)g(this)g Fg(r)n(e)n(ady)h(set)5 b Fn(,)12 b(solv)o(e)f(it,)h(and)
g(then)164 1326 y(c)o(hec)o(k)j(whether)h(the)g(solving)g(of)h(that)g
(instance)f(has)h(caused)g(an)o(y)f(of)h(its)f(dep)q(enden)o(ts)164
1387 y(to)e(b)q(e)g(ready)g(to)g(b)q(e)g(solv)o(ed.)20
b(Instances)14 b(that)g(are)g(th)o(us)g(made)e(ready)i(are)g(then)f
(placed)164 1447 y(in)23 b(the)h(ready)f(set.)44 b(Rep)q(eating)23
b(this)h(pro)q(cess)g(un)o(til)f(the)g(ready)h(set)f(is)h(empt)o(y)d
(is)164 1507 y(kno)o(wn)f(as)h Fg(de)n(c)n(or)n(ation)t
Fn(.)33 b(F)l(ollo)o(wing)20 b(a)g(decoration,)h(further)f(parsing)h
(of)g(the)f(input)164 1567 y(ma)o(y)12 b(result)g(in)h(creation)g(of)g
(parse-tree)g(no)q(des)h(and)g(insertion)f(of)g(attribute)g(instances)
164 1627 y(in)o(to)j(the)h(ready)g(set.)23 b(Sc)o(heduling)16
b(of)h(decorations)g(is)g(p)q(erformed)e(automatically)g(b)o(y)164
1688 y(the)k(ev)m(aluator.)30 b(Ev)m(aluation)20 b(of)f(a)h(giv)o(en)e
(syn)o(tactically-correct)f(input)i(in)o(v)o(olv)o(es)e(at)164
1748 y(least)k(one)g(decoration,)i(that)e(p)q(erformed)f(after)i(the)f
(\014nal)g(reduction)g(to)g(the)g(start)164 1808 y(sym)o(b)q(ol.)164
1974 y Fo(8)83 b(Programming)28 b(st)n(yle)164 2084 y
Fn(De\014nitions)16 b(of)h Fg(attribute)h(gr)n(ammar)5
b Fn(,)15 b(\(for)h(instance)g(those)h(in)f([Lorho)h(88)q(])e(and)164
2144 y([W)l(aite)g(84)q(]\))22 b(emplo)o(y)d(no)k(notion)f(of)g
(execution)43 b(sequence.)37 b(The)22 b(usual)h(Ox)e(pro-)164
2204 y(gramming)13 b(st)o(yle)h(in)o(v)o(olv)o(es)f(de\014ning)i(syn)o
(thesized)f(attribute)g(o)q(ccurrences)h(of)g(tok)o(ens)164
2264 y(in)g(terms)f(of)i Fd(yytext)d Fn(and)j Fd(yyleng)e
Fn(and)i(other)g(suc)o(h)f(data)h(structures)g(of)f(the)h(lexical)164
2325 y(analyzer.)21 b(Then)16 b(the)f(attribute)h(de\014nitions)g(of)g
(eac)o(h)f(pro)q(duction)i(are)f(written)f(only)164 2385
y(in)e(terms)e(of)i(constan)o(ts)h(and)f(other)g(attribute)g(o)q
(ccurrences)f(of)i(that)f(pro)q(duction.)21 b(F)l(or)164
2445 y(a)15 b(giv)o(en)e(sen)o(tence,)h(the)g(syn)o(thesized)f
(attribute)h(instances)g(of)h(the)f(tok)o(ens)h(then)f(com-)p
eop
%%Page: 18 19
18 18 bop 164 162 a Fk(9)49 b(POSTDECORA)l(TION)16 b(TRA)-5
b(VERSALS)678 b Fn(18)164 307 y(pletely)14 b(determine)g(the)h(v)m
(alues)h(of)h(all)e(attribute)h(instances)g(of)g(the)g(parse)g(tree.)21
b(The)164 367 y(attribute)14 b(instances)g(of)g(the)g(ro)q(ot)h(no)q
(de)f(are)g(often)g(of)h(particular)e(in)o(terest,)g(and)i(their)164
428 y(de\014nitions)i(often)g(con)o(tain)g(co)q(de)g(that)h(copies)f
(their)f(v)m(alues)h(to)h(global)f(C)g(v)m(ariables,)164
488 y(so)g(that)g(they)e(ma)o(y)g(b)q(e)h(used)h(in)f(co)q(de)g
(executed)f(after)h(the)g(return)g(from)f Fd(yyparse)p
Fn(.)237 548 y(Since)j(attribute)h(de\014nitions)f(in)h(Ox)f(co)q(de)h
(ma)o(y)f(con)o(tain)g(an)o(y)h(C)g(co)q(de,)h(the)e(Ox)164
608 y(programmer)f(ma)o(y)h(deviate)g(from)g(the)h(safe)g(approac)o(h)h
(describ)q(ed)f(ab)q(o)o(v)o(e)g(b)o(y)g(using)164 668
y(non-ro)q(ot)25 b(attribute)e(de\014nitions)h(that)f(read)h(or)g
(write)e(global)i(v)m(ariables.)43 b(Before)164 729 y(attempting)17
b(the)i(use)g(of)f(side)h(e\013ects,)f(the)h(programmer)d(should)k(b)q
(e)e(familiar)f(with)164 789 y(the)f(material)e(of)j(section)f(7.)237
849 y(Since)e(the)h(order)g(of)g(ev)m(aluation)g(of)g(attributes)g(b)o
(y)f(the)h(Ox-generated)f(ev)m(aluator)164 909 y(is)d(not)g(explicit)e
(in)i(the)g(Ox)g(input)g(sp)q(eci\014cations,)g(usually)g(it)g(is)g
(not)g(con)o(v)o(enien)o(t)e(to)j(use)164 969 y(attribute)k
(de\014nitions)g(for)g(order-sensitiv)o(e)f(side)h(e\013ects)g(suc)o(h)
g(as)33 b(co)q(de)16 b(generation.)237 1029 y(A)22 b(common)e(general)i
(approac)o(h)h(to)g(translation)f(is)g(to)h(build)f(and)g(decorate)h(a)
164 1090 y(parse)e(tree)f(\(mean)o(while)d(p)q(erforming)j(some)f(of)i
(the)f(c)o(hec)o(ks)f(for)i(seman)o(tic)d(errors\),)164
1150 y(and)24 b(to)f(then)g(mak)o(e)e(one)i(or)g(more)f
(determinate-order)f(tree)h(tra)o(v)o(ersals)h(for)g(\014nal)164
1210 y(error)16 b(c)o(hec)o(ks,)e(gathering)j(of)g(compilation)d
(statistics,)i(co)q(de)g(generation,)g(etc.)237 1270
y(Ox)g(has)h(a)f(facilit)o(y)e(for)j(sp)q(eci\014cation)f(of)g(suc)o(h)
g(tra)o(v)o(ersals,)f(and)i(this)e(is)h(the)g(topic)164
1330 y(of)h(section)e(9.)164 1497 y Fo(9)83 b(P)n(ostdecoration)27
b(tra)n(v)n(ersals)164 1606 y Fn(The)15 b(idea)g(of)h(decoration)f(w)o
(as)h(describ)q(ed)f(in)g(section)f(7.3.)22 b Fg(Postde)n(c)n(or)n
(ation)c Fn(refers)d(to)164 1667 y(an)o(y)f(time)e(after)j(the)f
Fg(\014nal)21 b Fn(decoration)14 b(of)h(the)f(parse)h(tree,)e(whic)o(h)
h(follo)o(ws)g(parsing)i(of)164 1727 y(a)d(correct)g(input.)20
b(This)13 b(section)g(sho)o(ws)h(ho)o(w)f(the)g(Ox)g(user)g(can)g
(cause)g Fg(p)n(ostde)n(c)n(or)n(ation)164 1787 y(tr)n(aversals)t
Fn(,)42 b(eac)o(h)20 b(of)g(whic)o(h)g(p)q(ermits)f(access)h(\(in)g(a)g
(user-sp)q(eci\014ed)g(order\))h(to)f(the)164 1847 y(tree's)15
b(attribute)h(instances.)164 1992 y Fb(9.1)70 b(Example:)29
b(in\014x)23 b(to)g(pre\014x)g(translation)164 2084 y
Fn(The)15 b(problem)e(of)j(parsing)f(in\014x)g(arithmetic)d
(expressions,)j(and)h(their)e(translation)i(to)164 2144
y(pre\014x)g(form)f(serv)o(es)g(to)i(in)o(tro)q(duce)f(Ox's)g(p)q
(ostdecoration)h(tra)o(v)o(ersal)e(facilit)o(y)l(.)237
2204 y(The)j(tok)o(ens)g(of)g(the)g(example)e(language)j(are)f
(determined)d(b)o(y)j(the)f(follo)o(wing)h(L-)164 2264
y(\014le:)p eop
%%Page: 19 20
19 19 bop 164 162 a Fk(9)49 b(POSTDECORA)l(TION)16 b(TRA)-5
b(VERSALS)678 b Fn(19)164 357 y Fa(\045{)164 407 y(#include)20
b("y.tab.h")164 457 y(#include)g("oxout.h")164 506 y(\045})164
606 y(\045\045)164 656 y([)i(\\n\\t\\f]*)85 b(;)164 706
y([0-9]+)173 b(return\(CONST\);)19 b(@{)i(sscanf\(yytext,"\045d",)o
(&@CON)o(ST.va)o(l@\);)d(@})164 756 y(\\\()261 b(return\('\('\);)164
805 y(\\\))g(return\('\)'\);)164 855 y(\\+)g(return\('+'\);)164
905 y(\\*)g(return\('*'\);)164 955 y(.)283 b(fprintf\(stderr,"il)o
(legal)18 b(character\\n"\);)164 1005 y(\045\045)237
1169 y Fn(The)e(follo)o(wing)g(Y-\014le)g(completes)e(the)i(sp)q
(eci\014cation)g(of)g(the)g(ev)m(aluator.)p eop
%%Page: 20 21
20 20 bop 164 162 a Fk(9)49 b(POSTDECORA)l(TION)16 b(TRA)-5
b(VERSALS)678 b Fn(20)164 357 y Fa(\045token)21 b(CONST)164
407 y(\045left)g('+')164 457 y(\045left)g('*')164 556
y(@attributes)e({int)i(val;})g(CONST)164 606 y(@traversal)f
(@lefttoright)f(@preorder)h(LRpre)164 706 y(\045{)164
756 y(#include)g("oxout.h")164 805 y(#include)g(<stdio.h>)164
855 y(\045})164 955 y(\045\045)164 1005 y(expr)86 b(:)153
b(expr)86 b('*')108 b(expr)544 b(/*)22 b(rule)f(1)g(*/)513
1054 y(@{)g(@LRpre)42 b(printf\(")21 b(*)g("\);)g(@})338
1154 y(|)153 b(expr)86 b('+')108 b(expr)544 b(/*)22 b(rule)f(2)g(*/)513
1204 y(@{)g(@LRpre)42 b(printf\(")21 b(+)g("\);)g(@})338
1303 y(|)153 b('\(')108 b(expr)86 b('\)')566 b(/*)22
b(rule)f(3)g(*/)338 1403 y(|)153 b(CONST)870 b(/*)22
b(rule)f(4)g(*/)513 1453 y(@{)g(@LRpre)42 b(printf\(")21
b(\045d)g(",@CONST.val@\);)e(@})338 1503 y(;)164 1553
y(\045\045)164 1702 y(main\(\))208 1752 y({yyparse\(\);)229
1802 y(printf\("\\n"\);)208 1851 y(})237 2015 y Fn(The)25
b(sequence:)38 b Fd(@traversal)22 b(@lefttorigh)o(t)h(@preorder)f
(LRpre)h Fn(sp)q(eci\014es)164 2076 y(that)18 b(a)g(left-to-righ)o(t)f
(preorder)g(tra)o(v)o(ersal)g(of)h(the)f(parse)h(tree)f(b)q(e)h(p)q
(erformed)e(b)o(y)h(the)164 2136 y(ev)m(aluator)j(after)g(the)g
(\014nal)f(decoration,)i(and)f(that)h(the)e(tra)o(v)o(ersal)g(b)q(e)h
(iden)o(ti\014ed)e(as)164 2196 y Fd(LRpre)p Fn(.)25 b(Note)18
b(that)h Fd(LRpre)d Fn(is)i(programmer-de\014ned,)e(and)j(is)f
Fg(not)24 b Fn(an)18 b(Ox)g(reserv)o(ed)164 2256 y(w)o(ord.)237
2316 y(Eac)o(h)h(attribute)g(reference)e(section)i(in)f(the)h(ab)q(o)o
(v)o(e)g(Y-\014le)f(con)o(tains)h(a)g Fg(tr)n(aversal)164
2377 y(action)e(sp)n(e)n(ci\014er)k Fn(starting)15 b(with)g(the)g
Fg(tr)n(aversal)h(mo)n(de)g(annunciator)22 b Fd(@LRpre)p
Fn(,)13 b(whic)o(h)164 2437 y(is)j(de\014ned)g(in)g(the)g(ab)q(o)o(v)o
(e-men)o(tioned)e Fd(@traversal)f Fn(sp)q(eci\014cation.)p
eop
%%Page: 21 22
21 21 bop 164 162 a Fk(9)49 b(POSTDECORA)l(TION)16 b(TRA)-5
b(VERSALS)678 b Fn(21)237 307 y(When)24 b(the)g Fd(LRpre)e
Fn(tra)o(v)o(ersal)h(reac)o(hes)h(a)g(no)q(de)h(at)f(whic)o(h)f(rule)h
(1)g(is)g(applied,)164 367 y(an)f(asterisk)f(is)g(prin)o(ted,)h(then)f
(eac)o(h)g(subtree)g(ro)q(oted)i(at)e(a)h(c)o(hild)e(of)i(the)f(no)q
(de)h(is)164 428 y(tra)o(v)o(ersed,)14 b(the)h(leftmost)f(subtree)i
(\014rst.)21 b(The)15 b(b)q(eha)o(vior)h(of)g(the)f(tra)o(v)o(ersal)g
(at)g(a)h(no)q(de)164 488 y(at)22 b(whic)o(h)g(rule)f(2)h(is)g(applied)
g(is)f(the)h(same,)g(except)f(that)h(a)h(plus)f(sign)g(is)g(prin)o(ted)
164 548 y(instead)d(of)g(an)g(asterisk.)29 b(When)18
b Fd(LRpre)f Fn(reac)o(hes)h(a)i(no)q(de)f(for)g(rule)f(3,)h(no)h(tra)o
(v)o(ersal)164 608 y(action)15 b(is)f(p)q(erformed,)g(but)h(the)f(c)o
(hildren)f(of)i(the)g(no)q(de)g(are)g(tra)o(v)o(ersed)f(recursiv)o(ely)
e(as)164 668 y(describ)q(ed)k(ab)q(o)o(v)o(e)g(for)g(no)q(des)h(for)g
(rules)f(1)g(and)h(2.)22 b(The)16 b Fd(val)f Fn(attribute)h(of)h(the)f
Fd(CONST)164 729 y Fn(c)o(hild)i(is)h(prin)o(ted)f(when)i(a)g(no)q(de)g
(for)f(rule)g(4)h(is)f(reac)o(hed.)29 b(No)20 b(action)f(is)g(p)q
(erformed)164 789 y(during)d(a)h(tra)o(v)o(ersal)f(of)g(a)h(subtree)f
(that)g(consists)h(of)g(a)f(terminal)e(no)q(de.)164 933
y Fb(9.2)70 b(General)22 b(description)164 1025 y Fj(9.2.1)55
b(T)-5 b(ra)n(v)n(ersal)19 b(sp)r(eci\014cations)164
1118 y Fn(The)f(Ox)f(programmer)g(ma)o(y)f(place)h(in)h(the)f
(declarations)h(section)g(\(the)f(part)i(b)q(efore)164
1178 y(the)f(\014rst)g Fd(\045\045)f Fn(mark\))f(of)j(the)e(Y-\014le)g
(one)h(or)g(more)f Fg(tr)n(aversal)i(sp)n(e)n(ci\014c)n(ations)t
Fn(.)26 b(Suc)o(h)18 b(a)164 1238 y(sp)q(eci\014cation)d(consists)g(of)
g(the)g(reserv)o(ed)e(w)o(ord)i Fd(@traversal)p Fn(,)c(follo)o(w)o(ed)j
(b)o(y)h(a)g Fg(tr)n(aver-)164 1298 y(sal)i(sp)n(e)n(ci\014er)f(se)n
(quenc)n(e)21 b Fn(and)16 b(a)f(non-empt)o(y)f(sequence)g(of)i(iden)o
(ti\014ers,)d(the)i(iden)o(ti\014ers)164 1359 y(b)q(eing)k(separated)h
(b)o(y)e(whitespace.)29 b(A)18 b(tra)o(v)o(ersal)h(sp)q(eci\014er)f
(sequence)g(ma)o(y)f(con)o(tain)164 1419 y(the)f(follo)o(wing)g
Fg(tr)n(aversal)h(sp)n(e)n(ci\014ers)j Fn(\(in)c(an)o(y)g(order\):)237
1521 y Fc(\017)24 b Fn(at)17 b(most)e(one)h(of:)22 b
Fd(@postorder)o Fn(,)13 b Fd(@preorder)237 1622 y Fc(\017)24
b Fn(at)17 b(most)e(one)h(of:)22 b Fd(@lefttorig)o(ht)p
Fn(,)12 b Fd(@righttolef)o(t)237 1724 y Fc(\017)24 b
Fn(optionally:)d Fd(@disable)164 1826 y Fn(If)15 b(neither)g
Fd(@postorder)d Fn(nor)k Fd(@preorder)c Fn(app)q(ears)17
b(in)f(the)f(sequence,)f(the)i(tra)o(v)o(ersal)164 1886
y(is)g(p)q(ostorder)h(b)o(y)e(default.)21 b(A)16 b(left-to-righ)o(t)f
(tra)o(v)o(ersal)g(is)h(sp)q(eci\014ed)g(b)o(y)f(default)h(when)164
1946 y(neither)f Fd(@lefttorigh)o(t)e Fn(nor)k Fd(@righttole)o(ft)c
Fn(app)q(ears.)237 2006 y(F)l(ollo)o(wing)19 b(the)g(\014nal)h
(decoration,)g(the)f(parse)g(tree)g(is)g(tra)o(v)o(ersed)g(once)g(for)g
(eac)o(h)164 2066 y(tra)o(v)o(ersal)g(sp)q(eci\014cation.)32
b(The)20 b(order)g(of)g(p)q(erforming)f(the)g(tra)o(v)o(ersals)h
(corresp)q(onds)164 2127 y(to)j(the)f(order)h(of)g(app)q(earance)g(of)g
(the)f(tra)o(v)o(ersal)g(sp)q(eci\014cations.)40 b(The)23
b Fd(@disable)164 2187 y Fn(reserv)o(ed)15 b(w)o(ord)i(causes)g(the)f
(generated)g(ev)m(aluator)h(to)g(skip)f(an)o(y)h(tra)o(v)o(ersal)e(in)h
(whose)164 2247 y(sp)q(eci\014cation)g(it)g(app)q(ears,)h(whic)o(h)e
(ma)o(y)g(b)q(e)h(useful)g(for)h(debugging.)237 2307
y(The)f(co)q(de)h(fragmen)o(t:)292 2409 y Fd(@traversal)22
b(@preorder)g(LRpre)292 2469 y(@traversal)g(LRpost)p
eop
%%Page: 22 23
22 22 bop 164 162 a Fk(9)49 b(POSTDECORA)l(TION)16 b(TRA)-5
b(VERSALS)678 b Fn(22)164 307 y(app)q(earing)14 b(in)e(the)h
(declarations)g(section)f(sp)q(eci\014es)g(that,)i(after)f(the)f
(\014nal)h(decoration,)164 367 y(the)g(generated)g(ev)m(aluator)g(is)g
(to)h(p)q(erform)e(a)h(left-to-righ)o(t)g(preorder)g(tra)o(v)o(ersal)f
(named)164 428 y Fd(LRpre)p Fn(,)i(follo)o(w)o(ed)h(b)o(y)h(a)h
(left-to-righ)o(t)e(p)q(ostorder)j(tra)o(v)o(ersal)d(named)g
Fd(LRpost)p Fn(.)164 557 y Fj(9.2.2)55 b(T)-5 b(ra)n(v)n(ersal)19
b(action)f(sp)r(eci\014cations)164 650 y Fn(In)e(addition)g(to)g
(attribute)g(de\014nitions)g(\(section)f(5.2\),)h(the)g(attribute)g
(reference)e(sec-)164 710 y(tions)j(of)g(the)f(Y-\014le)f(ma)o(y)g(con)
o(tain)i Fg(tr)n(aversal)g(action)i(sp)n(e)n(ci\014c)n(ations)t
Fn(.)j(Eac)o(h)16 b(of)h(these)164 770 y(consists)f(of)g(a)g
Fg(tr)n(aversal)g(mo)n(de)g(annunciator)5 b Fn(,)17 b(follo)o(w)o(ed)e
(b)o(y)g(a)h(sequence)e(of)i Fg(dynamic)164 830 y(tr)n(aversal)h(mo)n
(di\014ers)36 b Fn(and)17 b(a)g Fg(tr)n(aversal)g(action)t
Fn(.)22 b(A)16 b(tra)o(v)o(ersal)f(mo)q(de)g(ann)o(unciator)i(is)164
891 y Fd(@)f Fn(follo)o(w)o(ed)f(immedi)o(ately)e(b)o(y)j(the)g(name)f
(of)h(a)h(previously-declared)e(tra)o(v)o(ersal.)237
940 y(Supp)q(ose)j(tra)o(v)o(ersal)e(sp)q(eci\014cations)h(of)g
Fd(LRpre)e Fn(and)j Fd(LRpost)d Fn(as)i(ab)q(o)o(v)o(e.)23
b(Then)17 b(in)164 990 y(the)f(co)q(de)g(fragmen)o(t:)273
1082 y Fa(s)87 b(:)109 b(expr)513 1131 y(@{)21 b(@LRpost)f
(printf\("\\n"\);)521 b(/*)21 b(1)h(*/)578 1181 y(@LRpost)e(@revorder)g
(\(1\))h(printf\("postfix:)41 b("\);)i(/*)21 b(2)h(*/)578
1231 y(@LRpre)42 b(@revorder)20 b(\(1\))h(printf\("\\n"\);)216
b(/*)21 b(3)h(*/)578 1281 y(@LRpre)42 b(printf\("prefix:)63
b("\);)348 b(/*)21 b(4)h(*/)513 1331 y(@})382 1380 y(;)164
1482 y Fn(the)14 b(attribute)h(reference)e(section)h(has)h(four)g(tra)o
(v)o(ersal)f(action)h(sp)q(eci\014cations)f(and)h(no)164
1542 y(attribute)20 b(de\014nitions.)34 b(Eac)o(h)20
b(sp)q(eci\014cation)h(is)f(announced)h(b)o(y)f(either)f
Fd(@LRpre)g Fn(or)164 1602 y Fd(@LRpost)p Fn(.)f(Eac)o(h)e(of)f(the)g
Fd(printf)e Fn(statemen)o(ts)h(constitutes)h(a)h(tra)o(v)o(ersal)e
(action.)21 b(The)164 1663 y(form)c(of)i(a)f(tra)o(v)o(ersal)g(action)g
(is)g(that)h(of)f(a)h(C)f(co)q(de)h(fragmen)o(t,)e(except)g(that)i(it)e
(ma)o(y)164 1723 y(con)o(tain)f(references)f(to)h(the)g(attribute)g(o)q
(ccurrences)g(of)h(the)f(asso)q(ciated)h(rule.)237 1783
y(The)j(second)f(and)h(third)g(sp)q(eci\014cations)f(eac)o(h)g(ha)o(v)o
(e)g Fd(@revorder)j(\(1\))d Fn(as)h(a)g(dy-)164 1843
y(namic)15 b(tra)o(v)o(ersal)i(mo)q(di\014er.)22 b(A)16
b(dynamic)g(tra)o(v)o(ersal)g(mo)q(di\014er)f(is)i(either)f
Fd(@revorder)164 1903 y Fn(or)24 b Fd(@revdirect)o(ion)o
Fn(,)f(follo)o(w)o(ed)g(b)o(y)g(a)h(paren)o(thesized)f(expression)g
(that)i(conforms)164 1964 y(to)e(C)f(syn)o(tax,)h(except)e(that)i(it)f
(ma)o(y)e(refer)i(to)h(the)f(rule's)f(attribute)h(o)q(ccurrences.)164
2024 y Fd(@revorder)e Fn(and)25 b Fd(@revdirec)o(tio)o(n)c
Fn(ma)o(y)h(eac)o(h)h(o)q(ccur)h(at)g(most)f(once)g(in)h(a)g(giv)o(en)
164 2084 y(tra)o(v)o(ersal)e(action)h(sp)q(eci\014cation.)40
b(If)23 b Fd(@revdirec)o(tio)o(n)d Fn(app)q(ears)k(in)e(t)o(w)o(o)h
(tra)o(v)o(ersal)164 2144 y(action)15 b(sp)q(eci\014cations)g(within)f
(a)h(giv)o(en)f(attribute)g(reference)f(section,)h(the)h(t)o(w)o(o)g
(sp)q(ec-)164 2204 y(i\014cations)25 b(m)o(ust)f(ha)o(v)o(e)g
(di\013eren)o(t)g(ann)o(unciators.)48 b(Dynamic)24 b(tra)o(v)o(ersal)g
(mo)q(di\014ers)164 2265 y(are)e(used)h(to)f(o)o(v)o(erride)f(the)h
(tra)o(v)o(ersal)f(sp)q(eci\014cations)i(of)f(a)h(giv)o(en)e(tra)o(v)o
(ersal)h(when)164 2325 y(it)13 b(reac)o(hes)g(a)h(giv)o(en)f(kind)g(of)
h(no)q(de.)21 b(The)13 b(mo)q(di\014er)g Fd(@revorder)d
Fg(expr)19 b Fn(means)13 b(roughly)164 2385 y(\\rev)o(erse)i(order)i
Fd(if)e Fg(expr)5 b Fn(".)23 b(When)16 b(the)g Fd(LRpre)e
Fn(tra)o(v)o(ersal)i(reac)o(hes)f(a)i(no)q(de)g(at)g(whic)o(h)164
2445 y(the)f(rule)g Fd(s)26 b(:)51 b(expr)15 b Fn(is)h(applied,)g(the)h
(expression)f Fd(\(1\))g Fn(is)g(ev)m(aluated,)g(and)i(b)q(ecause)p
eop
%%Page: 23 24
23 23 bop 164 162 a Fk(10)50 b(O)o(X)20 b(MA)o(CR)o(OS)1162
b Fn(23)164 307 y(it)16 b(is)g(nonzero,)g(the)g(third)f(tra)o(v)o
(ersal)h(action,)f(whic)o(h)h(prin)o(ts)g(a)g(line)f(feed,)g(is)h
(executed)164 367 y(as)e(if)f Fd(LRpre)e Fn(w)o(ere)i(a)g(p)q(ostorder)
i(tra)o(v)o(ersal,)d(i.e.,)g Fg(after)19 b Fn(the)13
b(recursiv)o(e)e(tra)o(v)o(ersal)i(of)g(the)164 428 y(subtree)k(ro)q
(oted)i(at)f(the)g(no)q(de's)g(sole)f(c)o(hild.)25 b(The)17
b(execution)g(of)h(the)f(fourth)i(tra)o(v)o(er-)164 488
y(sal)e(action,)f Fd(printf\("p)o(ref)o(ix)o(:)48 b("\);)16
b Fn(is)g(not)h(a\013ected)f(b)o(y)g(an)o(y)g(dynamic)f(tra)o(v)o
(ersal)164 548 y(mo)q(di\014er,)k(and)i(o)q(ccurs)f(according)h(to)f
Fd(LRpre)p Fn('s)e(\(static\))i(sp)q(eci\014cation,)g(i.e.)31
b Fg(b)n(efor)n(e)164 608 y Fn(the)16 b(tra)o(v)o(ersal)f(of)i(the)f(c)
o(hild)f(subtree.)237 668 y(When)k(the)g Fd(LRpost)f
Fn(tra)o(v)o(ersal)g(reac)o(hes)h(a)g(no)q(de)h(at)g(whic)o(h)e
Fd(s)26 b(:)51 b(expr)43 b Fn(is)19 b(ap-)164 729 y(plied,)e(the)h
(second)h(tra)o(v)o(ersal)f(action)g(is)g(executed,)f(the)h(tra)o(v)o
(ersal)g(pro)q(ceeds)g(to)h(the)164 789 y(c)o(hild)c(subtree,)g(then)h
(the)g(\014rst)h(tra)o(v)o(ersal)e(action)i(is)f(executed.)237
849 y(The)i(preceding)f(description)g(is)h(generally)f(su\016cien)o(t)g
(for)h(understanding)h(p)q(ost-)164 909 y(decoration)12
b(tra)o(v)o(ersals,)h(but)f(app)q(endix)g(B)g(con)o(tains)h(a)f(pseudo)
q(co)q(de)i(description)d(that)164 969 y(describ)q(es)16
b(the)g(b)q(eha)o(vior)g(somewhat)g(more)f(formally)l(.)237
1029 y(F)l(acilit)o(y)j(for)i(inorder)g(tra)o(v)o(ersal)f(is)g(to)i(b)q
(e)f(implem)o(en)n(ted)d(in)j(future)f(v)o(ersions)h(of)164
1090 y(Ox.)164 1256 y Fo(10)83 b(Ox)27 b(macros)164 1366
y Fn(Ox's)17 b(input)h(sp)q(eci\014cation)f(ma)o(y)g(b)q(e)h(suc)o(h)f
(that)h(the)g(same)f(or)h(similar)e(text)h(app)q(ears)164
1426 y(in)22 b(more)f(than)h(one)h(place)e(in)h(attribute)g(reference)f
(sections.)38 b(There)22 b(is)g(a)h(macro)164 1486 y(substitution)16
b(feature)g(that)h(can)g(b)q(e)f(used)g(to)h(decrease)f(v)o(erb)q(osit)
o(y)f(in)h(suc)o(h)g(cases.)164 1630 y Fb(10.1)70 b(Macro)24
b(de\014nitions)164 1723 y Fn(Ox)19 b(macros)f(are)h(de\014ned)f(in)h
(the)g(declaration)f(section)h(of)g(the)g(Y-\014le.)28
b(Suc)o(h)19 b(a)g(def-)164 1783 y(inition)e(consists)i(of)f(the)g
Fd(@macro)e Fn(reserv)o(ed)h(w)o(ord,)h(an)h(iden)o(ti\014er)d(\(the)i
(name)f(of)h(the)164 1843 y(macro\),)j(a)h(left)e(paren)o(thesis,)i(a)g
(parameter)e(list,)h(a)h(righ)o(t)f(paren)o(thesis,)h(the)f(b)q(o)q(dy)
164 1903 y(of)d(the)f(macro,)f(and)i(the)f Fd(@end)f
Fn(reserv)o(ed)g(w)o(ord.)25 b(The)17 b(parameter)f(list)h(is)g(a)h(p)q
(ossibly)164 1964 y(empt)o(y)10 b(sequence)h(of)i(iden)o(ti\014ers,)e
(eac)o(h)h(\(including)g(the)g(last,)h(if)f(the)g(list)f(is)i(nonempt)o
(y\))164 2024 y(follo)o(w)o(ed)j(b)o(y)g(a)h(comma.)j(Eac)o(h)c(iden)o
(ti\014er)f(is)h(a)h(sequence)f(of)h(letters)e(and)j(digits,)e(b)q(e-)
164 2084 y(ginning)g(with)g(a)g(letter.)k(The)c(b)q(o)q(dy)h(of)f(the)g
(macro)f(is)g(a)i(segmen)o(t)d(of)i(arbitrary)g(text,)164
2144 y(terminated)j(b)o(y)i(the)g(\014rst)h(o)q(ccurrence)e(of)i
Fd(@end)p Fn(,)e(with)h(the)g(follo)o(wing)g(exceptions:)164
2204 y(When)e(inside)f(a)h(commen)o(t)d(or)j(a)g(string,)g(or)h(when)f
(preceded)e(immediatel)o(y)f(b)o(y)i(the)164 2264 y(bac)o(kslash)g
(escap)q(e)g(c)o(haracter,)g(an)g(o)q(ccurrence)g(of)g
Fd(@end)f Fn(is)h(considered)f(part)i(of)f(the)164 2325
y(macro)f(b)q(o)q(dy)i(\(hence)f(do)q(es)h(not)f(terminate)e(the)i
(macro\).)26 b(Suc)o(h)18 b(a)h(bac)o(kslash)f(c)o(har-)164
2385 y(acter)e(is)g(deleted)f(from)g(the)h(macro)f(b)q(o)q(dy)l(.)p
eop
%%Page: 24 25
24 24 bop 164 162 a Fk(10)50 b(O)o(X)20 b(MA)o(CR)o(OS)1162
b Fn(24)164 307 y Fb(10.2)70 b(Macro)24 b(uses)164 400
y Fn(Ox)f(macros)f(are)h(used)g(only)g(in)g(attribute)g(reference)e
(sections)i(and)g(in)g(other)g(Ox)164 460 y(macros.)j(Substitution)18
b(o)q(ccurs)g(where)g(a)g(macro)f(use)h(is)g(encoun)o(tered)f(outside)h
(of)h(a)164 520 y(string,)d(commen)o(t,)d(or)j(attribute)g(name.)237
580 y(A)h(macro)f(use)h(consists)g(of)h(the)e(name)g(of)h(a)h
(previously-de\014ned)e(macro,)g(and)h(an)164 640 y(argumen)o(t)12
b(list)h(in)g(paren)o(theses.)20 b(The)13 b(argumen)o(t)f(list)h(is)g
(a)g(p)q(ossibly)h(empt)o(y)d(sequence)164 700 y(of)19
b(text)g(fragmen)o(ts,)f(eac)o(h)g(\(including)g(the)h(last\))g(suc)o
(h)f(fragmen)o(t)g(terminated)f(b)o(y)i(a)164 761 y(comma.)f(In)12
b(expanding)h(a)h(macro)e(use,)h(eac)o(h)f(text)g(fragmen)o(t)g(is)g
(substituted)h(for)g(eac)o(h)164 821 y(o)q(ccurrence)j(in)h(the)g
(macro)f(b)q(o)q(dy)i(of)g(the)e(corresp)q(onding)i(parameter)e(in)h
(the)g(macro)164 881 y(de\014nition.)33 b(If)20 b(commas,)f(paren)o
(theses,)h(or)h(bac)o(kslashes)f(are)h(to)g(app)q(ear)g(in)f(a)h(text)
164 941 y(fragmen)o(t,)16 b(they)g(m)o(ust)g(b)q(e)i(preceded)e(b)o(y)h
(bac)o(kslash)g(escap)q(e)h(c)o(haracters,)e(whic)o(h)h(are)164
1001 y(remo)o(v)o(ed)d(during)i(substitution.)237 1062
y(It)f(is)h(not)g(necessary)f(that)h(the)g(de\014nition)f(of)h(a)g
(macro)f(precede)f(that)i(of)g(another)164 1122 y(macro)d(in)g(whic)o
(h)g(it)g(is)h(used,)g(as)g(no)g(macro)f(substitution)h(o)q(ccurs)g(un)
o(til)f(Ox)g(pro)q(cesses)164 1182 y(the)j(attribute)g(reference)e
(sections.)164 1326 y Fb(10.3)70 b(Example)164 1419 y
Fn(The)16 b(follo)o(wing)g(excerpts)f(from)h(a)g(Y-\014le)g(illustrate)
f(the)h(use)g(of)h(Ox)f(macros.)p eop
%%Page: 25 26
25 25 bop 164 162 a Fk(11)50 b(A)o(UTOMA)l(TIC)14 b(GENERA)l(TION)h(OF)
h(COPY)g(R)o(ULES)386 b Fn(25)237 295 y(.)237 312 y(.)237
329 y(.)164 412 y Fa(@macro)21 b(exprdefs\(op,\))208
462 y(@i)g(@expr.1.env@)e(=)j(@expr.env@;)208 512 y(@i)f(@expr.2.env@)e
(=)j(@expr.env@;)208 562 y(@i)f(@expr.type@)e(=)j(typeResolve\(@expr.)o
(1.ty)o(pe@,@)o(expr.)o(2.typ)o(e@,\);)208 612 y(@i)f(@expr.value@)e(=)
j(exprEval\(op,@expr)o(.typ)o(e@,@e)o(xpr.1)o(.type)o(@,@ex)o(pr.2.)o
(type)o(@,)861 661 y(@expr.1.value@,@exp)o(r.2.v)o(alue@)774
711 y(\);)164 761 y(@end)164 861 y(@macro)f(typeResolve\(typ)o(e1,ty)o
(pe2,\))229 910 y(\(\(type1)g(==)g(type2\))g(?)g(type1)g(:)h
(FLOATTYPE\))164 960 y(@end)237 1028 y Fn(.)237 1045
y(.)237 1061 y(.)164 1145 y Fa(\045\045)237 1216 y Fn(.)237
1233 y(.)237 1249 y(.)164 1333 y Fa(expr)f(:)152 b(expr)87
b('*')108 b(expr)382 1383 y(@{)21 b(exprdefs\('*',\))e(@})338
1433 y(|)153 b(expr)86 b('/')108 b(expr)382 1483 y(@{)21
b(exprdefs\('/',\))e(@})338 1532 y(|)153 b(expr)86 b('+')108
b(expr)382 1582 y(@{)21 b(exprdefs\('+',\))e(@})338 1632
y(|)153 b(expr)86 b('-')108 b(expr)382 1682 y(@{)21 b(exprdefs\('-',\))
e(@})338 1732 y(;)237 1805 y Fn(.)237 1822 y(.)237 1838
y(.)164 1959 y(The)e(iden)o(ti\014er)f Fd(exprEval)f
Fn(referenced)h(in)h(the)g(de\014nition)g(of)h(the)f
Fd(exprdefs)e Fn(macro)164 2019 y(is)h(the)f(name)g(of)h(either)f(a)h
(C)g(macro)f(or)h(C)g(function.)21 b(The)16 b(Ox)f(macro)g
Fd(typeResolv)o(e)164 2079 y Fn(ab)q(o)o(v)o(e)e(con)o(tains)g(no)g
(Ox-sp)q(eci\014c)f(constructs)h(and,)h(as)f(a)h(matter)d(of)i(st)o
(yle,)f(could)h(ha)o(v)o(e)164 2139 y(b)q(een)j(declared)g(instead)g
(as)h(a)f(C)h(macro)e(or)i(C)f(function.)164 2304 y Fo(11)83
b(Automatic)27 b(generation)h(of)g(cop)n(y)e(rules)164
2414 y Fn(Often)13 b(a)g(Y-\014le)f(has)i(attribute)f(de\014nitions)g
(that)h(function)f(only)f(to)i(cop)o(y)f(an)g(instance)164
2474 y(b)q(elonging)f(to)g(one)f(no)q(de)i(to)e(a)h(lik)o(e-named)d
(instance)i(b)q(elonging)h(to)g(the)f(no)q(de's)h(paren)o(t)p
eop
%%Page: 26 27
26 26 bop 164 162 a Fk(11)50 b(A)o(UTOMA)l(TIC)14 b(GENERA)l(TION)h(OF)
h(COPY)g(R)o(ULES)386 b Fn(26)164 307 y(or)24 b(c)o(hild.)43
b(Large)25 b(attribute)f(grammars)f(tend)h(to)g(ha)o(v)o(e)f(man)o(y)g
(suc)o(h)h(de\014nitions,)164 367 y(whic)o(h)19 b(are)g(sometimes)e
(called)h Fg(c)n(opy)i(rules)t Fn(.)32 b(The)20 b(situation)f(is)h
(conspicuous)g(when)164 428 y(con)o(textual)15 b(information)h(is)g(mo)
o(v)o(ed)e(leafw)o(ard)i(via)g(inherited)f(attributes.)237
488 y(The)i(Ox)g(user)g(ma)o(y)f(place)h(in)g(the)g(declarations)g
(section)g(of)g(the)g(Y-\014le)g(the)f(con-)164 548 y(struct:)237
668 y Fd(@autoinh)d Fi(<)p Fn(ID)p 554 668 15 2 v 18
w(list)p Fi(>)164 789 y Fn(where)j Fi(<)p Fn(ID)p 401
789 V 18 w(list)p Fi(>)g Fn(is)g(a)h(whitespace-separated)h(list)e(of)h
(attribute)f(names.)22 b(Supp)q(ose)164 849 y(that)16
b Fd(attrbID)c Fn(is)k(suc)o(h)f(an)g(attribute)g(name,)f(and)i(the)f
(ab)q(o)o(v)o(e)g(construct)h(is)f(follo)o(w)o(ed)164
909 y(b)o(y)f(an)i Fd(@attribut)o(es)c Fn(declaration)i(whereb)o(y)g
Fd(attrbID)f Fn(is)h(declared)g(as)i(an)f(attribute)164
969 y(of)i(the)f(grammar)f(sym)o(b)q(ol)g Fd(gSym)p Fn(.)21
b(Then)c(Ox)f(kno)o(ws)h(that)g Fd(attrbID)d Fn(is)i(an)h(inherited)164
1029 y(attribute)12 b(of)h Fd(gSym)p Fn(.)19 b(F)l(urther,)12
b(for)h(an)o(y)f(rule)g(ha)o(ving)h Fd(gSym)e Fn(on)i(the)f(RHS,)g(Ox)g
(searc)o(hes)164 1090 y(that)k(rule's)g(attribute)f(reference)g
(section)g(for)i(de\014nitions)f(of)g(the)g(RHS)f(o)q(ccurrences)164
1150 y(of)j Fd(attrbID)p Fn(.)c(When)j(suc)o(h)g(a)h(de\014nition)e(is)
h(missing,)f(Ox)h(c)o(hec)o(ks)f(whether)h(the)g(LHS)164
1210 y(has)g(an)f(o)q(ccurrence)f(of)h Fd(attrbID)p Fn(.)d(If)i(so,)i
(Ox)e(generates)h(de\014nitions)g(that)g(cop)o(y)f(that)164
1270 y(LHS)i(o)q(ccurrence)f(to)h(eac)o(h)g(RHS)f Fd(attrbID)f
Fn(o)q(ccurrence)h(that)h(lac)o(ks)f(a)i(de\014nition.)k(If)164
1330 y(there)16 b(is)g(no)g(suc)o(h)g(LHS)h(o)q(ccurrence,)e(Ox)h
(issues)g(an)h(error)f(message.)237 1391 y(There)j(is)h(an)g(analagous)
h(construct)f(for)g(automatic)e(generation)i(of)g(de\014nitions)164
1451 y(of)d(syn)o(thesized)d(o)q(ccurrences:)237 1571
y Fd(@autosyn)f Fi(<)p Fn(ID)p 554 1571 V 18 w(list)p
Fi(>)164 1692 y Fn(When)23 b(the)f Fd(@autosyn)e Fn(construct)i(is)h
(used,)h(Ox)e(tries)g(to)h(supply)g(missing)e(de\014ni-)164
1752 y(tions)e(of)g(syn)o(thesized)f(o)q(ccurrences)g(b)o(y)h(searc)o
(hing)f(the)h(RHS)f(for)h(same-named)e(o)q(c-)164 1812
y(currences.)41 b(If)23 b(exactly)f(one)i(suc)o(h)f(RHS)f(o)q
(ccurrence)h(is)g(found,)i(Ox)e(generates)h(a)164 1872
y(de\014nition)16 b(to)g(cop)o(y)g(it)g(to)h(the)f(LHS,)g(otherwise)g
(there)f(is)h(an)h(error.)237 1932 y(The)i(ab)q(o)o(v)o(e-describ)q(ed)
f(constructs)i(ha)o(v)o(e)e(a)h(global)g(c)o(haracter)f(in)h(that)g(a)g
(single)164 1993 y Fd(@autosyn)12 b Fn(or)j Fd(@autoinh)c
Fn(declaration)j(can)h(easily)f(b)q(e)h(used)f(to)h(supply)g(missing)e
(de\014-)164 2053 y(nitions)e(for)h(all)f(o)q(ccurrences)g(of)h
(attributes)g(of)g(a)f(giv)o(en)g(name.)19 b(These)11
b(reserv)o(ed)f(w)o(ords)164 2113 y(ma)o(y)17 b(b)q(e)i(used)g(in)g(a)g
(more)e(conserv)m(ativ)o(e)h(w)o(a)o(y)h(that)g(generates)g(missing)e
(de\014nitions)164 2173 y(only)f(for)h(o)q(ccurrences)e(b)q(elonging)i
(to)g(a)f(selected)f(set)h(of)h(grammar)e(sym)o(b)q(ols:)237
2233 y(A)o(ttribute)24 b(declarations)h(are)g(written)f(as)i(usual,)h
(except)d(that)h Fd(@autoinh)e Fn(or)164 2293 y Fd(@autosyn)18
b Fn(ma)o(y)h(app)q(ear)j(b)q(efore)f(the)g(attribute's)f(t)o(yp)q(e)h
(sp)q(eci\014er)f(\(i.e.,)g(after)h Fc(f)g Fn(or)164
2354 y Fd(;)p Fn(\).)g(Where)15 b Fi(<)p Fn(ID)p 495
2354 V 18 w(list)p Fi(>)g Fn(is)h(the)g(usual)h(comma-)d(separated)j
(list)e(of)h(attribute)g(names,)164 2414 y(and)h Fd(attrbID)c
Fn(is)k(a)f(mem)o(b)q(er)d(of)k Fi(<)p Fn(ID)p 883 2414
V 17 w(list)p Fi(>)p Fn(:)p eop
%%Page: 27 28
27 27 bop 164 162 a Fk(11)50 b(A)o(UTOMA)l(TIC)14 b(GENERA)l(TION)h(OF)
h(COPY)g(R)o(ULES)386 b Fn(27)237 307 y Fd(@attribute)o(s)87
b Fc(f)676 354 y Fn(.)676 370 y(.)676 387 y(.)676 447
y Fd(@autoinh)13 b Fi(<)p Fn(t)o(yp)q(esp)q(ec)p Fi(>)j(<)p
Fn(ID)p 1270 447 15 2 v 17 w(list)p Fi(>)g Fd(;)676 491
y Fn(.)676 507 y(.)676 524 y(.)603 584 y Fc(g)619 644
y Fi(<)p Fn(grammar)p 854 644 V 16 w(sym)o(b)q(ol)p 1022
644 V 16 w(list)p Fi(>)164 764 y Fn(declares)j Fd(attrbID)e
Fn(as)j(an)g(inherited)f(attribute)g(whenev)o(er)g(it)g(o)q(ccurs)h(in)
f(a)h(sym)o(b)q(ol)164 825 y(in)15 b Fi(<)p Fn(grammar)p
455 825 V 16 w(sym)o(b)q(ol)p 623 825 V 16 w(list)p Fi(>)p
Fn(.)21 b(F)l(urther,)14 b(this)i(instructs)f(Ox)h(to)g(attempt)e(to)i
(supply)164 885 y(missing)f(de\014nitions)h(of)g(suc)o(h)h(o)q
(ccurrences)e(b)o(y)h(cop)o(ying)g(from)f(the)h(LHS.)237
945 y Fd(@autosyn)d Fn(ma)o(y)i(b)q(e)i(used)f(lo)q(cally)f(in)h(an)h
(analagous)h(manner.)237 1005 y(F)l(or)i(safet)o(y)g(in)f(the)h(use)g
(of)g Fd(@autosyn)d Fn(and)k Fd(@autoinh)p Fn(,)c(there)i(is)h(pro)o
(vided)f(the)164 1065 y Fd(@warn)d Fn(reserv)o(ed)g(w)o(ord.)26
b(When)18 b(it)f(immediatel)o(y)e(follo)o(ws)i Fd(@autosyn)e
Fn(or)j Fd(@autoinh)p Fn(,)164 1126 y(Ox)g(issues)h(a)g(w)o(arning)g
(for)g(eac)o(h)g(de\014nition)f(supplied)g(b)o(y)g(virtue)g(of)h(the)g
(preceding)164 1186 y Fd(@autosyn)h Fn(or)i Fd(@autoinh)p
Fn(.)38 b Fd(@warn)20 b Fn(is)j(mainly)d(to)j(b)q(e)g(used)f(when)h(mo)
q(difying)e(the)164 1246 y(attribute)16 b(grammar.)164
1390 y Fb(11.1)70 b(Example)164 1483 y Fn(The)16 b(follo)o(wing)g(co)q
(de)h(fragmen)o(t)e(in)g(the)h(declarations)h(section)f(of)g(the)g
(Y-\014le:)p eop
%%Page: 28 29
28 28 bop 164 162 a Fk(11)50 b(A)o(UTOMA)l(TIC)14 b(GENERA)l(TION)h(OF)
h(COPY)g(R)o(ULES)386 b Fn(28)383 295 y(.)383 312 y(.)383
329 y(.)292 430 y Fd(@autoinh)23 b(env)292 551 y(@attribute)o(s)g
({struct)g(env)h(*env;)625 611 y(regNumType)e(maxRegNum;)600
671 y(})600 731 y(execElem)g(statement)292 852 y(@autosyn)h(maxRegNum)
292 972 y(@attribute)o(s)g({struct)g(env)h(*env;)625
1032 y(@autoinh)f(regNumType)f(regNum;)625 1092 y(regNumType)g
(maxRegNum;)625 1153 y(struct)i(sym)g(*formParamL)o(ist)o(;)625
1213 y(struct)g(sym)g(*func;)625 1273 y(lineNumType)e(line;)600
1333 y(})600 1393 y(actParamL)o(ist)292 1514 y(@attribute)o(s)h
({struct)g(env)h(*env;)625 1574 y(@autosyn)f(@warn)h(struct)f(sym)i
(*varLoc,*f)o(un)o(cLo)o(c;)625 1634 y(regNumType)d(regNum;)625
1694 y(regNumType)g(maxRegNum;)600 1755 y(})600 1815
y(block)i(blockElem)o(Li)o(st)383 1890 y Fn(.)383 1907
y(.)383 1923 y(.)164 2044 y(causes)g(Ox)f(to)h(attempt)e(to)h
(automatically)f(supply)h(missing)f(de\014nitions)i(for)f(o)q(c-)164
2104 y(currences)15 b(of:)p eop
%%Page: 29 30
29 29 bop 164 162 a Fk(12)50 b(FILE-LEVEL)17 b(OR)o(GANIZA)l(TION)c(OF)
j(O)o(X)21 b(EV)-5 b(ALUA)l(TORS)237 b Fn(29)237 307
y Fc(\017)24 b Fd(env)10 b Fn(for)h Fd(execElem)p Fn(,)d
Fd(statement)p Fn(,)g Fd(actParamLis)o(t)p Fn(,)h Fd(block)p
Fn(,)g(and)j Fd(blockElem)o(Lis)o(t)237 409 y Fc(\017)24
b Fd(maxRegNum)13 b Fn(for)j Fd(actParamLis)o(t)p Fn(,)d
Fd(block)p Fn(,)h(and)j Fd(blockElem)o(Lis)o(t)237 511
y Fc(\017)24 b Fd(regNum)14 b Fn(for)i Fd(actParamLis)o(t)237
612 y Fc(\017)24 b Fd(varLoc)14 b Fn(for)i Fd(block)f
Fn(and)i Fd(blockElem)o(Lis)o(t)p Fn(,)c(with)j(w)o(arning)237
714 y Fc(\017)24 b Fd(funcLoc)14 b Fn(for)i Fd(block)f
Fn(and)h Fd(blockElemLi)o(st)p Fn(,)c(with)17 b(w)o(arning)164
880 y Fo(12)83 b(File-lev)n(el)26 b(organization)i(of)g(Ox)f(ev)-5
b(aluators)164 1004 y Fb(12.1)70 b(Con)n(v)n(en)n(tions)23
b(of)g(naming)g(Ox)f(output)i(\014les)164 1097 y Fn(Ox)15
b(translates)h(the)f(Y-\014le)f(in)o(to)h(a)h(\014le)e(destined)h(for)h
(pro)q(cessing)g(b)o(y)e(Y)l(acc,)h(giv)o(en)f(the)164
1157 y(name)26 b Fd(oxout.y)p Fn(.)17 b(The)d(L-\014les)g(are)f
(translated)h(in)o(to)f(\014les)g(destined)g(for)g(Lex.)21
b(If)13 b(there)164 1217 y(is)h(exactly)f(one)h(L-\014le,)g(its)g
(corresp)q(onding)h(output)g(\014le)e(is)h(named)f Fd(oxout.l)p
Fn(.)18 b(If)c(there)164 1277 y(is)23 b(more)f(than)i(one)f(L-\014le,)i
(the)e(corresp)q(onding)i(outputs)f(are)f(named)f Fd(oxout0.l)p
Fn(,)164 1338 y Fd(oxout1.l)p Fn(,)13 b Fd(oxout2.l)p
Fn(,)g(etc.)164 1482 y Fb(12.2)70 b(Review:)26 b(com)n(bining)17
b(the)h(outputs)i(of)f(Y)-6 b(acc)18 b(and)i(Lex)164
1574 y Fn(In)f(dev)o(eloping)f(an)i(ordinary)f(\(i.e.,)f(non-Ox\))i(Y)l
(acc/Lex)f(ev)m(aluator,)h Fd(y.tab.c)c Fn(and)164 1635
y Fd(lex.yy.c)11 b Fn(can)i(b)q(e)h(compiled)d(imme)o(diately)f(in)o
(to)j(an)h(executable)e(\014le)h(b)o(y)g(placing)g(the)164
1695 y(line)369 1796 y Fd(#include)23 b("lex.yy.c)o(")164
1898 y Fn(in)16 b(a)h(C-co)q(de)f(section)g(of)h(the)f(Y)l(acc)f(input)
h(sp)q(eci\014cation)g([Lesk)g(75)q(].)237 1958 y(Alternativ)o(ely)l(,)
c(Y)l(acc)j(can)g(b)q(e)g(instructed)g(\(b)o(y)g(using)g(the)g
Fd(-d)g Fn(command-line)d(op-)164 2019 y(tion\))h(to)g(pro)q(duce)h(a)f
(separate)h(\014le)e Fd(y.tab.h)e Fn(that)k(con)o(tains)f(declarations)
g(needed)f(b)o(y)164 2079 y(b)q(oth)j Fd(y.tab.c)d Fn(and)i
Fd(lex.yy.c)p Fn(.)k(The)c(t)o(w)o(o)g(\014les)g(ma)o(y)e(then)i(b)q(e)
g(compiled)e(separately)164 2139 y(if)k(the)g(line)369
2241 y Fd(#include)23 b("y.tab.h")164 2342 y Fn(is)11
b(placed)g(in)f(a)i(C-co)q(de)g(sections)f(of)g(the)g(Lex)g(input)g(sp)
q(eci\014cation.)19 b(The)11 b(t)o(w)o(o)g(resulting)164
2402 y(ob)s(ject)16 b(\014les)f(can)i(then)f(b)q(e)g(link)o(ed)f(to)i
(pro)q(duce)f(an)h(executable)e(\014le.)p eop
%%Page: 30 31
30 30 bop 164 162 a Fk(13)50 b(COMMAND-LINE)15 b(OPTIONS)h(AND)f(OTHER)
h(POINTS)298 b Fn(30)164 307 y Fb(12.3)70 b(Com)n(bined)21
b(use)i(of)g(Ox,)g(Y)-6 b(acc,)23 b(and)h(Lex)164 400
y Fn(There)17 b(are)g(certain)g(declarations)g(that)g(m)o(ust)f(b)q(e)i
(visible)d(from)h(all)h(of)g(the)g(\014les)g(pro-)164
460 y(duced)12 b(b)o(y)g(Ox.)20 b(By)12 b(default,)g(Ox)h(pro)q(duces)g
(\014les)f(suitable)g(for)h(separate)g(compilation,)164
520 y(inasm)o(uc)o(h)i(as)i(the)g(Y)l(acc-destined)f(\014le)g(and)h
(the)g(Lex-destined)f(\014le\(s\))h(eac)o(h)f(con)o(tain)164
580 y(the)k(common)e(declarations.)34 b(Ox)20 b(also)g(supp)q(orts)i
(the)e(one-step)h(dev)o(elopmen)o(t)c(ap-)164 640 y(proac)o(h)g
(describ)q(ed)g(ab)q(o)o(v)o(e.)23 b(By)16 b(placing)h
Fd(-h)f Fn(on)i(Ox's)e(command)f(line,)g(the)i(designer)164
700 y(calls)j(for)h(generation)f(of)h(a)g(\014le)f Fd(oxout.h)e
Fn(con)o(taining)i(the)g(common)e(declarations,)164 761
y(whic)o(h)e(are)g(then)g(absen)o(t)g(from)f(Ox's)h(other)h(output)f
(\014les.)21 b(In)16 b(this)g(case,)g(the)g(line)369
862 y Fd(#include)23 b("oxout.h")164 964 y Fn(is)16 b(placed)g(in)g
(the)g(Y-\014le.)164 1109 y Fb(12.4)70 b(T)n(ypical)21
b(command)i(sequences)164 1201 y Fn(The)g(follo)o(wing)g(sequence)g(of)
g(shell)g(commands)e(is)j(an)g(example)d(of)i(the)g(separate)164
1261 y(compilation)c(approac)o(h)i(describ)q(ed.)33 b(In)20
b(this)g(example,)f(Ox)h(translates)h(the)f(Y-\014le)164
1321 y Fd(ev.Y)c Fn(in)o(to)h Fd(oxout.y)e Fn(and)i(the)h(L-\014le)f
Fd(ev.L)f Fn(in)o(to)h Fd(oxout.l)p Fn(.)22 b(The)17
b(last)g(command)f(of)164 1381 y(the)g(sequence)f(links)h(the)g(t)o(w)o
(o)g(ob)s(ject)f(\014les,)h(yielding)f(the)h(executable)e(\014le)i
Fd(ev)p Fn(.)338 1485 y Fa(ox)22 b(ev.Y)f(ev.L)338 1535
y(yacc)g(-d)h(oxout.y)338 1585 y(lex)f(oxout.l)338 1635
y(cc)h(-c)f(y.tab.c)338 1684 y(cc)h(-c)f(lex.yy.c)338
1734 y(cc)h(-o)f(ev)g(y.tab.o)g(lex.yy.o)f(-ll)h(-ly)237
1838 y Fn(The)16 b(follo)o(wing)g(command)f(sequence)g(do)q(es)i(a)f
(one-step)h(compilation.)338 1929 y Fa(ox)22 b(-h)f(ev.Y)g(ev.L)338
1979 y(yacc)g(oxout.y)338 2029 y(lex)g(oxout.l)338 2079
y(cc)h(y.tab.c)e(-ll)h(-ly)164 2245 y Fo(13)83 b(Command-line)26
b(options)i(and)f(other)g(p)r(oin)n(ts)164 2355 y Fn(This)17
b(section)f(describ)q(es)g(some)g(\014ne)g(p)q(oin)o(ts,)h(mostly)e
(related)h(to)h(Ox)f(command-line)164 2415 y(options.)22
b(Use)16 b(of)g(those)h(options)g(is)f(summarized)d(in)j(app)q(endix)g
(D.)p eop
%%Page: 31 32
31 31 bop 164 162 a Fk(13)50 b(COMMAND-LINE)15 b(OPTIONS)h(AND)f(OTHER)
h(POINTS)298 b Fn(31)164 307 y Fb(13.1)70 b(Error)24
b(reco)n(v)n(ery)164 400 y Fn(Y)l(acc)14 b(has)h(pro)o(visions)g(for)g
(building)f(parsers)i(that)f(attempt)e(to)i(reco)o(v)o(er)e(from)h(syn)
o(tax)164 460 y(errors,)j(and)g(the)g(designer)g(can)g(use)g(the)f(w)o
(ords)i Fd(error)p Fn(,)d Fd(yyerrok)p Fn(,)f(and)j Fd(yyclearin)164
520 y Fn(to)f(implem)o(e)o(n)o(t)c(suc)o(h)j(error)g(reco)o(v)o(ery)f
([Johnson)j(75)q(].)j(When)15 b(a)h(parser)f(that)h(emplo)o(ys)164
580 y(suc)o(h)k(tec)o(hniques)e(detects)h(a)h(syn)o(tax)g(error,)g(it)f
(ma)o(y)g(attempt)f(to)i(reco)o(v)o(er)e(b)o(y)i(p)q(op-)164
640 y(ping)g(items)d(from)i(its)g(stac)o(k)g(or)h(b)o(y)f(discarding)g
(tok)o(ens.)31 b(During)20 b(normal)f(parsing,)164 700
y(the)g(Ox-generated)h(ev)m(aluator)g(sync)o(hronizes)e(its)i(stac)o(k)
f(op)q(erations)h(with)g(those)g(of)164 761 y(the)h(Y)l(acc-generated)f
(parser)h(\(see)g(section)f(7\).)36 b(When)21 b(the)f(parser)i(is)e
(built)h(using)164 821 y Fd(error)p Fn(,)14 b Fd(yyerrok)p
Fn(,)e(or)17 b Fd(yyclearin)o Fn(,)c(and)j(a)g(syn)o(tax)g(error)g(o)q
(ccurs,)f(this)h(sync)o(hroniza-)164 881 y(tion)j(is)g(lost.)29
b(It)18 b(is)h(p)q(ossible)g(for)h(the)e(ev)m(aluator)i(to)f(corrupt)g
(its)g(stac)o(k)f(and)i(go)f(out)164 941 y(of)d(con)o(trol)f(in)h(suc)o
(h)f(cases.)22 b(Ox)15 b(pro)o(vides)g(the)h(function)f
Fd(yyyerror)e Fn(to)j(prev)o(en)o(t)e(suc)o(h)164 1001
y(c)o(haos.)35 b(The)21 b(parser)g(calls)f Fd(yyerror)f
Fn(up)q(on)j(an)o(y)e(syn)o(tax)h(error,)g(and)h(the)e(designer)164
1062 y(should)k(write)e Fd(yyerror)f Fn(suc)o(h)i(that)h
Fd(yyyerror)c Fn(is)k(executed)d(at)j(least)f(once)g(eac)o(h)164
1122 y(time)c Fd(yyerror)f Fn(is)j(called.)35 b(An)o(y)20
b(syn)o(tax)h(error)g(will)f(then)g(cancel)h(parse-tree)f(con-)164
1182 y(struction)14 b(and)h(attribute)f(ev)m(aluation,)g(and)h(it)f(is)
g(ensured)g(that)g(the)g(Y)l(acc-generated)164 1242 y(co)q(de)h(can)f
(con)o(tin)o(ue)f(safely)l(.)20 b(Use)14 b(of)h Fd(yyyerror)c
Fn(is)j(unnecessary)h(but)f(harmless)f(if)h(the)164 1302
y(Y-\014le)h(mak)o(es)g(no)i(use)f(of)h(the)f(w)o(ords)g
Fd(error)p Fn(,)e Fd(yyerrok)p Fn(,)g(and)i Fd(yyclearin)p
Fn(.)164 1447 y Fb(13.2)70 b(Memory)23 b(alignmen)n(t)164
1539 y Fn(Man)o(y)12 b(computing)g(systems)g(ha)o(v)o(e)g(hardw)o
(are-related)h(constrain)o(ts)g(on)h(the)e(addresses)164
1599 y(used)i(for)f(memory)e(accesses.)20 b(F)l(or)13
b(example,)f(for)h(a)h(certain)f(t)o(yp)q(e)g(it)g(ma)o(y)f(b)q(e)h
(required)164 1660 y(that)i(the)g(\014rst)g(b)o(yte)g(of)g(storage)h
(for)f(eac)o(h)g(v)m(ariable)f(of)i(that)f(t)o(yp)q(e)g(reside)f(at)h
(an)h(ev)o(en-)164 1720 y(n)o(um)o(b)q(ered)k(address.)39
b(Then)23 b(an)f(instruction)g(to)g(access)g(a)h(v)m(ariable)f(of)g
(that)g(t)o(yp)q(e)164 1780 y(at)c(an)g(o)q(dd-n)o(um)o(b)q(ered)f
(address)i(results)e(in)h(a)g(run-time)e(error.)26 b(When)18
b(Ox)f(is)h(giv)o(en)164 1840 y(the)k Fd(-a)p Fi(N)k
Fn(command-line)19 b(option,)k(it)e(pro)q(duces)i(an)f(ev)m(aluator)g
(that)g(aligns)g(all)g(C)164 1900 y(structures)14 b(on)h(addresses)h
(divisible)c(b)o(y)i(the)h(in)o(teger)e Fi(N)5 b Fn(.)21
b(The)15 b(default)f(v)m(alue)g(for)h(this)164 1961 y(alignmen)o(t)f
(constan)o(t)j(is)f(4,)g(whic)o(h)g(is)g(adequate)g(for)h(nearly)e(all)
h(curren)o(t)f(computers.)164 2105 y Fb(13.3)70 b(Stripping)22
b(Ox)h(constructs)164 2197 y Fn(Occasionally)l(,)16 b(the)h(designer)g
(ma)o(y)e(wish)i(copies)g(of)g(the)g(Y-\014le)f(and)i(L-\014le\(s\))f
(free)g(of)164 2258 y(Ox-sp)q(eci\014c)c(constructs.)20
b(Supp)q(ose,)15 b(for)f(instance,)f(that)h(c)o(hanges)g(to)f(the)h
(underlying)164 2318 y(grammar)h(are)i(under)f(consideration,)h(and)g
(that)g(it)g(is)f(desired)g(to)h(test)g(whether)f(the)164
2378 y(new)j(grammar)e(has)i(parsing)h(con\015icts.)29
b(T)l(o)19 b(satisfy)g(Ox)f(seman)o(tics)f(migh)o(t)g(require)164
2438 y(writing)12 b(attribute)f(de\014nitions)h(for)h(an)o(y)f(new)g
(rules.)19 b(Ox's)11 b(output)i(on)g Fd(oxout.y)c Fn(could)p
eop
%%Page: 32 33
32 32 bop 164 162 a Fk(13)50 b(COMMAND-LINE)15 b(OPTIONS)h(AND)f(OTHER)
h(POINTS)298 b Fn(32)164 307 y(then)16 b(b)q(e)g(submitted)f(to)i(Y)l
(acc)e(to)i(test)f(for)g(parsing)h(con\015icts.)237 367
y(T)l(o)23 b(a)o(v)o(oid)f(the)g(ab)q(o)o(v)o(e-men)o(tioned)f(writing)
h(of)h(attribute)f(de\014nitions,)i(the)e(de-)164 428
y(signer)h(can)g(use)g(Ox's)f Fd(-S)g Fn(command-line)e(option,)25
b(whic)o(h)d(\014lters)g(all)h(Ox-sp)q(eci\014c)164 488
y(constructs)17 b(from)e(the)h(inputs)g(and)h(yields)e(\014les)h
(acceptable)g(to)g(Y)l(acc)g(and)h(Lex.)k(The)164 548
y(original)14 b(copies)h(of)g(the)f(Y-\014le)g(and)h(L-\014le\(s\))g
(are)f(unc)o(hanged,)h(but)g(Ox's)f(outputs)h(on)164
608 y Fd(oxout.*)10 b Fn(con)o(tain)h(neither)h(Ox)f(constructs)i(nor)g
(the)e(usual)i(Ox-generated)f(parse-tree)164 668 y(managemen)o(t)i(co)q
(de.)164 809 y Fb(13.4)70 b(Prev)n(en)n(ting)15 b(execution)e(of)j
(attribute)e(de\014nition)g(co)r(de)164 902 y Fn(F)l(ault)o(y)22
b(user-written)g(co)q(de)h(in)f(attribute)g(reference)f(sections)h(ma)o
(y)f(cause)i(abnor-)164 962 y(mal)16 b(termination)g(of)i(the)f
(Ox-generated)h(ev)m(aluator.)26 b(F)l(or)17 b(instance,)g
(dereferencing)164 1022 y(a)i(stra)o(y)f(p)q(oin)o(ter)g(ma)o(y)e
(corrupt)i(the)g(ev)m(aluator's)h(data)g(structures)f(and)h(cause)f(it)
g(to)164 1082 y(falsely)d(rep)q(ort)h(a)h(cycle)d(during)i(attribute)g
(ev)m(aluation.)21 b(The)16 b Fd(-n)f Fn(command-line)e(op-)164
1143 y(tion)f(is)f(a)h(debugging)g(feature)g(that)g(can)f(b)q(e)h(used)
g(to)g(isolate)f(the)h(e\013ects)f(of)h(anomalous)164
1203 y(attribute)17 b(de\014nition)h(co)q(de.)26 b(When)18
b(Ox)f(is)h(used)g(with)f(this)h(option,)g(the)g(generated)164
1263 y(ev)m(aluator)j(uses)f(the)g(ready)g(set)g(as)g(usual)h(to)f
(determine)e(an)i(ev)m(aluation)g(order)h(for)164 1323
y(attribute)15 b(instances,)g(and)h(still)e(c)o(hec)o(ks)g(for)i
(cycles.)j(Eac)o(h)c(time)f(it)h(is)g(ready)g(to)h(solv)o(e)164
1383 y(an)i(instance,)g(ho)o(w)o(ev)o(er,)e(it)h(stops)i(short)g(of)f
(executing)e(the)i(co)q(de)g(for)g(the)f(de\014nition)164
1444 y(of)j(that)f(instance.)31 b(When)19 b Fd(-n)g Fn(is)g(used,)h
(the)f(designer)g(should)h(tak)o(e)f(sp)q(ecial)g(notice)164
1504 y(of)f(the)f(e\013ects)f(up)q(on)j(other)e(translation)h(phases)g
(of)g(suc)o(h)f(suppression)g(of)h(seman)o(tic)164 1564
y(analysis.)164 1705 y Fb(13.5)70 b(Con)n(trol)31 b(of)i(storage)f
(allo)r(cation)e(in)h(the)g(generated)355 1780 y(ev)l(aluator)164
1872 y Fn(When)15 b(initializing)e(itself,)h(the)h(Ox-generated)g(ev)m
(aluator)h(allo)q(cates)f(memory)e(for)i(its)164 1932
y(v)m(arious)i(data)g(structures.)k(When)16 b(ev)m(aluating)g(a)g
(large)g(input,)g(it)f(ma)o(y)g(happ)q(en)h(that)164
1993 y(the)g(space)h(allo)q(cated)g(for)g(a)g(giv)o(en)f(data)h
(structure)g(is)f(inadequate.)22 b(In)17 b(suc)o(h)f(a)h(case,)164
2053 y(the)k(ev)m(aluator)g(issues)g(an)g(error)g(message)g(indicating)
f(whic)o(h)g(data)i(structure)e(w)o(as)164 2113 y(exceeded)12
b(and)j(suggesting)g(an)f(appropriately)g(larger)g(size.)20
b(The)14 b(sizes)f(of)h(these)g(data)164 2173 y(structures)i(ma)o(y)f
(b)q(e)h(determined)e(b)o(y)h(the)h(default)g(v)m(alues)g(built)g(in)o
(to)g(Ox,)f(or)h(b)o(y)g(the)164 2233 y(ev)m(aluator)g(designer's)e
(use)h(of)h(the)e Fd(-Y)p Fi(aN)20 b Fn(option)15 b(on)h(the)f(Ox)f
(command)f(line,)h(where)164 2293 y Fi(a)g Fn(is)g(an)h(alphab)q(etic)f
(c)o(haracter)f(that)i(sp)q(eci\014es)f(the)g(data)h(structure)f(to)g
(b)q(e)h(sized,)e(and)164 2354 y Fi(N)18 b Fn(is)13 b(an)h(in)o(teger)e
(that)h(determines)e(the)i(size)f(of)h(data)h(structure)f
Fi(a)f Fn(\(see)h(app)q(endix)g(D\).)237 2414 y(The)23
b(ev)m(aluator)h(designer)f(can)g(easily)g(build)f(an)i(ev)m(aluator)g
(that)f(accepts)g(the)164 2474 y(same)c Fd(-Y)p Fi(aN)24
b Fn(command-line)18 b(options)i(accepted)g(b)o(y)g(Ox:)28
b(By)20 b(sp)q(ecifying)f(the)h Fd(-YY)p eop
%%Page: 33 34
33 33 bop 164 162 a Fk(13)50 b(COMMAND-LINE)15 b(OPTIONS)h(AND)f(OTHER)
h(POINTS)298 b Fn(33)164 307 y(option)19 b(on)g(Ox's)f(command)e(line,)
i(Ox)g(is)g(instructed)g(to)h(declare)f(in)g(the)g(generated)164
367 y(ev)m(aluator)h(a)h(function)e Fd(yyyCheckFo)o(rRe)o(siz)o(es)d
Fn(that)20 b(can)f(read)g Fd(main)p Fn('s)e(argumen)o(ts)164
428 y(\(i.e.,)11 b(the)h(command-line)d(options)k(passed)g(to)f(the)g
(generated)g(ev)m(aluator\))g(and)h(adjust)164 488 y(sizes)18
b(accordingly)l(.)29 b(When)19 b(using)g(the)g Fd(-YY)f
Fn(option,)h(the)g(designer)g(should)g(arrange)164 548
y(the)d(ev)m(aluator's)g Fd(main)f Fn(program)h(according)h(to)f(the)g
(follo)o(wing)g(form:)237 592 y(.)237 608 y(.)237 625
y(.)164 716 y Fa(void)21 b(yyyCheckForResize)o(s\(\);)237
801 y Fn(.)237 817 y(.)237 834 y(.)164 925 y Fa(main\(argc,argv\))208
975 y(int)g(argc;)208 1025 y(char)g(*argv[];)208 1075
y({)237 1154 y Fn(.)237 1170 y(.)237 1187 y(.)229 1278
y Fa(/*)h(This)f(is)g(executed)f(before)h(calling)f(yyparse)g(*/)229
1328 y(yyyCheckForResizes\()o(argc,)o(argv\))o(;)237
1413 y Fn(.)237 1429 y(.)237 1446 y(.)229 1537 y Fa(yyparse\(\);)237
1622 y Fn(.)237 1638 y(.)237 1655 y(.)208 1746 y Fa(})h(/*)h(main)e(*/)
164 1891 y Fb(13.6)70 b(P)n(arse)23 b(tree)f(statistics)164
1983 y Fn(Placing)g Fd(-u)g Fn(on)h(Ox's)f(command)f(line)g(causes)i
(generation)g(of)f(an)h(ev)m(aluator)g(that)164 2043
y(prin)o(ts,)16 b(for)h(eac)o(h)f(input,)g(statistics)h(regarding)g
(the)f(parse)h(tree)f(built)g(for)h(the)g(input.)164
2103 y(These)f(include)f(n)o(um)o(b)q(ers)g(of:)237 2205
y Fc(\017)24 b Fn(terminal)14 b(no)q(des)j(and)g(their)e(attribute)h
(instances,)237 2307 y Fc(\017)24 b Fn(non)o(terminal)14
b(no)q(des)j(and)g(their)f(attribute)g(instances,)164
2409 y(and)h(other)f(statistics.)p eop
%%Page: 34 35
34 34 bop 164 162 a Fk(14)50 b(EXAMPLE:)15 b(AN)h(INTEGER)g(CALCULA)l
(TOR)513 b Fn(34)164 307 y Fb(13.7)70 b(Adjusting)23
b(the)f(sizes)f(of)j(Ox's)f(data)g(structures)164 400
y Fn(Ox)d(itself)f(calls)h(system)f(memory)e(allo)q(cation)k(routines)f
(to)h(obtain)g(storage)g(for)g(its)164 460 y(in)o(ternal)15
b(data)i(structures.)k(The)16 b(default)f(sizes)g(of)i(these)e(data)i
(structures)f(are)g(quite)164 520 y(generous,)25 b(and)f(exceeding)e
(them)g(w)o(ould)i(b)q(e)f(somewhat)g(un)o(usual.)43
b(In)24 b(case)f(an)o(y)164 580 y(of)h(these)g(is)f(exceeded,)h(Ox)g
(prin)o(ts)f(an)h(error)g(message)g(indicating)f(the)g(use)h(of)h(a)164
640 y(command-line)12 b(option)j(of)f(the)h(form)e Fd(-X)p
Fi(aN)19 b Fn(to)c(mak)o(e)d Fi(N)20 b Fn(the)14 b(size)g(of)h(data)g
(structure)164 700 y Fi(a)p Fn(.)164 867 y Fo(14)83 b(Example:)36
b(an)27 b(in)n(teger)g(calculator)164 976 y Fn(This)21
b(section)g(has)i(Ox)e(co)q(de)g(for)h(an)g(ev)m(aluator)f(of)h(simple)
d(expressions)j(in)o(v)o(olving)164 1037 y(m)o(ultiplic)o(ation)e(and)j
(addition.)40 b(Since)22 b(the)g(grammar)f(has)i(only)f(syn)o(thesized)
f(at-)164 1097 y(tributes,)g(the)g(Ox)g(implem)o(en)n(tation)e
(o\013ers)j(little)d(adv)m(an)o(tage)j(o)o(v)o(er)e(one)h(that)h(uses)
164 1157 y(only)16 b(Y)l(acc)g(and)g(Lex;)g(it)g(is)g(presen)o(ted)f
(as)i(a)g(v)o(ery)e(easy)h(example)e(of)j(Ox)f(usage.)237
1207 y(The)d(L-\014le)f(sp)q(eci\014es)h(that)g(the)f(tok)o(ens)h(are)f
(digit)g(strings,)i(paren)o(theses,)f Fd('*')p Fn(,)e(and)164
1257 y Fd('+')p Fn(:)164 1348 y Fa(\045{)164 1398 y(/*)21
b(expr.L:)42 b(L-file)21 b(for)g(a)h(simple)e(expression)g(language)g
(*/)164 1448 y(#include)g("y.tab.h")164 1497 y(#include)g("oxout.h")164
1547 y(\045})164 1647 y(\045\045)164 1697 y([)i(\\n\\t\\f]*)107
b(;)164 1746 y([0-9]+)195 b(return\(CONST\);)19 b(@{)556
1796 y(sscanf\(yytext,"\045d",)o(&\(@C)o(ONST.)o(val@\))o(\);)g(@})164
1846 y(\\\()283 b(return\('\('\);)164 1896 y(\\\))g(return\('\)'\);)164
1946 y(\\+)g(return\('+'\);)164 1996 y(\\*)g(return\('*'\);)164
2045 y(\045\045)p eop
%%Page: 35 36
35 35 bop 164 162 a Fk(14)50 b(EXAMPLE:)15 b(AN)h(INTEGER)g(CALCULA)l
(TOR)513 b Fn(35)237 307 y(The)22 b(grammar)e(is)h(disam)o(biguated)g
(b)o(y)g(use)h(of)g(Y)l(acc's)f Fd(\045left)f Fn(reserv)o(ed)g(w)o
(ord.)164 357 y(Eac)o(h)k(parse-tree)g(no)q(de)h(lab)q(eled)f(b)o(y)g
Fd(s)p Fn(,)h Fd(e)p Fn(,)g(or)g Fd(CONST)d Fn(has)j(an)g(in)o(teger)e
(attribute)164 407 y(instance)14 b(named)e Fd(val)p Fn(.)20
b(Use)13 b(of)h(the)g(global)g(v)m(ariable)g Fd(sVal)e
Fn(ob)o(viates)i(p)q(ostdecoration)164 457 y(tra)o(v)o(ersal.)164
548 y Fa(/*)21 b(expr.Y:)42 b(Y-file)21 b(for)g(a)h(simple)e
(expression)g(language)g(*/)164 598 y(\045left)h('+')164
648 y(\045left)g('*')164 697 y(\045token)g(CONST)164
797 y(@attributes)e({long)i(val;})g(s)h(e)f(CONST)164
897 y(\045{)164 946 y(#include)f("oxout.h")164 996 y(long)h(sVal;)164
1046 y(\045})164 1146 y(\045\045)164 1196 y(s)152 b(:)h(e)338
1245 y(@{)22 b(@i)f(sVal)g(=)h(@s.val@)e(=)i(@e.val@;)259
b(@})338 1295 y(;)164 1345 y(e)152 b(:)h(e)f('+')108
b(e)338 1395 y(@{)22 b(@i)f(@e.0.val@)f(=)i(@e.1.val@)e(+)h(@e.2.val@;)
63 b(@})338 1445 y(;)164 1494 y(e)152 b(:)h(e)f('*')108
b(e)338 1544 y(@{)22 b(@i)f(@e.0.val@)f(=)i(@e.1.val@)e(*)h(@e.2.val@;)
63 b(@})338 1594 y(;)164 1644 y(e)152 b(:)h('\(')108
b(e)152 b('\)')338 1694 y(@{)22 b(@i)f(@e.val@)f(=)i(@e.1.val@;)368
b(@})338 1743 y(;)164 1793 y(e)152 b(:)h(CONST)338 1843
y(@{)22 b(@i)f(@e.val@)f(=)i(@CONST.val@;)324 b(@})338
1893 y(;)164 1943 y(\045\045)164 2042 y(main\(\))164
2092 y({yyparse\(\);)186 2142 y(printf\("\045d\\n",sV)o(al\);)164
2192 y(})p eop
%%Page: 36 37
36 36 bop 164 162 a Fk(15)50 b(EXAMPLE:)15 b(A)h(BINAR)l(Y)e(NUMBER)h
(TRANSLA)l(TOR)350 b Fn(36)237 307 y(The)15 b(follo)o(wing)f(command)f
(sequence)g(is)h(used)h(to)g(build)f(an)h(executable)e(\014le)h
Fd(calc)164 357 y Fn(from)h(the)h(ab)q(o)o(v)o(e)g(sp)q
(eci\014cations:)338 448 y Fa(ox)22 b(-h)f(expr.Y)g(expr.L)338
498 y(yacc)g(-d)h(oxout.y)338 548 y(lex)f(oxout.l)338
598 y(cc)h(-c)f(y.tab.c)338 648 y(cc)h(-c)f(lex.yy.c)338
697 y(cc)h(-o)f(calc)g(y.tab.o)f(lex.yy.o)h(-ly)g(-ll)164
864 y Fo(15)83 b(Example:)36 b(a)27 b(binary)g(n)n(um)n(b)r(er)f
(translator)164 973 y Fn(This)f(illustrates)f(the)h(use)g(of)g(Ox)g(to)
g(build)g(an)g(ev)m(aluator)h(based)f(on)h(an)f(exam-)164
1033 y(ple)c(attribute)g(grammar)42 b(that)22 b(app)q(ears)h(in)e(the)g
(seminal)f(pap)q(er)i(on)g(the)g(sub)s(ject)164 1094
y([Kn)o(uth)16 b(68].)33 b(The)20 b(input)h(\(after)f(remo)o(v)m(al)e
(of)j(whitespace\))f(is)g(either)f(a)i(nonempt)o(y)164
1154 y(string)16 b(of)g(binary)g(digits)g(or)g(t)o(w)o(o)g(suc)o(h)f
(strings)i(separated)f(b)o(y)f(a)i(p)q(erio)q(d.)k(This)16
b(input)164 1214 y(is)f(in)o(terpreted)e(as)i(a)h(binary)e(represen)o
(tation)h(of)g(a)g(\015oating)h(p)q(oin)o(t)f(n)o(um)o(b)q(er,)e(whic)o
(h)h(is)164 1274 y(then)i(prin)o(ted)f(on)i(the)f(standard)i(output)f
(in)e(its)h(base-ten)h(form.)237 1324 y(F)l(ollo)o(wing)f(is)g(the)g
(text)g(of)g(the)g(L-\014le:)164 1415 y Fa(\045{)164
1465 y(#include)k("y.tab.h")164 1515 y(\045})164 1615
y(\045\045)164 1664 y([0])261 b(return)20 b(ZERO;)164
1714 y([1])261 b(return)20 b(ONE;)164 1764 y(\\.)283
b(return)20 b(DOT;)164 1814 y([\\n\\t\\v)g(])131 b(;)164
1864 y(.)305 b({fprintf\(stderr,")o(illeg)o(al)19 b(character\\n"\);)
513 1914 y(exit\(-1\);)491 1963 y(})p eop
%%Page: 37 38
37 37 bop 164 162 a Fk(15)50 b(EXAMPLE:)15 b(A)h(BINAR)l(Y)e(NUMBER)h
(TRANSLA)l(TOR)350 b Fn(37)237 307 y(Here)15 b(is)h(the)g(text)g(of)g
(the)g(Y-\014le:)164 399 y Fa(\045token)21 b(ZERO)f(ONE)i(DOT)164
498 y(@attributes)d({float)i(value;)g(int)g(scale;})412
b(bit)164 548 y(@attributes)19 b({float)i(value;)g(int)g
(scale,length;})258 b(bitlist)164 598 y(@attributes)19
b({float)i(value;})652 b(num)164 697 y(\045start)21 b(num)164
797 y(\045{)164 847 y(#include)f(<stdio.h>)164 897 y(float)h(numValue;)
164 946 y(\045})p eop
%%Page: 38 39
38 38 bop 164 162 a Fk(15)50 b(EXAMPLE:)15 b(A)h(BINAR)l(Y)e(NUMBER)h
(TRANSLA)l(TOR)350 b Fn(38)164 307 y Fa(\045\045)164
357 y(bit)108 b(:)153 b(ZERO)513 407 y(@{)21 b(@i)g(@bit.value@)f(=)i
(0;)578 457 y(/*)f(value)g(is)h(synthesized)d(for)i(bit.)43
b(*/)578 506 y(/*)21 b(scale)g(is)h(inherited)d(for)j(bit.)86
b(*/)513 556 y(@})338 606 y(;)164 706 y(bit)108 b(:)153
b(ONE)513 756 y(@{)21 b(@i)g(@bit.value@)f(=)i(twoToThe\(@bit.s)o
(cale@)o(\);)513 805 y(@})338 855 y(;)164 955 y(bitlist)e(:)153
b(bit)513 1005 y(@{)21 b(@i)g(@bitlist.value@)e(=)j(@bit.value@;)578
1054 y(@i)f(@bit.scale@)f(=)i(@bitlist.scale@)o(;)578
1104 y(@i)f(@bitlist.length@)e(=)i(1;)578 1154 y(/*)g(value)g(and)g
(length)g(are)g(synthesized)f(for)h(bitlist.)42 b(*/)578
1204 y(/*)21 b(scale)g(is)h(inherited)d(for)j(bitlist.)347
b(*/)513 1254 y(@})338 1353 y(|)153 b(bitlist)20 b(bit)513
1403 y(@{)h(@i)g(@bitlist.0.value@)e(=)i(@bitlist.1.value@)e(+)i
(@bit.value@;)578 1453 y(@i)g(@bit.scale@)f(=)i(@bitlist.0.scal)o(e@;)
578 1503 y(@i)f(@bitlist.1.scale@)e(=)i(@bitlist.0.scale@)e(+)i(1;)578
1553 y(@i)g(@bitlist.0.length@)d(=)k(@bitlist.1.length@)c(+)k(1;)513
1602 y(@})338 1652 y(;)164 1752 y(num)108 b(:)153 b(bitlist)513
1802 y(@{)21 b(@i)g(numValue)g(=)g(@num.value@)f(=)h
(@bitlist.0.value@;)578 1851 y(@i)g(@bitlist.scale@)e(=)j(0;)578
1901 y(/*)f(value)g(is)h(synthesized)d(for)i(num.)g(*/)513
1951 y(@})338 2051 y(|)153 b(bitlist)20 b(DOT)108 b(bitlist)513
2100 y(@{)21 b(@i)g(numValue)g(=)g(@num.value@)f(=)709
2150 y(@bitlist.0.value)o(@)f(+)j(@bitlist.1.value)o(@;)578
2200 y(@i)f(@bitlist.0.scale@)e(=)i(0;)578 2250 y(@i)g
(@bitlist.1.scale@)e(=)i(-)h(@bitlist.1.length)o(@;)513
2300 y(@})338 2350 y(;)164 2399 y(\045\045)p eop
%%Page: 39 40
39 39 bop 164 162 a Fk(15)50 b(EXAMPLE:)15 b(A)h(BINAR)l(Y)e(NUMBER)h
(TRANSLA)l(TOR)350 b Fn(39)164 307 y Fa(main\(\))208
357 y({if)21 b(\(!\(yyparse\(\)\)\))295 407 y(printf\("\04530.15f\\)o
(n",nu)o(mValu)o(e\);)208 457 y(})164 656 y(float)g(twoToThe\(in\))281
b(/*)21 b(returns)f(2)i(raised)e(to)i(the)f(power)g(in)g(*/)208
706 y(int)g(in;)208 756 y({if)g(\(in)g(<)g(0\))h(return)e(\(1.0)h(/)h
(twoToThe\(-in\)\);)229 805 y(if)g(\(in)f(==)g(0\))h(return)e(1.0;)295
855 y(else)h(return)f(\(2.0)h(*)h(twoToThe\(in)d(-)j(1\)\);)208
905 y(})237 1169 y Fn(Construction)16 b(of)g(the)f(ab)q(o)o(v)o(e)g(ev)
m(aluator)h(follo)o(ws)g(the)f(separate)g(compilation)f(ap-)164
1229 y(proac)o(h)i(describ)q(ed)g(in)g(section)g(12.)237
1289 y(Remo)o(ving)e(the)h(Ox-sp)q(eci\014c)f(constructs)i(and)g(the)f
Fd(printf)e Fn(statemen)o(t)h(from)g(the)164 1349 y(ab)q(o)o(v)o(e)i
(source)g(yields)f(a)h(pair)g(of)g(\014les)g(that)g(constitute)g(a)g
(seman)o(tics-free)e(recognizer)164 1409 y(of)j(binary)f(n)o(um)o(b)q
(ers.)p eop
%%Page: 40 41
40 40 bop 164 162 a Fk(16)50 b(EXAMPLE:)15 b(TRANSLA)l(TION)g(TO)i
(POSTFIX)e(AND)h(PREFIX)176 b Fn(40)164 315 y Fo(16)83
b(Example:)34 b(translation)25 b(to)g(p)r(ost\014x)f(and)h(pre-)329
407 y(\014x)164 516 y Fn(In)20 b(this)g(example,)f(the)h(generated)g
(ev)m(aluator)h(is)f(to)g(p)q(erform)g(t)o(w)o(o)g(p)q(ostdecoration)
164 577 y(tra)o(v)o(ersals,)f(one)h(for)g(prin)o(ting)f(the)g(pre\014x)
g(form)f(of)i(a)g(giv)o(en)f(in\014x)g(expression,)g(and)164
637 y(one)g(for)g(prin)o(ting)f(the)g(p)q(ost\014x)i(form.)27
b(The)19 b(tok)o(ens)g(of)g(the)f(language)i(are)e(sp)q(eci\014ed)164
697 y(as)f(follo)o(ws:)164 801 y Fa(\045{)164 850 y(/*)k(L-file)g(for)g
(translation)f(of)h(infix)g(expressions)e(*/)164 900
y(#include)h("y.tab.h")164 950 y(#include)g("oxout.h")164
1050 y(char)h(*lexeme\(\))208 1100 y({char)f(*dum;)229
1149 y(dum)i(=)f(\(char)g(*\)malloc\(yyleng+1)o(\);)229
1199 y(strcpy\(dum,yytext\);)229 1249 y(return)g(dum;)208
1299 y(})164 1398 y(\045})164 1498 y(\045\045)164 1548
y([)h(\\n\\t\\f]*)303 b(;)164 1598 y([0-9]+\\.?[0-9]*)193
b(return\(CONST\);)19 b(@{)i(@CONST.lexeme@)e(=)j(lexeme\(\);)e(@})164
1648 y([A-Za-z_][A-Za-z_)o(0-9]*)40 b(return\(ID\);)85
b(@{)21 b(@ID.lexeme@)f(=)h(lexeme\(\);)86 b(@})164 1697
y(\\\()479 b(return\('\('\);)164 1747 y(\\\))g(return\('\)'\);)164
1797 y(\\+)g(return\('+'\);)164 1847 y(\\*)g(return\('*'\);)164
1897 y(\\/)g(return\('/'\);)164 1946 y(\\-)g(return\('-'\);)164
1996 y(\045\045)p eop
%%Page: 41 42
41 41 bop 164 162 a Fk(16)50 b(EXAMPLE:)15 b(TRANSLA)l(TION)g(TO)i
(POSTFIX)e(AND)h(PREFIX)176 b Fn(41)237 307 y(The)18
b(\014rst)h(tra)o(v)o(ersal)e(p)q(erformed)g(is)h(named)f
Fd(LRpre)p Fn(,)g(and)i(the)f(second)g(is)g(named)164
367 y Fd(LRpost)p Fn(.)23 b(By)16 b(default,)h(b)q(oth)i(are)e
(left-to-righ)o(t)g(tra)o(v)o(ersals.)24 b Fd(LRpost)16
b Fn(is)h(a)h(p)q(ostorder)164 428 y(tra)o(v)o(ersal)d(b)o(y)h
(default.)21 b Fd(LRpre)14 b Fn(is)j(sp)q(eci\014ed)e(as)i(a)g
(preorder)f(tra)o(v)o(ersal.)164 581 y Fa(/*)21 b(Y-file)g(for)g
(translation)f(of)h(infix)g(expressions)e(to)j(prefix)e(and)h(postfix)g
(*/)164 631 y(\045token)g(ID)g(CONST)164 681 y(\045start)g(s)164
731 y(\045left)g('+')g('-')164 780 y(\045left)g('*')g('/')164
880 y(@attributes)e({char)i(*lexeme;})f(ID)i(CONST)164
930 y(@traversal)e(@preorder)g(LRpre)164 980 y(@traversal)g(LRpost)164
1079 y(\045{)164 1129 y(#include)g("oxout.h")164 1179
y(#include)g(<stdio.h>)164 1229 y(\045})p eop
%%Page: 42 43
42 42 bop 164 162 a Fk(16)50 b(EXAMPLE:)15 b(TRANSLA)l(TION)g(TO)i
(POSTFIX)e(AND)h(PREFIX)176 b Fn(42)164 307 y Fa(\045\045)164
357 y(s)152 b(:)h(expr)513 407 y(@{)21 b(@LRpost)f(printf\("\\n"\);)578
457 y(@LRpost)g(@revorder)g(\(1\))h(printf\("postfix:)41
b("\);)578 506 y(@LRpre)h(@revorder)20 b(\(1\))h(printf\("\\n"\);)578
556 y(@LRpre)42 b(printf\("prefix:)63 b("\);)513 606
y(@})164 656 y(expr)86 b(:)153 b(expr)86 b('*')108 b(expr)513
706 y(@{)21 b(@LRpost)f(printf\(")h(*)g("\);)578 756
y(@LRpre)42 b(printf\(")21 b(*)g("\);)513 805 y(@})338
855 y(|)153 b(expr)86 b('+')108 b(expr)513 905 y(@{)21
b(@LRpre)42 b(printf\(")21 b(+)g("\);)578 955 y(@LRpost)f(printf\(")h
(+)g("\);)513 1005 y(@})338 1054 y(|)153 b(expr)86 b('/')108
b(expr)513 1104 y(@{)21 b(@LRpost)f(printf\(")h(/)g("\);)578
1154 y(@LRpre)42 b(printf\(")21 b(/)g("\);)513 1204 y(@})338
1254 y(|)153 b(expr)86 b('-')108 b(expr)513 1303 y(@{)21
b(@LRpost)f(printf\(")h(-)g("\);)578 1353 y(@LRpre)42
b(printf\(")21 b(-)g("\);)513 1403 y(@})338 1453 y(|)153
b('\(')108 b(expr)86 b('\)')338 1503 y(|)153 b(ID)513
1553 y(@{)21 b(@LRpost)f(printf\(")h(\045s)g(",@ID.lexeme@\);)578
1602 y(@LRpre)42 b(printf\(")21 b(\045s)g(",@ID.lexeme@\);)513
1652 y(@})338 1702 y(|)153 b(CONST)513 1752 y(@{)21 b(@LRpost)f
(printf\(")h(\045s)g(",@CONST.lexeme@\))o(;)578 1802
y(@LRpre)42 b(printf\(")21 b(\045s)g(",@CONST.lexeme@\))o(;)513
1851 y(@})338 1901 y(;)164 1951 y(\045\045)164 2100 y(main\(\))208
2150 y({yyparse\(\);)208 2200 y(})p eop
%%Page: 43 44
43 43 bop 164 162 a Fk(A)48 b(USING)16 b(O)o(X)k(WITH)c(NON-LEX)21
b(LEXICAL)16 b(ANAL)l(YZERS)277 b Fn(43)164 315 y Fo(A)83
b(Using)27 b(Ox)g(with)g(non-Lex)g(lexical)f(analyzers)164
440 y Fb(A.1)69 b(Default)30 b(con)n(text-sensitivi)o(t)n(y)e(of)j
(L-\014le)f(prepro)r(cess-)338 514 y(ing)164 607 y Fn(Unless)18
b(instructed)h(otherwise,)g(Ox)g(searc)o(hes)f(eac)o(h)h(L-\014le)g
(for)g Fd(return)e Fn(statemen)o(ts)164 667 y(in)g(the)g(con)o(text)g
(of)h(C-co)q(ded)g(Lex)f(actions.)25 b(Since)17 b(the)g(string)h
Fd(return)d Fn(m)o(ust)h(b)q(e)i(ig-)164 727 y(nored)e(outside)f(of)h
(that)g(con)o(text)f(\(for)g(instance,)g(in)g(a)h(Lex)g(regular)f
(expression\),)g(the)164 787 y(default)k(b)q(eha)o(vior)h(of)g
(Ox-prepro)q(cessing)g(is)f(to)h(assume)f(that)h(the)g(L-\014le)g
(conforms)164 847 y(to)h(the)g(syn)o(tax)g(of)g(a)g(\(p)q(ossibly)g
(Ox-augmen)o(ted\))f(Lex)g(\014le.)35 b(Th)o(us)21 b(Ox)g(recognizes)
164 908 y(the)15 b(three)h Fd(return)d Fn(statemen)o(ts)h(in)i(the)f
(follo)o(wing)g(\(unaugmen)o(ted\))g(fragmen)o(t)f(of)i(an)164
968 y(L-\014le:)237 1062 y(.)237 1078 y(.)237 1095 y(.)164
1184 y Fd(renames)74 b(return\(TK_R)o(ENA)o(ME)o(S\);)164
1244 y(return)100 b(return\(TK_R)o(ETU)o(RN)o(\);)164
1305 y(reverse)74 b(return\(TK_R)o(EVE)o(RS)o(E\);)237
1375 y Fn(.)237 1391 y(.)237 1408 y(.)164 1528 y(as)24
b(p)q(oin)o(ts)g(of)g Fd(return)d Fn(of)j(tok)o(ens)g(b)o(y)f
Fd(yylex)p Fn(.)41 b(Ox's)23 b(sensitivit)o(y)e(to)j(the)g(con)o(text)
164 1588 y(of)16 b(the)g(string)g Fd(return)d Fn(in)j(the)f(second)h
(Lex)g(regular)f(expression)h(ab)q(o)o(v)o(e)g(prev)o(en)o(ts)e(its)164
1648 y(erroneous)j(recognition)f(as)h(a)f(p)q(oin)o(t)h(of)f
Fd(return)e Fn(from)h(the)h(lexical)f(analyzer.)164 1791
y Fb(A.2)69 b(Ox-prepro)r(cessing)23 b(of)g(C-co)r(ded)f(lexical)e
(analyzers)164 1883 y Fn(Ox)h(alw)o(a)o(ys)g(ignores)h(the)f(string)g
Fd(return)e Fn(in)i(the)g(con)o(text)f(of)i(C/C++)g(commen)o(ts)164
1943 y(and)g(string)g(constan)o(ts.)39 b(When)21 b(giv)o(en)g(the)h
Fd(-G)f Fn(command-line)d(option)23 b(preceding)164 2003
y(the)18 b(name)f(of)h(an)h(L-\014le,)f(it)g(ignores)g
Fd(return)e Fg(only)j Fn(in)f(those)g(con)o(texts.)27
b(Th)o(us)18 b(a)h(\014le)164 2064 y(con)o(taining)13
b(C/C++)h(co)q(de)g(ma)o(y)e(b)q(e)i(augmen)o(ted)e(with)h(attribute)g
(reference)f(sections)164 2124 y(and)21 b(input)g(to)g(Ox)g(as)g(an)g
(L-\014le.)35 b(The)21 b(o)q(ccurrences)f(of)h(the)g(string)g
Fd(return)d Fn(m)o(ust)164 2184 y(coincide)d(exactly)g(with)h
Fd(return)p Fn(s)e(of)j(tok)o(ens.)164 2312 y Fj(A.2.1)55
b(Example)164 2404 y Fn(Supp)q(ose)17 b(it)e(is)h(desired)f(to)h(con)o
(v)o(ert)e(to)i(Ox)g(a)g(translator)h(that)f(uses)g(the)f(follo)o(wing)
h(C)164 2464 y(co)q(de)g(for)h(its)f(lexical)e(analyzer:)p
eop
%%Page: 44 45
44 44 bop 164 162 a Fk(A)48 b(USING)16 b(O)o(X)k(WITH)c(NON-LEX)21
b(LEXICAL)16 b(ANAL)l(YZERS)277 b Fn(44)164 307 y Fa(#include)20
b(<stdio.h>)164 357 y(#include)g(<string.h>)164 407 y(#include)g
("y.tab.h")164 506 y(#define)g(bufsize)h(80)164 556 y(char)g
(buf[bufsize];)164 606 y(char)g(*lexBuf;)164 706 y(char)g
(*lexeme\(inString\))208 756 y(char)g(inString[];)208
805 y({return)f(strcpy\(\(char)f(*\)malloc\(1+strlen\()o(inStr)o
(ing\)\))o(,inSt)o(ring\))o(;})164 905 y(int)i(yylex\(\))208
955 y({char)f(*bufp)h(=)h(buf;)229 1054 y(while)f(\(\(*bufp)f(=)i
(getchar\(\)\))e(!=)h(EOF\))273 1104 y({if)g(\(bufp)g(==)g(\(buf)g(+)h
(bufsize)e(-)i(1\)\))360 1154 y({fprintf\(stderr,"e)o(xceed)o(ed)d
(buffer\\n"\);)g(exit\(-1\);})295 1204 y(if)i(\(\(*bufp)f(==)i(')f('\))
44 b(||)21 b(\(*bufp)g(==)g('\\n'\))g(||)382 1254 y(\(*bufp)f(==)i
('\\t'\))f(||)g(\(*bufp)g(==)g('\\f'\))360 1303 y(\))360
1353 y({if)g(\(bufp)g(==)g(buf\))g(continue;)f(else)h(break;})295
1403 y(if)g(\(!isalnum\(*bufp\)\))d({fprintf\(stderr,"il)o(legal)g
(character\\n"\);)h(exit\(-1\);})295 1453 y(bufp++;)273
1503 y(})229 1553 y(if)j(\(bufp)e(!=)i(buf\))295 1602
y({*++bufp)e(=)h('\\0';)317 1652 y(lexBuf)f(=)i(lexeme\(buf\);)317
1702 y(bufp)e(=)i(lexBuf;)317 1752 y(if)f(\(isalpha\(lexBuf[0)o(]\)\))
382 1802 y({while)f(\(*bufp)h(!=)g('\\0'\))447 1851 y(if)h
(\(isdigit\(*bufp++)o(\)\))513 1901 y({fprintf\(stderr,)o("ille)o(gal)c
(string\\n"\);)i(exit\(-1\);})404 1951 y(return)g(\(IDENT\);)382
2001 y(})317 2051 y(if)h(\(isdigit\(lexBuf[0)o(]\)\))382
2100 y({while)f(\(*bufp)h(!=)g('\\0'\))447 2150 y(if)h
(\(isalpha\(*bufp++)o(\)\))513 2200 y({fprintf\(stderr,)o("ille)o(gal)c
(string\\n"\);)i(exit\(-1\);})404 2250 y(return)g(\(ICONST\);)382
2300 y(})295 2350 y(})229 2399 y(return)h(0;)208 2449
y(})p eop
%%Page: 45 46
45 45 bop 164 162 a Fk(A)48 b(USING)16 b(O)o(X)k(WITH)c(NON-LEX)21
b(LEXICAL)16 b(ANAL)l(YZERS)277 b Fn(45)237 307 y(The)18
b(C)g(reserv)o(ed)e(w)o(ord)i Fd(return)e Fn(o)q(ccurs)i(in)f(the)g
(\014le)g(exactly)g(four)h(times.)24 b(Only)164 367 y(t)o(w)o(o)17
b(of)g(these)g(o)q(ccurrences)g(corresp)q(ond)h(to)f
Fd(return)p Fn(s)e(of)j(tok)o(ens)f(b)o(y)f(the)h(lexical)e(an-)164
428 y(alyzer.)26 b(The)18 b(approac)o(h)h(is)f(to)h(excise)d(from)h
(the)h(\014le)g(a)g(section)g(of)h(co)q(de)f(con)o(taining)164
488 y(those)i(t)o(w)o(o)f(o)q(ccurrences)g(\(and)h(no)f(others\),)h
(place)f(that)h(co)q(de)f(section)g(it)g(in)g(a)h(sep-)164
548 y(arate)g(\014le,)f(and)h(submit)e(the)i(new)f(\014le)g(to)h(Ox)f
(as)h(a)g(non-Lex)g(L-\014le,)g(b)o(y)f(using)h(the)164
608 y Fd(-G)15 b Fn(option.)22 b(Ox)15 b(translates)h(the)g(new)g
(\014le)f(and)h(places)f(it)h(on)g Fd(oxout.l)p Fn(.)i(The)e(excised)
164 668 y(co)q(de)g(is)g(replaced)g(in)g(the)g(original)g(\014le)f(b)o
(y)h(the)g(line:)292 770 y Fd(#include)23 b("oxout.l")237
872 y Fn(Here)17 b(is)g(the)g(L-\014le,)h(whic)o(h)f(has)h(b)q(een)g
(augmen)o(ted)e(b)o(y)h(t)o(w)o(o)g(attribute)h(reference)164
932 y(sections:)317 1036 y Fa(if)j(\(isalpha\(lexBuf[0)o(]\)\))382
1086 y({while)f(\(*bufp)h(!=)g('\\0'\))447 1135 y(if)h
(\(isdigit\(*bufp++)o(\)\))513 1185 y({fprintf\(stderr,)o("ille)o(gal)c
(string\\n"\);)i(exit\(-1\);})404 1235 y(return)g(\(IDENT\);)42
b(@{)22 b(@IDENT.string@)c(=)k(lexBuf;)e(@})382 1285
y(})317 1335 y(if)h(\(isdigit\(lexBuf[0)o(]\)\))382 1384
y({while)f(\(*bufp)h(!=)g('\\0'\))447 1434 y(if)h(\(isalpha\(*bufp++)o
(\)\))513 1484 y({fprintf\(stderr,)o("ille)o(gal)c(string\\n"\);)i
(exit\(-1\);})404 1534 y(return)g(\(ICONST\);)g(@{)i(@ICONST.string@)c
(=)k(lexBuf;)e(@})382 1584 y(})237 1698 y Fn(Here)12
b(is)i(the)f(sk)o(eleton)f(of)i(the)f(lexical)e(analyzer,)i(whic)o(h)g
(no)o(w)h Fd(#include)p Fn(s)c(the)j(\014les)164 1758
y Fd(oxout.h)h Fn(and)i Fd(oxout.l)p Fn(:)p eop
%%Page: 46 47
46 46 bop 164 162 a Fk(A)48 b(USING)16 b(O)o(X)k(WITH)c(NON-LEX)21
b(LEXICAL)16 b(ANAL)l(YZERS)277 b Fn(46)164 307 y Fa(#include)20
b(<stdio.h>)164 357 y(#include)g(<string.h>)164 407 y(#include)g
("y.tab.h")164 457 y(#include)g("oxout.h")164 556 y(#define)g(bufsize)h
(80)164 606 y(char)g(buf[bufsize];)164 656 y(char)g(*lexBuf;)164
756 y(char)g(*lexeme\(inString\))208 805 y(char)g(inString[];)208
855 y({return)f(strcpy\(\(char)f(*\)malloc\(1+strlen\()o(inStr)o
(ing\)\))o(,inSt)o(ring\))o(;})164 955 y(int)i(yylex\(\))208
1005 y({char)f(*bufp)h(=)h(buf;)229 1104 y(while)f(\(\(*bufp)f(=)i
(getchar\(\)\))e(!=)h(EOF\))273 1154 y({if)g(\(bufp)g(==)g(\(buf)g(+)h
(bufsize)e(-)i(1\)\))360 1204 y({fprintf\(stderr,"e)o(xceed)o(ed)d
(buffer\\n"\);)g(exit\(-1\);})295 1254 y(if)i(\(\(*bufp)f(==)i(')f('\))
44 b(||)21 b(\(*bufp)g(==)g('\\n'\))g(||)382 1303 y(\(*bufp)f(==)i
('\\t'\))f(||)g(\(*bufp)g(==)g('\\f'\))360 1353 y(\))360
1403 y({if)g(\(bufp)g(==)g(buf\))g(continue;)f(else)h(break;})295
1453 y(if)g(\(!isalnum\(*bufp\)\))d({fprintf\(stderr,"il)o(legal)g
(character\\n"\);)h(exit\(-1\);})295 1503 y(bufp++;)273
1553 y(})229 1602 y(if)j(\(bufp)e(!=)i(buf\))295 1652
y({*++bufp)e(=)h('\\0';)317 1702 y(lexBuf)f(=)i(lexeme\(buf\);)317
1752 y(bufp)e(=)i(lexBuf;)164 1851 y(#include)e("oxout.l")295
1951 y(})229 2001 y(return)h(0;)208 2051 y(})p eop
%%Page: 47 48
47 47 bop 164 162 a Fk(B)48 b(TRA)-5 b(VERSAL)16 b(SEMANTICS)874
b Fn(47)164 315 y Fo(B)82 b(T)-7 b(ra)n(v)n(ersal)27
b(seman)n(tics)164 425 y Fn(The)16 b(b)q(eha)o(vior)g(of)g(p)q
(ostdecoration)i(tra)o(v)o(ersals)d(w)o(as)i(illustrated)e(in)h(the)g
(examples)e(of)164 485 y(section)d(9.2.)20 b(In)11 b(view)g(of)g(those)
h(examples,)e(the)h(C-lik)o(e)f(pseudo)q(co)q(de)j(in)e(this)g(app)q
(endix)164 545 y(holds)h(no)h(surprises,)f(but)g(describ)q(es)g(suc)o
(h)g(b)q(eha)o(vior)g(somewhat)f(more)g(formally)l(.)18
b(The)164 606 y(tra)o(v)o(ersals)d(are)i(carried)e(out)h(b)o(y)g(a)g
(single)g(call)f(of)i Fd(doTravers)o(als)12 b Fn(\(b)q(elo)o(w\))k
(after)g(the)164 666 y(\014nal)g(decoration.)164 770
y Fa(enum)21 b(orderType)f({PREORDER,POSTORD)o(ER};)164
819 y(enum)h(directionType)e({LEFTTORIGHT,RIGHT)o(TOLE)o(FT};)164
1019 y(enum)i(orderType)f(staticOrder\(trave)o(rsal)e(T\))208
1068 y({if)j(\(@preorder)e(appears)i(in)g(the)g(traversal)f
(specification)f(of)j(T\))317 1118 y(return)e(PREORDER;)229
1168 y(return)h(POSTORDER;)208 1218 y(})164 1417 y(enum)g
(directionType)e(staticDirection\(tr)o(aver)o(sal)g(T\))208
1467 y({if)i(\(@righttoleft)e(appears)h(in)i(the)f(traversal)f
(specification)f(of)i(T\))317 1517 y(return)f(RIGHTTOLEFT;)229
1567 y(return)h(LEFTTORIGHT;)208 1616 y(})164 1816 y(int)g
(isDisabled\(travers)o(al)e(T\))208 1865 y({if)i(\(@disable)f(appears)g
(in)h(the)h(traversal)d(specification)h(of)h(T\))317
1915 y(return)f(1;)229 1965 y(return)h(0;)208 2015 y(})p
eop
%%Page: 48 49
48 48 bop 164 162 a Fk(B)48 b(TRA)-5 b(VERSAL)16 b(SEMANTICS)874
b Fn(48)164 307 y Fa(void)21 b(pdTrav\(parse_tree)o(_node)d(N,)k
(traversal)d(T\))208 357 y({grammar_rule)g(R;)261 b(/*)21
b(the)g(rule)g(applied)g(at)g(N)h(*/)229 407 y(enum)f(orderType)f
(order[Z];)64 b(/*)43 b(Z)g(>=)g(#)22 b(of)f(traversal)f(action)h
(specs)1057 457 y(for)h(T)f(in)h(R)43 b(*/)229 506 y(enum)21
b(directionType)e(direction;)229 556 y(int)j(i,j,k;)229
656 y(R)g(=)g(the)f(grammar)f(rule)h(applied)f(at)i(N;)229
706 y(let)g(the)f(traversal)f(actions)g(for)h(T)h(in)f(the)g(attribute)
f(definition)g(section)317 756 y(of)h(R)g(be)h(numbered)e(from)h(0)h
(to)f(k-1;)229 805 y(for)h(\(i=0;)e(i<k;)h(i++\))317
855 y({if)g(\(the)g(ith)g(traversal)f(action)g(specifier)g(has)h(no)h
(@revorder\))491 905 y(order[i])e(=)i(staticOrder\(T\);)404
955 y(else)f(if)g(\(\(the)g(expression)f(associated)f(with)i
(@revorder\))f(==)h(0\))491 1005 y(order[i])f(=)i(staticOrder\(T\);)404
1054 y(else)f(if)g(\(staticOrder\(T\))e(==)i(POSTORDER\))491
1104 y(order[i])f(=)i(PREORDER;)404 1154 y(else)491 1204
y(order[i])e(=)i(POSTORDER;)338 1254 y(if)g(\(the)f(ith)g(traversal)f
(action)g(specifier)g(has)h(no)h(@revdirection\))491
1303 y(direction)e(=)h(staticDirection\(T\);)404 1353
y(else)g(if)g(\(\(the)g(expression)f(asociated)f(with)i
(@revdirection\))e(==)j(0\))491 1403 y(direction)e(=)h
(staticDirection\(T\);)404 1453 y(else)g(if)g(\(staticDirection\(T)o
(\))e(==)i(LEFTTORIGHT\))491 1503 y(direction)f(=)h(RIGHTTOLEFT;)404
1553 y(else)491 1602 y(direction)f(=)h(LEFTTORIGHT;)317
1652 y(})229 1702 y(for)h(\(i=0;)e(i<k;)h(i++\))317 1752
y(if)g(\(order[i])f(=)h(PREORDER\))404 1802 y(execute)f(the)h(ith)g
(traversal)f(action;)229 1851 y(number)h(the)g(children)f(of)i(N)f
(from)g(left)g(to)g(right)338 1901 y(with)g(integers)f(from)h(0)h(to)f
(j-1;)229 1951 y(if)h(\(direction)d(==)j(LEFTTORIGHT\))317
2001 y(for)f(\(i=0;)f(i<j;)h(i++\))43 b(pdTrav\(the)20
b(ith)h(child)g(of)g(N,T\);)317 2051 y(else)317 2100
y(for)g(\(i=j-1;)f(i>=0;)h(i--\))43 b(pdTrav\(the)19
b(ith)i(child)g(of)h(N,T\);)229 2150 y(for)g(\(i=0;)e(i<k;)h(i++\))317
2200 y(if)g(\(order[i])f(=)h(POSTORDER\))404 2250 y(execute)f(the)h
(ith)g(traversal)f(action;)208 2300 y(})p eop
%%Page: 49 50
49 49 bop 164 162 a Fk(B)48 b(TRA)-5 b(VERSAL)16 b(SEMANTICS)874
b Fn(49)164 307 y Fa(void)21 b(doTraversals\(\))208 357
y({int)g(i,k;)229 407 y(parse_tree_node)e(r;)229 506
y(r)j(=)g(the)f(root)g(of)g(the)g(parse)g(tree;)229 556
y(k)h(=)g(the)f(number)f(of)i(traversals;)229 606 y(number)f(the)g
(traversals)f(from)h(0)g(to)h(k-1,)f(according)f(to)295
656 y(the)h(order)g(of)g(appearance)f(of)h(their)g(specifications;)229
706 y(for)h(\(i=0;)e(i<k;)h(i++\))317 756 y(if)g(\(!isDisabled\(the)d
(ith)k(traversal\)\))382 805 y(pdTrav\(r,the)d(ith)i(traversal\);)208
855 y(})p eop
%%Page: 50 51
50 50 bop 164 162 a Fk(C)49 b(LIST)17 b(OF)f(RESER)-5
b(VED)16 b(W)o(ORDS)g(AND)g(RESER)-5 b(VED)16 b(FILE)g(NAMES)69
b Fn(50)164 315 y Fo(C)82 b(List)36 b(of)i(reserv)n(ed)d(w)n(ords)h
(and)g(reserv)n(ed)f(\014le)306 407 y(names)164 516 y
Fn(The)16 b(Ox)g(reserv)o(ed)f(w)o(ords)i(are)f(as)h(follo)o(ws:)189
623 y Fd(@)p Fc(f)189 683 y Fd(@)p Fc(g)189 743 y Fd(@attribute)o(s)189
803 y(@autoinh)189 864 y(@autosyn)189 924 y(@disable)189
984 y(@e)189 1044 y(@i)189 1104 y(@lefttorig)o(ht)189
1165 y(@m)189 1225 y(@postorder)189 1285 y(@preorder)189
1345 y(@revdirect)o(io)o(n)189 1405 y(@revorder)189 1465
y(@righttole)o(ft)189 1526 y(@warn)164 1668 y Fn(The)23
b(follo)o(wing)g(\014le)g(names)g(in)g(the)g(curren)o(t)f(directory)h
(are)g(reserv)o(ed)f(for)i(use)f(b)o(y)164 1728 y(Ox:)189
1835 y Fd(oxout.h)638 b Fn(\(exactly)15 b(when)h(using)h
Fd(-h)e Fn(option\))189 1895 y Fd(oxout.y)189 1955 y(oxout.l)638
b Fn(\(exactly)15 b(when)h(using)h(exactly)e(one)h(Y-\014le\))189
2015 y Fd(oxout0.l)p Fn(,)d Fd(oxout1.l)p Fn(,)g Fd(oxout2.l)p
Fn(,)f Fi(:)c(:)g(:)58 b Fn(\(when)16 b(using)h(more)e(than)i(one)f
(L-\014le\))p eop
%%Page: 51 52
51 51 bop 164 162 a Fk(D)49 b(SUMMAR)l(Y)14 b(OF)i(COMMAND-LINE)g
(OPTIONS)474 b Fn(51)164 315 y Fo(D)83 b(Summary)26 b(of)i
(command-line)f(options)164 425 y Fn(The)16 b(Ox)g(command)e(line)h
(tak)o(es)h(the)g(form:)237 545 y Fd(ox)g Fc(f)g Fg(option)g
Fc(g)g Fg(Y-\014le)j Fn([)p Fd(-G)p Fn(])14 b Fg(L-\014le)k
Fc(f)e Fn([)p Fd(-G)p Fn(])f Fg(L-\014le)i Fc(g)164 666
y Fn(The)f Fd(-G)g Fn(ann)o(unciator)g(and)h(the)f Fg(option)p
Fn(s)h(are)f(describ)q(ed)g(as)h(follo)o(ws:)164 767
y Fd(-G)24 b Fn(The)14 b(\014lename)f(whic)o(h)h(follo)o(ws)h(is)g
(that)g(of)g(a)g(generic)f(\(i.e.)19 b(non-Lex\))d(L-\014le.)21
b(This)286 828 y(option)14 b(is)g(used)g(when)g(the)g(Ox)g(user)f
(prefers)h(a)g(scanner)g(hand-written)h(in)e(C)i(or)286
888 y(C++.)22 b(Except)16 b(for)h(attribute)f(reference)f(sections,)h
(the)g(L-\014le)h(m)o(ust)e(conform)286 948 y(to)23 b(C/C++)g(syn)o
(tax.)39 b(The)23 b Fd(return)d Fn(reserv)o(ed)h(w)o(ord)i(is)f
(recognized)g(in)g(an)o(y)286 1008 y(con)o(text)15 b(other)i(than)f
(commen)o(ts)e(and)j(string)f(literals.)k(See)c(app)q(endix)g(A.)164
1110 y Fd(-C)24 b Fn(Prin)o(t)15 b(the)h(Ox)g(cop)o(yrigh)o(t)g
(statemen)o(t)e(and)j(disclaimer.)164 1212 y Fd(-I)24
b Fn(Generate)16 b(co)q(de)g(for)h(C++)f(or)h(ANSI/ISO)e(C)h
(compilation.)164 1313 y Fd(-S)24 b Fn(Strip)c(Ox-sp)q(eci\014c)g
(constructs)h(from)e(the)h(Y-\014le)g(and)h(L-\014le\(s\))g(and)g
(place)f(the)286 1374 y(pure)c(Y)l(acc)g(and)g(pure)g(Lex)h(results)f
(on)g Fd(oxout*.*)p Fn(.)j(See)c(section)h(13.3.)164
1475 y Fd(-U)24 b Fn(Sho)o(w)16 b(the)g(form)f(of)i(the)f(Ox)g(command)
e(line.)164 1577 y Fd(-V)24 b Fn(Prin)o(t)15 b(the)h(v)o(ersion)g(n)o
(um)o(b)q(er.)164 1679 y Fd(-h)24 b Fn(Pro)q(duce)c(an)g(Ox)f(header)h
(\014le)f Fd(oxout.h)e Fn(to)j(b)q(e)g Fd(#include)p
Fn(d)d(in)i(a)h(co)q(de)g(section)286 1739 y(\(b)q(et)o(w)o(een)f
Fd(\045)p Fc(f)g Fn(and)h Fd(\045)p Fc(g)p Fn(\))f(in)g(the)h(Y-\014le)
e(or)i(L-\014le\(s\).)32 b(This)19 b(p)q(ermits)f(one-step)286
1799 y(compilation)11 b(of)i(the)g(parser)g(and)g(scanner\(s\).)21
b(When)12 b(this)h(option)g(is)g(not)g(used,)286 1859
y(Ox)18 b(places)f(the)h(header)g(information)f(in)h(eac)o(h)f(output)i
(\014le)e(rather)h(than)h(in)f(a)286 1919 y(separate)f(header)f
(\014le.)k(See)c(section)g(12.3.)164 2021 y Fd(-n)24
b Fn(Generate)12 b(an)i(ev)m(aluator)f(that)h(determines)d(an)i(ev)m
(aluation)g(order)h(and)f(c)o(hec)o(ks)f(for)286 2081
y(cycles,)f(but)h(do)q(es)h(not)f(execute)f(the)g(co)q(de)h(that)h(ev)m
(aluates)f(attribute)f(instances.)286 2141 y(See)16 b(section)f(13.4.)
164 2243 y Fd(-u)24 b Fn(Generate)16 b(an)g(ev)m(aluator)h(that)f(prin)
o(ts)g(parse-tree)g(memory-usage)f(statistics)h(for)286
2303 y(eac)o(h)g(input.)21 b(See)15 b(section)h(13.6.)164
2405 y Fd(-a)p Fi(N)29 b Fn(Set)13 b Fi(N)18 b Fn(as)13
b(the)g(generated)g(ev)m(aluator's)g(default)g(structure-alignmen)o(t)d
(size.)20 b(By)286 2465 y(default,)15 b(the)h(default)g
(structure-alignmen)o(t)f(size)g(is)h(4.)22 b(See)15
b(section)h(13.2.)p eop
%%Page: 52 53
52 52 bop 164 162 a Fk(D)49 b(SUMMAR)l(Y)14 b(OF)i(COMMAND-LINE)g
(OPTIONS)474 b Fn(52)164 307 y Fd(-Y)p Fi(aN)28 b Fn(Where)21
b Fi(N)k Fn(is)c(an)g(in)o(teger)e(and)j Fi(a)e Fn(is)g(one)h(of)g(the)
f(alphab)q(etic)g(c)o(haracters)h Fd(n)p Fn(,)286 367
y Fd(c)p Fn(,)g(or)g Fd(r)p Fn(,)g(c)o(hange)g(the)f(default)h(size)f
(of)h(data)g(structure)g Fi(a)f Fn(in)g(the)h(generated)286
428 y(ev)m(aluator)k(to)f(size)f Fi(N)5 b Fn(.)46 b(When)24
b(suc)o(h)g(a)g(data)h(structure)f(is)g(exceeded,)g(the)286
488 y(generated)18 b(ev)m(aluator)h(issues)f(an)g(error)h(message)e
(calling)g(for)i(use)f(of)g(a)h Fd(-Y)p Fi(aN)286 548
y Fn(option.)j(The)16 b(e\013ects)f(of)i(the)e Fd(-Y)p
Fi(aN)20 b Fn(options)d(for)f(the)g(v)m(arious)h(v)m(alues)f(of)g
Fi(a)g Fn(are)286 608 y(as)h(follo)o(ws:)286 710 y Fd(n)24
b(-Yn)p Fi(N)17 b Fn(causes)d(allo)q(cation)g(of)g Fi(N)k
Fn(b)o(ytes)13 b(for)h(parse-tree)f(no)q(des)h(and)g(attribute)393
770 y(instances.)286 851 y Fd(c)24 b Fi(N)17 b Fn(is)12
b(the)f(maxim)o(um)d(n)o(um)o(b)q(er)i(of)i(non-ro)q(ot)i(no)q(des)e
(in)g(the)f(parse)i(tree.)19 b Fd(-Yc)p Fi(N)393 911
y Fn(causes)j(allo)q(cation)g(of)f Fi(N)27 b Fd(*)e(sizeof\(void)d(*\))
f Fn(b)o(ytes)f(for)i(p)q(oin)o(ters)g(to)393 971 y(c)o(hild)15
b(no)q(des.)286 1052 y Fd(r)24 b Fi(N)f Fn(is)17 b(the)g(maxim)o(um)c
(n)o(um)o(b)q(er)j(of)i(attribute)f(instances)h(in)f(the)g(parse)h
(tree.)393 1112 y Fi(N)k Fn(b)o(ytes)15 b(are)i(allo)q(cated)f(for)g
(this.)286 1214 y(See)g(sections)g(13.5)h(and)g(13.6.)164
1316 y Fd(-YY)23 b Fn(Enable)c(the)g(generated)f(ev)m(aluator)h(to)h
(understand)f(the)g(same)e Fd(-Y)p Fi(aN)23 b Fn(options)286
1376 y(as)17 b(do)q(es)g(Ox)f(itself.)k(See)c(section)f(13.5.)164
1478 y Fd(-X)p Fi(aN)28 b Fn(Where)19 b Fi(N)24 b Fn(is)19
b(an)g(in)o(teger)f(and)i Fi(a)f Fn(is)f(an)i(alphab)q(etic)f(c)o
(haracter,)f(c)o(hange)h(the)286 1538 y(default)j(size)f(of)i(Ox's)f
(data)h(structure)f Fi(a)g Fn(to)h(size)e Fi(N)5 b Fn(.)40
b(When)22 b(suc)o(h)g(a)h(data)286 1598 y(structure)c(is)g(exceeded,)f
(Ox)h(issues)g(an)h(error)f(message)g(calling)f(for)i(use)f(of)h(a)286
1658 y Fd(-X)p Fi(aN)g Fn(option.)p eop
%%Page: 53 54
53 53 bop 164 162 a Fk(REFERENCES)1235 b Fn(53)164 315
y Fo(References)164 425 y Fn([Johnson)17 b(75])151 b(Stephen)16
b(C.)h(Johnson,)g Fg(Y)l(ac)n(c:)24 b(Y)l(et)18 b(A)o(nother)g
(Compiler)g(Com-)581 485 y(piler)p Fn(,)40 b(Computing)34
b(Science)f(T)l(ec)o(hnical)h(Rep)q(ort)h(No.)g(32,)581
545 y(A)l(T&T)14 b(Bell)f(Lab)q(oratories,)j(Murra)o(y)d(Hill,)g(New)g
(Jersey)l(,)h(1975.)581 606 y(Reprin)o(ted)26 b(as)i(PS1:15)g(in)e
Fg(UNIX)i(Pr)n(o)n(gr)n(ammer's)d(Manual)p Fn(,)581 666
y(Usenix)15 b(Asso)q(ciation,)h(1986.)164 767 y([Lesk)g(75])228
b(M.E.)13 b(Lesk)h(and)g(E.)g(Sc)o(hmidt,)e Fg(L)n(ex{A)j(L)n(exic)n
(al)g(A)o(nalyzer)h(Gen-)581 828 y(er)n(ator)p Fn(,)32
b(Computing)d(Science)g(T)l(ec)o(hnical)f(Rep)q(ort)i(No.)g(39,)581
888 y(A)l(T&T)17 b(Bell)e(Lab)q(oratories,)j(Murra)o(y)e(Hills,)e(New)i
(Jersey)l(,)g(Oc-)581 948 y(tob)q(er)g(1975.)h(Reprin)o(ted)e(as)i
(PS1:16)f(in)g Fg(UNIX)h(Pr)n(o)n(gr)n(ammer's)581 1008
y(Manual)p Fn(,)f(Usenix)g(Asso)q(ciation,)g(1986.)164
1110 y([KR)g(88])251 b(Brian)15 b(W.)g(Kernighan)g(and)h(Dennis)f(M.)f
(Ritc)o(hie,)f Fg(The)k(C)f(Pr)n(o-)581 1170 y(gr)n(amming)h(L)n
(anguage,)h(2nd)g(Ed.)e Fn(Pren)o(tice-Hall,)e(1988.)164
1272 y([W)l(aite)h(84])201 b(William)22 b(M.)i(W)l(aite)g(and)h
(Gerhard)g(Go)q(os,)i Fg(Compiler)e(Con-)581 1332 y(struction)p
Fn(,)17 b(Springer-V)l(erlag,)e(1984.)164 1434 y([Aho)h(86])237
b(Alfred)30 b(V.)g(Aho,)35 b(Ra)o(vi)30 b(Sethi,)k(and)e(Je\013rey)f
(D.)g(Ullman,)581 1494 y Fg(Compilers:)26 b(Principles,)21
b(T)l(e)n(chniques,)h(and)d(T)l(o)n(ols)p Fn(,)g(Addison-)581
1554 y(W)l(esley)l(,)c(1986.)164 1656 y([Jaza)o(y)o(eri)g(75])152
b(M.)12 b(Jaza)o(y)o(eri,)g(W.F.)g(Ogden,)h(and)h(W.C.)e(Rounds,)i
Fg(The)g(Intrin-)581 1716 y(sic)g(Exp)n(onential)h(Complexity)e(of)h
(the)g(Cir)n(cularity)e(Pr)n(oblem)h(for)581 1776 y(A)o(ttribute)18
b(Gr)n(ammars)p Fn(,)13 b(Comm)o(unications)h(of)i(the)f(A)o(CM,)g(V)l
(ol.)581 1836 y(18,)i(No.)e(12,)i(pp.)f(697-706,)i(Decem)o(b)q(er)c
(1975.)164 1938 y([Lorho)j(88])200 b(Pierre)15 b(Deransart,)i(Martin)f
(Jourdan,)g(and)h(Bernhard)f(Lorho,)581 1998 y Fg(A)o(ttribute)27
b(Gr)n(ammars:)36 b(De\014nitions,)29 b(Systems,)g(and)c(Bibli-)581
2058 y(o)n(gr)n(aphy)p Fn(,)j(Lecture)f(Notes)g(in)g(Computer)f
(Science,)j(v.)d(323,)581 2119 y(Springer)16 b(V)l(erlag,)f(1988.)164
2220 y([Kn)o(uth)h(68])188 b(Donald)18 b(E.)f(Kn)o(uth,)g
Fg(Semantics)j(of)e(Context-F)l(r)n(e)n(e)h(L)n(anguages)581
2281 y Fn(Mathematical)10 b(Systems)g(Theory)l(,)i(V)l(ol.)e(2,)i(No.)f
(2,)i(pp.)e(127-145,)581 2341 y(1968.)p eop
%%Page: 54 55
54 54 bop 164 391 a Fo(Index)164 481 y Fd(@)p Fc(f)p
Fn(,)15 b(8,)i(9)164 542 y Fd(@)p Fc(g)p Fn(,)e(8,)i(9)247
602 y(\(as)24 b(attribute)g(de\014nition)f(termi-)330
662 y(nator\),)17 b(10)164 722 y Fd(@attribute)o(s)p
Fn(,)c(6)164 782 y Fd(@autoinh)p Fn(,)g(26,)j(27)164
843 y Fd(@autosyn)p Fn(,)d(26,)j(27)164 903 y Fd(@disable)p
Fn(,)d(21)164 963 y Fd(@e)p Fn(,)i(10)164 1023 y Fd(@i)p
Fn(,)g(10)164 1083 y Fd(@lefttorig)o(ht)p Fn(,)d(21)164
1143 y Fd(@m)p Fn(,)j(10)164 1204 y Fd(@postorder)o Fn(,)e(21)164
1264 y Fd(@preorder)p Fn(,)f(21)164 1324 y Fd(@revdirect)o(ion)o
Fn(,)h(22)164 1384 y Fd(@revorder)p Fn(,)f(22)164 1444
y Fd(@righttole)o(ft)p Fn(,)g(21)164 1505 y Fd(@warn)p
Fn(,)i(27)164 1565 y Fd($$)p Fn(,)25 b Fd($1)p Fn(,)f
Fd($2)p Fn(,)h(...,)f(\(Y)l(acc)f(pseudo)o(v)m(ari-)330
1625 y(ables\),)16 b(17)164 1685 y Fd(oxout.*)p Fn(,)d(29)164
1745 y Fd(oxout?.l)p Fn(,)g(29)164 1847 y(alignmen)o(t)h(constan)o(t,)j
(31)164 1907 y(am)o(biguous)23 b(form)g(of)h Fd(return)e
Fn(of)i(to-)330 1967 y(k)o(en,)15 b(14)164 2028 y(attribute)247
2088 y(inherited,)f Fj(9)247 2148 y Fn(syn)o(thesized,)h
Fj(9)164 2208 y Fn(attribute)22 b(\(as)g(b)q(elonging)h(to)f(a)h(sym-)
330 2268 y(b)q(ol\),)16 b Fj(7)164 2329 y Fn(attribute)g(declaration,)f
Fj(6)164 2389 y Fn(attribute)h(de\014nition,)f Fj(9)247
2449 y Fn(dep)q(endency)h(part)g(of,)g Fj(9)1129 481
y Fn(ev)m(aluation)g(part)h(of,)f Fj(9)1129 542 y Fn(explicit)e(mo)q
(de,)h(10)1129 602 y(implicit)e(mo)q(de,)i(11)1129 662
y(mixed)f(mo)q(de,)h(11)1129 722 y(termination)g(of,)h
Fj(10)1046 782 y Fn(attribute)g(de\014nition)g(mo)q(des,)f(10)1046
843 y(attribute)h(grammar)1129 903 y(class)22 b(of)h(A)o(Gs)f(accepted)
f(b)o(y)h(Ox,)1212 963 y(12)1129 1023 y(execution)12
b(sequence)g(not)i(explicit)1212 1083 y(in,)i(17)1046
1143 y(attribute)g(instance,)g Fj(7)1129 1204 y Fn(solving)g(an,)h
Fj(11)1046 1264 y Fn(attribute)e(instance)h(\(as)g(b)q(elonging)h(to)
1212 1324 y(a)g(no)q(de\),)f Fj(7)1046 1384 y Fn(attribute)g(instances)
1129 1444 y(ready)g(set)g(of,)g Fj(17)1046 1505 y Fn(attribute)g(o)q
(ccurrence,)f Fj(7)1129 1565 y Fn(dep)q(endees)h(of)h(an,)f(10)1129
1625 y(dep)q(enden)o(ts)g(of)h(an,)f(10)1129 1685 y(inherited,)f
Fj(8)1129 1745 y Fn(syn)o(thesized,)g Fj(8)1046 1806
y Fn(attribute)h(o)q(ccurrence)g(,)f(8)1046 1866 y(attribute)h
(reference,)e Fj(10)1046 1926 y Fn(attribute)i(reference)f(section,)g
Fj(8)p Fn(,)h Fj(12)1046 1986 y Fn(attribute)26 b(reference)f(section)h
(delim-)1212 2046 y(iters,)15 b(12)1046 2148 y(circular)g(grammar,)f
Fj(15)1046 2208 y Fn(co)q(de)j(generation,)f(18)1046
2268 y(command-line)d(options,)k(51)1046 2329 y(command-line)c(syn)o
(tax,)j(51)1046 2389 y(commen)o(ts,)d(6)1046 2449 y(cop)o(y)j(rule,)f
Fj(26)949 2599 y Fn(54)p eop
%%Page: 55 56
55 55 bop 164 162 a Fk(INDEX)1408 b Fn(55)164 307 y(cycle)14
b(\(in)i(an)g(attributed)g(parse)g(tree\),)330 367 y
Fj(15)164 428 y Fn(cycle)f(detection,)f(15)164 524 y(declaration)247
584 y(attribute,)h Fj(6)164 644 y Fn(decoration,)h Fj(17)164
704 y Fn(de\014ned,)g(attribute)f(o)q(ccurrence,)h(10)164
765 y(de\014nition)247 825 y(attribute,)f Fj(9)164 885
y Fn(de\014nition)h(mo)q(de)f(ann)o(unciator,)h Fj(10)164
945 y Fn(dep)q(endee,)f Fj(10)164 1005 y Fn(dep)q(endency)h
(expression,)f Fj(10)164 1066 y Fn(dep)q(endency)24 b(part)h(\(of)g(an)
g(attribute)330 1126 y(de\014nition\),)15 b Fj(9)164
1186 y Fn(dep)q(enden)o(t,)g Fj(10)164 1246 y Fn(dep)q(ends)i(up)q(on,)
f(10)164 1306 y(dynamic)e(tra)o(v)o(ersal)i(mo)q(di\014er,)e
Fj(22)164 1403 y Fn(ev)m(aluation)i(expression,)g Fj(10)164
1463 y Fn(ev)m(aluation)11 b(part)g(\(of)g(an)h(attribute)e(def-)330
1523 y(inition\),)15 b Fj(9)164 1583 y Fn(example)247
1643 y(Kn)o(uth's)h(classical,)f(36)247 1704 y(v)o(ery)g(easy)l(,)h(34)
164 1764 y(execution)j(sequence)h(not)h(explicit)d(in)330
1824 y(attribute)e(grammars,)e(17)164 1884 y(explicit)g(mo)q(de)h(ann)o
(unciator,)i(10,)f Fj(10)164 1944 y Fn(explicit)i(mo)q(de)i(attribute)h
(de\014nition,)330 2005 y Fj(10)164 2101 y Fn(\014le)16
b(names)247 2161 y(Ox)g(output,)g(29)164 2221 y(\014nal)g(decoration,)g
Fj(17,)j(18)164 2318 y Fn(global)e(v)m(ariables)247 2378
y(reference)e(to)h(C's,)g(18)164 2474 y(header)g(\014le)g
Fd(oxout.h)p Fn(,)d(30)1046 307 y(home)i(rule,)g Fj(9)1046
407 y Fn(implicit)e(mo)q(de)i(ann)o(unciator,)i Fj(11)p
Fn(,)e(11)1046 468 y(implicit)g(mo)q(de)j(attribute)g(de\014nition,)
1212 528 y Fj(11)1046 588 y Fn(inherited)d(attribute,)h
Fj(9)1046 648 y Fn(inherited)f(attribute)h(o)q(ccurrence,)f
Fj(8)1046 708 y Fn(instance)1129 769 y(attribute,)h Fj(7)1046
869 y Fn(Kn)o(uth's)g(classical)f(example,)f(36)1046
969 y(L-\014le,)i Fj(5)1046 1029 y Fn(LALR\(1\))c(prop)q(ert)o(y)e
(preserv)o(ed)g(b)o(y)g(Ox-)1212 1090 y(prepro)q(cessing,)16
b(16)1046 1150 y(left-hand)g(side,)g(7)1046 1210 y(LHS)g(\(left-hand)h
(side\),)e(7)1046 1270 y(lo)q(ok)m(ahead)j(bu\013er,)e
Fj(16)1046 1371 y Fn(macros,)f(23)1046 1431 y(macros)10
b(forbidden)h(for)g Fd(return)e Fn(of)i(yylex,)1212 1491
y(12)1046 1551 y(mixed)j(mo)q(de)h(ann)o(unciator,)i(11,)f
Fj(11)1046 1611 y Fn(mixed)9 b(mo)q(de)h(attribute)g(de\014nition,)h
Fj(11)1046 1672 y Fn(mo)q(de)1129 1732 y(attribute)16
b(de\014nition,)f(10)1046 1792 y(mo)q(de)g(ann)o(unciator)1129
1852 y Fd(@e)h Fn(\(explicit\),)d(10)1129 1912 y Fd(@i)j
Fn(\(implici)o(t\),)d(10,)k(11)1129 1972 y Fd(@m)f Fn(\(mixed\),)d(10,)
k(11)1129 2033 y(de\014nition,)e Fj(10)1129 2093 y Fn(tra)o(v)o(ersal,)
g Fj(20)1046 2193 y Fn(o)q(ccurrence)1129 2253 y(attribute,)h
Fj(7)p Fn(,)f(8)1046 2314 y(options)1129 2374 y(command-line,)e(51)1046
2474 y(paren)o(t)j(rule,)f Fj(9)p eop
%%Page: 56 57
56 56 bop 164 162 a Fk(INDEX)1408 b Fn(56)164 307 y(p)q(ostdecoration,)
17 b Fj(18)164 367 y Fn(p)q(ostdecoration)g(tra)o(v)o(ersal,)e
Fj(18)164 428 y Fn(pseudo)o(v)m(ariables)247 488 y(references)g(to)h(Y)
l(acc's,)f(17)164 588 y(ready)21 b(set)h(\(of)f(attribute)g
(instances\),)330 648 y Fj(17)164 708 y Fn(reference)247
769 y(attribute,)15 b Fj(10)164 829 y Fd(return)247 889
y Fn(of)i(yylex)d(m)o(ust)h(b)q(e)h(explicit,)e(12)164
949 y Fd(return)g Fn(statemen)o(ts)247 1009 y(lexical)9
b(rules)h(asso)q(ciated)i(with,)f Fj(12)164 1070 y Fn(RHS)16
b(\(righ)o(t-hand)h(side\),)e(7)164 1130 y(righ)o(t-hand)i(side,)e(7)
164 1190 y(rule,)g Fj(7)247 1250 y Fn(home,)g Fj(9)247
1310 y Fn(paren)o(t,)h Fj(9)247 1371 y Fd(return)p Fn(ed)e(tok)o(en)i
(as)g(a,)h Fj(7)164 1431 y Fn(rules)f(section)g(of)g(a)h(Y)l(acc)e
(\014le,)g Fj(9)164 1531 y Fn(side)h(e\013ects,)f(18)164
1591 y(solving)h(\(an)h(attribute)f(instance\),)f Fj(11)164
1651 y Fn(sync)o(hronization)247 1712 y(Ox)h(and)h(Y)l(acc)e(stac)o(k,)
h(16,)g(31)164 1772 y(syn)o(thesized)f(attribute,)g Fj(9)164
1832 y Fn(syn)o(thesized)c(attribute)h(o)q(ccurrence,)g
Fj(8)164 1932 y Fn(tok)o(en)247 1993 y(inherited)j(attributes)h(of)h
(a,)f(12)247 2053 y(syn)o(thesized)f(attributes)h(of)h(a,)f(12)164
2113 y(tra)o(v)o(ersal)247 2173 y(p)q(ostdecoration,)h
Fj(18)164 2233 y Fn(tra)o(v)o(ersal)e(action,)h Fj(22)164
2293 y Fn(tra)o(v)o(ersal)f(action)i(sp)q(eci\014cation,)e
Fj(22)164 2354 y Fn(tra)o(v)o(ersal)g(action)i(sp)q(eci\014er,)e
Fj(20)164 2414 y Fn(tra)o(v)o(ersal)10 b(mo)q(de)g(ann)o(unciator,)i
Fj(20)p Fn(,)g Fj(22)164 2474 y Fn(tra)o(v)o(ersal)j(mo)q(di\014er)1129
307 y(dynamic,)f Fj(22)1046 367 y Fn(tra)o(v)o(ersal)i(sp)q
(eci\014cation,)f Fj(21)1046 428 y Fn(tra)o(v)o(ersal)h(sp)q
(eci\014er,)f Fj(21)1046 488 y Fn(tra)o(v)o(ersal)h(sp)q(eci\014er)f
(sequence,)g Fj(21)1046 589 y Fn(Y-\014le,)g Fj(5)1046
650 y Fd(yyleng)p Fn(,)f(17)1046 710 y Fd(yytext)p Fn(,)g(17)p
eop
%%Trailer
end
userdict /end-hook known{end-hook}if
%%EOF
@EOF
set `sum $sumopt <oxDistG1.04/docs/oxURM.ps`; if test $1 -ne 39615
then
	echo ERROR: oxDistG1.04/docs/oxURM.ps checksum is $1 should be 39615
fi
set `wc -lwc <oxDistG1.04/docs/oxURM.ps`
if test $1$2$3 != 419410956278142
then
	echo ERROR: wc results of oxDistG1.04/docs/oxURM.ps are $* should be 4194 10956 278142
fi

chmod 755 oxDistG1.04/docs/oxURM.ps

if test -f oxDistG1.04/docs/ox.1
then
	echo Ok to overwrite existing file oxDistG1.04/docs/ox.1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/docs/ox.1
	if test -f oxDistG1.04/docs/ox.1
	then
		echo Error: could not remove oxDistG1.04/docs/ox.1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/docs/ox.1
sed 's/^@//' >oxDistG1.04/docs/ox.1 <<'@EOF'
@. $Header: manpage.s,v 5.4 94/02/08 20:05:57 bischoff Exp $
@.\" @(#)ox.1 92/11/14; 
@.TH OX 1 "15 August 1993"
@.SH NAME
ox \- an attribute-grammar compiling system based on Yacc, Lex, and C 
@.SH SYNOPSIS
ox
[ \-options ]
@.I Y\-file 
[-G] 
@.I L\-file 
[ [-G] 
@.I L\-file1 
[-G] 
@.I L\-file2 ... 
]
@.SH DESCRIPTION
@.B Ox 
generalizes the function of 
@.B Yacc 
in the way that attribute
grammars generalize context-free grammars.  Ordinary 
@.B Yacc 
and 
@.B Lex
specifications may be augmented with definitions of synthesized
and inherited attributes written in 
@.BR C / C++
syntax.  From these specifications, 
@.B Ox 
generates a program that builds and 
decorates attributed parse trees.  The 
user may specify postdecoration traversals for
easy ordering of side effects such as code generation.  
@.B Ox 
handles the details of writing code for parse-tree management,
and accepts a most general class of attribute grammars.  
@.B Ox 
may also be used with 
@.BR Yacc -
and 
@.BR Lex -
workalikes such as 
@.B Bison
and 
@.BR Flex .

@.SH MAIN POINTS OF USE 
@.B Ox 
is a 
@.BR Yacc / Lex / C 
preprocessor, and inherits all of the syntax and semantics of 
those languages.  The 
contents of 
@.I "Y-file"
are translated to 
@.B Yacc 
code and placed on 
@.BR oxout.y .
If there is exactly one 
@.IR "L-file" ,
it is translated to 
@.B Lex 
code and placed on 
@.BR oxout.l .
In case there are multiple 
@.IR "L-file" s,
they are translated and placed on
@.BR oxout.0.l ,
@.BR oxout.1.l ,
@.BR oxout.2.l ,
etc.
This describes the most-used  
@.BR Ox \-specific 
elements of 
@.B Ox
syntax and gives some indications of their
semantics.  See the 
@.I "User Manual for Ox"
(mentioned below)
for details and examples.

For each grammar symbol, there may be declared a set of attributes:
Preceding the initial
@.B %%
mark in the Y-file, the user may place 
@.B attribute 
@.BR declarations ,
which consist of the 
@.B Ox 
reserved word
@.B @attributes
followed by
@.BR { ,
an 
@.B attribute declaration 
@.BR list ,
@.BR } ,
and a
@.B grammar symbol 
@.BR list .
An attribute declaration list
is a sequence made of identifiers, digit strings, and the symbols:
@.BR * , 
@.BR : , 
@.BR ; , 
@.BR char , 
@.BR class , 
@.BR short , 
@.BR int , 
@.BR long , 
@.BR float , 
@.BR double , 
@.BR signed , 
@.BR unsigned , 
@.BR struct , 
@.BR union , 
and 
@.BR enum ,
arranged according to 
the syntax of 
@.B C 
structure declarations.  A 
grammar symbol list
is a possibly-empty sequence of 
@.B Yacc 
tokens (including character constants)
and nonterminals, members of the list being separated by whitespace.

Also preceding the initial
@.B %%
of the Y-file, there may appear 
@.B traversal 
@.BR specifications .
These consist of: 
@.B @traversal 
followed by a 
@.B traversal-modifier sequence
and a nonempty sequence of identifiers, 
members of the list separated by whitespace.  A
traversal modifier sequence
consists of the following (in any order):
at most one of: 
@.BR @postorder , 
@.BR @preorder ,
at most one of: 
@.BR @lefttoright , 
@.BR @righttoleft ,
and optionally:
@.BR @disable .
Traversals are left-to-right, postorder by default.

The user may write,
after any rule body (right-hand side of a grammar rule) 
in the Y-file, an 
@.B attribute reference 
@.BR section .  
When present, the attribute reference section follows any 
@.B Yacc 
action belonging to the rule body.  Each 
attribute reference section is 
@.BR @{ ,
followed by a possibly-empty sequence of 
@.B attribute definitions
and 
@.B traversal action 
@.BR specifiers ,
followed by 
@.BR @} .
The most common kind of attribute definition 
consists of the 
@.B definition mode anunciator @i 
followed by an 
@.BR OC-fragment .
An OC-fragment is a fragment of code conforming to 
@.BR C / C++
syntax, except that 
@.B attribute references
may appear anywhere  
@.BR C / C++
variables may appear.  An
attribute reference
takes the form

@.RS 5
@.I "@grammar_symbol.[integer.]attribute_name@"
@.RS -5

where 
@.I "attribute_name" 
appears as an identifier in the 
attribute declaration list 
of the attribute declaration for 
@.I "grammar_symbol."
If 
@.I "integer"
is
@.BR n ,
the reference is to the 
@.BR n th
occurrence of
@.I "grammar_symbol"
counting from the left of the rule 
(the leftmost occurrence being the 0th).  The 
notation above means that
@.I "integer"
and the second 
@.B .
are optional.  Note 
that whitespace is not permitted between the
@.BR @ s. 
When the
@.B @i
mode anunciator is used, the attribute definition 
must contain an attribute reference, and the one appearing leftmost 
in the definition is the one 
@.I "defined"
there:  Solving the leftmost   
@.I "depends on"
solving any to the right of it in the definition.  An 
attribute definition is terminated 
by the mode anunciator for the following 
attribute definition or traversal action specifier, or by 
@.BR @} .
A 
@.B traversal mode anunciator 
is of the form
@.I "@identifier,"
where 
@.I "identifier"
appears in a traversal declaration.  In its simplest form,
a traversal action specifier is a traversal mode anunciator
followed by an OC-fragment.  The
OC-fragment is executed when the 
@.I "identifier"
traversal reaches a node labeled by
the rule with which the 
attribute reference section appears.  A traversal action
specifier is terminated by the mode anunciator of
the following traversal action specifier or attribute definition,
or by 
@.BR @} .

The only 
@.B Ox 
construct permitted in the L-file(s) is the 
@.B attribute reference 
@.BR section ,
which differs somewhat from its analog in the Y-file.  Attribute 
reference sections in the L-file(s) appear
immediately following 
@.I "return" 
statements (in 
@.B Lex 
actions unless the 
@.B -G 
option is used (see below)).  They are OC-fragments delimited by 
@.B @{ 
and 
@.BR @} .
\ The object of the 
@.I "return" 
statement should
be a terminal grammar symbol for which 
there is an attribute declaration in the Y-file.  Traversal action
specifiers are not permitted in the L-files.

@.B Ox 
makes certain well-formedness checks of the grammar.  In particular,
it determines from context for each attribute whether the attribute
is inherited or synthesized.  Each one must be either inherited or
synthesized, but not both.  
@.B Ox 
can automatically generate attribute definitions that
function only to copy an instance belonging to one node 
to a like-named instance belonging to 
the node's parent or child.  To permit this, the 
@.B Ox 
user can place in the declarations section of 
the Y-file one of the constructs:
@.B @autoinh 
@.I "ID_list" 
or
@.B @autosyn
@.IR "ID_list" ,
where 
@.I "ID_list"
is a whitespace-separated list of attribute names.  
If 
@.I "attrbID"
is such an attribute name, 
@.B Ox 
supplies missing definitions for occurrences of 
@.I "attrbID"
corresponding to subsequent 
@.B @attributes 
declarations.  Placing 
@.B @warn 
immediately after 
@.B @autoinh 
or
@.B @autosyn
causes 
@.B Ox 
to issue a warning for every definition 
that it generates by virtue of the preceding
@.B @autoinh 
or
@.BR @autosyn .


@.SH OPTIONS
@.TP
@.B \-G 
The filename which follows is that of a 
@.I "generic"
(i.e. 
@.RB non- Lex )
L\-file.  This option is used when
the 
@.B Ox 
user prefers a scanner hand-written in  
@.B C
or 
@.BR C++ .
Except for attribute reference sections, the L\-file must conform to 
@.BR C / C++
syntax.  The 
@.I return 
reserved word is recognized in any context
other than comments and string literals.
@.TP
@.B \-I
Generate code for 
@.B C++ 
or
@.BR ANSI / ISO 
@.B C 
compilation.
@.TP
@.B \-S
Strip 
@.BR Ox \-specific 
constructs from the Y-file and L-file(s)
and place the 
pure
@.B Yacc 
and pure
@.B Lex 
results on 
@.BR oxout.* .
@.TP
@.B \-C
Print the 
@.B Ox 
copyright statement and disclaimer.
@.TP
@.B \-U
Show  
@.B Ox 
command-line usage.
@.TP
@.B \-V
Print the version number.
@.TP
@.B \-h
Produce an 
@.B Ox 
header file 
@.B oxout.h 
to be 
@.BR #include d 
in a code section (between 
@.BR %{ and 
@.BR %} ) 
in the Y-file or L-file(s).  
\ This permits one-step compilation of 
the parser and scanner(s).  When this option is not used,
@.B Ox 
places the header information in each output file
rather than in a separate header file. 
@.TP
@.B \-n
Generate an evaluator that determines an evaluation order
and checks for cycles, but does not execute 
the code that evaluates attribute instances.
@.TP
@.B \-u
Generate an evaluator that prints parse-tree
memory-usage statistics for each input.
@.TP
@.B \-aN
Set 
@.B N 
as the generated evaluator's
default structure-alignment size.  By default, the default
structure-alignment size is 4.
@.TP
@.B \-YaN
Where 
@.B N 
is an integer
and
@.B a 
is one of the alphabetic characters  
@.BR n ,
@.BR c ,
or
@.BR r ,
change the default size of 
data structure
@.B a
in the generated evaluator 
to size
@.BR N .
\ When such a data structure is exceeded, 
the generated evaluator issues an error message 
calling for use of a 
@.B \-YaN 
option. 
\ The effects of the 
@.B \-YaN 
options for the various values of 
@.B a
are as follows:  

@.RS 5
@.TP
@.B n
@.B \-YnN
causes allocation of 
@.B N 
bytes for parse-tree nodes and attribute instances. 
@.TP
@.B c 
@.B N 
is the maximum number of non-root nodes in the parse tree.
@.B \-YcN 
causes allocation of 
@.B N 
* sizeof(void *) bytes for pointers to child nodes.
@.TP
@.B r 
@.B N 
is the maximum number of  
attribute instances in the parse tree. 
@.B N 
bytes are allocated for this.
@.RE 

@.TP
@.B \-YY
Enable the generated evaluator to understand
the same  
@.B \-YaN  
options as does 
@.B Ox 
itself.  See the 
@.I "User Manual for Ox"
(mentioned below) for details.

@.SH IDENTIFICATION
Author: Kurt M. Bischoff.
@.br
Copyright (C) 1992, 1993, 1994 by Kurt M. Bischoff.
@.br

@.SH SEE ALSO
@.BR yacc (1),
@.BR lex (1),
@.BR cc (1),
@.BR CC (1)

@.LP
@.I "Ox: An Attribute\-Grammar Compiling System based on Yacc, Lex, and C: User Reference Manual"
Kurt M. Bischoff, included with the Ox distribution, 
October, 1993.

@.I "Ox: An Attribute\-Grammar Compiling System based on Yacc, Lex, and C: Tutorial Introduction"
Kurt M. Bischoff, included with the Ox distribution, 
October, 1993.

@.I "GPPL: A Small Block-Structured Imperative Programming Language Implemented Using Ox,"
Kurt M. Bischoff, Iowa State University, Department of Computer Science, 
TR92\-32, December, 1992.

\".SH NOTES
\".SH NOTES
\"stub
\".SH BUGS
\"stub
@EOF
set `sum $sumopt <oxDistG1.04/docs/ox.1`; if test $1 -ne 710
then
	echo ERROR: oxDistG1.04/docs/ox.1 checksum is $1 should be 710
fi
set `wc -lwc <oxDistG1.04/docs/ox.1`
if test $1$2$3 != 491172210226
then
	echo ERROR: wc results of oxDistG1.04/docs/ox.1 are $* should be 491 1722 10226
fi

chmod 755 oxDistG1.04/docs/ox.1

if test -f oxDistG1.04/docs/README
then
	echo Ok to overwrite existing file oxDistG1.04/docs/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/docs/README
	if test -f oxDistG1.04/docs/README
	then
		echo Error: could not remove oxDistG1.04/docs/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/docs/README
sed 's/^@//' >oxDistG1.04/docs/README <<'@EOF'
The present directory contains Ox documents in the following
files:

     oxURM.dvi   oxURM.ps   oxTutor.dvi   oxTutor.ps   ox.1

The Ox Tutorial Introduction is an informal overview of Ox.  It
emphasizes examples, and gives quick familiarity with the Ox
features that are most immediately useful.  It is 19 pages and is
stored in LaTeX device-independent format in `oxTutor.dvi', and
in Postscript format in `oxTutor.ps'.  The tutorial is the best
starting point for the new user.

The Ox User Reference Manual is stored in `oxURM.dvi' and
`oxURM.ps'.  The Manual is about 57 pages and is the primary
reference on the use of Ox.

`ox.1' is an on-line manual for Ox.  It can be placed in an
appropriate system file for viewing by `man ox' or viewed using
`nroff -man <ox.1 |more'.

The .ps files can be viewed with a PostScript previewer such as
`ghostview', or printed directly on a PostScript printer.  The
@.dvi files can be viewed with a DVI previewer such as `xdvi'.

*****************************************************************
       Ox source code and documentation are copyrighted:

       Copyright (c) 1992, 1993, 1994  Kurt M. Bischoff
                      All rights reserved.

Public distribution of Ox (for instance, placing it on an
anonymous-ftp archive or on a CD-ROM) requires permission from
the author.

THIS SOFTWARE IS PROVIDED FOR USE "AS IS" AND WITHOUT ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.
*****************************************************************
@EOF
set `sum $sumopt <oxDistG1.04/docs/README`; if test $1 -ne 16886
then
	echo ERROR: oxDistG1.04/docs/README checksum is $1 should be 16886
fi
set `wc -lwc <oxDistG1.04/docs/README`
if test $1$2$3 != 392291596
then
	echo ERROR: wc results of oxDistG1.04/docs/README are $* should be 39 229 1596
fi

chmod 755 oxDistG1.04/docs/README

chmod 755 oxDistG1.04/docs

echo mkdir - oxDistG1.04/grammars
mkdir oxDistG1.04/grammars

if test -f oxDistG1.04/grammars/README
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/README
	if test -f oxDistG1.04/grammars/README
	then
		echo Error: could not remove oxDistG1.04/grammars/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/README
cat >oxDistG1.04/grammars/README <<'@EOF'
Each subdirectory of the present directory contains an Ox grammar
for a parser for one of several popular languages.

Most of the grammars are taken from an archive site mentioned in
the comp.compilers monthly message.  They included Yacc, Lex, and
C source code and `make' files that cause preprocessing by Ox.
Each is a CFG ready for augmentation with attribute definitions.

Each parser has been compiled without warnings under HP-UX and
SunOS, but some of them are still a little rough: if you use a
fastidious compiler, you may have to change some small details of
some of the C code and some command-line options in the
Makefiles.  Note that these problems are in the code as gotten
from the archive, and do not indicate defects in Ox.  These small
problems will be cleaned up in a later distribution.

The directories are named:

                    ada  c  c++  ftn  pascal

These contain attribute-grammars-to-be for:

     * ANSI C  (by Jeff Lee)
     * C++  (by Jim Roskind)
     * ANSI Pascal  (by ?)
     * FORTRAN 77 subset  (by John Levine)
     * ANSI Ada  (by Tom Shields and others)

*****************************************************************

THIS SOFTWARE IS PROVIDED FOR USE "AS IS" AND WITHOUT ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.

*****************************************************************
@EOF
set `sum $sumopt <oxDistG1.04/grammars/README`; if test $1 -ne 29780
then
	echo ERROR: oxDistG1.04/grammars/README checksum is $1 should be 29780
fi
set `wc -lwc <oxDistG1.04/grammars/README`
if test $1$2$3 != 362141436
then
	echo ERROR: wc results of oxDistG1.04/grammars/README are $* should be 36 214 1436
fi

chmod 755 oxDistG1.04/grammars/README

if test -f oxDistG1.04/grammars/.expand
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/.expand\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/.expand
	if test -f oxDistG1.04/grammars/.expand
	then
		echo Error: could not remove oxDistG1.04/grammars/.expand, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/.expand
cat >oxDistG1.04/grammars/.expand <<'@EOF'
#
foreach i(ada c c++ ftn pascal)
  cd $i
  make
  cd ..
end

@EOF
set `sum $sumopt <oxDistG1.04/grammars/.expand`; if test $1 -ne 56555
then
	echo ERROR: oxDistG1.04/grammars/.expand checksum is $1 should be 56555
fi
set `wc -lwc <oxDistG1.04/grammars/.expand`
if test $1$2$3 != 71362
then
	echo ERROR: wc results of oxDistG1.04/grammars/.expand are $* should be 7 13 62
fi

chmod 755 oxDistG1.04/grammars/.expand

echo mkdir - oxDistG1.04/grammars/ada
mkdir oxDistG1.04/grammars/ada

echo mkdir - oxDistG1.04/grammars/ada/RCS
mkdir oxDistG1.04/grammars/ada/RCS

if test -f oxDistG1.04/grammars/ada/RCS/gram.y,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ada/RCS/gram.y,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ada/RCS/gram.y,v
	if test -f oxDistG1.04/grammars/ada/RCS/gram.y,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ada/RCS/gram.y,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ada/RCS/gram.y,v '[non-ascii]'
$unpacker <<'@eof'
begin 755 oxDistG1.04/grammars/ada/RCS/gram.y,v
M:&5A9" @(" @,2XV.PIA8V-E<W,@(" ["G-Y;6)O;',@(#L*;&]C:W,@(" @X
M8FES8VAO9F8Z,2XV.R!S=')I8W0["F-O;6UE;G0@($ @*B! .PH*"C$N-@IDX
M871E(" @(" Y,RXQ,"XS,2XQ-2XU-"XP,CL@(&%U=&AO<B!B:7-C:&]F9CL@X
M('-T871E($5X<#L*8G)A;F-H97,@.PIN97AT(" @(" Q+C4["@HQ+C4*9&%TX
M92 @(" @.3,N,3 N,38N,34N-3<N,C0[("!A=71H;W(@8FES8VAO9F8[("!SX
M=&%T92!%>' ["F)R86YC:&5S(#L*;F5X=" @(" @,2XT.PH*,2XT"F1A=&4@X
M(" @(#DS+C$P+C$V+C$U+C(W+C0T.R @875T:&]R(&)I<V-H;V9F.R @<W1AX
M=&4@17AP.PIB<F%N8VAE<R ["FYE>'0@(" @(#$N,SL*"C$N,PID871E(" @X
M(" Y,RXQ,"XP-BXR,"XS.2XU-#L@(&%U=&AO<B!B:7-C:&]F9CL@('-T871EX
M($5X<#L*8G)A;F-H97,@.PIN97AT(" @(" Q+C(["@HQ+C(*9&%T92 @(" @X
M.3,N,3 N,#8N,3DN,3<N-3<[("!A=71H;W(@8FES8VAO9F8[("!S=&%T92!%X
M>' ["F)R86YC:&5S(#L*;F5X=" @(" @,2XQ.PH*,2XQ"F1A=&4@(" @(#DSX
M+C$P+C V+C$V+C V+C,P.R @875T:&]R(&)I<V-H;V9F.R @<W1A=&4@17APX
M.PIB<F%N8VAE<R ["FYE>'0@(" @(#L*"@ID97-C"D!A<R!I="!C86UE(&9RX
M;VT@5&]M92!_?W\(""!3:&EE;&1S"D *"@HQ+C8*;&]G"D J*BH@96UP='D@X
M;&]G(&UE<W-A9V4@*BHJ"D *=&5X= I +RHM+2TM+2TM+2TM+2TM+2TM+2TMX
M+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TMX
M+2TM+2TM+2TM+2HO"B\J"0D)"0D)"0D)(" @("HO"B\J"0D)($$@3$%,4B@QX
M*2!G<F%M;6%R(&9O<B!!3E-)($%D82H)"2 @(" J+PHO*@D)"0D)"0D)"2 @X
M(" J+PHO*@D)"2!!9&%P=&5D(&9O<B!904-#("A53DE8*2!);G!U=',)"0D@X
M(" @*B\*+RH)"0D)"0D)"0D@(" @*B\*+RH@(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @("HO"B\J(" @(" @(" @(" @(" @(" @(" @(" @(" @("!(X
M97)M86X@1FES8VAE<B @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" JX
M+PHO*B @(" @(" @(" @(" @(" @(" @(" @(" @($QI='1O;B!$871A(%-YX
M<W1E;7,@(" @(" @(" @(" @(" @(" @(" @(" @(" @*B\*+RH@(" @(" @X
M(" @(" @(" @(" @(" @(#@P,# @5V]O9&QE>2!!=F4N+"!M<R T-"TS," @X
M(" @(" @(" @(" @(" @(" @(" @("HO"B\J(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @5F%N($YU>7,L($-!(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" J+PHO*B @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M*B\*+RH@(" @(" @(" @(" @(" @(" @(" @(" @(" @(" X,3@O.3 R+34QX
M,SD@(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @("HO"B\J(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @2$9I<V-H97) 0&5C;&(N87)P82 @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @*B\*+RH@(" @(" @(" @(" @(" @X
M(" @(" @("![8V5P=2QT<G=R8GTA;&ET=F%X(69I<V-H97(@(" @(" @(" @X
M(" @(" @(" @(" @("HO"B\J(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" J+PHO*B @(" @(" @(" @(" @(" @(" @(" @(" @(" @36%R8V@@,C8LX
M(#$Y.#0@(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @*B\*+RH)"0D)X
M"0D)"0D@(" @*B\*+RH@(" @(" @(" @(" @(" @(" @02!#;VYT<FEB=71IX
M;VX@=&\@=&AE(%!U8FQI8R!$;VUA:6X@(" @(" @(" @(" @(" @(" @("HOX
M"B\J(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @("!F;W(@(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" J+PHO*B @(" @(" @X
M(" @(%)E<V5A<F-H+"!$979E;&]P;65N="P@86YD(%1R86EN:6YG(%!U<G!OX
M<V5S($]N;'D@(" @(" @(" @(" @*B\*+RH@(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @("HO"B\J(" @(" @($%N>2!#;W)R96-T:6]N<R!O<B!0<F]BX
M;&5M<R!A<F4@=&\@8F4@4F5P;W)T960@=&\@=&AE($%U=&AO<B @(" @(" JX
M+PHO*B @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @*B\*+RH@(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @("HO"B5["G-T871I8PIC:&%R(')C<VEDX
M6UT@/0HB)$AE861E<CH@9W)A;2YY+'8@,2XU(#DS+S$P+S$V(#$U.C4W.C(TX
M(&)I<V-H;V9F($5X<" D(CL*)7T*+RH@)$QO9SH)9W)A;2YY+'8@) H@*B!2X
M979I<VEO;B Q+C4@(#DS+S$P+S$V(" Q-3HU-SHR-" @,34Z-3<Z,C0@(&)IX
M<V-H;V9F("A+=7)T($)I<V-H;V9F*0H@*B!N;R!C:&%N9V4*("H@"B J(%)EX
M=FES:6]N(#$N-" @.3,O,3 O,38@(#$U.C(W.C0T(" Q-3HR-SHT-" @8FESX
M8VAO9F8@*$MU<G0@0FES8VAO9F8I"B J("HJ*B!E;7!T>2!L;V<@;65S<V%GX
M92 J*BH*("H@"B J(%)E=FES:6]N(#$N,R @.3,O,3 O,#8@(#(P.C,Y.C4TX
M(" R,#HS.3HU-" @8FES8VAO9F8@*$MU<G0@0FES8VAO9F8I"B J("HJ*B!EX
M;7!T>2!L;V<@;65S<V%G92 J*BH*("H@"B J(%)E=FES:6]N(#$N,B @.3,OX
M,3 O,#8@(#$Y.C$W.C4W(" Q.3HQ-SHU-R @8FES8VAO9F8@*$MU<G0@0FESX
M8VAO9F8I"B J('=O<FMD"',*("H@"B J(%)E=FES:6]N(#$N,2 @.3,O,3 OX
M,#8@(#$V.C V.C,P(" Q-CHP-CHS," @8FES8VAO9F8@*$MU<G0@0FES8VAOX
M9F8I"B J($EN:71I86P@<F5V:7-I;VX*("H@"B J(%)E=FES:6]N(#$N-B @X
M.#DO,3 O,3(@(#$W.C(R.C X("!S:&EE;&1S"B J(&UI;F]R(&-H86YG97,@X
M=&\@9F]R;6%T=&EN9PH@*B *("H@4F5V:7-I;VX@,2XU(" X.2\Q,"\Q,2 @X
M,C$Z-3$Z,3,@('-H:65L9',*("H@;6EN;W(@8VAA;F=E('1O("=Y>65R<F]RX
M)PH@*B *("H@4F5V:7-I;VX@,2XT(" X.2\Q,"\Q,2 @,C$Z,S<Z,CD@('-HX
M:65L9',*("H@8VAA;F=E9" B97AT97)N(B!D969I;FET:6]N(&]F("=Y>71EX
M>'0G('1O(&1E<&5N9"!O;B!W:&5T:&5R('1H90H@*B @("!L97AE<B!I<R!GX
M96YE<F%T960@8GD@3$58(&]R($9,15@@+2!,15@@9&5F:6YE<R G>7ET97ATX
M)R!A<R!T>7!E"B J(" @("=C:&%R(%M=)RP@=VAI;&4@1DQ%6"!D969I;F5SX
M("=Y>71E>'0G(&%S('1Y<&4@)V-H87(@*B<L(&%N9"!T:&5S90H@*B @("!TX
M>7!E<R!A<F4@;F]T(&-O;7!A=&EB;&4@9F]R(")E>'1E<FXB(&]B:F5C=',*X
M("H@;6EN;W(@8VAA;F=E('1O("=Y>65R<F]R)PH@*B *("H@4F5V:7-I;VX@X
M,2XS(" X."\P-B\Q,2 @,3DZ,C@Z-38@('-H:65L9',*("H@<VEM<&QI9FEEX
M9"]C;&%R:69I960O<F5S=')U8W1U<F5D(&=R86UM87(@9F]R(')E861A8FELX
M:71Y(&%N9"!T;R!M86ME"B J(" @('-E;6%N=&EC(&%C=&EO;G,@96%S:65RX
M('1O(&-O;G-T<G5C= H@*B!R961U8V5D('1H92!!9&$@<W5P97)S970@9&5FX
M:6YE9"!B>2!T:&4@9W)A;6UA<B!I;B!V87)I;W5S('=A>7,Z"B J(" @("=OX
M8FIE8W1?9"<@;F\@;&]N9V5R(&=E;F5R871E<R!D969E<G)E9"!C;VYS=&%NX
M="!D96-L87)A8W1I;VYS"B J(" @("=A9V=R)R!N;R!L;VYG97(@9V5N97)AX
M=&5S(&EN9&5X(&%N9"!D:7-C<FEM:6YA;G0@8V]N<W1R86EN=',L(&%N9 H@X
M*B @(" @("!I<R!N;R!L;VYG97(@=7-E9"!T;R!G96YE<F%T92!P87)E;G1HX
M97-I>F5D(&5X<')E<W-I;VYS(&]R"B J(" @(" @('!A<F5N=&AE<VEZ960@X
M97AP<F5S<VEO;B!L:7-T<RP@97AC97!T('=H97)E('5S960@87,@86X@86=GX
M<F5G871E"B J(" @("=N86UE)R!N;R!L;VYG97(@=7-E9"!T;R!G96YE<F%TX
M92!P<F]C961U<F4@86YD(&5N=')Y(&-A;&P@<W1A=&5M96YT<PH@*B!D96QEX
M=&5D('5N=7-E9"!O<&5R871O<B!S>6YT86-T:6,@8V%T96=O<FEE<PH@*B *X
M("H@4F5V:7-I;VX@,2XR(" X."\P-B\P.2 @,C,Z-#(Z-#$@('-H:65L9',*X
M("H@<VEM<&QI9FEE9"!B:6YA<GD@;W!E<F%T;W(@<&%R="!O9B!G<F%M;6%RX
M('5S:6YG(%E!0T,@)6QE9G0L("5N;VYA<W-O8RP*("H@(" @86YD("5P<F5CX
M(&1I<V%M8FEG=6%T:6]N(&9A8VEL:71I97,@+2!A;'-O('-I;7!L:69I960@X
M<V]M92!O9B!T:&4*("H@(" @<G5L97,@9F]R(')E861A8FEL:71Y"B J(&-OX
M<G)E8W1E9"!E<G)O<B!I;B!R=6QE<R!F;W(@)W)E8U]R97!?8VPG("T@)RYAX
M;&=T7V-L+B<@8V]U;&0@9V5N97)A=&4*("H@(" @82!S97%U96YC92!E;F1IX
M;F<@:6X@)RXN<')A9RXN)RP@86YD("<N+F-M<&]N7V-L+BXG(&-O=6QD(&)EX
M(&5M<'1Y+ H@*B @("!R97-U;'1I;F<@:6X@82!R96-O<F0@<F5P<F5S96YTX
M871I;VX@8VQA=7-E(&-O;G1A:6YI;F<@;VYL>2!A"B J(" @('-E<75E;F-EX
M(&]F('!R86=M87,@:6X@<&QA8V4@;V8@=&AE('-E<75E;F-E(&]F(&-O;7!OX
M;F5N="!C;&%U<V5S+ H@*B @("!I;B!V:6]L871I;VX@;V8@3%)-(#(N."@UX
M*0H@*B!R97-T<G5C='5R960@<G5L97,@:6YV;VQV:6YG('!R86=M87,@9F]RX
M(')E861A8FEL:71Y(&%N9"!T;R!M86ME('-E;6%N=&EC"B J(" @(&%C=&EOX
M;G,@96%S:65R('1O(&1E9FEN90H@*B H3D]413H@<')A9VUA(')U;&4@8V]RX
M<F5C=&EO;B!A;F0@<F5S=')U8W1U<FEN9R!I;G1R;V1U8V5D('-H:69T+W)EX
M9'5C90H@*B @("!A;6)I9W5I=&EE<R!R97-O;'9A8FQE(&)Y(%E!0T,G<R!CX
M:&]I8V4@;V8@=&AE('-H:69T(&%C=&EO;BP@<V\@=&AE"B J(" @(&%M8FEGX
M=6ET:65S('=E<F4@;&5F="!A<RUI<RD*("H@9&5L971E9"!R=6QE<R!D969IX
M;FEN9R!R97-E<G9E9"!W;W)D<R G1$E'2513)RP@)T1%3%1!)R!A;F0@)U)!X
M3D=%)R!A<PH@*B @("!A;'1E<FYA=&EV97,@9F]R("=A='1R:6)U=&5?9&5SX
M:6=N871O<B<@+2!C;W)R97-P;VYD<R!T;R!C:&%N9V4@;6%D90H@*B @("!IX
M;B!,15@@9&5F:6YI=&EO;B!O9B!L97AE<B!T;R!R971U<FX@86QL(&%T=')IX
M8G5T92!D97-I9VYA=&]R<PH@*B @("!A<R G241%3E1)1DE%4B<@=&]K96YSX
M"B J( H@*B!2979I<VEO;B Q+C$@(#@X+S U+S Y(" Q-SHR.3HU-2 @<VAIX
M96QD<PH@*B!A9&1E9"!M:7-S:6YG("<N9FUL7W!A<G0N)R!A="!E;F0@;V8@X
M9FER<W0@86QT97)N871I=F4@<G5L92!F;W(@)W-U8G!R9U]S<&5C)PH@*B!AX
M9&1E9"!E<G)O<B!R=6QE"B J(" @(&QA=&5R7V1E8VQ?:71E;2 Z(&5R<F]RX
M("<[)PH@*B!C;&5A;F5D('5P(&=R86UM87(@<')E<V5N=&%T:6]N(&9O<FUAX
M="!S;&EG:'1L>0H@*B!A9&1E9"!20U,@2&5A9&5R(&%N9"!,;V<@:V5Y=V]RX
M9',@=&\@<V]U<F-E(&9I;&4*("H@"B J(%)E=FES:6]N(#$N," @.#<O,3(OX
M,3<@(#$X.C(R.C$Q("!J=V%B:6L*("H@;W)I9VEN86P@=F5R<VEO;B!C;W!IX
M960@9G)O;2!324U414PR, H@*@H@*B\*+RH@(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @("HO"B\J(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" JX
M+PHO*B @36]D<R!T;R!T:&4@;W)I9VEN86PZ($IE9F8@5V%B:6LL($-O;G1RX
M;VP@1&%T82!#;W)P;W)A=&EO;@D)(" @("HO"B\J("!$96-E;6)E<BP@,3DXX
M-SH@($UA:6YL>2!R969O<FUA='1E9"!T;R!M86ME('1H92!904-#(')E861AX
M8FQE(" @(" @(" @(" J+PHO*B @>R!U;6XM8W,A<VAA;6%S:"%J=V%B:6L@X
M?0D)"0D)"2 @(" J+PHO*B @1&ES8VQA:6TZ("!#1$,@:7,@;F]T(')E<W!OX
M;G-I8FQE+@D)"0D)(" @("HO"B\J(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" J+PHO*B @3F]T92!T:&%T($AE<FT@1FES8VAE<B=S(&YE=R!A9&1RX
M97-S+"!E9F9E8W1I=F4@.2\R,R\X-RP@:7,Z(" @(" @(" @(" @*B\*+RH@X
M('L@:&5R;6EX(69I<V-H97) 0')A;F0M=6YI>"Y!4E!!('T)"0D)"2 @(" JX
M+PHO*B @>R![:6AN<#0L9&5C=F%X+'1R=W)B+'-E:7-M;RQE=&,N?2%H97)MX
M:7@A9FES8VAE<B!]"0D)(" @("HO"B\J(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" J+PHO*B @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @*B\*X
M+RH@(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @("HO"B\J(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" J+PHO*B @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(&%D87!T960@9G)O;2 @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @*B\*+RH@(" @(" @(" @(" @(" @(" @(" @(" @(" @("!TX
M:&4@9W)A;6UA<B @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @("HOX
M"B\J(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(&)Y.B @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" J+PHO*@D)"0D)"0D)X
M"2 @(" J+PHO*B @(" @(" @(" @($=E<G)Y($9I<VAE<B @(" @(" @(" @X
M(" @(" @(" @(" @("!0:&EL:7!P92!#:&%R;&5S(" @(" @(" @*B\*+RH@X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @("HO"B\J(" @($-O;7!U=&5RX
M(%-C:65N8V5S($-O<G!O<F%T:6]N(" @(" F(" @(" @(" @(" @($%D82 @X
M4')O:F5C=" @(" @(" @(" J+PHO*B @(" @(" @(#0P-#4@2&%N8V]C:R!3X
M=')E970@(" @(" @(" @(" @(" @(" @("!.97<@66]R:R!5;FEV97)S:71YX
M(" @(" @*B\*+RH@(" @(" @("!386X@1&EE9V\L($-!(#DR,3(Q(" @(" @X
M(" @(" @(" @(" @(" @(#(U,2!-97)C97(@4W1R965T(" @(" @("HO"B\JX
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M("!.97<@66]R:RP@3F5W(%EO<FL@,3 P,3(@(" J+PHO*@D)"0D)"0D)"2 @X
M(" J+PHO*@D)"0D)"0D)"2 @(" J+PHO*B @("!4:&ES(&=R86UM87(@:7,@X
M;W)G86YI>F5D(&EN('1H92!S86UE(&]R9&5R(&%S('1H92!S>6YT87@@<W5MX
M;6%R>2 @(" @*B\*+RH@:6X@87!P96YD:7@@12!O9B!T:&4@04Y322!!9&$@X
M4F5F97)E;F-E($UA;G5A;"X@("!!;&P@<F5S97)V960@=V]R9',@(" @("HOX
M"B\J(&%R92!W<FET=&5N(&EN('5P<&5R(&-A<V4@;&5T=&5R<RX@(%1H92!LX
M97AI8V%L(&-A=&5G;W)I97,@(" @(" @(" @(" @(" J+PHO*B!.54U%4DE#X
M7TQ)5$5204PL(%-44DE.1U],251%4D%,+"!E=&,L(&%R92!V:65W960@87,@X
M=&5R;6EN86QS+B @5&AE(" @(" @*B\*+RH@<G5L97,@9F]R('!R86=M87,@X
M87,@<W1A=&5D(&EN(&-H87!T97(@,BP@<V5C=&EO;B X+"!H879E(&)E96X@X
M(" @(" @(" @("HO"B\J(&EN8V]R<&]R871E9"!I;B!T:&4@9W)A;6UA<BX@X
M($-O;6UE;G1S(&%R92!I;F-L=61E9"!W:&5R979E<B!W92!H860@=&\@(" JX
M+PHO*B!D979I871E(&9R;VT@=&AE('-Y;G1A>"!G:79E;B!I;B!A<'!E;F1IX
M>"!%+B @1&EF9F5R96YT('-Y;6)O;',@=7-E9 D@(" @*B\*+RH@:&5R92 HX
M=&\@8V]M<&QY('=I=&@@64%#0R!R97%U:7)E;65N=',I(&%R92!O9B!N;W1EX
M.B @(" @(" @(" @(" @(" @(" @("HO"B\J"7LL<V]M971H:6YG?0EI<R!DX
M96YO=&5D("XN+G-O;65T:&EN9RXN"0D)(" @("HO"B\J"7MS;VUE=&AI;F=]X
M"6ES(&1E;F]T960@+BYS;VUE=&AI;F<N+@D)"2 @(" J+PHO*@E;<V]M971HX
M:6YG70EI<R!D96YO=&5D("YS;VUE=&AI;F<N"0D)"2 @(" J+PHO*B!#;VYSX
M=')U8W1S(&EN=F]L=FEN9R!M971A(&)R86-K971S+"!E+F<N+" N+BY)1$5.X
M5$E&2452+BX@87)E(" @(" @(" @(" @*B\*+RH@<F5P<F5S96YT960@8GD@X
M82!N;VYT97)M:6YA;"!F;W)M960@8GD@8V]N8V%T96YA=&EN9R!T:&4@8V]NX
M<W1R=6-T(" @(" @("HO"B\J('-Y;6)O;',@*&%S("XN+DE$14Y4249)15(NX
M+B!I;B!T:&4@97AA;7!L92D@9F]R('=H:6-H('1H92!R=6QE<R!A<F4@(" @X
M(" J+PHO*B!G:79E;B!A="!T:&4@96YD+B @5VAE;B!R96%D:6YG('1H:7,@X
M9W)A;6UA<BP@:70@:7,@:6UP;W)T86YT('1O(&YO=&4@(" @*B\*+RH@=&AAX
M="!A;&P@<WEM8F]L<R!A<'!E87)I;F<@:6X@=&AE(')U;&5S(&%R92!S97!AX
M<F%T960@8GD@;VYE(&]R(&UO<F4@(" @("HO"B\J(&)L86YK<RX@($$@<W1RX
M:6YG('-U8V@@87,@)TE$14Y4249)15)?='EP95]M87)K)R!I<R!A8W1U86QLX
M>2!A('-I;F=L92 @(" J+PHO*B!N;VYT97)M:6YA;"!S>6UB;VP@9&5F:6YEX
M9"!A="!T:&4@96YD(&]F('1H92!R=6QE<RX@(%1H92 G+RHG('-Y;6)O;"!IX
M<R @*B\*+RH@=7-E9"!T;R!I;F1I8V%T92!T:&%T('1H92!R97-T(&]F('1HX
M92!L:6YE(&ES(&$@8V]M;65N="P@:G5S="!A<R!I;B @(" @("HO"B\J(%E!X
M0T,@<')O9W)A;7,N(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" J+PHO*B @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @X
M(" @(" @(" @(" @(" @*B\*+RH@(" @(%1H:7,@9W)A;6UA<B!I<R!P<F5SX
M96YT960@:&5R92!I;B!A(&9O<FT@<W5I=&%B;&4@9F]R(&EN<'5T('1O(&$@X
M(" @("HO"B\J(%E!0T,@<&%R<V5R(&=E;F5R871O<BX@($ET(&AA<R @8F5EX
M;B @<')O8V5S<V5D("!B>2!T:&4@0F5L;"!3>7-T96T@(" @(" J+PHO*B!)X
M24D@3$58+UE!0T,@8V]M8FEN871I;VXL(&%N9"!T97-T960@86=A:6YS="!OX
M=F5R(#0P,"!!0U9#('1E<W1S+B @(" @(" @*B\*+RH)"0D)"0D)"0D@(" @X
M*B\*+RH@*D%D82!I<R!A(')E9VES=&5R960@=')A9&4@;6%R:R!O9B!T:&4@X
M($1E<&%R=&UE;G0@;V8@($1E9F5N<V4@("A!9&$@(" @("HO"B\J($IO:6YTX
M(%!R;V=R86T@($]F9FEC92DN"0D)"0D)(" @("HO"B\J"0D)"0D)"0D)(" @X
M("HO"B\J+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TMX
M+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TJ+PH*)7L*"B-IX
M;F-L=61E(#QS=&1I;RYH/@HC:6YC;'5D92 \8W1Y<&4N:#X*(V1E9FEN92!LX
M97@@,0H*(VEF9&5F(&QE> IE>'1E<FX@8VAA<B!Y>71E>'1;73L*(V5N9&EFX
M(&QE> HC:69D968@9FQE> IE>'1E<FX@8VAA<B J>7ET97AT.PHC96YD:68@X
M9FQE> IE>'1E<FX@:6YT('EY;&EN96YO.PH*)7T*"@HE=6YI;VX@>PH)8VAAX
M<B J>5]S='(["@EI;G0@>5]N=6T["GT["@H*+RHE=&5R;6EN86QS("TM+2TMX
M+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TMX
M+2TM+2TM+2TM(" @("HO"@HE=&]K96X@04)/4E1?($%"4U\@04-#15!47R!!X
M0T-%4U-?($%,3%\@04Y$7R!!4E)!65\*)71O:V5N($%47R!"14=)3E\@0D]$X
M65\@0T%315\@0T].4U1!3E1?"B5T;VME;B!$14-,05)%7R!$14Q!65\@1$5,X
M5$%?($1)1TE44U\@1$]?($5,4T5?($5,4TE&7PHE=&]K96X@14Y$7R!%3E12X
M65\@15A#15!424].7R!%6$E47R!&3U)?"B5T;VME;B!&54Y#5$E/3E\@1T5.X
M15))0U\@1T]43U\@249?($E.7R!)4U\@3$E-251%1%\*)71O:V5N($Q/3U!?X
M($U/1%\@3D577R!.3U1?($Y53$Q?($]&7R!/4E\*)71O:V5N($]42$524U\@X
M3U547R!004-+04=%7R!04D%'34%?(%!2259!5$5?"B5T;VME;B!04D]#1415X
M4D5?(%)!25-%7R!204Y'15\@4D5#3U)$7R!214U?"B5T;VME;B!214Y!3453X
M7R!215154DY?(%)%5D524T5?(%-%3$5#5%\@4T5005)!5$5?"B5T;VME;B!3X
M54)465!%7R!405-+7R!415)-24Y!5$5?(%1(14Y?"B5T;VME;B!465!%7R!5X
M4T5?(%=(14Y?(%=(24Q%7R!7251(7R!83U)?"@HE=&]K96X@241%3E1)1DE%X
M4B!.54U%4DE#7TQ)5$5204P@4U1224Y'7TQ)5$5204P@0TA!4D%#5$527TQ)X
M5$5204P*)71O:V5N($%24D]77R!$0DQ$3U1?($584%\@05-324=.7R!.3U1%X
M44Q?($=415%,7R!,5$517R!,7TQ"3%\@4E],0DQ?($)/6%\*"B5L969T"0DGX
M+"<*)6QE9G0)"4%.1%\@3U)?(%A/4E\*)6YO;F%S<V]C"2<])R!.3U1%44Q?X
M("<\)R!,5$517R G/B<@1U1%44Q?($Y/5%\@24Y?"B5L969T"0DG*R<@)RTGX
M("<F)PHE;&5F= D))RHG("<O)R!-3T1?(%)%35\*)6YO;F%S<V]C"4584%\*X
M"B5S=&%R= EC;VUP:6QA=&EO;@H*+RH@5&AE(&9O;&QO=VEN9R S('-H:69TX
M+W)E9'5C92!E<G)O<G,L(')E<V]L=F5D(&)Y(%E!0T,@8GD@8VAO;W-I;F<*X
M(" @=&AE('-H:69T(&%C=&EO;BP@87)E(&5X<&5C=&5D("HO"B\J('-H:69TX
M(%!204=-05\@:6X@)RXN<')A9RXN)R!I=&5R871I;VXL(&]R"B @(')E9'5CX
M92 \96UP='D^("T^("<N86QG=%]C;"XG('1E<FUI;F%T:6YG("<N+G!R86<NX
M+B<@:71E<F%T:6]N(&%N9"!S=&%R=&EN9PH@(" G+BYC;7!O;E]C;"XN)R!IX
M=&5R871I;VX@=VET:&EN("=R96-?<F5P7V-L)R J+PHO*B!S:&EF="!04D%'X
M34%?(&EN("<N+F5N=%]D+BXG(&ET97)A=&EO;BP@;W(*(" @<F5D=6-E(#QEX
M;7!T>3X@+3X@)RXN<F5P7V-L+BXG('1E<FUI;F%T:6YG("<N+F5N=%]D+BXGX
M(&ET97)A=&EO;B!A;F0@<W1A<G1I;F<*(" @)RXN<F5P7V-L+BXG(&ET97)AX
M=&EO;B!W:71H:6X@)RYT87-K7VEN=&5R9F%C92XG("HO"B\J('-H:69T(%!2X
M04=-05\@:6X@)V-M<&]N7V1S)R!I=&5R871I;VXL(&]R"B @(')E9'5C92 GX
M8VUP;VY?9',G("T^("=C;7!O;G,G('1E<FUI;F%T:6YG("=C;7!O;E]D<R<@X
M:71E<F%T:6]N(&%N9"!S=&%R=&EN9PH@(" G8VUP;VYS)R!I=&5R871I;VX@X
M=VET:&EN("=C;7!O;G,G("HO"@HE)0DO*B!B96=I;FYI;F<@;V8@<G5L97,@X
M<V5C=&EO;B J+PH*"B\J(#(N." J+PH*<')A9PD).B!04D%'34%?($E$14Y4X
M249)15(@+G!R86=?87)G7W!A<G0N("<[)PH)"3L*"G!R86=?87)G7W!A<G0)X
M.B G*"<@87)G7V%S8W,@)RDG"@IA<F=?87-C<PDZ(&%R9U]A<V,*"0E\(&%RX
M9U]A<V-S("<L)R!A<F=?87-C"@D).PH*87)G7V%S8PD).B!E>'!R"@D)?"!)X
M1$5.5$E&2452($%24D]77R!E>'!R"@D).PH*"B\J(#,N,2 J+PH*8F%S:6-?X
M9 D).B!O8FIE8W1?9 H)"7P@;G5M8F5R7V0*"0E\('1Y7V0*"0E\('-U8G1YX
M7V0*"0E\('-U8G!R9U]D"@D)?"!P:V=?9 H)"7P@=&%S:U]D"@D)?"!G96Y?X
M9 H)"7P@97AC<'1N7V0*"0E\(&=E;E]I;G-T"@D)?"!R96YA;6EN9U]D"@D)X
M?"!D969E<E]C;VYS=%]D"@D)?"!E<G)O<B G.R<*"0D["@H*+RH@,RXR("HOX
M"@IO8FIE8W1?9 DZ(&ED96YT<R G.B<@<W5B='E?:6YD("Y!4U-)1TY?97APX
M<BX@)SLG"@D)?"!I9&5N=',@)SHG($-/3E-404Y47R!S=6)T>5]I;F0@05-3X
M24=.7R!E>'!R("<[)PH)"7P@:61E;G1S("<Z)R!C7V%R<E]D968@+D%34TE'X
M3E]E>'!R+B G.R<*"0E\(&ED96YT<R G.B<@0T].4U1!3E1?(&-?87)R7V1EX
M9B!!4U-)1TY?(&5X<'(@)SLG"@D).PH*;G5M8F5R7V0).B!I9&5N=',@)SHGX
M($-/3E-404Y47R!!4U-)1TY?(&5X<'(@)SLG"@D).PH*:61E;G1S"0DZ($E$X
M14Y4249)15(*"0E\(&ED96YT<R G+"<@241%3E1)1DE%4@H)"3L*"@HO*B SX
M+C,N,2 J+PH*='E?9 D).B!F=6QL7W1Y7V0*"0E\(&EN8V]M<&QE=&5?='E?X
M9 H)"7P@<')I=E]T>5]D"@D).PH*9G5L;%]T>5]D"3H@5%E015\@241%3E1)X
M1DE%4B N9&ES8W)?<&%R="X@25-?('1Y7V1E9B G.R<*"0D["@IT>5]D968)X
M"3H@96YU;5]T>5]D968*"0E\(&EN=&5G97)?='E?9&5F"@D)?"!R96%L7W1YX
M7V1E9@H)"7P@87)R87E?='E?9&5F"@D)?"!R96-?='E?9&5F"@D)?"!A8V-EX
M<W-?='E?9&5F"@D)?"!D97)I=F5D7W1Y7V1E9@H)"3L*"@HO*B S+C,N,B JX
M+PH*<W5B='E?9 D).B!354)465!%7R!)1$5.5$E&2452($E37R!S=6)T>5]IX
M;F0@)SLG"@D).PH*<W5B='E?:6YD"3H@='E?;6L@+F-O;G-T<G0N"@D).PH*X
M='E?;6L)"3H@97AP86YD961?;@H)"3L*"F-O;G-T<G0)"3H@<FYG7V,*"0E\X
M(&9L=&=?<&]I;G1?8PH)"7P@9FEX961?<&]I;G1?8PHO*@D)?"!I9'A?8R OX
M*B!A<R G:61X7V]R7V1I<V-R7V,G("HO"B\J"0E\(&1I<V-R7V,@+RH@87,@X
M)VED>%]O<E]D:7-C<E]C)R J+PH)"7P@:61X7V]R7V1I<V-R7V,*"0D["@H*X
M+RH@,RXT("HO"@ID97)I=F5D7W1Y7V1E9@DZ($Y%5U\@<W5B='E?:6YD"@D)X
M.PH*"B\J(#,N-2 J+PH*<FYG7V,)"3H@4D%.1T5?(')N9PH)"3L*"G)N9PD)X
M.B!N86UE("\J(&UU<W0@8F4@86X@)V%T=')I8G5T92<@*B\*"0E\('-I;5]EX
M>'!R($1"3$1/5%\@<VEM7V5X<'(*"0D["@H*+RH@,RXU+C$@*B\*"F5N=6U?X
M='E?9&5F"3H@)R@G(&5N=6U?;&ET7W-P96-S("<I)PH)"3L*"F5N=6U?;&ETX
M7W-P96-S"3H@96YU;5]L:71?<W!E8PH)"7P@96YU;5]L:71?<W!E8W,@)RPGX
M(&5N=6U?;&ET7W-P96,*"0D["@IE;G5M7VQI=%]S<&5C"3H@96YU;5]L:70*X
M"0D["@IE;G5M7VQI= DZ($E$14Y4249)15(*"0E\($-(05)!0U1%4E],251%X
M4D%,"@D).PH*"B\J(#,N-2XT("HO"@II;G1E9V5R7W1Y7V1E9@DZ(')N9U]CX
M"@D).PH*"B\J(#,N-2XV("HO"@IR96%L7W1Y7V1E9@DZ(&9L=&=?<&]I;G1?X
M8PH)"7P@9FEX961?<&]I;G1?8PH)"3L*"@HO*B S+C4N-R J+PH*9FQT9U]PX
M;VEN=%]C"3H@9FQT9U]A8V-U<F%C>5]D968@+G)N9U]C+@H)"3L*"F9L=&=?X
M86-C=7)A8WE?9&5F"3H@1$E'25137R!S:6U?97AP<@H)"3L*"@HO*B S+C4NX
M.2 J+PH*9FEX961?<&]I;G1?8PDZ(&9I>&5D7V%C8W5R86-Y7V1E9B N<FYGX
M7V,N"@D).PH*9FEX961?86-C=7)A8WE?9&5F"3H@1$5,5$%?('-I;5]E>'!RX
M"@D).PH*"B\J(#,N-B J+PH*87)R87E?='E?9&5F"3H@=6YC;G-T<FYD7V%RX
M<F%Y7V1E9@H)"7P@8U]A<G)?9&5F"@D).PH*=6YC;G-T<FYD7V%R<F%Y7V1EX
M9@DZ($%24D%97R G*"<@:61X7W-U8G1Y7V1E9G,@)RDG($]&7R!S=6)T>5]IX
M;F0*"0D["@II9'A?<W5B='E?9&5F<PDZ(&ED>%]S=6)T>5]D968*"0E\(&EDX
M>%]S=6)T>5]D969S("<L)R!I9'A?<W5B='E?9&5F"@D).PH*:61X7W-U8G1YX
M7V1E9@DZ(&YA;64@4D%.1T5?($)/6%\*"0D["@IC7V%R<E]D968).B!!4E)!X
M65\@:61X7V,@3T9?('-U8G1Y7VEN9 H)"3L*"FED>%]C"0DZ("<H)R!D<V-RX
M7W)N9W,@)RDG"@D).PH*9'-C<E]R;F=S"3H@9'-C<E]R;F<*"0E\(&1S8W)?X
M<FYG<R G+"<@9'-C<E]R;F<*"0D["@ID<V-R7W)N9PDZ(')N9PH)"7P@;F%MX
M92!R;F=?8PH)"3L*"@HO*B S+C<@*B\*"G)E8U]T>5]D968).B!214-/4D1?X
M(&-M<&]N<R!%3D1?(%)%0T]21%\*"0D["@IC;7!O;G,)"3H@+BYP<F%G+BX@X
M8VUP;VY?9',*"0E\("XN<')A9RXN("YC;7!O;E]D<RX@=F%R:6%N=%]P87)TX
M"@D)?" N+G!R86<N+B!.54Q,7R G.R<*"0E\(&-M<&]N<R!P<F%G"@D).PH*X
M8VUP;VY?9',).B!C;7!O;E]D"@D)?"!C;7!O;E]D<R!C;7!O;E]D"@D)?"!CX
M;7!O;E]D<R!P<F%G"@D).PH*8VUP;VY?9 D).B!I9&5N=',@)SHG(&-M<&]NX
M7W-U8G1Y7V1E9B N05-324=.7V5X<'(N("<[)PH)"3L*"F-M<&]N7W-U8G1YX
M7V1E9@DZ('-U8G1Y7VEN9 H)"3L*"@HO*B S+C<N,2 J+PH*9&ES8W)?<&%RX
M= DZ("<H)R!D:7-C<E]S<&5C<R G*2<*"0D["@ID:7-C<E]S<&5C<PDZ(&1IX
M<V-R7W-P96,*"0E\(&1I<V-R7W-P96-S("<[)R!D:7-C<E]S<&5C"@D).PH*X
M9&ES8W)?<W!E8PDZ(&ED96YT<R G.B<@='E?;6L@+D%34TE'3E]E>'!R+@H)X
M"3L*"@HO*B S+C<N,B J+PH*+RH*9&ES8W)?8PD).B G*"<@9&ES8W)?87-CX
M<R G*2<*"0D["@ID:7-C<E]A<V-S"3H@9&ES8W)?87-C"@D)?"!D:7-C<E]AX
M<V-S("<L)R!D:7-C<E]A<V,*"0D["@ID:7-C<E]A<V,).B!E>'!R"@D)?"!SX
M:6U?;E]C:&]I8V5S($%24D]77R!E>'!R"@D).PHJ+PHO*B!I;F-L=61E9"!UX
M;F1E<B G:61X7V]R7V1I<V-R7V,G("HO"@IS:6U?;E]C:&]I8V5S"3H@<VEMX
M7VX*"0E\('-I;5]N7V-H;VEC97,@)WPG('-I;5]N"@D).PH*"B\J(#,N-RXSX
M("HO"@IV87)I86YT7W!A<G0).B!#05-%7R!S:6U?;B!)4U\@+BYP<F%G+BX@X
M=F%R:6%N=',@14Y$7R!#05-%7R G.R<*"0D@("\J(%!R86=M87,@869T97(@X
M)W9A<FEA;G1S)R!A<F4@:6X@)V-M<&]N<R<@870@96YD(&]F(')H<R J+PH)X
M"2 @+RH@;V8@)W9A<FEA;G0G("HO"@D).PH*=F%R:6%N=',).B!V87)I86YTX
M"@D)?"!V87)I86YT<R!V87)I86YT"@D).PH*=F%R:6%N= D).B!72$5.7R!CX
M:&]I8V5S($%24D]77R!C;7!O;G,*"0D["@IC:&]I8V5S"0DZ(&-H;VEC90H)X
M"7P@8VAO:6-E<R G?"<@8VAO:6-E"@D).PH*8VAO:6-E"0DZ('-I;5]E>'!RX
M"@D)?"!N86UE(')N9U]C"@D)?"!S:6U?97AP<B!$0DQ$3U1?('-I;5]E>'!RX
M"@D)?"!/5$A%4E-?"@D).PH*"B\J(#,N." J+PH*86-C97-S7W1Y7V1E9@DZX
M($%#0T534U\@<W5B='E?:6YD"@D).PH*"B\J(#,N."XQ("HO"@II;F-O;7!LX
M971E7W1Y7V0).B!465!%7R!)1$5.5$E&2452("YD:7-C<E]P87)T+B G.R<*X
M"0D["@H*+RH@,RXY("HO"@ID96-L7W!A<G0).B N+F)A<VEC7V1E8VQ?:71EX
M;2XN"@D)?" N+F)A<VEC7V1E8VQ?:71E;2XN(&)O9'D@+BYL871E<E]D96-LX
M7VET96TN+@H)"3L*"B\J($$@)V)O9'DG(&ES('1H92!O;FQY("=L871E<E]DX
M96-L7VET96TG('1H870@:7,@;F]T(&%L<V\@80DJ+PHO*B G8F%S:6-?9&5CX
M;%]I=&5M)RX@270@:7,@=&AE<F5F;W)E('5S960@87,@=&AE(&1I=FED:6YGX
M"2HO"B\J('!O:6YT(&)E='=E96X@=&AE('1W;R!L:7-T<R!O9B!D96-L(&ETX
M96US+@D)"2HO"@IB87-I8U]D96-L7VET96T).B!B87-I8U]D"@D)?"!R97!?X
M8VP*"0E\('5S95]C; H)"3L*"FQA=&5R7V1E8VQ?:71E;0DZ(&)O9'D*"0E\X
M('-U8G!R9U]D"@D)?"!P:V=?9 H)"7P@=&%S:U]D"@D)?"!G96Y?9 H)"7P@X
M=7-E7V-L"@D)?"!G96Y?:6YS= H)"7P@97)R;W(@)SLG"@D).PH*8F]D>0D)X
M.B!P<F]P97)?8F]D>0H)"7P@8F]D>5]S='5B"@D).PH*<')O<&5R7V)O9'D)X
M.B!S=6)P<F=?8F]D>0H)"7P@<&MG7V)O9'D*"0E\('1A<VM?8F]D>0H)"3L*X
M"@HO*B T+C$@*B\*"FYA;64)"3H@<VEM7VX*"0E\($-(05)!0U1%4E],251%X
M4D%,"@D)?"!O<%]S>6UB;VP*"0E\(&ED>&5D7V-M<&]N"B\J"0E\(&9U;F-?X
M8V%L;" O*B!P87)A;65T97)L97-S+"!A<R G<VEM7VXG(&]R("=S96QE8W1EX
M9%]C;7!O;B<[("HO"B\J"0D)(" @(" @('=I=&@@<&%R86UE=&5R<RP@87,@X
M)VED>&5D7V-M<&]N)R J+PHO*@D)?"!S;&EC92 O*B!I;F-L=61E9"!U;F1EX
M<B G:61X961?8VUP;VXG("HO"@D)?"!S96QE8W1E9%]C;7!O;@H)"7P@871TX
M<FEB=71E"@D).PH*<VEM7VX)"3H@241%3E1)1DE%4@H)"3L*"G!R969I> D)X
M.B!N86UE"@D).PH*"B\J(#0N,2XQ("HO"@II9'AE9%]C;7!O;@DZ('!R969IX
M>" G*"<@97AP<G,@)RDG"@D).PH*97AP<G,)"3H@97AP<@H)"7P@<VEM7V5XX
M<'(@1$),1$]47R!S:6U?97AP<@H)"7P@241%3E1)1DE%4B!!4E)/5U\@97APX
M<@H)"2\J('-U8G!R9U]C86QL(&9O<FUA;"!P87)A;65T97(@87-S;V-I871IX
M;VX@*B\*"0E\(&YA;64@<FYG7V,*"0E\(&5X<')S("<L)R!E>'!R<PH)"3L*X
M"@HO*B T+C$N,B J+PH*+RH*<VQI8V4)"3H@<')E9FEX("<H)R!D<V-R7W)NX
M9R G*2<*"0D["BHO"B\J(&EN8VQU9&5D('5N9&5R("=I9'AE9%]C;7!O;B<@X
M*B\*"@HO*B T+C$N,R J+PH*<V5L96-T961?8VUP;VX).B!P<F5F:7@@)RXGX
M('-E;&5C=&]R"@D).PH*<V5L96-T;W().B!S:6U?;@H)"7P@0TA!4D%#5$52X
M7TQ)5$5204P*"0E\(&]P7W-Y;6)O; H)"7P@04Q,7PH)"3L*"@HO*B T+C$NX
M-" J+PH*871T<FEB=71E"3H@<')E9FEX("=<)R<@871T<FEB=71E7V1E<VEGX
M;F%T;W(*"0D["B\J(%1H:7,@8V%N(&)E(&%N("=A='1R:6)U=&4G+" G:61XX
M961?8VUP;VXG+" G<VQI8V4G+"!O<B G<W5B<')G7V-A;&PG("HO"@IA='1RX
M:6)U=&5?9&5S:6=N871O<@DZ('-I;5]N"B\J"0E\('-I;5]N("<H)R!E>'!RX
M("<I)R O*B!R961U8V5D(&%S("=I9'AE9%]C;7!O;B<@*B\*"0D["@H*+RH@X
M-"XS("HO"@IA9V=R"0DZ("<H)R!C:&]I8V5S($%24D]77R!E>'!R("<I)PH)X
M"2 @+RH@82!S:6YG;&4@8V]M<&]N96YT(&%G9W)E9V%T92!M=7-T('5S92!NX
M86UE9"!N;W1A=&EO;B J+PH)"7P@)R@G(&-M<&]N7V%S8W,@)RDG"@D).PH*X
M8VUP;VY?87-C<PDZ(&-M<&]N7V%S8R G+"<@8VUP;VY?87-C"@D)?"!C;7!OX
M;E]A<V-S("<L)R!C;7!O;E]A<V,*"0D["@IC;7!O;E]A<V,).B!E>'!R"@D)X
M?"!C:&]I8V5S($%24D]77R!E>'!R"@D).PH*"B\J(#0N-" J+PH*97AP<@D)X
M.B!E>'!R($%.1%\@97AP<@H)"7P@97AP<B!!3D1?(%1(14Y?(&5X<'())7!RX
M96,@04Y$7PH)"7P@97AP<B!/4E\@97AP<@H)"7P@97AP<B!/4E\@14Q315\@X
M97AP<@DE<')E8R!/4E\*"0E\(&5X<'(@6$]27R!E>'!R"@D)?"!E>'!R("<]X
M)R!E>'!R"@D)?"!E>'!R($Y/5$513%\@97AP<@H)"7P@97AP<B G/"<@97APX
M<@H)"7P@97AP<B!,5$517R!E>'!R"@D)?"!E>'!R("<^)R!E>'!R"@D)?"!EX
M>'!R($=415%,7R!E>'!R"@D)?"!E>'!R($E.7R!R;F<*"0E\(&5X<'(@3D]4X
M7R!)3E\@<FYG"25P<F5C($E.7PHO*@D)?"!E>'!R($E.7R!T>5]M:R O*B!IX
M;F-L=61E9"!U;F1E<B G97AP<B!)3E\@<FYG)R J+PHO*@D)?"!E>'!R($Y/X
M5%\@24Y?('1Y7VUK"25P<F5C($E.7R O*B!I;F-L=61E9"!U;F1E<@HG97APX
M<B!.3U1?($E.7R!R;F<G("HO"@D)?"!S:6U?97AP<@H)"3L*"G-I;5]E>'!RX
M"3H@<VEM7V5X<'(@)RLG('1E<FT*"0E\('-I;5]E>'!R("<M)R!T97)M"@D)X
M?"!S:6U?97AP<B G)B<@=&5R;0H)"7P@)RLG('1E<FT*"0E\("<M)R!T97)MX
M"@D)?"!T97)M"@D).PH*=&5R;0D).B!T97)M("<J)R!T97)M"@D)?"!T97)MX
M("<O)R!T97)M"@D)?"!T97)M($U/1%\@=&5R;0H)"7P@=&5R;2!214U?('1EX
M<FT*"0E\('1E<FT@15A07R!T97)M"@D)?"!!0E-?('!R:0H)"7P@3D]47R!PX
M<FD*"0E\('!R:0H)"3L*"G!R:0D).B!.54U%4DE#7TQ)5$5204P*"0E\($Y5X
M3$Q?"@D)?"!A9V=R"@D)?"!N86UE"@D)(" O*B!I;F-L=61E<R!#2$%204-4X
M15)?3$E415)!3"!A;F0@4U1224Y'7TQ)5$5204P@*B\*"0D@("\J(%-44DE.X
M1U],251%4D%,(&ES(&EN8VQU9&5D(&%S("=O<%]S>6UB;VPG("HO"@D)?"!AX
M;&QO8V%T;W(*+RH)"7P@9G5N8U]C86QL("\J(&EN8VQU9&5D('5N9&5R("=NX
M86UE)R J+PHO*@D)?"!T>5]C;G9R("\J(&EN8VQU9&5D('5N9&5R("=N86UEX
M)R J+PH)"7P@<75A;&EF:65D7V5X<'(*"0E\("<H)R!E>'!R("<I)PH)"3L*X
M"@HO*B T+C8@*B\*"B\J"G1Y7V-N=G()"3H@='E?;6L@)R@G(&5X<'(@)RDGX
M"@D).PHJ+PHO*B!I;F-L=61E9"!U;F1E<B G;F%M92<@*B\*"@HO*B T+C<@X
M*B\*"G%U86QI9FEE9%]E>'!R"3H@<')E9FEX("\J(&UU<W0@8F4@82 G='E?X
M;6LG("HO("=<)R<@)R@G(&5X<'(@)RDG"@D)?"!P<F5F:7@@+RH@;75S="!BX
M92!A("=T>5]M:R<@*B\@)UPG)R!A9V=R"@D).PH*"B\J(#0N." J+PH*86QLX
M;V-A=&]R"3H@3D577R!T>5]M:PHO*@D)?"!.15=?('1Y7VUK(&ED>%]C("HOX
M"B\J"0E\($Y%5U\@='E?;6L@9&ES8W)?8R J+PH)"7P@3D577R!T>5]M:R!IX
M9'A?;W)?9&ES8W)?8PHO*@D)?"!.15=?('%U86QI9FEE9%]E>'!R("HO"@D)X
M?"!.15=?('1Y7VUK("=<)R<@)R@G(&5X<'(@)RDG"@D)?"!.15=?('1Y7VUKX
M("=<)R<@86=G<@H)"3L*"@HO*B U+C$@*B\*"G-E<5]O9E]S=&UT<PDZ("XNX
M<')A9RXN('-T;70*"0E\('-E<5]O9E]S=&UT<R!S=&UT"@D)?"!S97%?;V9?X
M<W1M=',@<')A9PH)"3L*"G-T;70)"3H@+BYL86)E;"XN('-I;5]S=&UT"@D)X
M?" N+FQA8F5L+BX@8V]M<&]U;F1?<W1M= H)"7P@97)R;W(@)SLG"@D).PH*X
M<VEM7W-T;70).B!N=6QL7W-T;70*"0E\(&%S<VEG;FUE;G1?<W1M= H)"7P@X
M97AI=%]S=&UT"@D)?"!R971U<FY?<W1M= H)"7P@9V]T;U]S=&UT"@D)?"!DX
M96QA>5]S=&UT"@D)?"!A8F]R=%]S=&UT"@D)?"!R86ES95]S=&UT"@D)?"!CX
M;V1E7W-T;70*"0E\('-I;5]N("<[)PH)"7P@<V5L96-T961?8VUP;VX@)SLGX
M"@D)?"!I9'AE9%]C;7!O;B G.R<*+RH)"7P@96YT7V-A;&Q?<W1M=" O*B!PX
M87)A;65T97)L97-S+"!A<R G<VEM7VXG(&]R("HO"B\J"0D)"2 G<V5L96-TX
M961?8VUP;VXG.R!W:71H('!A<F%M971E<G,L(&%S("HO"B\J"0D)"2 G:61XX
M961?8VUP;VXG("HO"B\J"0E\('!R;V-E9'5R95]C86QL7W-T;70@+RH@<&%RX
M86UE=&5R;&5S<RP@87,@)W-I;5]N)R!O<B J+PHO*@D)"0D@)W-E;&5C=&5DX
M7V-M<&]N)SL@=VET:"!P87)A;65T97)S+"!A<R J+PHO*@D)"0D@)VED>&5DX
M7V-M<&]N)R J+PH)"3L*"F-O;7!O=6YD7W-T;70).B!I9E]S=&UT"@D)?"!CX
M87-E7W-T;70*"0E\(&QO;W!?<W1M= H)"7P@8FQO8VM?<W1M= H)"7P@86-CX
M97!T7W-T;70*"0E\('-E;&5C=%]S=&UT"@D).PH*;&%B96P)"3H@3%],0DQ?X
M('-I;5]N(%)?3$),7PH)"3L*"FYU;&Q?<W1M= DZ($Y53$Q?("<[)PH)"3L*X
M"@HO*B U+C(@*B\*"F%S<VEG;FUE;G1?<W1M= DZ(&YA;64@05-324=.7R!EX
M>'!R("<[)PH)"3L*"@HO*B U+C,@*B\*"FEF7W-T;70)"3H@249?(&-O;F0@X
M5$A%3E\@<V5Q7V]F7W-T;71S"@D)(" N+D5,4TE&7U]C;VYD7U]42$5.7U]SX
M97%?;V9?<W1M=',N+@H)"2 @+D5,4T5?7W-E<5]O9E]S=&UT<RX*"0D@($5.X
M1%\@249?("<[)PH)"3L*"F-O;F0)"3H@97AP<@H)"3L*"@HO*B U+C0@*B\*X
M"F-A<V5?<W1M= DZ($-!4T5?(&5X<'(@25-?("XN<')A9RXN(&-A<V5?<W1MX
M=%]A;'1S($5.1%\@0T%315\@)SLG"@D)(" O*B!0<F%G;6%S(&%F=&5R("=CX
M87-E7W-T;71?86QT<R<@87)E(&EN("=S97%?;V9?<W1M=',G(&%T("HO"@D)X
M(" O*B!E;F0@;V8@<FAS(&]F("=C87-E7W-T;71?86QT)R J+PH)"3L*"F-AX
M<V5?<W1M=%]A;'1S"3H@8V%S95]S=&UT7V%L= H)"7P@8V%S95]S=&UT7V%LX
M=',@8V%S95]S=&UT7V%L= H)"3L*"F-A<V5?<W1M=%]A;'0).B!72$5.7R!CX
M:&]I8V5S($%24D]77R!S97%?;V9?<W1M=',*"0D["@H*+RH@-2XU("HO"@ILX
M;V]P7W-T;70).B N<VEM7VY#+B O*B!S:6U?;B G.B<@*B\*"0D@("YI=&5RX
M871I;VY?<V-H96UE+B!,3T]07PH)"2 @<V5Q7V]F7W-T;71S"@D)("!%3D1?X
M($Q/3U!?("YS:6U?;BX@)SLG"@D).PH*:71E<F%T:6]N7W-C:&5M93H@5TA)X
M3$5?(&-O;F0*"0E\($9/4E\@;&]O<%]P<FU?<W!E8PH)"3L*"FQO;W!?<')MX
M7W-P96,).B!)1$5.5$E&2452($E.7R N4D5615)312X@9'-C<E]R;F<*"0D[X
M"@H*+RH@-2XV("HO"@IB;&]C:U]S=&UT"3H@+G-I;5]N0RX@+RH@<VEM7VX@X
M)SHG("HO"@D)(" N1$5#3$%215]?9&5C;%]P87)T+@H)"2 @0D5'24Y?"@D)X
M("!S97%?;V9?<W1M=',*"0D@("YF<F%M95]E>&-P=&Y?:&%N9&QE<G,N"@D)X
M("!%3D1?("YS:6U?;BX@)SLG"@D).PH*"B\J(#4N-R J+PH*97AI=%]S=&UTX
M"3H@15A)5%\@+F5X<&%N9&5D7VXN("Y72$5.7U]C;VYD+B G.R<*"0D["@H*X
M+RH@-2XX("HO"@IR971U<FY?<W1M= DZ(%)%5%523E\@+F5X<'(N("<[)PH)X
M"3L*"@HO*B U+CD@*B\*"F=O=&]?<W1M= DZ($=/5$]?(&5X<&%N9&5D7VX@X
M)SLG"@D).PH*"B\J(#8N,2 J+PH*<W5B<')G7V0).B!S=6)P<F=?<W!E8R GX
M.R<*"0D["@IS=6)P<F=?<W!E8PDZ(%!23T-%1%5215\@241%3E1)1DE%4B NX
M9FUL7W!A<G0N"@D)?"!&54Y#5$E/3E\@(&1E<VEG;F%T;W(@+F9M;%]P87)TX
M+B!215154DY?('1Y7VUK"@D).PH*9&5S:6=N871O<@DZ($E$14Y4249)15(*X
M"0E\(&]P7W-Y;6)O; H)"3L*"F]P7W-Y;6)O; DZ(%-44DE.1U],251%4D%,X
M"@D).PH*9FUL7W!A<G0).B G*"<@<')M7W-P96-S("<I)PH)"3L*"G!R;5]SX
M<&5C<PDZ('!R;5]S<&5C"@D)?"!P<FU?<W!E8W,@)SLG('!R;5]S<&5C"@D)X
M.PH*<')M7W-P96,).B!I9&5N=',@)SHG(&UO9&4@='E?;6L@+D%34TE'3E]EX
M>'!R+@H)"3L*"FUO9&4)"3H@+DE.+@H)"7P@24Y?($]55%\*"0E\($]55%\*X
M"0D["@H*+RH@-BXS("HO"@IS=6)P<F=?8F]D>0DZ('-U8G!R9U]S<&5C($E3X
M7R N9&5C;%]P87)T+@H)"2 @0D5'24Y?"@D)("!S97%?;V9?<W1M=',*"0D@X
M("YF<F%M95]E>&-P=&Y?:&%N9&QE<G,N"@D)("!%3D1?("YD97-I9VYA=&]RX
M+B G.R<*"0D["@H*+RH@-BXT("HO"@HO*@IP<F]C961U<F5?8V%L;%]S=&UTX
M"3H@<')O8V5D=7)E7VX@+F%C=%]P<FU?<&%R="X@)SLG"@D).PHJ+PHO*B!IX
M;F-L=61E9"!U;F1E<B G;F%M92<@*B\*"B\J"F9U;F-?8V%L; DZ(&9U;F-?X
M;B N86-T7W!R;5]P87)T+@H)"3L**B\*+RH@:6YC;'5D960@=6YD97(@)VYAX
M;64G("HO"@HO*@IA8W1?<')M7W!A<G0).B G*"<@<')M7V%S8R N+BYP<FU?X
M87-C+BX@)RDG"@D).PH*<')M7V%S8PD).B!F;6Q?<')M($%24D]77R!A8W1?X
M<')M"@D)?"!A8W1?<')M"@D).PH*9FUL7W!R;0D).B!S:6U?;@H)"3L*"F%CX
M=%]P<FT)"3H@97AP<@H)"7P@;F%M90H)"7P@='E?;6L@)R@G(&YA;64@)RDGX
M"@D).PHJ+PH*"B\J(#<N,2 J+PH*<&MG7V0)"3H@<&MG7W-P96,@)SLG"@D)X
M.PH*<&MG7W-P96,).B!004-+04=%7R!)1$5.5$E&2452($E37PH)"2 @+BYBX
M87-I8U]D96-L7VET96TN+@H)"2 @+G!R:79A=&5?<&%R="X@14Y$7R N<VEMX
M7VXN"@D).PH*<&MG7V)O9'D).B!004-+04=%7R!"3T197R!S:6U?;B!)4U\*X
M"0D@("YD96-L7W!A<G0N"@D)(" N<&MG7V)O9'E?:6YI="X*"0D@($5.1%\@X
M+G-I;5]N+B G.R<*"0D["@H*+RH@-RXT("HO"@IP<FEV7W1Y7V0).B!465!%X
M7R!)1$5.5$E&2452("YD:7-C<E]P87)T+B!)4U\@+DQ)34E4140N(%!2259!X
M5$5?("<[)PH)"3L*"F1E9F5R7V-O;G-T7V0).B!I9&5N=',@)SHG($-/3E-4X
M04Y47R!T>5]M:R G.R<*"0D["@H*+RH@."XT("HO"@IU<V5?8VP)"3H@55-%X
M7R!E>'!A;F1E9%]N<R G.R<*"0D["@IE>'!A;F1E9%]N<PDZ(&5X<&%N9&5DX
M7VX*"0E\(&5X<&%N9&5D7VYS("<L)R!E>'!A;F1E9%]N"@D).PH*"B\J(#@NX
M-2 J+PH*<F5N86UI;F=?9 DZ(&ED96YT<R G.B<@='E?;6L@(" @("!214Y!X
M34537R!N86UE("<[)PH)"7P@:61E;G1S("<Z)R!%6$-%4%1)3TY?(%)%3D%-X
M15-?(&5X<&%N9&5D7VX@)SLG"B\J("=I9&5N=',G(&EN('1H92!T=V\@86)OX
M=F4@<G5L97,@;75S="!C;VYT86EN(&]N;'D@;VYE("=)1$5.5$E&2452)R JX
M+PH)"7P@4$%#2T%'15\@241%3E1)1DE%4B @(%)%3D%-15-?(&5X<&%N9&5DX
M7VX@)SLG"@D)?"!S=6)P<F=?<W!E8R @(" @(" @(" @4D5.04U%4U\@;F%MX
M92 G.R<*"0D["@H*+RH@.2XQ("HO"@IT87-K7V0)"3H@=&%S:U]S<&5C("<[X
M)PH)"3L*"G1A<VM?<W!E8PDZ(%1!4TM?("Y465!%+B!)1$5.5$E&2452("YTX
M87-K7VEN=&5R9F%C92X*"0D["@IT87-K7V)O9'D).B!405-+7R!"3T197R!SX
M:6U?;B!)4U\@+F1E8VQ?<&%R="X*"0D@($)%1TE.7PH)"2 @<V5Q7V]F7W-TX
M;71S"@D)(" N9G)A;65?97AC<'1N7VAA;F1L97)S+@H)"2 @14Y$7R N<VEMX
M7VXN("<[)PH)"3L*"@HO*B Y+C4@*B\*"F5N=%]D"0DZ($5.5%)97R!)1$5.X
M5$E&2452(" @(" @(" @(" @(" @(" @+F9M;%]P87)T+B G.R<*"0E\($5.X
M5%)97R!)1$5.5$E&2452("<H)R!D<V-R7W)N9R G*2<@+F9M;%]P87)T+B GX
M.R<*"0D["@IE;G1?8V%L;%]S=&UT"3H@+BYP<F%G+BX@<VEM7VX@)SLG("\JX
M('!A<F%M971E<FQE<W,@*B\*"0E\("XN<')A9RXN('-E;&5C=&5D7V-M<&]NX
M("<[)R O*B!P87)A;65T97)L97-S("HO"@D)?" N+G!R86<N+B!I9'AE9%]CX
M;7!O;B G.R<@+RH@=VET:"!P87)A;65T97)S("HO"@D).PH*86-C97!T7W-TX
M;70).B!!0T-%4%1?('-I;5]N("Y096YT7VED>%]0+BYF;6Q?<&%R="X*"0D@X
M("Y$3U]?<V5Q7V]F7W-T;71S7U]%3D0N<VEM7VXN+B G.R<*"0D["@IE;G1?X
M:61X"0DZ(&5X<'(*"0D["@H*+RH@.2XV("HO"@ID96QA>5]S=&UT"3H@1$5,X
M05E?('-I;5]E>'!R("<[)PH)"3L*"@HO*B Y+C<@*B\*"G-E;&5C=%]S=&UTX
M"3H@<V5L96-?=V%I= H)"7P@8V]N9&%L7V5N=%]C86QL"@D)?"!T:6UE9%]EX
M;G1?8V%L; H)"3L*"@HO*B Y+C<N,2 J+PH*<V5L96-?=V%I= DZ(%-%3$5#X
M5%\@<V5L96-T7V%L=',@+D5,4T5?7W-E<5]O9E]S=&UT<RX@14Y$7R!314Q%X
M0U1?("<[)PH)"3L*"G-E;&5C=%]A;'1S"3H@<V5L96-T7V%L= H)"7P@<V5LX
M96-T7V%L=',@3U)?('-E;&5C=%]A;'1S"@D).PH*<V5L96-T7V%L= DZ('-EX
M;&5C7W=A:71?86QT"@D)?"!72$5.7R!C;VYD($%24D]77R!S96QE8U]W86ETX
M7V%L= H)"3L*"G-E;&5C7W=A:71?86QT"3H@86-C97!T7V%L= H)"7P@9&5LX
M87E?86QT"@D)?"!T97)M:6YA=&5?86QT"@D).PH*86-C97!T7V%L= DZ("XNX
M<')A9RXN(&%C8V5P=%]S=&UT("YS97%?;V9?<W1M=',N"@D).PH*9&5L87E?X
M86QT"3H@+BYP<F%G+BX@9&5L87E?<W1M=" N<V5Q7V]F7W-T;71S+@H)"3L*X
M"G1E<FUI;F%T95]A;'0).B N+G!R86<N+B!415)-24Y!5$5?("<[)R N+G!RX
M86<N+@H)"3L*"@HO*B Y+C<N,B J+PH*8V]N9&%L7V5N=%]C86QL"3H@4T5,X
M14-47R!E;G1?8V%L;%]S=&UT("YS97%?;V9?<W1M=',N"@D)("!%3%-%7R!SX
M97%?;V9?<W1M=',@14Y$7R!314Q%0U1?("<[)PH)"3L*"@HO*B Y+C<N,R JX
M+PH*=&EM961?96YT7V-A;&P).B!314Q%0U1?(&5N=%]C86QL7W-T;70@+G-EX
M<5]O9E]S=&UT<RX*"0D@($]27R!D96QA>5]A;'0@14Y$7R!314Q%0U1?("<[X
M)PH)"3L*"@HO*B Y+C$P("HO"@IA8F]R=%]S=&UT"3H@04)/4E1?(&YA;65SX
M("<[)PH)"3L*"FYA;65S"0DZ(&YA;64*"0E\(&YA;65S("<L)R!N86UE"@D)X
M.PH*"B\J(#$P+C$@*B\*"F-O;7!I;&%T:6]N"3H@8V]M<&EL871I;VY?=6YIX
M=',*"0D["@IC;VUP:6QA=&EO;E]U;FET<PDZ("XN<')A9RXN"@D)?"!C;VUPX
M:6QA=&EO;E]U;FET<R!C;VUP:6QA=&EO;E]U;FET"@D).PH*8V]M<&EL871IX
M;VY?=6YI=#H@+BYC;VYT97AT7V-L+BX@;&EB<F%R>5]U;FET("XN<')A9RXNX
M"@D)?" N+F-O;G1E>'1?8VPN+B!S96-O;F1A<GE?=6YI=" N+G!R86<N+@H)X
M"3L*"FQI8G)A<GE?=6YI= DZ('-U8G!R9U]D"@D)?"!P:V=?9 H)"7P@9V5NX
M7V0*"0E\(&=E;E]I;G-T"@D)?"!S=6)P<F=?8F]D>0H)"3L*"G-E8V]N9&%RX
M>5]U;FET"3H@;&EB<F%R>5]U;FET7V)O9'D*"0E\('-U8G5N:70*"0D["@ILX
M:6)R87)Y7W5N:71?8F]D>0DZ('!K9U]B;V1Y"B\J"0E\('-U8G!R9U]B;V1YX
M("\J(&%L<F5A9'D@8V]N=&%I;F5D(&EN("=L:6)R87)Y7W5N:70G("HO"@D)X
M.PH*"B\J(#$P+C$N,2 J+PH*8V]N=&5X=%]C; DZ('=I=&A?8VP*"0E\(&-OX
M;G1E>'1?8VP@=7-E7V-L"@D)?"!C;VYT97AT7V-L('!R86<*"0D["@IW:71HX
M7V-L"0DZ(%=)5$A?('-I;5]N<R G.R<*"0D["@IS:6U?;G,)"3H@<VEM7VX*X
M"0E\('-I;5]N<R G+"<@<VEM7VX*"0D["@H*+RH@,3 N,B J+PH*8F]D>5]SX
M='5B"3H@<W5B<')G7W-P96,@(" @(" @(" @25-?(%-%4$%2051%7R G.R<*X
M"0E\(%!!0TM!1T5?($)/1%E?('-I;5]N($E37R!315!!4D%415\@)SLG"@D)X
M?"!405-+7R @("!"3T197R!S:6U?;B!)4U\@4T5005)!5$5?("<[)PH)"3L*X
M"G-U8G5N:70)"3H@4T5005)!5$5?("<H)R!E>'!A;F1E9%]N("<I)R!P<F]PX
M97)?8F]D>0H)"3L*"@HO*B Q,2XQ("HO"@IE>&-P=&Y?9 DZ(&ED96YT<R GX
M.B<@15A#15!424].7R G.R<*"0D["@H*+RH@,3$N,B J+PH*97AC<'1N7VAAX
M;F1L97().B!72$5.7R!E>&-P=&Y?8VAO:6-E<R!!4E)/5U\@<V5Q7V]F7W-TX
M;71S"@D)(" O*B!0<F%G;6%S(&%F=&5R("=E>&-P=&Y?:&%N9&QE<B<@87)EX
M(&EN("=S97%?;V9?<W1M=',G(&%T("HO"@D)(" O*B!E;F0@;V8@<FAS("HOX
M"@D).PH*97AC<'1N7V-H;VEC97,).B!E>&-P=&Y?8VAO:6-E"@D)?"!E>&-PX
M=&Y?8VAO:6-E<R G?"<@97AC<'1N7V-H;VEC90H)"3L*"F5X8W!T;E]C:&]IX
M8V4).B!E>'!A;F1E9%]N"@D)?"!/5$A%4E-?"@D).PH*"B\J(#$Q+C,@*B\*X
M"G)A:7-E7W-T;70).B!204E315\@+F5X<&%N9&5D7VXN("<[)PH)"3L*"@HOX
M*B Q,BXQ("HO"@IG96Y?9 D).B!G96Y?<W!E8R G.R<*"0D["@IG96Y?<W!EX
M8PDZ(&=E;E]F;6Q?<&%R="!S=6)P<F=?<W!E8PH)"7P@9V5N7V9M;%]P87)TX
M('!K9U]S<&5C"@D).PH*9V5N7V9M;%]P87)T"3H@1T5.15))0U\@+BYG96Y?X
M<')M7V0N+@H)"3L*"F=E;E]P<FU?9 DZ(&ED96YT<R G.B<@+DE.+D]55"XNX
M('1Y7VUK("Y!4U-)1TY?97AP<BX@)SLG"@D)?"!465!%7R!)1$5.5$E&2452X
M"@D)(" N9&ES8W)?<&%R="X@+RH@+F1I<V-R7W!A<G0N(&UU<W0@8F4@96UPX
M='D[(&%D9&5D(&]N;'D*"0D)"2 @=&\@<F5S;VQV92!A('-H:69T+W)E9'5CX
M92!A;6)I9W5I='D@*B\*"0D@($E37R!G96Y?='E?9&5F("<[)PH)"7P@<')IX
M=E]T>5]D"@D)?"!7251(7R!S=6)P<F=?<W!E8R G.R<*"0E\(%=)5$A?('-UX
M8G!R9U]S<&5C($E37R!"3UA?("<[)PH)"7P@5TE42%\@<W5B<')G7W-P96,@X
M25-?(&YA;64@)SLG"@D).PH*9V5N7W1Y7V1E9@DZ("<H)R!"3UA?("<I)PH)X
M"7P@4D%.1T5?($)/6%\*"0E\($1)1TE44U\@0D]87PH)"7P@1$5,5$%?($)/X
M6%\*"0E\(&%R<F%Y7W1Y7V1E9@H)"7P@86-C97-S7W1Y7V1E9@H)"3L*"@HOX
M*B Q,BXS("HO"@IG96Y?:6YS= DZ(%!!0TM!1T5?($E$14Y4249)15(@($E3X
M7R!.15=?(&5X<&%N9&5D7VX@+F=E;E]A8W1?<&%R="X@)SLG"@D)?"!S=6)PX
M<F=?<W!E8R @(" @(" @("!)4U\@3D577R!E>'!A;F1E9%]N("YG96Y?86-TX
M7W!A<G0N("<[)PH)"2\J('1H92!M;W)E(&=E;F5R86P@)W-U8G!R9U]S<&5CX
M)R!I<R!U<V5D('1O(&%V;VED(&-O;F9L:6-T<R J+PH)"7P@1E5.0U1)3TY?X
M(&1E<VEG;F%T;W(@25-?($Y%5U\@97AP86YD961?;B N9V5N7V%C=%]P87)TX
M+B G.R<*"0D["@IG96Y?86-T7W!A<G0).B G*"<@9V5N7V%S8W,@)RDG"@D)X
M.PH*9V5N7V%S8W,).B!G96Y?87-C"@D)?"!G96Y?87-C<R G+"<@9V5N7V%SX
M8PH)"3L*"F=E;E]A<V,)"3H@9V5N7V%C=%]P<FT*"0E\(&=E;E]F;6Q?<')MX
M($%24D]77R!G96Y?86-T7W!R;0H)"3L*"F=E;E]F;6Q?<')M"3H@<VEM7VX*X
M"0E\(&]P7W-Y;6)O; H)"3L*"F=E;E]A8W1?<')M"3H@97AP<@HO*@D)?"!NX
M86UE("\J(&EN8VQU9&5D('5N9&5R("=E>'!R)R J+PHO*@D)?"!S=6)P<F=?X
M;B O*B!I;F-L=61E9"!U;F1E<B G97AP<B<@*B\*+RH)"7P@96YT7VX@+RH@X
M:6YC;'5D960@=6YD97(@)V5X<'(G("HO"B\J"0E\('1Y7VUK("\J(&EN8VQUX
M9&5D('5N9&5R("=E>'!R)R J+PH)"3L*"@HO*B Q,RXQ("HO"@IR97!?8VP)X
M"3H@='E?<F5P7V-L"@D)?"!A9&1R97-S7V-L"@D).PH*='E?<F5P7V-L"3H@X
M;&5N9W1H7V-L"@D)?"!E;G5M7W)E<%]C; H)"7P@<F5C7W)E<%]C; H)"3L*X
M"@HO*B Q,RXR("HO"@IL96YG=&A?8VP).B!&3U)?(&%T=')I8G5T92!54T5?X
M('-I;5]E>'!R("<[)PH)"3L*"@HO*B Q,RXS("HO"@IE;G5M7W)E<%]C; DZX
M($9/4E\@<VEM7VX@55-%7R!A9V=R("<[)PH)"3L*"@HO*B Q,RXT("HO"@IRX
M96-?<F5P7V-L"3H@1D]27R!S:6U?;B O*B G<VEM7VXG(&UU<W0@8F4@82 GX
M='E?<VEM7VXG("HO(%5315\*"0D@(%)%0T]21%\@+BYP<F%G+BX@+F%L9W1?X
M8VPN"@D)(" N+F-M<&]N7V-L+BX*"0D@($5.1%\@4D5#3U)$7R G.R<*"0D[X
M"@IA;&=T7V-L"0DZ($%47R!-3T1?('-I;5]E>'!R("<[)PH)"3L*"F-M<&]NX
M7V-L<PDZ(&-M<&]N7V-L"@D)?"!C;7!O;E]C;',@8VUP;VY?8VP*"0E\(&-MX
M<&]N7V-L<R!P<F%G"@D).PH*8VUP;VY?8VP).B!N86UE($%47R!S:6U?97APX
M<B!204Y'15\@<FYG("<[)PH)"3L*"@HO*B Q,RXU("HO"@IA9&1R97-S7V-LX
M"3H@1D]27R!S:6U?;B!54T5?($%47R!S:6U?97AP<B G.R<*"0D["@H*+RH@X
M,3,N." J+PH*8V]D95]S=&UT"3H@<')E9FEX("\J(&UU<W0@8F4@82 G='E?X
M;6LG("HO("=<)R<@86=G<B G.R<*"0D["@H*+RHM+2TM+2TM+2TM+2TM+2TMX
M+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TMX
M+2TM+2TM+2TM*B\*"B\J(%1H92!F;VQL;W=I;F<@<G5L97,@9&5F:6YE('-EX
M;6%N=&EC86QL>2!Q=6%L:69I960@<WEM8F]L<R!U;F1E<B!M;W)E"B\J(&=EX
M;F5R86P@8V%T96=O<FEE<RX*"B\J(" @(" N+BX@=&AE<V4@:&%V92!B965NX
M(')E<&QA8V5D(&QO9VEC86QL>2!T;R!R961U8V4@=&AE(&YU;6)E<B @(" JX
M+PHO*B @(" @(" @(&]F(%E!0T-?(&YO;G1E<FUI;F%L(")R=6QE<R(@(" @X
M(" @(" @(" @(" @(" @(" @(" @(" @(" @("HO"@HO*B!4:&4@9F]L;&]WX
M:6YG(')U;&5S(&5X<&%N9"!T:&4@8V]N8V%T96YA=&5D(&-O;G-T<G5C=',@X
M86YD(&1E9FEN92!T:&4@*B\*+RH@<W!E8VEA;&QY(&%D9&5D('-Y;G1A8W1IX
M8V%L(&-L87-S97,N"0D)"0D@*B\*"@HO*B R+C@@*B\*"BYP<F%G7V%R9U]PX
M87)T+@DZ("\J(&5M<'1Y("HO"@D)?"!P<F%G7V%R9U]P87)T"@D).PH*+BYPX
M<F%G+BX).B O*B!E;7!T>2 J+PH)"7P@+BYP<F%G+BX@<')A9PH)"3L*"@HOX
M*B S+C$@*B\*"BY!4U-)1TY?97AP<BX).B O*B!E;7!T>2 J+PH)"7P@05-3X
M24=.7R!E>'!R"@D).PH*+F-O;G-T<G0N"3H@+RH@96UP='D@*B\*"0E\(&-OX
M;G-T<G0*"0D["@IE>'!A;F1E9%]N"3H@241%3E1)1DE%4@H)"7P@97AP86YDX
M961?;B G+B<@241%3E1)1DE%4@H)"3L*+RH@)V5X<&%N9&5D7VXG(&ES('5SX
M960@9F]R(&YA;65S('1H870@8V%N(&)E('=R:71T96X@=7-I;F<@;VYL>2!SX
M96QE8W1O<G,@*B\*"BYR;F=?8RX)"3H@+RH@96UP='D@*B\*"0E\(')N9U]CX
M"@D).PH*"B\J(#,N,RXQ("HO"@HN9&ES8W)?<&%R="X).B O*B!E;7!T>2 JX
M+PH)"7P@9&ES8W)?<&%R= H)"3L*"@HO*B S+C,N,B J+PH*:61X7V]R7V1IX
M<V-R7V,).B G*"<@9'-C<E]R;F=S7V]R7V1I<V-R7V%S8W,@)RDG"@D).PH*X
M9'-C<E]R;F=S7V]R7V1I<V-R7V%S8W,).B!D<V-R7W)N9U]O<E]D:7-C<E]AX
M<V,*"0E\(&1S8W)?<FYG<U]O<E]D:7-C<E]A<V-S("<L)R!D<V-R7W)N9U]OX
M<E]D:7-C<E]A<V,*"0D["@ID<V-R7W)N9U]O<E]D:7-C<E]A<V,).B!S:6U?X
M97AP<B!$0DQ$3U1?('-I;5]E>'!R"B\J"0E\(&YA;64@+RH@;75S="!B92!AX
M;B G871T<FEB=71E)R J+PH)"7P@;F%M92!R;F=?8PH)"7P@97AP<B O*B!IX
M;F-L=61E<R G;F%M92<@*B\*"0E\('-I;5]N7V-H;VEC97,@05)23U=?(&5XX
M<'(*"0D["@H*+RH@,RXW("HO"@HN8VUP;VY?9',N"3H@+RH@96UP='D@*B\*X
M"0E\(&-M<&]N7V1S"@D).PH*"B\J(#,N.2 J+PH*+BYB87-I8U]D96-L7VETX
M96TN+@DZ("\J(&5M<'1Y("HO"@D)?" N+F)A<VEC7V1E8VQ?:71E;2XN('!RX
M86<*"0E\("XN8F%S:6-?9&5C;%]I=&5M+BX@8F%S:6-?9&5C;%]I=&5M"@D)X
M.PH*+BYL871E<E]D96-L7VET96TN+@DZ("\J(&5M<'1Y("HO"@D)?" N+FQAX
M=&5R7V1E8VQ?:71E;2XN('!R86<*"0E\("XN;&%T97)?9&5C;%]I=&5M+BX@X
M;&%T97)?9&5C;%]I=&5M"@D).PH*"B\J(#4N,2 J+PH*+BYL86)E;"XN"3H@X
M+RH@96UP='D@*B\*"0E\("XN;&%B96PN+B!L86)E; H)"3L*"BXN14Q3249?X
M7V-O;F1?7U1(14Y?7W-E<5]O9E]S=&UT<RXN"3H@+RH@96UP='D@*B\*"0E\X
M("XN14Q3249?7V-O;F1?7U1(14Y?7W-E<5]O9E]S=&UT<RXN"@D)("!%3%-)X
M1E\@8V]N9"!42$5.7R!S97%?;V9?<W1M=',*"0D["@HN14Q315]?<V5Q7V]FX
M7W-T;71S+@DZ("\J(&5M<'1Y("HO"@D)?"!%3%-%7R!S97%?;V9?<W1M=',*X
M"0D["@HN<VEM7VY#+@DZ("\J(&5M<'1Y("HO"@D)?"!S:6U?;B G.B<*"0D[X
M"@HN<VEM7VXN"0DZ("\J(&5M<'1Y("HO"@D)?"!S:6U?;@H)"3L*"BYI=&5RX
M871I;VY?<V-H96UE+@DZ("\J(&5M<'1Y("HO"@D)?"!I=&5R871I;VY?<V-HX
M96UE"@D).PH*+E)%5D524T4N"3H@+RH@96UP='D@*B\*"0E\(%)%5D524T5?X
M"@D).PH*+D1%0TQ!4D5?7V1E8VQ?<&%R="X).B O*B!E;7!T>2 J+PH)"7P@X
M1$5#3$%215\@9&5C;%]P87)T"@D).PH*+F9R86UE7V5X8W!T;E]H86YD;&5RX
M<RX).B O*B!E;7!T>2 J+PH)"7P@15A#15!424].7R N+G!R86<N+B!E>&-PX
M=&Y?:&%N9&QE<G,*"0DO*B!0<F%G;6%S(&%F=&5R("=E>&-P=&Y?:&%N9&QEX
M<B<@87)E(&EN("=S97%?;V9?<W1M=',G("HO"@D).PH*97AC<'1N7VAA;F1LX
M97)S"3H@97AC<'1N7VAA;F1L97(*"0E\(&5X8W!T;E]H86YD;&5R<R!E>&-PX
M=&Y?:&%N9&QE<@H)"3L*"BYE>'!A;F1E9%]N+@DZ("\J(&5M<'1Y("HO"@D)X
M?"!E>'!A;F1E9%]N"@D).PH*+E=(14Y?7V-O;F0N"3H@+RH@96UP='D@*B\*X
M"0E\(%=(14Y?(&-O;F0*"0D["@HN97AP<BX)"3H@+RH@96UP='D@*B\*"0E\X
M(&5X<'(*"0D["@H*+RH@-BXQ("HO"@HN9FUL7W!A<G0N"3H@+RH@96UP='D@X
M*B\*"0E\(&9M;%]P87)T"@D).PH*+DE.+@D).B O*B!E;7!T>2 J+PH)"7P@X
M24Y?"@D).PH*+F1E8VQ?<&%R="X).B!D96-L7W!A<G0*"0DO*B G9&5C;%]PX
M87)T)R!C86X@86QR96%D>2!B92!E;7!T>2 J+PH)"3L*"BYD97-I9VYA=&]RX
M+@DZ("\J(&5M<'1Y("HO"@D)?"!D97-I9VYA=&]R"@D).PH*"B\J(#<N,2 JX
M+PH*+DQ)34E4140N"3H@+RH@96UP='D@*B\*"0E\($Q)34E4141?"@D).PH*X
M+G!R:79A=&5?<&%R="X).B O*B!E;7!T>2 J+PH)"7P@4%))5D%415\@+BYBX
M87-I8U]D96-L7VET96TN+@H)"3L*"BYP:V=?8F]D>5]I;FET+@DZ("\J(&5MX
M<'1Y("HO"@D)?"!"14=)3E\*"0D@('-E<5]O9E]S=&UT<PH)"2 @+F9R86UEX
M7V5X8W!T;E]H86YD;&5R<RX*"0D["@H*+RH@.2XQ("HO"@HN5%E012X)"3H@X
M+RH@96UP='D@*B\*"0E\(%194$5?"@D).PH*+G1A<VM?:6YT97)F86-E+@DZX
M("\J(&5M<'1Y("HO"@D)?"!)4U\@+BYE;G1?9"XN("XN<F5P7V-L+BX@14Y$X
M7R N<VEM7VXN"@D).PH*+BYE;G1?9"XN"3H@+RH@96UP='D@*B\*"0E\("XNX
M96YT7V0N+B!P<F%G"@D)?" N+F5N=%]D+BX@96YT7V0*"0D["@HN+G)E<%]CX
M;"XN"3H@+RH@96UP='D@*B\*"0E\("XN<F5P7V-L+BX@<')A9PH)"7P@+BYRX
M97!?8VPN+B!R97!?8VP*"0D["@H*+RH@.2XU("HO"@HN4&5N=%]I9'A?4"XNX
M9FUL7W!A<G0N"3H@+F9M;%]P87)T+@H)"7P@)R@G(&5N=%]I9'@@)RDG("YFX
M;6Q?<&%R="X*"0D["@HN1$]?7W-E<5]O9E]S=&UT<U]?14Y$+G-I;5]N+BX)X
M.B O*B!E;7!T>2 J+PH)"7P@1$]?('-E<5]O9E]S=&UT<R!%3D1?("YS:6U?X
M;BX*"0D["@HN<V5Q7V]F7W-T;71S+@DZ("XN<')A9RXN"@D)?"!S97%?;V9?X
M<W1M=',*"0D["@H*+RH@,3 N,2XQ("HO"@HN+F-O;G1E>'1?8VPN+@DZ("\JX
M(&5M<'1Y("HO"@D)?" N+F-O;G1E>'1?8VPN+B!C;VYT97AT7V-L"@D).PH*X
M"B\J(#$R+C$@*B\*"BXN9V5N7W!R;5]D+BX).B O*B!E;7!T>2 J+PH)"7P@X
M+BYG96Y?<')M7V0N+B!G96Y?<')M7V0*"0D["@HN24XN3U54+BX).B N24XNX
M"@D)?"!)3E\@3U547PH)"3L*"BYG96Y?86-T7W!A<G0N"3H@+RH@96UP='D@X
M*B\*"0E\(&=E;E]A8W1?<&%R= H)"3L*"@HO*B Q,RXT("HO"@HN86QG=%]CX
M;"X).B O*B!E;7!T>2 J+PH)"7P@86QG=%]C; H)"3L*"BXN8VUP;VY?8VPNX
M+@DZ("\J(&5M<'1Y("HO"@D)?" N+G!R86<N+B!C;7!O;E]C;',*"0D["@HEX
M)0DO*B!S=&%R="!O9B!P<F]G<F%M<R J+PH*;6%I;B@I('L*(" @>7EP87)SX
M92 H*3L*?0H*>7EE<G)O<BAS=')I;F<I"F-H87(@*G-T<FEN9SL*>PH@("!FX
M<')I;G1F("AS=&1E<G(L(")<;CX^/EQN/CX^("5S(&%T(&QI;F4@)60@;F5AX
M<B E<RY<;CX^/EQN(BP*"0D@(" @<W1R:6YG+"!Y>6QI;F5N;RP@>7ET97ATX
M*3L*?0H*0 H*"C$N-0IL;V<*0&YO(&-H86YG90I "G1E>'0*0&0R.2 Q"F$RX
M.2 Q"B(D2&5A9&5R.B!G<F%M+GDL=B Q+C0@.3,O,3 O,38@,34Z,C<Z-#0@X
M8FES8VAO9F8@17AP("0B.PID,S(@,PI "@H*,2XT"FQO9PI *BHJ(&5M<'1YX
M(&QO9R!M97-S86=E("HJ*@I "G1E>'0*0&0R.2 Q"F$R.2 Q"B(D2&5A9&5RX
M.B!G<F%M+GDL=B Q+C,@.3,O,3 O,#8@,C Z,SDZ-30@8FES8VAO9F8@17APX
M("0B.PID,S(@,PI "@H*,2XS"FQO9PI *BHJ(&5M<'1Y(&QO9R!M97-S86=EX
M("HJ*@I "G1E>'0*0&0R.2 Q"F$R.2 Q"B(D2&5A9&5R.B!G<F%M+GDL=B QX
M+C(@.3,O,3 O,#8@,3DZ,3<Z-3<@8FES8VAO9F8@17AP("0B.PID,S(@,PI X
M"@H*,2XR"FQO9PI =V]R:V0(<PI "G1E>'0*0&0R.2 Q"F$R.2 Q"B(D2&5AX
M9&5R.B!G<F%M+GDL=B Q+C$@.3,O,3 O,#8@,38Z,#8Z,S @8FES8VAO9F8@X
M17AP("0B.PID,S(@,PI "@H*,2XQ"FQO9PI 26YI=&EA;"!R979I<VEO;@I X
M"G1E>'0*0&0R.2 Q"F$R.2 Q"B(D2&5A9&5R.B N+U)#4R]A9&$N>2QV(#$NX
M-B X.2\Q,"\Q,B Q-SHR,CHP."!S:&EE;&1S($5X<" D(CL*9#,Q(#0*83,TX
?(#$*+RH@)$QO9SH)861A+GDL=B D"F0Q-#D@,0I "B D                X
                                                             X
end
@eof
set `sum $sumopt <oxDistG1.04/grammars/ada/RCS/gram.y,v`; if test $1 -ne 24182
then
	echo ERROR: oxDistG1.04/grammars/ada/RCS/gram.y,v checksum is $1 should be 24182
fi
set `wc -lwc <oxDistG1.04/grammars/ada/RCS/gram.y,v`
if test $1$2$3 != 1618433130541
then
	echo ERROR: wc results of oxDistG1.04/grammars/ada/RCS/gram.y,v are $* should be 1618 4331 30541
fi

chmod 755 oxDistG1.04/grammars/ada/RCS/gram.y,v

if test -f oxDistG1.04/grammars/ada/RCS/scan.l,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ada/RCS/scan.l,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ada/RCS/scan.l,v
	if test -f oxDistG1.04/grammars/ada/RCS/scan.l,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ada/RCS/scan.l,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ada/RCS/scan.l,v
sed 's/^@//' >oxDistG1.04/grammars/ada/RCS/scan.l,v <<'@EOF'
head     1.6;
access   ;
symbols  ;
locks    bischoff:1.6; strict;
comment  @ * @;


1.6
date     93.10.31.15.54.05;  author bischoff;  state Exp;
branches ;
next     1.5;

1.5
date     93.10.16.15.57.44;  author bischoff;  state Exp;
branches ;
next     1.4;

1.4
date     93.10.16.15.27.47;  author bischoff;  state Exp;
branches ;
next     1.3;

1.3
date     93.10.06.20.39.59;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.06.19.18.05;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.06.16.07.15;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@as it came from Tom Shields
@@


1.6
log
@@*** empty log message ***
@@
text
@@%{
/*
@From shields@@Stars.Reston.Paramax.COM Wed Oct  6 12:43 CDT 1993
Received: from stars.reston.paramax.com by flash.cs.iastate.edu with SMTP
	(1.37.109.6/16.2) id AA07474; Wed, 6 Oct 93 12:43:29 -0500
Received: from repos (repos.stars.reston.paramax.com) by aviary.Stars.Reston.Paramax.COM (4.1/mls/3.2) 
	id AA04910; Wed, 6 Oct 93 13:42:38 EDT
Received: by repos (4.1/mls/3.5) 
	id AA00578; Wed, 6 Oct 93 13:40:08 EDT
To: robles@@dit.upm.es (Tomas Robles Valladares), Al Lau <allau@@sequent.com>,
        dickey@@software.org (Thomas Dickey),
        honig@@dutiws.twi.tudelft.nl (J.Honig.TI-tel-4570),
        karl@@grebyn.com (Karl A. Nyberg), harold@@issi.com,
        Kurt Bischoff <bischoff>, Margie Price <mprice@@rbse.mountain.net>
Subject: Re: Need a yaccable/lexable Ada grammar
In-Reply-To: Your message of Thu, 30 Sep 93 11:48:49 BST.
             <199309301048.AA24877@@yeti.dit.upm.es> 
Return-Receipt-To: shields@@Stars.Reston.Paramax.COM
Date: Wed, 06 Oct 93 13:40:07 -0400
Message-Id: <577.749929207@@repos>
@From: "Thomas E. Shields" <shields@@Stars.Reston.Paramax.COM>
Status: R

Kurt Bischoff said: "I wonder if the files you describe are descendent
from the ones mentioned in the comp.compilers monthly FAQ."

My answer: "I don't know - I got the original source from SIMTEL20 back
in December 1987.  I've passed these sources out several times over the
years, so the files mentioned in comp.compilers might or might not even
be these files."

Margie Price said: "I'm from the AdaNET repository, and I'll be glad to
include those in the repository.  Do you have some documentations?  I think
what I'll do is, to include your version and still keep the SIMTEL20
version.  Or, are they very similar, and you just made it work correctly?"

My answer: "All I have to offer is the lex and yacc specifications, which
are directly derived from the corresponding files I downloaded from
SIMTEL20 in December 1987.  I don't know if the SIMTEL20 files were ever
updated."

Lex specification file at the end of this message, yacc specification
follows in the next message.  Note that some of the flex-related hackery
was necessary for the version of flex available at the time, but may
no longer be necessary, as flex has matured significantly since then.
I haven't had the time or interest to update any of this, so what you
are getting is the state as of the last RCS log entries in the two files.

Tom
   --------------------------------------------------------------------------
   Thomas E. Shields, PhD, CCP        Software Engineering - 7720
   Software Technologist              Unisys Government Systems Group
   (703) 620-7028                     Systems Development/Information Systems
   (703) 620-7913 FAX                 12010 Sunrise Valley Drive
   shields@@stars.reston.paramax.com   Reston, VA 22091
   --------------------------------------------------------------------------

file: ada.l
====snip====snip====snip====snip====snip====snip====snip====snip====
*/
%}
%{
/*------------------------------------------------------------------------*/
/* Lexical input for LEX for LALR(1) Grammar for ANSI Ada                 */
/*                                                                        */
/*              Herman Fischer                                            */
/*            Litton Data Systems                                         */
/*              March 26, 1984                                            */
/*                                                                        */
/*                                                                        */
static
char rcsid[] =
"$Header: scan.l,v 1.5 93/10/16 15:57:44 bischoff Exp $";
/*                                                                        */
/* $Log:	scan.l,v $
 * Revision 1.5  93/10/16  15:57:44  15:57:44  bischoff (Kurt Bischoff)
 * no change
 * 
 * Revision 1.4  93/10/16  15:27:47  15:27:47  bischoff (Kurt Bischoff)
 * *** empty log message ***
 * 
 * Revision 1.3  93/10/06  20:39:59  20:39:59  bischoff (Kurt Bischoff)
 * *** empty log message ***
 * 
 * Revision 1.2  93/10/06  19:18:05  19:18:05  bischoff (Kurt Bischoff)
 * works
 * 
 * Revision 1.1  93/10/06  16:07:15  16:07:15  bischoff (Kurt Bischoff)
 * Initial revision
 * 
 * Revision 1.7  89/10/11  21:15:42  shields
 * formatting changes
 * modifications to enable use with either LEX or FLEX (FLEX generates a
 *    faster lexer than does LEX):
 *    added global declaration of 'yylineno'
 *    moved recognition of '\n' character from ignored white space set to
 *       a separate rule with an action to increment 'yylineno'
 *    (note: these changes are "#ifdef flex", since they are not compatible
 *     with LEX - FLEX doesn't do builtin 'yylineno' management, LEX does)
 * "#ifdef lex" around definition of 'yywrap()' function, which is done
 *    with a "#define" by FLEX
 * 
 * Revision 1.6  89/10/10  19:35:53  shields
 * removed "extern" definition for 'yylval', since latest version of BISON
 *    now generates it in the 'y.tab.h' file
 * 
 * Revision 1.5  88/06/11  20:20:53  shields
 * added reserved work lookup variation using perfect hash algorithm
 *    (faster than binary search variation)
 * modified existing binary search variation slightly
 * 
 * Revision 1.4  88/06/09  19:44:42  shields
 * added <ATTR> start state to distinguish those predefined attribute
 *    designators that are identical to reserved words from their use as
 *    reserved words - allows simplification of associated LALR(1) grammar
 * corrected conditions for entering <IDENT> start state - the apostrophe
 *    delimiter must be preceded by one of the token classes IDENTIFIER,
 *    CHARACTER, STRING, or ')', or the reserved work 'ALL', none of which
 *    can precede a character literal
 * 
 * Revision 1.3  87/12/29  09:24:02  shields
 * added 'extern' definition for 'yylval' - BISON doesn't put one in the
 *    'y.tab.h' file like YACC does
 * changed error message for invalid characters to come out on 'stderr'
 *    rather than 'stdout'
 * 
 * Revision 1.2  87/12/19  19:10:11  shields
 * added a LEX hack - use undocumented predefined <INITIAL> start state in
 *    place of user-defined <Z> start state to reduce size of generated tables
 * 
 * Revision 1.1  87/12/19  17:47:38  shields
 * added rules defining character substitutions as defined in LRM 2.10 -
 *    '!' for '|'; ':' for '#' in based numeric literals; '%' for '"' in
 *    string literals not containing '"'
 * added '\f' to set of ignored white space characters
 * corrected rule for ''' character literal and treatment of '_' character
 *    in identifiers and numeric literals
 * cleaned up grammar presentation format slightly - replaced complicated
 *    regular expression patterns in rules with named regular expressions
 * added RCS Header and Log keywords to source file
 * 
 * Revision 1.0  87/12/17  18:22:11  jwabik
 * original version copied from SIMTEL20
 *
 */
/*                                                                        */
/* Rewrite:  To a version that a non-supercomputer can handle (8^) by:	  */
/*           Jeff Wabik, Control Data Corporation, December 1987	  */ 
/*	     { umn-cs!shamash!jwabik }				 	  */
/*                                                                        */
/*------------------------------------------------------------------------*/
#include "y.tab.h"
#include <stdio.h>
#include <ctype.h>

#define Token(a)	(int)a

#define lex 1
#ifdef lex
#define bump_lineno /* LEX-generated lexers do this automatically */
#endif lex
#ifdef flex
int yylineno=1;
#define bump_lineno yylineno++
#endif flex

/* #define NOHASH /* to get binary search variation */
#define HASH /* to get perfect hash variation */
%}

	/* regular expression definitions */

Letter            [a-zA-Z]
Digit             [0-9]
ExtendedDigit     ({Digit})|[a-fA-F]

LetterDigit       ({Letter})|({Digit})

Identifier        ({Letter})(_?({LetterDigit}))*

Integer           ({Digit})(_?({Digit}))*
Based_Integer     ({ExtendedDigit})(_?({ExtendedDigit}))*

Integer_Fraction  [.]({Integer})
Based_Fraction    [.]({Based_Integer})

Exponent          [Ee][-+]?({Integer})

Decimal_Literal   ({Integer})({Integer_Fraction})?({Exponent})?

Based_Literal1    ({Integer})#({Based_Integer})({Based_Fraction})?#({Exponent})?
                  /* LRM 2.10(3) defines the following alternative */
Based_Literal2    ({Integer}):({Based_Integer})({Based_Fraction})?:({Exponent})?
Based_Literal     ({Based_Literal1})|({Based_Literal2})

String_Literal1   \"([^"]|(\"\"))*\"
                  /* LRM 2.10(4) defines the following alternative */
String_Literal2   %([^%"]|(%%))*%
String_Literal    ({String_Literal1})|({String_Literal2})

Character_Literal \'([^']|(\'))\'

%START IDENT ATTR

%%
"--".*			{ECHO; /* ignore comments to end-of-line */}
[\ \t\f]		{ECHO; /* ignore space, tab, and formfeed */}
[\n]			{ECHO; /* ignore newline */
			 bump_lineno; /* but count it */
			}
"=>"    		{ECHO; BEGIN INITIAL; return (ARROW_);}
".."    		{ECHO; BEGIN INITIAL; return (DBLDOT_);}
"**"    		{ECHO; BEGIN INITIAL; return (EXP_);}
":="    		{ECHO; BEGIN INITIAL; return (ASSIGN_);}
"/="    		{ECHO; BEGIN INITIAL; return (NOTEQL_);}
">="    		{ECHO; BEGIN INITIAL; return (GTEQL_);}
"<="    		{ECHO; BEGIN INITIAL; return (LTEQ_);}
"<<"    		{ECHO; BEGIN INITIAL; return (L_LBL_);}
">>"    		{ECHO; BEGIN INITIAL; return (R_LBL_);}
"<>"    		{ECHO; BEGIN INITIAL; return (BOX_);}
"&"     		{ECHO; BEGIN INITIAL; return ('&'); }
"("     		{ECHO; BEGIN INITIAL; return ('('); }
")"     		{ECHO; BEGIN IDENT;   return (')'); }
"*"     		{ECHO; BEGIN INITIAL; return ('*'); }
"+"     		{ECHO; BEGIN INITIAL; return ('+'); }
","     		{ECHO; BEGIN INITIAL; return (','); }
"-"     		{ECHO; BEGIN INITIAL; return ('-'); }
"."     		{ECHO; BEGIN INITIAL; return ('.'); }
"/"     		{ECHO; BEGIN INITIAL; return ('/'); }
":"     		{ECHO; BEGIN INITIAL; return (':'); }
";"     		{ECHO; BEGIN INITIAL; return (';'); }
"<"     		{ECHO; BEGIN INITIAL; return ('<'); }
"="     		{ECHO; BEGIN INITIAL; return ('='); }
">"     		{ECHO; BEGIN INITIAL; return ('>'); }
"|"|"!"     		{ECHO; BEGIN INITIAL; return ('|'); /* LRM 2.10(2) */}
<IDENT>'  		{ECHO; BEGIN ATTR;    return ('\'');}

<ATTR>{Identifier}	{ECHO; BEGIN IDENT;   return (IDENTIFIER);}

<INITIAL,IDENT>{Identifier} {int token = LookUp (yytext); ECHO;
			if ((token == IDENTIFIER) || (token == ALL_))
			     BEGIN IDENT;
			else BEGIN INITIAL;
			return (token);}

{Decimal_Literal}	{ECHO; BEGIN INITIAL; return (NUMERIC_LITERAL);}

{Based_Literal}		{ECHO; BEGIN INITIAL; return (NUMERIC_LITERAL);}

{String_Literal}	{ECHO; BEGIN IDENT;   return (STRING_LITERAL);}

<INITIAL>{Character_Literal} {ECHO; BEGIN IDENT; return (CHARACTER_LITERAL);}

@.       		{ECHO; fprintf (stderr,
					"Syntax error \"%s\" at line %d.\n\t",
					yytext,yylineno); }
%%

#ifdef lex
yywrap() {
	return (1);
}
#endif lex

static int new_IDENTIFIER(name)
char *name;
{
   yylval.y_str = (char *) calloc (strlen (name)+1, sizeof (char));
   strcpy (yylval.y_str, name);
   return (IDENTIFIER);
}

#ifdef lex
#define MAX_TOKEN_LENGTH (YYLMAX-1)
#endif lex
#ifdef flex
#define MAX_TOKEN_LENGTH YY_BUF_MAX
#endif flex

#ifdef NOHASH
typedef struct token_struct {
   char *token;
   int tokval;
} TOKEN;

static int LookUp(name) 
char *name; 
/* Compare what was just read in to the literal form of a reserved word.
   If there is a match, return the TOKEN of the reserved word, otherwise
   return the IDENTIFIER token. */
{
   TOKEN *tokpnt;
   extern TOKEN tokens[];
   extern unsigned num_tokens;
   int TokenCmp();
   char *MakeLower();

   if ((tokpnt = (TOKEN *) bsearch (MakeLower (name), tokens, num_tokens,
	sizeof (TOKEN), TokenCmp)) != NULL)
      return (tokpnt->tokval);
   else
      return (new_IDENTIFIER (name));
}

static int TokenCmp(str,tab_ele)
char str[];
TOKEN *tab_ele;
{
   return (strcmp (str,tab_ele->token));
}

static char *MakeLower(str)
char str[];
{
   register int i;
   static char up_str[MAX_TOKEN_LENGTH+1];

   for (i=0; str[i] != '\0'; i++)
      if (isupper(str[i]))
	 up_str[i] = tolower(str[i]);
      else
	 up_str[i] = str[i];
   up_str[i] = '\0';
   return up_str;
}

static TOKEN tokens[] = {
   "abort",	Token(ABORT_),
   "abs",	Token(ABS_),
   "accept",	Token(ACCEPT_),
   "access",	Token(ACCESS_),
   "all",	Token(ALL_),
   "and",	Token(AND_),
   "array",	Token(ARRAY_),
   "at",	Token(AT_),
   "begin",	Token(BEGIN_),
   "body",	Token(BODY_),
   "case",	Token(CASE_),
   "constant",	Token(CONSTANT_),
   "declare",	Token(DECLARE_),
   "delay",	Token(DELAY_),
   "delta",	Token(DELTA_),
   "digits",	Token(DIGITS_),
   "do",	Token(DO_),
   "else",	Token(ELSE_),
   "elsif",	Token(ELSIF_),
   "end",	Token(END_),
   "entry",	Token(ENTRY_),
   "exception",	Token(EXCEPTION_),
   "exit",	Token(EXIT_),
   "for",	Token(FOR_),
   "function",	Token(FUNCTION_),
   "generic",	Token(GENERIC_),
   "goto",	Token(GOTO_),
   "if",	Token(IF_),
   "in",	Token(IN_),
   "is",	Token(IS_),
   "limited",	Token(LIMITED_),
   "loop",	Token(LOOP_),
   "mod",	Token(MOD_),
   "new",	Token(NEW_),
   "not",	Token(NOT_),
   "null",	Token(NULL_),
   "of",	Token(OF_),
   "or",	Token(OR_),
   "others",	Token(OTHERS_),
   "out",	Token(OUT_),
   "package",	Token(PACKAGE_),
   "pragma",	Token(PRAGMA_),
   "private",	Token(PRIVATE_),
   "procedure",	Token(PROCEDURE_),
   "raise",	Token(RAISE_),
   "range",	Token(RANGE_),
   "record",	Token(RECORD_),
   "rem",	Token(REM_),
   "renames",	Token(RENAMES_),
   "return",	Token(RETURN_),
   "reverse",	Token(REVERSE_),
   "select",	Token(SELECT_),
   "separate",	Token(SEPARATE_),
   "subtype",	Token(SUBTYPE_),
   "task",	Token(TASK_),
   "terminate",	Token(TERMINATE_),
   "then",	Token(THEN_),
   "type",	Token(TYPE_),
   "use",	Token(USE_),
   "when",	Token(WHEN_),
   "while",	Token(WHILE_),
   "with",	Token(WITH_),
   "xor",	Token(XOR_),
};

static unsigned num_tokens = sizeof (tokens) / sizeof (TOKEN);
#endif NOHASH

#ifdef HASH
static int LookUp(name)
char *name;
/* Compare what was just read in to the literal form of a reserved word.
   If there is a match, return the TOKEN of the reserved word, otherwise
   return the IDENTIFIER token. */
{
   void calc_hash_vector();

   int j, id_length = strlen (name);
   static char reserved_word[MAX_TOKEN_LENGTH+1];

   int xlate_first, xlate_last, second_to_last; /* range -38 .. +56 */
   int hash_value; /* range -76 .. +171 */

   /* Ada reserved words are 2..9 characters in length. */
   /* All other tokens are not Ada reserved words.	*/

   if ((id_length > 9) || (id_length < 2)) return (new_IDENTIFIER (name));

   /* See if input characters legal and, if so, convert to lowercase */
   for (j=0; j < id_length; j++) {
      /* Reserved words have alphabetic characters only */
      if (!isalpha(name[j])) return (new_IDENTIFIER (name));
      reserved_word[j] = isupper(name[j]) ?
			  tolower(name[j])
			: name[j];
   }
   reserved_word[id_length] = '\0';

   /* Compute the hash function value. */

   /* Translate token characters into numeric values for the	*/
   /* hash function computation.				*/

   calc_hash_vector (reserved_word, &xlate_first, &xlate_last, &second_to_last);

   hash_value = xlate_first+xlate_last+(2*second_to_last)+id_length;

   /* Look up the identifier in the hash table to see if a	*/
   /* reserved word was found.					*/
   return (reserved_word_or_IDENTIFIER (hash_value, reserved_word, name));
}

#define FALSE 0
#define TRUE 1

/* This is called "XLATE array" in the paper. */
static int char_value_array[] = {
/* 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' */
    0, 49,  0, -7,-20, 18, -2,-38, 33,  0, -9,  9, 29, -9,  6,
/* 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z'		      */
   26,  0,  8,  1,  1, -9,  0, 56,-28, 11,  0
};

static void calc_hash_vector (token, xlate_first, xlate_last, second_to_last)
char *token;
int *xlate_first, *xlate_last, *second_to_last; /* range -38 .. +56 */
   /* The range here is the min and max of the individual components of
      the hashing function. */
{
   /* Given a string, compute the components of its hash function. */

   *xlate_first    = char_value_array[token[0] - (int)'a'];
   *xlate_last     = char_value_array[token[strlen (token)-1] - (int)'a'];
   *second_to_last = token[strlen (token)-2] - (int)'a';
}

static char *hash_table[72] = {
   "else",    "exit",      "end",        "at",       "then",      "range",
   "abs",     "do",        "exception",  "delay",    "use",       "xor",
   "select",  NULL,        "declare",    "type",     "array",     "limited",
   "subtype", "elsif",     "case",       "generic",  "and",       "not",
   "renames", "package",   "null",       "separate", "terminate", "raise",
   "entry",   "reverse",   "task",       NULL,       "all",       "constant",
   "delta",   "accept",    "digits",     "return",   "abort",     "record",
   "in",      "access",    "or",         "function", "goto",      "others",
   "rem",     "procedure", "out",        "private",  "is",        "mod",
   "of",      NULL,        "pragma",     "for",      "new",       "when",
   "with",    "begin",     NULL,         "while",    NULL,        NULL,
   NULL,      "loop",      NULL,         "if",       "body",      NULL
};

static int token_table[72] = {
   ELSE_,     EXIT_,       END_,         AT_,        THEN_,       RANGE_, 
   ABS_,      DO_,         EXCEPTION_,   DELAY_,     USE_,        XOR_, 
   SELECT_,   0,           DECLARE_,     TYPE_,      ARRAY_,      LIMITED_, 
   SUBTYPE_,  ELSIF_,      CASE_,        GENERIC_,   AND_,        NOT_, 
   RENAMES_,  PACKAGE_,    NULL_,        SEPARATE_,  TERMINATE_,  RAISE_, 
   ENTRY_,    REVERSE_,    TASK_,        0,          ALL_,        CONSTANT_, 
   DELTA_,    ACCEPT_,     DIGITS_,      RETURN_,    ABORT_,      RECORD_, 
   IN_,       ACCESS_,     OR_,          FUNCTION_,  GOTO_,       OTHERS_, 
   REM_,      PROCEDURE_,  OUT_,         PRIVATE_,   IS_,         MOD_, 
   OF_,       0,           PRAGMA_,      FOR_,       NEW_,        WHEN_, 
   WITH_,     BEGIN_,      0,            WHILE_,     0,           0,
   0,         LOOP_,       0,            IF_,        BODY_,       0
};

static int reserved_word_or_IDENTIFIER(hash_value, reserved_word, name)
int hash_value; /* range -76 .. +171 */
   /* The range here is the min and max values the hashing function
      can produce.  It is calculated as follows:
      -38    <= xlate_first					<= 56
      -38-38 <= xlate_first+xlate_last				<= 56+56
      -76-0  <= xlate_first+xlate_last+2*second_to_last		<= 112+(2*25)
      -76+2  <= xlate_first+xlate_last+2*second_to_last+length	<= 162+9 */

char *reserved_word, *name;
{
/* We know the hash_value for our string, and its (probably) the
   same as the hash value for the reserved word.  This routine
   answers TRUE/FALSE to "the indicated hash_value/identifier
   correspond to the proper Ada reserved word". */

   if ((hash_value < 0)
    || (hash_value >= (sizeof (hash_table)/sizeof (hash_table[0]))))
      return (new_IDENTIFIER (name));

   if (hash_table[hash_value] && !strcmp (hash_table[hash_value], reserved_word))
      return (token_table [hash_value]);
   else
      return (new_IDENTIFIER (name));
}
#endif HASH

@@


1.5
log
@@no change
@@
text
@@d73 1
a73 1
"$Header: scan.l,v 1.4 93/10/16 15:27:47 bischoff Exp $";
d76 3
@@


1.4
log
@@*** empty log message ***
@@
text
@@d73 1
a73 1
"$Header: scan.l,v 1.3 93/10/06 20:39:59 bischoff Exp $";
d76 3
@@


1.3
log
@@*** empty log message ***
@@
text
@@d73 1
a73 1
"$Header: scan.l,v 1.2 93/10/06 19:18:05 bischoff Exp $";
d76 3
@@


1.2
log
@@works
@@
text
@@d73 1
a73 1
"$Header: scan.l,v 1.1 93/10/06 16:07:15 bischoff Exp $";
d76 3
@@


1.1
log
@@Initial revision
@@
text
@@d73 1
a73 1
"$Header: ./RCS/ada.l,v 1.7 89/10/11 21:15:42 shields Exp $";
d75 4
a78 1
/* $Log:	ada.l,v $
d146 1
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ada/RCS/scan.l,v`; if test $1 -ne 10973
then
	echo ERROR: oxDistG1.04/grammars/ada/RCS/scan.l,v checksum is $1 should be 10973
fi
set `wc -lwc <oxDistG1.04/grammars/ada/RCS/scan.l,v`
if test $1$2$3 != 632249820585
then
	echo ERROR: wc results of oxDistG1.04/grammars/ada/RCS/scan.l,v are $* should be 632 2498 20585
fi

chmod 755 oxDistG1.04/grammars/ada/RCS/scan.l,v

if test -f oxDistG1.04/grammars/ada/RCS/Makefile,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ada/RCS/Makefile,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ada/RCS/Makefile,v
	if test -f oxDistG1.04/grammars/ada/RCS/Makefile,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ada/RCS/Makefile,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ada/RCS/Makefile,v
sed 's/^@//' >oxDistG1.04/grammars/ada/RCS/Makefile,v <<'@EOF'
head     1.6;
access   ;
symbols  ;
locks    bischoff:1.6; strict;
comment  @# @;


1.6
date     93.10.31.15.54.00;  author bischoff;  state Exp;
branches ;
next     1.5;

1.5
date     93.10.16.15.55.06;  author bischoff;  state Exp;
branches ;
next     1.4;

1.4
date     93.10.16.15.27.39;  author bischoff;  state Exp;
branches ;
next     1.3;

1.3
date     93.10.06.20.39.42;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.06.19.17.48;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.06.18.59.59;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@trying to get Tm Shiel t Tom Shields' Ada grammar to compile.
@@


1.6
log
@@*** empty log message ***
@@
text
@@WF=gram.y scan.l

YACC=yacc
LEX=lex
CLIBS= -ll -ly 
OXFLAGS=

# YACC=bison -o y.tab.c
# CLIBS= -ll -ly -lcurses -ltermcap
# OXFLAGS= -T

all: $(WF) 
	co $(WF) ; make ada

ada: y.tab.o lex.yy.o
	cc -o ada y.tab.o lex.yy.o $(CLIBS) 

y.tab.o: y.tab.c
	cc -c y.tab.c

lex.yy.o: lex.yy.c y.tab.h
	cc -c lex.yy.c

y.tab.c: oxout.y
	$(YACC) -d oxout.y

lex.yy.c: oxout.l
	$(LEX) oxout.l

oxout.y oxout.l:gram.y scan.l
	ox $(OXFLAGS) gram.y scan.l

gram.y: RCS/gram.y,v
	co gram.y

scan.l: RCS/scan.l,v
	co scan.l

clean:
	rm lex.yy.c y.tab.h y.tab.c oxout.? *.o ada
@@


1.5
log
@@*** empty log message ***
@@
text
@@d1 2
d9 1
a9 1
# CLIBS= -ll -ly -lcurses
d12 3
d16 1
a16 1
	cc -o ada y.tab.o lex.yy.o $(CFLAGS) 
@@


1.4
log
@@*** empty log message ***
@@
text
@@@


1.3
log
@@just dandy
@@
text
@@a0 1
# YACC=bison -o y.tab.c
d3 2
d6 4
d11 1
a11 1
	cc -o ada y.tab.o lex.yy.o -ll -ly -lcurses
d26 1
a26 1
	ox -T gram.y scan.l
d28 6
d35 1
a35 1
	rm lex.yy.? y.tab.? oxout.? ada
@@


1.2
log
@@works
@@
text
@@d6 1
a6 1
	cc -o ada y.tab.o lex.yy.o -ll -ly
d14 2
a15 2
y.tab.c: gram.y
	$(YACC) -dv gram.y
d17 2
a18 2
lex.yy.c: scan.l
	$(LEX) scan.l
d20 3
d24 1
a24 1
	rm lex.yy.c y.tab.c y.tab.h y.tab.o lex.yy.o
@@


1.1
log
@@Initial revision
@@
text
@@d1 3
a3 2
YACC=bison -o y.tab.c
LEX=flex
d18 1
a18 1
	lex scan.l
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ada/RCS/Makefile,v`; if test $1 -ne 50415
then
	echo ERROR: oxDistG1.04/grammars/ada/RCS/Makefile,v checksum is $1 should be 50415
fi
set `wc -lwc <oxDistG1.04/grammars/ada/RCS/Makefile,v`
if test $1$2$3 != 1733402034
then
	echo ERROR: wc results of oxDistG1.04/grammars/ada/RCS/Makefile,v are $* should be 173 340 2034
fi

chmod 755 oxDistG1.04/grammars/ada/RCS/Makefile,v

if test -f oxDistG1.04/grammars/ada/RCS/README,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ada/RCS/README,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ada/RCS/README,v
	if test -f oxDistG1.04/grammars/ada/RCS/README,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ada/RCS/README,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ada/RCS/README,v
sed 's/^@//' >oxDistG1.04/grammars/ada/RCS/README,v <<'@EOF'
head     1.6;
access   ;
symbols  ;
locks    bischoff:1.6; strict;
comment  @# @;


1.6
date     93.10.31.15.53.52;  author bischoff;  state Exp;
branches ;
next     1.5;

1.5
date     93.10.16.15.54.37;  author bischoff;  state Exp;
branches ;
next     1.4;

1.4
date     93.10.16.15.27.31;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@@


1.6
log
@@*** empty log message ***
@@
text
@@$Header: README,v 1.5 93/10/16 15:54:37 bischoff Exp $

The code in this directory originated as a Yacc/Lex specification 
for a parser for the Ada language.  I received it from Tom Shields,
as documented in the copy of his mail message to me (see below).
The grammar seems to be descendent from one that was on an archive 
mentioned in the comp.compilers monthly message around December
1992.  It seems that at that time, the archived grammar was quite 
old.  The present grammar seems better than that archived one, since 
it doesn't overload the `aggr' nonterminal for parsing things like 
parenthesized expressions, subprogram calls, and indexed components, 
as did the archived one.  I don't know whether it is otherwise faithful 
to the grammar in the Ada Reference Manual.  Presumably it gives
correct yes/no answers regarding the presence of syntax errors.

This is an adaptation for use with Ox of Tom Shield's code.  The Yacc 
input specification file `gram.y', and the Lex input specification file 
`scan.l' are barely changed from what Tom sent me, a line

	#define lex 1

added to each to select Lex instead of Flex.  The `Makefile' and 
this `README' were created for this Ox adaptation. 

Inputting the original files to Ox results in a parser that behaves
in every way as the original Yacc/Lex parser, except that it builds
a `dummy' parse tree, (i.e., one without attributes).  `gram.y' and
`scan.l' are ready for augmentation with Ox constructs, which results
in a parser that constructs a parse tree bearing inherited and/or
synthesized attributes.  Code for tree construction, decoration,
and traversal are generated automatically by Ox.  For further 
information, see the Ox Tuturial Introduction and the Ox User
Reference Manual, which accompany the Ox distribution.  
 
--Kurt Bischoff, Sat Oct 16 16:38:22 EDT 1993 
*************************************************************************



@From shields@@Stars.Reston.Paramax.COM Wed Oct  6 12:43 CDT 1993
Received: from stars.reston.paramax.com by flash.cs.iastate.edu with SMTP
	(1.37.109.6/16.2) id AA07474; Wed, 6 Oct 93 12:43:29 -0500
Received: from repos (repos.stars.reston.paramax.com) by aviary.Stars.Reston.Paramax.COM (4.1/mls/3.2) 
	id AA04910; Wed, 6 Oct 93 13:42:38 EDT
Received: by repos (4.1/mls/3.5) 
	id AA00578; Wed, 6 Oct 93 13:40:08 EDT
To: robles@@dit.upm.es (Tomas Robles Valladares), Al Lau <allau@@sequent.com>,
        dickey@@software.org (Thomas Dickey),
        honig@@dutiws.twi.tudelft.nl (J.Honig.TI-tel-4570),
        karl@@grebyn.com (Karl A. Nyberg), harold@@issi.com,
        Kurt Bischoff <bischoff>, Margie Price <mprice@@rbse.mountain.net>
Subject: Re: Need a yaccable/lexable Ada grammar
In-Reply-To: Your message of Thu, 30 Sep 93 11:48:49 BST.
             <199309301048.AA24877@@yeti.dit.upm.es> 
Return-Receipt-To: shields@@Stars.Reston.Paramax.COM
Date: Wed, 06 Oct 93 13:40:07 -0400
Message-Id: <577.749929207@@repos>
@From: "Thomas E. Shields" <shields@@Stars.Reston.Paramax.COM>
Status: R

Kurt Bischoff said: "I wonder if the files you describe are descendent
from the ones mentioned in the comp.compilers monthly FAQ."

My answer: "I don't know - I got the original source from SIMTEL20 back
in December 1987.  I've passed these sources out several times over the
years, so the files mentioned in comp.compilers might or might not even
be these files."

Margie Price said: "I'm from the AdaNET repository, and I'll be glad to
include those in the repository.  Do you have some documentations?  I think
what I'll do is, to include your version and still keep the SIMTEL20
version.  Or, are they very similar, and you just made it work correctly?"

My answer: "All I have to offer is the lex and yacc specifications, which
are directly derived from the corresponding files I downloaded from
SIMTEL20 in December 1987.  I don't know if the SIMTEL20 files were ever
updated."

Lex specification file at the end of this message, yacc specification
follows in the next message.  Note that some of the flex-related hackery
was necessary for the version of flex available at the time, but may
no longer be necessary, as flex has matured significantly since then.
I haven't had the time or interest to update any of this, so what you
are getting is the state as of the last RCS log entries in the two files.

Tom
   --------------------------------------------------------------------------
   Thomas E. Shields, PhD, CCP        Software Engineering - 7720
   Software Technologist              Unisys Government Systems Group
   (703) 620-7028                     Systems Development/Information Systems
   (703) 620-7913 FAX                 12010 Sunrise Valley Drive
   shields@@stars.reston.paramax.com   Reston, VA 22091
   --------------------------------------------------------------------------
@@


1.5
log
@@*** empty log message ***
@@
text
@@d1 1
a1 1
$Header: README,v 1.4 93/10/16 15:27:31 bischoff Exp $
@@


1.4
log
@@*** empty log message ***
@@
text
@@d1 1
a1 1
$Header$
d10 5
a14 4
it doesn't 
overload the `aggr' nonterminal for parsing things like parenthesized 
expressions, subprogram calls, and indexed components, as did the 
archived one.
d17 2
a18 5
input specification file `gram.y', the Lex input specification file 
`scan.l', and the main program file `main.c' are barely changed from 
the originals.  `Makefile' and this `README' were created for this 
distribution. 
of the originals are in the RCS directory as revision 1.1.  
d20 5
d35 1
a35 1
--Kurt Bischoff, Sat Oct 16 14:38:18 EDT 1993
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ada/RCS/README,v`; if test $1 -ne 26547
then
	echo ERROR: oxDistG1.04/grammars/ada/RCS/README,v checksum is $1 should be 26547
fi
set `wc -lwc <oxDistG1.04/grammars/ada/RCS/README,v`
if test $1$2$3 != 1658475934
then
	echo ERROR: wc results of oxDistG1.04/grammars/ada/RCS/README,v are $* should be 165 847 5934
fi

chmod 755 oxDistG1.04/grammars/ada/RCS/README,v

chmod 755 oxDistG1.04/grammars/ada/RCS

if test -f oxDistG1.04/grammars/ada/README
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ada/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ada/README
	if test -f oxDistG1.04/grammars/ada/README
	then
		echo Error: could not remove oxDistG1.04/grammars/ada/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ada/README
sed 's/^@//' >oxDistG1.04/grammars/ada/README <<'@EOF'
$Header: README,v 1.6 93/10/31 15:53:52 bischoff Exp $

The code in this directory originated as a Yacc/Lex specification 
for a parser for the Ada language.  I received it from Tom Shields,
as documented in the copy of his mail message to me (see below).
The grammar seems to be descendent from one that was on an archive 
mentioned in the comp.compilers monthly message around December
1992.  It seems that at that time, the archived grammar was quite 
old.  The present grammar seems better than that archived one, since 
it doesn't overload the `aggr' nonterminal for parsing things like 
parenthesized expressions, subprogram calls, and indexed components, 
as did the archived one.  I don't know whether it is otherwise faithful 
to the grammar in the Ada Reference Manual.  Presumably it gives
correct yes/no answers regarding the presence of syntax errors.

This is an adaptation for use with Ox of Tom Shield's code.  The Yacc 
input specification file `gram.y', and the Lex input specification file 
`scan.l' are barely changed from what Tom sent me, a line

	#define lex 1

added to each to select Lex instead of Flex.  The `Makefile' and 
this `README' were created for this Ox adaptation. 

Inputting the original files to Ox results in a parser that behaves
in every way as the original Yacc/Lex parser, except that it builds
a `dummy' parse tree, (i.e., one without attributes).  `gram.y' and
`scan.l' are ready for augmentation with Ox constructs, which results
in a parser that constructs a parse tree bearing inherited and/or
synthesized attributes.  Code for tree construction, decoration,
and traversal are generated automatically by Ox.  For further 
information, see the Ox Tuturial Introduction and the Ox User
Reference Manual, which accompany the Ox distribution.  
 
--Kurt Bischoff, Sat Oct 16 16:38:22 EDT 1993 
*************************************************************************



@From shields@Stars.Reston.Paramax.COM Wed Oct  6 12:43 CDT 1993
Received: from stars.reston.paramax.com by flash.cs.iastate.edu with SMTP
	(1.37.109.6/16.2) id AA07474; Wed, 6 Oct 93 12:43:29 -0500
Received: from repos (repos.stars.reston.paramax.com) by aviary.Stars.Reston.Paramax.COM (4.1/mls/3.2) 
	id AA04910; Wed, 6 Oct 93 13:42:38 EDT
Received: by repos (4.1/mls/3.5) 
	id AA00578; Wed, 6 Oct 93 13:40:08 EDT
To: robles@dit.upm.es (Tomas Robles Valladares), Al Lau <allau@sequent.com>,
        dickey@software.org (Thomas Dickey),
        honig@dutiws.twi.tudelft.nl (J.Honig.TI-tel-4570),
        karl@grebyn.com (Karl A. Nyberg), harold@issi.com,
        Kurt Bischoff <bischoff>, Margie Price <mprice@rbse.mountain.net>
Subject: Re: Need a yaccable/lexable Ada grammar
In-Reply-To: Your message of Thu, 30 Sep 93 11:48:49 BST.
             <199309301048.AA24877@yeti.dit.upm.es> 
Return-Receipt-To: shields@Stars.Reston.Paramax.COM
Date: Wed, 06 Oct 93 13:40:07 -0400
Message-Id: <577.749929207@repos>
@From: "Thomas E. Shields" <shields@Stars.Reston.Paramax.COM>
Status: R

Kurt Bischoff said: "I wonder if the files you describe are descendent
from the ones mentioned in the comp.compilers monthly FAQ."

My answer: "I don't know - I got the original source from SIMTEL20 back
in December 1987.  I've passed these sources out several times over the
years, so the files mentioned in comp.compilers might or might not even
be these files."

Margie Price said: "I'm from the AdaNET repository, and I'll be glad to
include those in the repository.  Do you have some documentations?  I think
what I'll do is, to include your version and still keep the SIMTEL20
version.  Or, are they very similar, and you just made it work correctly?"

My answer: "All I have to offer is the lex and yacc specifications, which
are directly derived from the corresponding files I downloaded from
SIMTEL20 in December 1987.  I don't know if the SIMTEL20 files were ever
updated."

Lex specification file at the end of this message, yacc specification
follows in the next message.  Note that some of the flex-related hackery
was necessary for the version of flex available at the time, but may
no longer be necessary, as flex has matured significantly since then.
I haven't had the time or interest to update any of this, so what you
are getting is the state as of the last RCS log entries in the two files.

Tom
   --------------------------------------------------------------------------
   Thomas E. Shields, PhD, CCP        Software Engineering - 7720
   Software Technologist              Unisys Government Systems Group
   (703) 620-7028                     Systems Development/Information Systems
   (703) 620-7913 FAX                 12010 Sunrise Valley Drive
   shields@stars.reston.paramax.com   Reston, VA 22091
   --------------------------------------------------------------------------
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ada/README`; if test $1 -ne 3124
then
	echo ERROR: oxDistG1.04/grammars/ada/README checksum is $1 should be 3124
fi
set `wc -lwc <oxDistG1.04/grammars/ada/README`
if test $1$2$3 != 936674807
then
	echo ERROR: wc results of oxDistG1.04/grammars/ada/README are $* should be 93 667 4807
fi

chmod 755 oxDistG1.04/grammars/ada/README

if test -f oxDistG1.04/grammars/ada/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ada/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ada/Makefile
	if test -f oxDistG1.04/grammars/ada/Makefile
	then
		echo Error: could not remove oxDistG1.04/grammars/ada/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ada/Makefile
cat >oxDistG1.04/grammars/ada/Makefile <<'@EOF'
WF=gram.y scan.l

YACC=yacc
LEX=lex
CLIBS= -ll -ly 
OXFLAGS=

# YACC=bison -o y.tab.c
# CLIBS= -ll -ly -lcurses -ltermcap
# OXFLAGS= -T

all: $(WF) 
	co $(WF) ; make ada

ada: y.tab.o lex.yy.o
	cc -o ada y.tab.o lex.yy.o $(CLIBS) 

y.tab.o: y.tab.c
	cc -c y.tab.c

lex.yy.o: lex.yy.c y.tab.h
	cc -c lex.yy.c

y.tab.c: oxout.y
	$(YACC) -d oxout.y

lex.yy.c: oxout.l
	$(LEX) oxout.l

oxout.y oxout.l:gram.y scan.l
	ox $(OXFLAGS) gram.y scan.l

gram.y: RCS/gram.y,v
	co gram.y

scan.l: RCS/scan.l,v
	co scan.l

clean:
	rm lex.yy.c y.tab.h y.tab.c oxout.? *.o ada
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ada/Makefile`; if test $1 -ne 64906
then
	echo ERROR: oxDistG1.04/grammars/ada/Makefile checksum is $1 should be 64906
fi
set `wc -lwc <oxDistG1.04/grammars/ada/Makefile`
if test $1$2$3 != 4080560
then
	echo ERROR: wc results of oxDistG1.04/grammars/ada/Makefile are $* should be 40 80 560
fi

chmod 755 oxDistG1.04/grammars/ada/Makefile

if test -f oxDistG1.04/grammars/ada/gram.y
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ada/gram.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ada/gram.y
	if test -f oxDistG1.04/grammars/ada/gram.y
	then
		echo Error: could not remove oxDistG1.04/grammars/ada/gram.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ada/gram.y
sed 's/^@//' >oxDistG1.04/grammars/ada/gram.y <<'@EOF'
/*--------------------------------------------------------------------------*/
/*									    */
/*			 A LALR(1) grammar for ANSI Ada*		    */
/*									    */
/*			 Adapted for YACC (UNIX) Inputs			    */
/*									    */
/*                                                                          */
/*                             Herman Fischer                               */
/*                           Litton Data Systems                            */
/*                       8000 Woodley Ave., ms 44-30                        */
/*                              Van Nuys, CA                                */
/*                                                                          */
/*                              818/902-5139                                */
/*                           HFischer@eclb.arpa                             */
/*                        {cepu,trwrb}!litvax!fischer                       */
/*                                                                          */
/*                             March 26, 1984                               */
/*									    */
/*                   A Contribution to the Public Domain                    */
/*                                   for                                    */
/*            Research, Development, and Training Purposes Only             */
/*                                                                          */
/*       Any Corrections or Problems are to be Reported to the Author       */
/*                                                                          */
/*                                                                          */
%{
static
char rcsid[] =
"$Header: gram.y,v 1.6 93/10/31 15:54:02 bischoff Exp $";
%}
/* $Log:	gram.y,v $
 * Revision 1.6  93/10/31  15:54:02  15:54:02  bischoff (Kurt Bischoff)
 * *** empty log message ***
 * 
 * Revision 1.5  93/10/16  15:57:24  15:57:24  bischoff (Kurt Bischoff)
 * no change
 * 
 * Revision 1.4  93/10/16  15:27:44  15:27:44  bischoff (Kurt Bischoff)
 * *** empty log message ***
 * 
 * Revision 1.3  93/10/06  20:39:54  20:39:54  bischoff (Kurt Bischoff)
 * *** empty log message ***
 * 
 * Revision 1.2  93/10/06  19:17:57  19:17:57  bischoff (Kurt Bischoff)
 * workds
 * 
 * Revision 1.1  93/10/06  16:06:30  16:06:30  bischoff (Kurt Bischoff)
 * Initial revision
 * 
 * Revision 1.6  89/10/12  17:22:08  shields
 * minor changes to formatting
 * 
 * Revision 1.5  89/10/11  21:51:13  shields
 * minor change to 'yyerror'
 * 
 * Revision 1.4  89/10/11  21:37:29  shields
 * changed "extern" definition of 'yytext' to depend on whether the
 *    lexer is generated by LEX or FLEX - LEX defines 'yytext' as type
 *    'char []', while FLEX defines 'yytext' as type 'char *', and these
 *    types are not compatible for "extern" objects
 * minor change to 'yyerror'
 * 
 * Revision 1.3  88/06/11  19:28:56  shields
 * simplified/clarified/restructured grammar for readability and to make
 *    semantic actions easier to construct
 * reduced the Ada superset defined by the grammar in various ways:
 *    'object_d' no longer generates deferred constant declaractions
 *    'aggr' no longer generates index and discriminant constraints, and
 *       is no longer used to generate parenthesized expressions or
 *       parenthesized expression lists, except where used as an aggregate
 *    'name' no longer used to generate procedure and entry call statements
 * deleted unused operator syntactic categories
 * 
 * Revision 1.2  88/06/09  23:42:41  shields
 * simplified binary operator part of grammar using YACC %left, %nonassoc,
 *    and %prec disambiguation facilities - also simplified some of the
 *    rules for readability
 * corrected error in rules for 'rec_rep_cl' - '.algt_cl.' could generate
 *    a sequence ending in '..prag..', and '..cmpon_cl..' could be empty,
 *    resulting in a record representation clause containing only a
 *    sequence of pragmas in place of the sequence of component clauses,
 *    in violation of LRM 2.8(5)
 * restructured rules involving pragmas for readability and to make semantic
 *    actions easier to define
 * (NOTE: pragma rule correction and restructuring introduced shift/reduce
 *    ambiguities resolvable by YACC's choice of the shift action, so the
 *    ambiguities were left as-is)
 * deleted rules defining reserved words 'DIGITS', 'DELTA' and 'RANGE' as
 *    alternatives for 'attribute_designator' - corresponds to change made
 *    in LEX definition of lexer to return all attribute designators
 *    as 'IDENTIFIER' tokens
 * 
 * Revision 1.1  88/05/09  17:29:55  shields
 * added missing '.fml_part.' at end of first alternative rule for 'subprg_spec'
 * added error rule
 *    later_decl_item : error ';'
 * cleaned up grammar presentation format slightly
 * added RCS Header and Log keywords to source file
 * 
 * Revision 1.0  87/12/17  18:22:11  jwabik
 * original version copied from SIMTEL20
 *
 */
/*                                                                          */
/*                                                                          */
/*  Mods to the original: Jeff Wabik, Control Data Corporation		    */
/*  December, 1987:  Mainly reformatted to make the YACC readable           */
/*  { umn-cs!shamash!jwabik }						    */
/*  Disclaim:  CDC is not responsible.					    */
/*                                                                          */
/*  Note that Herm Fischer's new address, effective 9/23/87, is:            */
/*  { hermix!fischer@rand-unix.ARPA }					    */
/*  { {ihnp4,decvax,trwrb,seismo,etc.}!hermix!fischer }			    */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/*                              adapted from                                */
/*                              the grammar                                 */
/*                                  by:                                     */
/*									    */
/*            Gerry Fisher                         Philippe Charles         */
/*                                                                          */
/*    Computer Sciences Corporation     &             Ada  Project          */
/*         4045 Hancock Street                     New York University      */
/*         San Diego, CA 92121                      251 Mercer Street       */
/*                                               New York, New York 10012   */
/*									    */
/*									    */
/*    This grammar is organized in the same order as the syntax summary     */
/* in appendix E of the ANSI Ada Reference Manual.   All reserved words     */
/* are written in upper case letters.  The lexical categories               */
/* NUMERIC_LITERAL, STRING_LITERAL, etc, are viewed as terminals.  The      */
/* rules for pragmas as stated in chapter 2, section 8, have been           */
/* incorporated in the grammar.  Comments are included wherever we had to   */
/* deviate from the syntax given in appendix E.  Different symbols used	    */
/* here (to comply with YACC requirements) are of note:                     */
/*	{,something}	is denoted ...something..			    */
/*	{something}	is denoted ..something..			    */
/*	[something]	is denoted .something.				    */
/* Constructs involving meta brackets, e.g., ...IDENTIFIER.. are            */
/* represented by a nonterminal formed by concatenating the construct       */
/* symbols (as ...IDENTIFIER.. in the example) for which the rules are      */
/* given at the end.  When reading this grammar, it is important to note    */
/* that all symbols appearing in the rules are separated by one or more     */
/* blanks.  A string such as 'IDENTIFIER_type_mark' is actually a single    */
/* nonterminal symbol defined at the end of the rules.  The '/*' symbol is  */
/* used to indicate that the rest of the line is a comment, just as in      */
/* YACC programs.                                                           */
/*                                                                          */
/*     This grammar is presented here in a form suitable for input to a     */
/* YACC parser generator.  It has  been  processed  by the Bell System      */
/* III LEX/YACC combination, and tested against over 400 ACVC tests.        */
/*									    */
/* *Ada is a registered trade mark of the  Department of  Defense  (Ada     */
/* Joint Program  Office).						    */
/*									    */
/*--------------------------------------------------------------------------*/

%{

#include <stdio.h>
#include <ctype.h>
#define lex 1

#ifdef lex
extern char yytext[];
#endif lex
#ifdef flex
extern char *yytext;
#endif flex
extern int yylineno;

%}


%union {
	char *y_str;
	int y_num;
};


/*%terminals -----------------------------------------------------------    */

%token ABORT_ ABS_ ACCEPT_ ACCESS_ ALL_ AND_ ARRAY_
%token AT_ BEGIN_ BODY_ CASE_ CONSTANT_
%token DECLARE_ DELAY_ DELTA_ DIGITS_ DO_ ELSE_ ELSIF_
%token END_ ENTRY_ EXCEPTION_ EXIT_ FOR_
%token FUNCTION_ GENERIC_ GOTO_ IF_ IN_ IS_ LIMITED_
%token LOOP_ MOD_ NEW_ NOT_ NULL_ OF_ OR_
%token OTHERS_ OUT_ PACKAGE_ PRAGMA_ PRIVATE_
%token PROCEDURE_ RAISE_ RANGE_ RECORD_ REM_
%token RENAMES_ RETURN_ REVERSE_ SELECT_ SEPARATE_
%token SUBTYPE_ TASK_ TERMINATE_ THEN_
%token TYPE_ USE_ WHEN_ WHILE_ WITH_ XOR_

%token IDENTIFIER NUMERIC_LITERAL STRING_LITERAL CHARACTER_LITERAL
%token ARROW_ DBLDOT_ EXP_ ASSIGN_ NOTEQL_ GTEQL_ LTEQ_ L_LBL_ R_LBL_ BOX_

%left		','
%left		AND_ OR_ XOR_
%nonassoc	'=' NOTEQL_ '<' LTEQ_ '>' GTEQL_ NOT_ IN_
%left		'+' '-' '&'
%left		'*' '/' MOD_ REM_
%nonassoc	EXP_

%start	compilation

/* The following 3 shift/reduce errors, resolved by YACC by choosing
   the shift action, are expected */
/* shift PRAGMA_ in '..prag..' iteration, or
   reduce <empty> -> '.algt_cl.' terminating '..prag..' iteration and starting
   '..cmpon_cl..' iteration within 'rec_rep_cl' */
/* shift PRAGMA_ in '..ent_d..' iteration, or
   reduce <empty> -> '..rep_cl..' terminating '..ent_d..' iteration and starting
   '..rep_cl..' iteration within '.task_interface.' */
/* shift PRAGMA_ in 'cmpon_ds' iteration, or
   reduce 'cmpon_ds' -> 'cmpons' terminating 'cmpon_ds' iteration and starting
   'cmpons' iteration within 'cmpons' */

%%	/* beginning of rules section */


/* 2.8 */

prag		: PRAGMA_ IDENTIFIER .prag_arg_part. ';'
		;

prag_arg_part	: '(' arg_ascs ')'

arg_ascs	: arg_asc
		| arg_ascs ',' arg_asc
		;

arg_asc		: expr
		| IDENTIFIER ARROW_ expr
		;


/* 3.1 */

basic_d		: object_d
		| number_d
		| ty_d
		| subty_d
		| subprg_d
		| pkg_d
		| task_d
		| gen_d
		| excptn_d
		| gen_inst
		| renaming_d
		| defer_const_d
		| error ';'
		;


/* 3.2 */

object_d	: idents ':' subty_ind .ASSIGN_expr. ';'
		| idents ':' CONSTANT_ subty_ind ASSIGN_ expr ';'
		| idents ':' c_arr_def .ASSIGN_expr. ';'
		| idents ':' CONSTANT_ c_arr_def ASSIGN_ expr ';'
		;

number_d	: idents ':' CONSTANT_ ASSIGN_ expr ';'
		;

idents		: IDENTIFIER
		| idents ',' IDENTIFIER
		;


/* 3.3.1 */

ty_d		: full_ty_d
		| incomplete_ty_d
		| priv_ty_d
		;

full_ty_d	: TYPE_ IDENTIFIER .discr_part. IS_ ty_def ';'
		;

ty_def		: enum_ty_def
		| integer_ty_def
		| real_ty_def
		| array_ty_def
		| rec_ty_def
		| access_ty_def
		| derived_ty_def
		;


/* 3.3.2 */

subty_d		: SUBTYPE_ IDENTIFIER IS_ subty_ind ';'
		;

subty_ind	: ty_mk .constrt.
		;

ty_mk		: expanded_n
		;

constrt		: rng_c
		| fltg_point_c
		| fixed_point_c
/*		| idx_c /* as 'idx_or_discr_c' */
/*		| discr_c /* as 'idx_or_discr_c' */
		| idx_or_discr_c
		;


/* 3.4 */

derived_ty_def	: NEW_ subty_ind
		;


/* 3.5 */

rng_c		: RANGE_ rng
		;

rng		: name /* must be an 'attribute' */
		| sim_expr DBLDOT_ sim_expr
		;


/* 3.5.1 */

enum_ty_def	: '(' enum_lit_specs ')'
		;

enum_lit_specs	: enum_lit_spec
		| enum_lit_specs ',' enum_lit_spec
		;

enum_lit_spec	: enum_lit
		;

enum_lit	: IDENTIFIER
		| CHARACTER_LITERAL
		;


/* 3.5.4 */

integer_ty_def	: rng_c
		;


/* 3.5.6 */

real_ty_def	: fltg_point_c
		| fixed_point_c
		;


/* 3.5.7 */

fltg_point_c	: fltg_accuracy_def .rng_c.
		;

fltg_accuracy_def	: DIGITS_ sim_expr
		;


/* 3.5.9 */

fixed_point_c	: fixed_accuracy_def .rng_c.
		;

fixed_accuracy_def	: DELTA_ sim_expr
		;


/* 3.6 */

array_ty_def	: uncnstrnd_array_def
		| c_arr_def
		;

uncnstrnd_array_def	: ARRAY_ '(' idx_subty_defs ')' OF_ subty_ind
		;

idx_subty_defs	: idx_subty_def
		| idx_subty_defs ',' idx_subty_def
		;

idx_subty_def	: name RANGE_ BOX_
		;

c_arr_def	: ARRAY_ idx_c OF_ subty_ind
		;

idx_c		: '(' dscr_rngs ')'
		;

dscr_rngs	: dscr_rng
		| dscr_rngs ',' dscr_rng
		;

dscr_rng	: rng
		| name rng_c
		;


/* 3.7 */

rec_ty_def	: RECORD_ cmpons END_ RECORD_
		;

cmpons		: ..prag.. cmpon_ds
		| ..prag.. .cmpon_ds. variant_part
		| ..prag.. NULL_ ';'
		| cmpons prag
		;

cmpon_ds	: cmpon_d
		| cmpon_ds cmpon_d
		| cmpon_ds prag
		;

cmpon_d		: idents ':' cmpon_subty_def .ASSIGN_expr. ';'
		;

cmpon_subty_def	: subty_ind
		;


/* 3.7.1 */

discr_part	: '(' discr_specs ')'
		;

discr_specs	: discr_spec
		| discr_specs ';' discr_spec
		;

discr_spec	: idents ':' ty_mk .ASSIGN_expr.
		;


/* 3.7.2 */

/*
discr_c		: '(' discr_ascs ')'
		;

discr_ascs	: discr_asc
		| discr_ascs ',' discr_asc
		;

discr_asc	: expr
		| sim_n_choices ARROW_ expr
		;
*/
/* included under 'idx_or_discr_c' */

sim_n_choices	: sim_n
		| sim_n_choices '|' sim_n
		;


/* 3.7.3 */

variant_part	: CASE_ sim_n IS_ ..prag.. variants END_ CASE_ ';'
		  /* Pragmas after 'variants' are in 'cmpons' at end of rhs */
		  /* of 'variant' */
		;

variants	: variant
		| variants variant
		;

variant		: WHEN_ choices ARROW_ cmpons
		;

choices		: choice
		| choices '|' choice
		;

choice		: sim_expr
		| name rng_c
		| sim_expr DBLDOT_ sim_expr
		| OTHERS_
		;


/* 3.8 */

access_ty_def	: ACCESS_ subty_ind
		;


/* 3.8.1 */

incomplete_ty_d	: TYPE_ IDENTIFIER .discr_part. ';'
		;


/* 3.9 */

decl_part	: ..basic_decl_item..
		| ..basic_decl_item.. body ..later_decl_item..
		;

/* A 'body' is the only 'later_decl_item' that is not also a	*/
/* 'basic_decl_item'. It is therefore used as the dividing	*/
/* point between the two lists of decl items.			*/

basic_decl_item	: basic_d
		| rep_cl
		| use_cl
		;

later_decl_item	: body
		| subprg_d
		| pkg_d
		| task_d
		| gen_d
		| use_cl
		| gen_inst
		| error ';'
		;

body		: proper_body
		| body_stub
		;

proper_body	: subprg_body
		| pkg_body
		| task_body
		;


/* 4.1 */

name		: sim_n
		| CHARACTER_LITERAL
		| op_symbol
		| idxed_cmpon
/*		| func_call /* parameterless, as 'sim_n' or 'selected_cmpon'; */
/*			       with parameters, as 'idxed_cmpon' */
/*		| slice /* included under 'idxed_cmpon' */
		| selected_cmpon
		| attribute
		;

sim_n		: IDENTIFIER
		;

prefix		: name
		;


/* 4.1.1 */

idxed_cmpon	: prefix '(' exprs ')'
		;

exprs		: expr
		| sim_expr DBLDOT_ sim_expr
		| IDENTIFIER ARROW_ expr
		/* subprg_call formal parameter association */
		| name rng_c
		| exprs ',' exprs
		;


/* 4.1.2 */

/*
slice		: prefix '(' dscr_rng ')'
		;
*/
/* included under 'idxed_cmpon' */


/* 4.1.3 */

selected_cmpon	: prefix '.' selector
		;

selector	: sim_n
		| CHARACTER_LITERAL
		| op_symbol
		| ALL_
		;


/* 4.1.4 */

attribute	: prefix '\'' attribute_designator
		;
/* This can be an 'attribute', 'idxed_cmpon', 'slice', or 'subprg_call' */

attribute_designator	: sim_n
/*		| sim_n '(' expr ')' /* reduced as 'idxed_cmpon' */
		;


/* 4.3 */

aggr		: '(' choices ARROW_ expr ')'
		  /* a single component aggregate must use named notation */
		| '(' cmpon_ascs ')'
		;

cmpon_ascs	: cmpon_asc ',' cmpon_asc
		| cmpon_ascs ',' cmpon_asc
		;

cmpon_asc	: expr
		| choices ARROW_ expr
		;


/* 4.4 */

expr		: expr AND_ expr
		| expr AND_ THEN_ expr	%prec AND_
		| expr OR_ expr
		| expr OR_ ELSE_ expr	%prec OR_
		| expr XOR_ expr
		| expr '=' expr
		| expr NOTEQL_ expr
		| expr '<' expr
		| expr LTEQ_ expr
		| expr '>' expr
		| expr GTEQL_ expr
		| expr IN_ rng
		| expr NOT_ IN_ rng	%prec IN_
/*		| expr IN_ ty_mk /* included under 'expr IN_ rng' */
/*		| expr NOT_ IN_ ty_mk	%prec IN_ /* included under
'expr NOT_ IN_ rng' */
		| sim_expr
		;

sim_expr	: sim_expr '+' term
		| sim_expr '-' term
		| sim_expr '&' term
		| '+' term
		| '-' term
		| term
		;

term		: term '*' term
		| term '/' term
		| term MOD_ term
		| term REM_ term
		| term EXP_ term
		| ABS_ pri
		| NOT_ pri
		| pri
		;

pri		: NUMERIC_LITERAL
		| NULL_
		| aggr
		| name
		  /* includes CHARACTER_LITERAL and STRING_LITERAL */
		  /* STRING_LITERAL is included as 'op_symbol' */
		| allocator
/*		| func_call /* included under 'name' */
/*		| ty_cnvr /* included under 'name' */
		| qualified_expr
		| '(' expr ')'
		;


/* 4.6 */

/*
ty_cnvr		: ty_mk '(' expr ')'
		;
*/
/* included under 'name' */


/* 4.7 */

qualified_expr	: prefix /* must be a 'ty_mk' */ '\'' '(' expr ')'
		| prefix /* must be a 'ty_mk' */ '\'' aggr
		;


/* 4.8 */

allocator	: NEW_ ty_mk
/*		| NEW_ ty_mk idx_c */
/*		| NEW_ ty_mk discr_c */
		| NEW_ ty_mk idx_or_discr_c
/*		| NEW_ qualified_expr */
		| NEW_ ty_mk '\'' '(' expr ')'
		| NEW_ ty_mk '\'' aggr
		;


/* 5.1 */

seq_of_stmts	: ..prag.. stmt
		| seq_of_stmts stmt
		| seq_of_stmts prag
		;

stmt		: ..label.. sim_stmt
		| ..label.. compound_stmt
		| error ';'
		;

sim_stmt	: null_stmt
		| assignment_stmt
		| exit_stmt
		| return_stmt
		| goto_stmt
		| delay_stmt
		| abort_stmt
		| raise_stmt
		| code_stmt
		| sim_n ';'
		| selected_cmpon ';'
		| idxed_cmpon ';'
/*		| ent_call_stmt /* parameterless, as 'sim_n' or */
/*				 'selected_cmpon'; with parameters, as */
/*				 'idxed_cmpon' */
/*		| procedure_call_stmt /* parameterless, as 'sim_n' or */
/*				 'selected_cmpon'; with parameters, as */
/*				 'idxed_cmpon' */
		;

compound_stmt	: if_stmt
		| case_stmt
		| loop_stmt
		| block_stmt
		| accept_stmt
		| select_stmt
		;

label		: L_LBL_ sim_n R_LBL_
		;

null_stmt	: NULL_ ';'
		;


/* 5.2 */

assignment_stmt	: name ASSIGN_ expr ';'
		;


/* 5.3 */

if_stmt		: IF_ cond THEN_ seq_of_stmts
		  ..ELSIF__cond__THEN__seq_of_stmts..
		  .ELSE__seq_of_stmts.
		  END_ IF_ ';'
		;

cond		: expr
		;


/* 5.4 */

case_stmt	: CASE_ expr IS_ ..prag.. case_stmt_alts END_ CASE_ ';'
		  /* Pragmas after 'case_stmt_alts' are in 'seq_of_stmts' at */
		  /* end of rhs of 'case_stmt_alt' */
		;

case_stmt_alts	: case_stmt_alt
		| case_stmt_alts case_stmt_alt
		;

case_stmt_alt	: WHEN_ choices ARROW_ seq_of_stmts
		;


/* 5.5 */

loop_stmt	: .sim_nC. /* sim_n ':' */
		  .iteration_scheme. LOOP_
		  seq_of_stmts
		  END_ LOOP_ .sim_n. ';'
		;

iteration_scheme: WHILE_ cond
		| FOR_ loop_prm_spec
		;

loop_prm_spec	: IDENTIFIER IN_ .REVERSE. dscr_rng
		;


/* 5.6 */

block_stmt	: .sim_nC. /* sim_n ':' */
		  .DECLARE__decl_part.
		  BEGIN_
		  seq_of_stmts
		  .frame_excptn_handlers.
		  END_ .sim_n. ';'
		;


/* 5.7 */

exit_stmt	: EXIT_ .expanded_n. .WHEN__cond. ';'
		;


/* 5.8 */

return_stmt	: RETURN_ .expr. ';'
		;


/* 5.9 */

goto_stmt	: GOTO_ expanded_n ';'
		;


/* 6.1 */

subprg_d	: subprg_spec ';'
		;

subprg_spec	: PROCEDURE_ IDENTIFIER .fml_part.
		| FUNCTION_  designator .fml_part. RETURN_ ty_mk
		;

designator	: IDENTIFIER
		| op_symbol
		;

op_symbol	: STRING_LITERAL
		;

fml_part	: '(' prm_specs ')'
		;

prm_specs	: prm_spec
		| prm_specs ';' prm_spec
		;

prm_spec	: idents ':' mode ty_mk .ASSIGN_expr.
		;

mode		: .IN.
		| IN_ OUT_
		| OUT_
		;


/* 6.3 */

subprg_body	: subprg_spec IS_ .decl_part.
		  BEGIN_
		  seq_of_stmts
		  .frame_excptn_handlers.
		  END_ .designator. ';'
		;


/* 6.4 */

/*
procedure_call_stmt	: procedure_n .act_prm_part. ';'
		;
*/
/* included under 'name' */

/*
func_call	: func_n .act_prm_part.
		;
*/
/* included under 'name' */

/*
act_prm_part	: '(' prm_asc ...prm_asc.. ')'
		;

prm_asc		: fml_prm ARROW_ act_prm
		| act_prm
		;

fml_prm		: sim_n
		;

act_prm		: expr
		| name
		| ty_mk '(' name ')'
		;
*/


/* 7.1 */

pkg_d		: pkg_spec ';'
		;

pkg_spec	: PACKAGE_ IDENTIFIER IS_
		  ..basic_decl_item..
		  .private_part. END_ .sim_n.
		;

pkg_body	: PACKAGE_ BODY_ sim_n IS_
		  .decl_part.
		  .pkg_body_init.
		  END_ .sim_n. ';'
		;


/* 7.4 */

priv_ty_d	: TYPE_ IDENTIFIER .discr_part. IS_ .LIMITED. PRIVATE_ ';'
		;

defer_const_d	: idents ':' CONSTANT_ ty_mk ';'
		;


/* 8.4 */

use_cl		: USE_ expanded_ns ';'
		;

expanded_ns	: expanded_n
		| expanded_ns ',' expanded_n
		;


/* 8.5 */

renaming_d	: idents ':' ty_mk      RENAMES_ name ';'
		| idents ':' EXCEPTION_ RENAMES_ expanded_n ';'
/* 'idents' in the two above rules must contain only one 'IDENTIFIER' */
		| PACKAGE_ IDENTIFIER   RENAMES_ expanded_n ';'
		| subprg_spec           RENAMES_ name ';'
		;


/* 9.1 */

task_d		: task_spec ';'
		;

task_spec	: TASK_ .TYPE. IDENTIFIER .task_interface.
		;

task_body	: TASK_ BODY_ sim_n IS_ .decl_part.
		  BEGIN_
		  seq_of_stmts
		  .frame_excptn_handlers.
		  END_ .sim_n. ';'
		;


/* 9.5 */

ent_d		: ENTRY_ IDENTIFIER                  .fml_part. ';'
		| ENTRY_ IDENTIFIER '(' dscr_rng ')' .fml_part. ';'
		;

ent_call_stmt	: ..prag.. sim_n ';' /* parameterless */
		| ..prag.. selected_cmpon ';' /* parameterless */
		| ..prag.. idxed_cmpon ';' /* with parameters */
		;

accept_stmt	: ACCEPT_ sim_n .Pent_idx_P..fml_part.
		  .DO__seq_of_stmts__END.sim_n.. ';'
		;

ent_idx		: expr
		;


/* 9.6 */

delay_stmt	: DELAY_ sim_expr ';'
		;


/* 9.7 */

select_stmt	: selec_wait
		| condal_ent_call
		| timed_ent_call
		;


/* 9.7.1 */

selec_wait	: SELECT_ select_alts .ELSE__seq_of_stmts. END_ SELECT_ ';'
		;

select_alts	: select_alt
		| select_alts OR_ select_alts
		;

select_alt	: selec_wait_alt
		| WHEN_ cond ARROW_ selec_wait_alt
		;

selec_wait_alt	: accept_alt
		| delay_alt
		| terminate_alt
		;

accept_alt	: ..prag.. accept_stmt .seq_of_stmts.
		;

delay_alt	: ..prag.. delay_stmt .seq_of_stmts.
		;

terminate_alt	: ..prag.. TERMINATE_ ';' ..prag..
		;


/* 9.7.2 */

condal_ent_call	: SELECT_ ent_call_stmt .seq_of_stmts.
		  ELSE_ seq_of_stmts END_ SELECT_ ';'
		;


/* 9.7.3 */

timed_ent_call	: SELECT_ ent_call_stmt .seq_of_stmts.
		  OR_ delay_alt END_ SELECT_ ';'
		;


/* 9.10 */

abort_stmt	: ABORT_ names ';'
		;

names		: name
		| names ',' name
		;


/* 10.1 */

compilation	: compilation_units
		;

compilation_units	: ..prag..
		| compilation_units compilation_unit
		;

compilation_unit: ..context_cl.. library_unit ..prag..
		| ..context_cl.. secondary_unit ..prag..
		;

library_unit	: subprg_d
		| pkg_d
		| gen_d
		| gen_inst
		| subprg_body
		;

secondary_unit	: library_unit_body
		| subunit
		;

library_unit_body	: pkg_body
/*		| subprg_body /* already contained in 'library_unit' */
		;


/* 10.1.1 */

context_cl	: with_cl
		| context_cl use_cl
		| context_cl prag
		;

with_cl		: WITH_ sim_ns ';'
		;

sim_ns		: sim_n
		| sim_ns ',' sim_n
		;


/* 10.2 */

body_stub	: subprg_spec          IS_ SEPARATE_ ';'
		| PACKAGE_ BODY_ sim_n IS_ SEPARATE_ ';'
		| TASK_    BODY_ sim_n IS_ SEPARATE_ ';'
		;

subunit		: SEPARATE_ '(' expanded_n ')' proper_body
		;


/* 11.1 */

excptn_d	: idents ':' EXCEPTION_ ';'
		;


/* 11.2 */

excptn_handler	: WHEN_ excptn_choices ARROW_ seq_of_stmts
		  /* Pragmas after 'excptn_handler' are in 'seq_of_stmts' at */
		  /* end of rhs */
		;

excptn_choices	: excptn_choice
		| excptn_choices '|' excptn_choice
		;

excptn_choice	: expanded_n
		| OTHERS_
		;


/* 11.3 */

raise_stmt	: RAISE_ .expanded_n. ';'
		;


/* 12.1 */

gen_d		: gen_spec ';'
		;

gen_spec	: gen_fml_part subprg_spec
		| gen_fml_part pkg_spec
		;

gen_fml_part	: GENERIC_ ..gen_prm_d..
		;

gen_prm_d	: idents ':' .IN.OUT.. ty_mk .ASSIGN_expr. ';'
		| TYPE_ IDENTIFIER
		  .discr_part. /* .discr_part. must be empty; added only
				  to resolve a shift/reduce ambiguity */
		  IS_ gen_ty_def ';'
		| priv_ty_d
		| WITH_ subprg_spec ';'
		| WITH_ subprg_spec IS_ BOX_ ';'
		| WITH_ subprg_spec IS_ name ';'
		;

gen_ty_def	: '(' BOX_ ')'
		| RANGE_ BOX_
		| DIGITS_ BOX_
		| DELTA_ BOX_
		| array_ty_def
		| access_ty_def
		;


/* 12.3 */

gen_inst	: PACKAGE_ IDENTIFIER  IS_ NEW_ expanded_n .gen_act_part. ';'
		| subprg_spec          IS_ NEW_ expanded_n .gen_act_part. ';'
		/* the more general 'subprg_spec' is used to avoid conflicts */
		| FUNCTION_ designator IS_ NEW_ expanded_n .gen_act_part. ';'
		;

gen_act_part	: '(' gen_ascs ')'
		;

gen_ascs	: gen_asc
		| gen_ascs ',' gen_asc
		;

gen_asc		: gen_act_prm
		| gen_fml_prm ARROW_ gen_act_prm
		;

gen_fml_prm	: sim_n
		| op_symbol
		;

gen_act_prm	: expr
/*		| name /* included under 'expr' */
/*		| subprg_n /* included under 'expr' */
/*		| ent_n /* included under 'expr' */
/*		| ty_mk /* included under 'expr' */
		;


/* 13.1 */

rep_cl		: ty_rep_cl
		| address_cl
		;

ty_rep_cl	: length_cl
		| enum_rep_cl
		| rec_rep_cl
		;


/* 13.2 */

length_cl	: FOR_ attribute USE_ sim_expr ';'
		;


/* 13.3 */

enum_rep_cl	: FOR_ sim_n USE_ aggr ';'
		;


/* 13.4 */

rec_rep_cl	: FOR_ sim_n /* 'sim_n' must be a 'ty_sim_n' */ USE_
		  RECORD_ ..prag.. .algt_cl.
		  ..cmpon_cl..
		  END_ RECORD_ ';'
		;

algt_cl		: AT_ MOD_ sim_expr ';'
		;

cmpon_cls	: cmpon_cl
		| cmpon_cls cmpon_cl
		| cmpon_cls prag
		;

cmpon_cl	: name AT_ sim_expr RANGE_ rng ';'
		;


/* 13.5 */

address_cl	: FOR_ sim_n USE_ AT_ sim_expr ';'
		;


/* 13.8 */

code_stmt	: prefix /* must be a 'ty_mk' */ '\'' aggr ';'
		;


/*----------------------------------------------------------------------*/

/* The following rules define semantically qualified symbols under more
/* general categories.

/*     ... these have been replaced logically to reduce the number    */
/*         of YACC_ nonterminal "rules"                                */

/* The following rules expand the concatenated constructs and define the */
/* specially added syntactical classes.					 */


/* 2.8 */

@.prag_arg_part.	: /* empty */
		| prag_arg_part
		;

@..prag..	: /* empty */
		| ..prag.. prag
		;


/* 3.1 */

@.ASSIGN_expr.	: /* empty */
		| ASSIGN_ expr
		;

@.constrt.	: /* empty */
		| constrt
		;

expanded_n	: IDENTIFIER
		| expanded_n '.' IDENTIFIER
		;
/* 'expanded_n' is used for names that can be written using only selectors */

@.rng_c.		: /* empty */
		| rng_c
		;


/* 3.3.1 */

@.discr_part.	: /* empty */
		| discr_part
		;


/* 3.3.2 */

idx_or_discr_c	: '(' dscr_rngs_or_discr_ascs ')'
		;

dscr_rngs_or_discr_ascs	: dscr_rng_or_discr_asc
		| dscr_rngs_or_discr_ascs ',' dscr_rng_or_discr_asc
		;

dscr_rng_or_discr_asc	: sim_expr DBLDOT_ sim_expr
/*		| name /* must be an 'attribute' */
		| name rng_c
		| expr /* includes 'name' */
		| sim_n_choices ARROW_ expr
		;


/* 3.7 */

@.cmpon_ds.	: /* empty */
		| cmpon_ds
		;


/* 3.9 */

@..basic_decl_item..	: /* empty */
		| ..basic_decl_item.. prag
		| ..basic_decl_item.. basic_decl_item
		;

@..later_decl_item..	: /* empty */
		| ..later_decl_item.. prag
		| ..later_decl_item.. later_decl_item
		;


/* 5.1 */

@..label..	: /* empty */
		| ..label.. label
		;

@..ELSIF__cond__THEN__seq_of_stmts..	: /* empty */
		| ..ELSIF__cond__THEN__seq_of_stmts..
		  ELSIF_ cond THEN_ seq_of_stmts
		;

@.ELSE__seq_of_stmts.	: /* empty */
		| ELSE_ seq_of_stmts
		;

@.sim_nC.	: /* empty */
		| sim_n ':'
		;

@.sim_n.		: /* empty */
		| sim_n
		;

@.iteration_scheme.	: /* empty */
		| iteration_scheme
		;

@.REVERSE.	: /* empty */
		| REVERSE_
		;

@.DECLARE__decl_part.	: /* empty */
		| DECLARE_ decl_part
		;

@.frame_excptn_handlers.	: /* empty */
		| EXCEPTION_ ..prag.. excptn_handlers
		/* Pragmas after 'excptn_handler' are in 'seq_of_stmts' */
		;

excptn_handlers	: excptn_handler
		| excptn_handlers excptn_handler
		;

@.expanded_n.	: /* empty */
		| expanded_n
		;

@.WHEN__cond.	: /* empty */
		| WHEN_ cond
		;

@.expr.		: /* empty */
		| expr
		;


/* 6.1 */

@.fml_part.	: /* empty */
		| fml_part
		;

@.IN.		: /* empty */
		| IN_
		;

@.decl_part.	: decl_part
		/* 'decl_part' can already be empty */
		;

@.designator.	: /* empty */
		| designator
		;


/* 7.1 */

@.LIMITED.	: /* empty */
		| LIMITED_
		;

@.private_part.	: /* empty */
		| PRIVATE_ ..basic_decl_item..
		;

@.pkg_body_init.	: /* empty */
		| BEGIN_
		  seq_of_stmts
		  .frame_excptn_handlers.
		;


/* 9.1 */

@.TYPE.		: /* empty */
		| TYPE_
		;

@.task_interface.	: /* empty */
		| IS_ ..ent_d.. ..rep_cl.. END_ .sim_n.
		;

@..ent_d..	: /* empty */
		| ..ent_d.. prag
		| ..ent_d.. ent_d
		;

@..rep_cl..	: /* empty */
		| ..rep_cl.. prag
		| ..rep_cl.. rep_cl
		;


/* 9.5 */

@.Pent_idx_P..fml_part.	: .fml_part.
		| '(' ent_idx ')' .fml_part.
		;

@.DO__seq_of_stmts__END.sim_n..	: /* empty */
		| DO_ seq_of_stmts END_ .sim_n.
		;

@.seq_of_stmts.	: ..prag..
		| seq_of_stmts
		;


/* 10.1.1 */

@..context_cl..	: /* empty */
		| ..context_cl.. context_cl
		;


/* 12.1 */

@..gen_prm_d..	: /* empty */
		| ..gen_prm_d.. gen_prm_d
		;

@.IN.OUT..	: .IN.
		| IN_ OUT_
		;

@.gen_act_part.	: /* empty */
		| gen_act_part
		;


/* 13.4 */

@.algt_cl.	: /* empty */
		| algt_cl
		;

@..cmpon_cl..	: /* empty */
		| ..prag.. cmpon_cls
		;

%%	/* start of programs */

main() {
   yyparse ();
}

yyerror(string)
char *string;
{
   fprintf (stderr, "\n>>>\n>>> %s at line %d near %s.\n>>>\n",
		    string, yylineno, yytext);
}

@EOF
set `sum $sumopt <oxDistG1.04/grammars/ada/gram.y`; if test $1 -ne 36595
then
	echo ERROR: oxDistG1.04/grammars/ada/gram.y checksum is $1 should be 36595
fi
set `wc -lwc <oxDistG1.04/grammars/ada/gram.y`
if test $1$2$3 != 1509413229335
then
	echo ERROR: wc results of oxDistG1.04/grammars/ada/gram.y are $* should be 1509 4132 29335
fi

chmod 755 oxDistG1.04/grammars/ada/gram.y

if test -f oxDistG1.04/grammars/ada/scan.l
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ada/scan.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ada/scan.l
	if test -f oxDistG1.04/grammars/ada/scan.l
	then
		echo Error: could not remove oxDistG1.04/grammars/ada/scan.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ada/scan.l
sed 's/^@//' >oxDistG1.04/grammars/ada/scan.l <<'@EOF'
%{
/*
@From shields@Stars.Reston.Paramax.COM Wed Oct  6 12:43 CDT 1993
Received: from stars.reston.paramax.com by flash.cs.iastate.edu with SMTP
	(1.37.109.6/16.2) id AA07474; Wed, 6 Oct 93 12:43:29 -0500
Received: from repos (repos.stars.reston.paramax.com) by aviary.Stars.Reston.Paramax.COM (4.1/mls/3.2) 
	id AA04910; Wed, 6 Oct 93 13:42:38 EDT
Received: by repos (4.1/mls/3.5) 
	id AA00578; Wed, 6 Oct 93 13:40:08 EDT
To: robles@dit.upm.es (Tomas Robles Valladares), Al Lau <allau@sequent.com>,
        dickey@software.org (Thomas Dickey),
        honig@dutiws.twi.tudelft.nl (J.Honig.TI-tel-4570),
        karl@grebyn.com (Karl A. Nyberg), harold@issi.com,
        Kurt Bischoff <bischoff>, Margie Price <mprice@rbse.mountain.net>
Subject: Re: Need a yaccable/lexable Ada grammar
In-Reply-To: Your message of Thu, 30 Sep 93 11:48:49 BST.
             <199309301048.AA24877@yeti.dit.upm.es> 
Return-Receipt-To: shields@Stars.Reston.Paramax.COM
Date: Wed, 06 Oct 93 13:40:07 -0400
Message-Id: <577.749929207@repos>
@From: "Thomas E. Shields" <shields@Stars.Reston.Paramax.COM>
Status: R

Kurt Bischoff said: "I wonder if the files you describe are descendent
from the ones mentioned in the comp.compilers monthly FAQ."

My answer: "I don't know - I got the original source from SIMTEL20 back
in December 1987.  I've passed these sources out several times over the
years, so the files mentioned in comp.compilers might or might not even
be these files."

Margie Price said: "I'm from the AdaNET repository, and I'll be glad to
include those in the repository.  Do you have some documentations?  I think
what I'll do is, to include your version and still keep the SIMTEL20
version.  Or, are they very similar, and you just made it work correctly?"

My answer: "All I have to offer is the lex and yacc specifications, which
are directly derived from the corresponding files I downloaded from
SIMTEL20 in December 1987.  I don't know if the SIMTEL20 files were ever
updated."

Lex specification file at the end of this message, yacc specification
follows in the next message.  Note that some of the flex-related hackery
was necessary for the version of flex available at the time, but may
no longer be necessary, as flex has matured significantly since then.
I haven't had the time or interest to update any of this, so what you
are getting is the state as of the last RCS log entries in the two files.

Tom
   --------------------------------------------------------------------------
   Thomas E. Shields, PhD, CCP        Software Engineering - 7720
   Software Technologist              Unisys Government Systems Group
   (703) 620-7028                     Systems Development/Information Systems
   (703) 620-7913 FAX                 12010 Sunrise Valley Drive
   shields@stars.reston.paramax.com   Reston, VA 22091
   --------------------------------------------------------------------------

file: ada.l
====snip====snip====snip====snip====snip====snip====snip====snip====
*/
%}
%{
/*------------------------------------------------------------------------*/
/* Lexical input for LEX for LALR(1) Grammar for ANSI Ada                 */
/*                                                                        */
/*              Herman Fischer                                            */
/*            Litton Data Systems                                         */
/*              March 26, 1984                                            */
/*                                                                        */
/*                                                                        */
static
char rcsid[] =
"$Header: scan.l,v 1.6 93/10/31 15:54:05 bischoff Exp $";
/*                                                                        */
/* $Log:	scan.l,v $
 * Revision 1.6  93/10/31  15:54:05  15:54:05  bischoff (Kurt Bischoff)
 * *** empty log message ***
 * 
 * Revision 1.5  93/10/16  15:57:44  15:57:44  bischoff (Kurt Bischoff)
 * no change
 * 
 * Revision 1.4  93/10/16  15:27:47  15:27:47  bischoff (Kurt Bischoff)
 * *** empty log message ***
 * 
 * Revision 1.3  93/10/06  20:39:59  20:39:59  bischoff (Kurt Bischoff)
 * *** empty log message ***
 * 
 * Revision 1.2  93/10/06  19:18:05  19:18:05  bischoff (Kurt Bischoff)
 * works
 * 
 * Revision 1.1  93/10/06  16:07:15  16:07:15  bischoff (Kurt Bischoff)
 * Initial revision
 * 
 * Revision 1.7  89/10/11  21:15:42  shields
 * formatting changes
 * modifications to enable use with either LEX or FLEX (FLEX generates a
 *    faster lexer than does LEX):
 *    added global declaration of 'yylineno'
 *    moved recognition of '\n' character from ignored white space set to
 *       a separate rule with an action to increment 'yylineno'
 *    (note: these changes are "#ifdef flex", since they are not compatible
 *     with LEX - FLEX doesn't do builtin 'yylineno' management, LEX does)
 * "#ifdef lex" around definition of 'yywrap()' function, which is done
 *    with a "#define" by FLEX
 * 
 * Revision 1.6  89/10/10  19:35:53  shields
 * removed "extern" definition for 'yylval', since latest version of BISON
 *    now generates it in the 'y.tab.h' file
 * 
 * Revision 1.5  88/06/11  20:20:53  shields
 * added reserved work lookup variation using perfect hash algorithm
 *    (faster than binary search variation)
 * modified existing binary search variation slightly
 * 
 * Revision 1.4  88/06/09  19:44:42  shields
 * added <ATTR> start state to distinguish those predefined attribute
 *    designators that are identical to reserved words from their use as
 *    reserved words - allows simplification of associated LALR(1) grammar
 * corrected conditions for entering <IDENT> start state - the apostrophe
 *    delimiter must be preceded by one of the token classes IDENTIFIER,
 *    CHARACTER, STRING, or ')', or the reserved work 'ALL', none of which
 *    can precede a character literal
 * 
 * Revision 1.3  87/12/29  09:24:02  shields
 * added 'extern' definition for 'yylval' - BISON doesn't put one in the
 *    'y.tab.h' file like YACC does
 * changed error message for invalid characters to come out on 'stderr'
 *    rather than 'stdout'
 * 
 * Revision 1.2  87/12/19  19:10:11  shields
 * added a LEX hack - use undocumented predefined <INITIAL> start state in
 *    place of user-defined <Z> start state to reduce size of generated tables
 * 
 * Revision 1.1  87/12/19  17:47:38  shields
 * added rules defining character substitutions as defined in LRM 2.10 -
 *    '!' for '|'; ':' for '#' in based numeric literals; '%' for '"' in
 *    string literals not containing '"'
 * added '\f' to set of ignored white space characters
 * corrected rule for ''' character literal and treatment of '_' character
 *    in identifiers and numeric literals
 * cleaned up grammar presentation format slightly - replaced complicated
 *    regular expression patterns in rules with named regular expressions
 * added RCS Header and Log keywords to source file
 * 
 * Revision 1.0  87/12/17  18:22:11  jwabik
 * original version copied from SIMTEL20
 *
 */
/*                                                                        */
/* Rewrite:  To a version that a non-supercomputer can handle (8^) by:	  */
/*           Jeff Wabik, Control Data Corporation, December 1987	  */ 
/*	     { umn-cs!shamash!jwabik }				 	  */
/*                                                                        */
/*------------------------------------------------------------------------*/
#include "y.tab.h"
#include <stdio.h>
#include <ctype.h>

#define Token(a)	(int)a

#define lex 1
#ifdef lex
#define bump_lineno /* LEX-generated lexers do this automatically */
#endif lex
#ifdef flex
int yylineno=1;
#define bump_lineno yylineno++
#endif flex

/* #define NOHASH /* to get binary search variation */
#define HASH /* to get perfect hash variation */
%}

	/* regular expression definitions */

Letter            [a-zA-Z]
Digit             [0-9]
ExtendedDigit     ({Digit})|[a-fA-F]

LetterDigit       ({Letter})|({Digit})

Identifier        ({Letter})(_?({LetterDigit}))*

Integer           ({Digit})(_?({Digit}))*
Based_Integer     ({ExtendedDigit})(_?({ExtendedDigit}))*

Integer_Fraction  [.]({Integer})
Based_Fraction    [.]({Based_Integer})

Exponent          [Ee][-+]?({Integer})

Decimal_Literal   ({Integer})({Integer_Fraction})?({Exponent})?

Based_Literal1    ({Integer})#({Based_Integer})({Based_Fraction})?#({Exponent})?
                  /* LRM 2.10(3) defines the following alternative */
Based_Literal2    ({Integer}):({Based_Integer})({Based_Fraction})?:({Exponent})?
Based_Literal     ({Based_Literal1})|({Based_Literal2})

String_Literal1   \"([^"]|(\"\"))*\"
                  /* LRM 2.10(4) defines the following alternative */
String_Literal2   %([^%"]|(%%))*%
String_Literal    ({String_Literal1})|({String_Literal2})

Character_Literal \'([^']|(\'))\'

%START IDENT ATTR

%%
"--".*			{ECHO; /* ignore comments to end-of-line */}
[\ \t\f]		{ECHO; /* ignore space, tab, and formfeed */}
[\n]			{ECHO; /* ignore newline */
			 bump_lineno; /* but count it */
			}
"=>"    		{ECHO; BEGIN INITIAL; return (ARROW_);}
".."    		{ECHO; BEGIN INITIAL; return (DBLDOT_);}
"**"    		{ECHO; BEGIN INITIAL; return (EXP_);}
":="    		{ECHO; BEGIN INITIAL; return (ASSIGN_);}
"/="    		{ECHO; BEGIN INITIAL; return (NOTEQL_);}
">="    		{ECHO; BEGIN INITIAL; return (GTEQL_);}
"<="    		{ECHO; BEGIN INITIAL; return (LTEQ_);}
"<<"    		{ECHO; BEGIN INITIAL; return (L_LBL_);}
">>"    		{ECHO; BEGIN INITIAL; return (R_LBL_);}
"<>"    		{ECHO; BEGIN INITIAL; return (BOX_);}
"&"     		{ECHO; BEGIN INITIAL; return ('&'); }
"("     		{ECHO; BEGIN INITIAL; return ('('); }
")"     		{ECHO; BEGIN IDENT;   return (')'); }
"*"     		{ECHO; BEGIN INITIAL; return ('*'); }
"+"     		{ECHO; BEGIN INITIAL; return ('+'); }
","     		{ECHO; BEGIN INITIAL; return (','); }
"-"     		{ECHO; BEGIN INITIAL; return ('-'); }
"."     		{ECHO; BEGIN INITIAL; return ('.'); }
"/"     		{ECHO; BEGIN INITIAL; return ('/'); }
":"     		{ECHO; BEGIN INITIAL; return (':'); }
";"     		{ECHO; BEGIN INITIAL; return (';'); }
"<"     		{ECHO; BEGIN INITIAL; return ('<'); }
"="     		{ECHO; BEGIN INITIAL; return ('='); }
">"     		{ECHO; BEGIN INITIAL; return ('>'); }
"|"|"!"     		{ECHO; BEGIN INITIAL; return ('|'); /* LRM 2.10(2) */}
<IDENT>'  		{ECHO; BEGIN ATTR;    return ('\'');}

<ATTR>{Identifier}	{ECHO; BEGIN IDENT;   return (IDENTIFIER);}

<INITIAL,IDENT>{Identifier} {int token = LookUp (yytext); ECHO;
			if ((token == IDENTIFIER) || (token == ALL_))
			     BEGIN IDENT;
			else BEGIN INITIAL;
			return (token);}

{Decimal_Literal}	{ECHO; BEGIN INITIAL; return (NUMERIC_LITERAL);}

{Based_Literal}		{ECHO; BEGIN INITIAL; return (NUMERIC_LITERAL);}

{String_Literal}	{ECHO; BEGIN IDENT;   return (STRING_LITERAL);}

<INITIAL>{Character_Literal} {ECHO; BEGIN IDENT; return (CHARACTER_LITERAL);}

@.       		{ECHO; fprintf (stderr,
					"Syntax error \"%s\" at line %d.\n\t",
					yytext,yylineno); }
%%

#ifdef lex
yywrap() {
	return (1);
}
#endif lex

static int new_IDENTIFIER(name)
char *name;
{
   yylval.y_str = (char *) calloc (strlen (name)+1, sizeof (char));
   strcpy (yylval.y_str, name);
   return (IDENTIFIER);
}

#ifdef lex
#define MAX_TOKEN_LENGTH (YYLMAX-1)
#endif lex
#ifdef flex
#define MAX_TOKEN_LENGTH YY_BUF_MAX
#endif flex

#ifdef NOHASH
typedef struct token_struct {
   char *token;
   int tokval;
} TOKEN;

static int LookUp(name) 
char *name; 
/* Compare what was just read in to the literal form of a reserved word.
   If there is a match, return the TOKEN of the reserved word, otherwise
   return the IDENTIFIER token. */
{
   TOKEN *tokpnt;
   extern TOKEN tokens[];
   extern unsigned num_tokens;
   int TokenCmp();
   char *MakeLower();

   if ((tokpnt = (TOKEN *) bsearch (MakeLower (name), tokens, num_tokens,
	sizeof (TOKEN), TokenCmp)) != NULL)
      return (tokpnt->tokval);
   else
      return (new_IDENTIFIER (name));
}

static int TokenCmp(str,tab_ele)
char str[];
TOKEN *tab_ele;
{
   return (strcmp (str,tab_ele->token));
}

static char *MakeLower(str)
char str[];
{
   register int i;
   static char up_str[MAX_TOKEN_LENGTH+1];

   for (i=0; str[i] != '\0'; i++)
      if (isupper(str[i]))
	 up_str[i] = tolower(str[i]);
      else
	 up_str[i] = str[i];
   up_str[i] = '\0';
   return up_str;
}

static TOKEN tokens[] = {
   "abort",	Token(ABORT_),
   "abs",	Token(ABS_),
   "accept",	Token(ACCEPT_),
   "access",	Token(ACCESS_),
   "all",	Token(ALL_),
   "and",	Token(AND_),
   "array",	Token(ARRAY_),
   "at",	Token(AT_),
   "begin",	Token(BEGIN_),
   "body",	Token(BODY_),
   "case",	Token(CASE_),
   "constant",	Token(CONSTANT_),
   "declare",	Token(DECLARE_),
   "delay",	Token(DELAY_),
   "delta",	Token(DELTA_),
   "digits",	Token(DIGITS_),
   "do",	Token(DO_),
   "else",	Token(ELSE_),
   "elsif",	Token(ELSIF_),
   "end",	Token(END_),
   "entry",	Token(ENTRY_),
   "exception",	Token(EXCEPTION_),
   "exit",	Token(EXIT_),
   "for",	Token(FOR_),
   "function",	Token(FUNCTION_),
   "generic",	Token(GENERIC_),
   "goto",	Token(GOTO_),
   "if",	Token(IF_),
   "in",	Token(IN_),
   "is",	Token(IS_),
   "limited",	Token(LIMITED_),
   "loop",	Token(LOOP_),
   "mod",	Token(MOD_),
   "new",	Token(NEW_),
   "not",	Token(NOT_),
   "null",	Token(NULL_),
   "of",	Token(OF_),
   "or",	Token(OR_),
   "others",	Token(OTHERS_),
   "out",	Token(OUT_),
   "package",	Token(PACKAGE_),
   "pragma",	Token(PRAGMA_),
   "private",	Token(PRIVATE_),
   "procedure",	Token(PROCEDURE_),
   "raise",	Token(RAISE_),
   "range",	Token(RANGE_),
   "record",	Token(RECORD_),
   "rem",	Token(REM_),
   "renames",	Token(RENAMES_),
   "return",	Token(RETURN_),
   "reverse",	Token(REVERSE_),
   "select",	Token(SELECT_),
   "separate",	Token(SEPARATE_),
   "subtype",	Token(SUBTYPE_),
   "task",	Token(TASK_),
   "terminate",	Token(TERMINATE_),
   "then",	Token(THEN_),
   "type",	Token(TYPE_),
   "use",	Token(USE_),
   "when",	Token(WHEN_),
   "while",	Token(WHILE_),
   "with",	Token(WITH_),
   "xor",	Token(XOR_),
};

static unsigned num_tokens = sizeof (tokens) / sizeof (TOKEN);
#endif NOHASH

#ifdef HASH
static int LookUp(name)
char *name;
/* Compare what was just read in to the literal form of a reserved word.
   If there is a match, return the TOKEN of the reserved word, otherwise
   return the IDENTIFIER token. */
{
   void calc_hash_vector();

   int j, id_length = strlen (name);
   static char reserved_word[MAX_TOKEN_LENGTH+1];

   int xlate_first, xlate_last, second_to_last; /* range -38 .. +56 */
   int hash_value; /* range -76 .. +171 */

   /* Ada reserved words are 2..9 characters in length. */
   /* All other tokens are not Ada reserved words.	*/

   if ((id_length > 9) || (id_length < 2)) return (new_IDENTIFIER (name));

   /* See if input characters legal and, if so, convert to lowercase */
   for (j=0; j < id_length; j++) {
      /* Reserved words have alphabetic characters only */
      if (!isalpha(name[j])) return (new_IDENTIFIER (name));
      reserved_word[j] = isupper(name[j]) ?
			  tolower(name[j])
			: name[j];
   }
   reserved_word[id_length] = '\0';

   /* Compute the hash function value. */

   /* Translate token characters into numeric values for the	*/
   /* hash function computation.				*/

   calc_hash_vector (reserved_word, &xlate_first, &xlate_last, &second_to_last);

   hash_value = xlate_first+xlate_last+(2*second_to_last)+id_length;

   /* Look up the identifier in the hash table to see if a	*/
   /* reserved word was found.					*/
   return (reserved_word_or_IDENTIFIER (hash_value, reserved_word, name));
}

#define FALSE 0
#define TRUE 1

/* This is called "XLATE array" in the paper. */
static int char_value_array[] = {
/* 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' */
    0, 49,  0, -7,-20, 18, -2,-38, 33,  0, -9,  9, 29, -9,  6,
/* 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z'		      */
   26,  0,  8,  1,  1, -9,  0, 56,-28, 11,  0
};

static void calc_hash_vector (token, xlate_first, xlate_last, second_to_last)
char *token;
int *xlate_first, *xlate_last, *second_to_last; /* range -38 .. +56 */
   /* The range here is the min and max of the individual components of
      the hashing function. */
{
   /* Given a string, compute the components of its hash function. */

   *xlate_first    = char_value_array[token[0] - (int)'a'];
   *xlate_last     = char_value_array[token[strlen (token)-1] - (int)'a'];
   *second_to_last = token[strlen (token)-2] - (int)'a';
}

static char *hash_table[72] = {
   "else",    "exit",      "end",        "at",       "then",      "range",
   "abs",     "do",        "exception",  "delay",    "use",       "xor",
   "select",  NULL,        "declare",    "type",     "array",     "limited",
   "subtype", "elsif",     "case",       "generic",  "and",       "not",
   "renames", "package",   "null",       "separate", "terminate", "raise",
   "entry",   "reverse",   "task",       NULL,       "all",       "constant",
   "delta",   "accept",    "digits",     "return",   "abort",     "record",
   "in",      "access",    "or",         "function", "goto",      "others",
   "rem",     "procedure", "out",        "private",  "is",        "mod",
   "of",      NULL,        "pragma",     "for",      "new",       "when",
   "with",    "begin",     NULL,         "while",    NULL,        NULL,
   NULL,      "loop",      NULL,         "if",       "body",      NULL
};

static int token_table[72] = {
   ELSE_,     EXIT_,       END_,         AT_,        THEN_,       RANGE_, 
   ABS_,      DO_,         EXCEPTION_,   DELAY_,     USE_,        XOR_, 
   SELECT_,   0,           DECLARE_,     TYPE_,      ARRAY_,      LIMITED_, 
   SUBTYPE_,  ELSIF_,      CASE_,        GENERIC_,   AND_,        NOT_, 
   RENAMES_,  PACKAGE_,    NULL_,        SEPARATE_,  TERMINATE_,  RAISE_, 
   ENTRY_,    REVERSE_,    TASK_,        0,          ALL_,        CONSTANT_, 
   DELTA_,    ACCEPT_,     DIGITS_,      RETURN_,    ABORT_,      RECORD_, 
   IN_,       ACCESS_,     OR_,          FUNCTION_,  GOTO_,       OTHERS_, 
   REM_,      PROCEDURE_,  OUT_,         PRIVATE_,   IS_,         MOD_, 
   OF_,       0,           PRAGMA_,      FOR_,       NEW_,        WHEN_, 
   WITH_,     BEGIN_,      0,            WHILE_,     0,           0,
   0,         LOOP_,       0,            IF_,        BODY_,       0
};

static int reserved_word_or_IDENTIFIER(hash_value, reserved_word, name)
int hash_value; /* range -76 .. +171 */
   /* The range here is the min and max values the hashing function
      can produce.  It is calculated as follows:
      -38    <= xlate_first					<= 56
      -38-38 <= xlate_first+xlate_last				<= 56+56
      -76-0  <= xlate_first+xlate_last+2*second_to_last		<= 112+(2*25)
      -76+2  <= xlate_first+xlate_last+2*second_to_last+length	<= 162+9 */

char *reserved_word, *name;
{
/* We know the hash_value for our string, and its (probably) the
   same as the hash value for the reserved word.  This routine
   answers TRUE/FALSE to "the indicated hash_value/identifier
   correspond to the proper Ada reserved word". */

   if ((hash_value < 0)
    || (hash_value >= (sizeof (hash_table)/sizeof (hash_table[0]))))
      return (new_IDENTIFIER (name));

   if (hash_table[hash_value] && !strcmp (hash_table[hash_value], reserved_word))
      return (token_table [hash_value]);
   else
      return (new_IDENTIFIER (name));
}
#endif HASH

@EOF
set `sum $sumopt <oxDistG1.04/grammars/ada/scan.l`; if test $1 -ne 58552
then
	echo ERROR: oxDistG1.04/grammars/ada/scan.l checksum is $1 should be 58552
fi
set `wc -lwc <oxDistG1.04/grammars/ada/scan.l`
if test $1$2$3 != 523229919377
then
	echo ERROR: wc results of oxDistG1.04/grammars/ada/scan.l are $* should be 523 2299 19377
fi

chmod 755 oxDistG1.04/grammars/ada/scan.l

echo mkdir - oxDistG1.04/grammars/ada/samples
mkdir oxDistG1.04/grammars/ada/samples

if test -f oxDistG1.04/grammars/ada/samples/hello.a
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ada/samples/hello.a\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ada/samples/hello.a
	if test -f oxDistG1.04/grammars/ada/samples/hello.a
	then
		echo Error: could not remove oxDistG1.04/grammars/ada/samples/hello.a, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ada/samples/hello.a
cat >oxDistG1.04/grammars/ada/samples/hello.a <<'@EOF'
with TEXT_IO;  use TEXT_IO;

procedure hello is
begin

      Put_Line("hello, world");

end hello;
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ada/samples/hello.a`; if test $1 -ne 14430
then
	echo ERROR: oxDistG1.04/grammars/ada/samples/hello.a checksum is $1 should be 14430
fi
set `wc -lwc <oxDistG1.04/grammars/ada/samples/hello.a`
if test $1$2$3 != 81299
then
	echo ERROR: wc results of oxDistG1.04/grammars/ada/samples/hello.a are $* should be 8 12 99
fi

chmod 755 oxDistG1.04/grammars/ada/samples/hello.a

if test -f oxDistG1.04/grammars/ada/samples/expr.a
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ada/samples/expr.a\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ada/samples/expr.a
	if test -f oxDistG1.04/grammars/ada/samples/expr.a
	then
		echo Error: could not remove oxDistG1.04/grammars/ada/samples/expr.a, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ada/samples/expr.a
cat >oxDistG1.04/grammars/ada/samples/expr.a <<'@EOF'
procedure foo is
  i:integer;
begin
  i := (5);
  i := 6;
end foo;
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ada/samples/expr.a`; if test $1 -ne 51429
then
	echo ERROR: oxDistG1.04/grammars/ada/samples/expr.a checksum is $1 should be 51429
fi
set `wc -lwc <oxDistG1.04/grammars/ada/samples/expr.a`
if test $1$2$3 != 61367
then
	echo ERROR: wc results of oxDistG1.04/grammars/ada/samples/expr.a are $* should be 6 13 67
fi

chmod 755 oxDistG1.04/grammars/ada/samples/expr.a

chmod 755 oxDistG1.04/grammars/ada/samples

chmod 755 oxDistG1.04/grammars/ada

echo mkdir - oxDistG1.04/grammars/c
mkdir oxDistG1.04/grammars/c

echo mkdir - oxDistG1.04/grammars/c/RCS
mkdir oxDistG1.04/grammars/c/RCS

if test -f oxDistG1.04/grammars/c/RCS/Makefile,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/RCS/Makefile,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/RCS/Makefile,v
	if test -f oxDistG1.04/grammars/c/RCS/Makefile,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c/RCS/Makefile,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/RCS/Makefile,v
sed 's/^@//' >oxDistG1.04/grammars/c/RCS/Makefile,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @# @;


1.3
date     93.11.07.01.16.47;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.16.18.48.14;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.16.17.47.42;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@Jeff Lee's original C grammar, to be adapted to Ox.
@@


1.3
log
@@*** empty log message ***
@@
text
@@YFLAGS	= -dv
CFLAGS	=  
LFLAGS	=
CLIBS   =
OXFLAGS =
# CLIBS   = -lcurses -ltermcap
# OXFLAGS = -T

SRC	= gram.y scan.l main.c
OBJ	= gram.o scan.o main.o

ansi_c :	$(OBJ)
	cc $(CFLAGS) $(OBJ) -o ansi_c $(CLIBS)

oxout.y oxout.l: gram.y scan.l
	ox $(OXFLAGS) gram.y scan.l

y.tab.c:oxout.y
	yacc -dv oxout.y

lex.yy.c:oxout.l
	lex oxout.l

gram.o  : y.tab.c
	cc -c y.tab.c; mv y.tab.o gram.o

scan.o	: lex.yy.c y.tab.h
	cc -c lex.yy.c; mv lex.yy.o scan.o

main.o  : main.c
	cc -c main.c

gram.y: RCS/gram.y,v
	co gram.y

scan.l: RCS/scan.l,v
	co scan.l 

main.c: RCS/main.c,v
	co main.c 

clean	:
	rm -f y.tab.h y.tab.c y.output lex.yy.c oxout* *.o

@@


1.2
log
@@*** empty log message ***
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@d2 1
a2 1
CFLAGS	= -O
d4 4
d12 2
a13 2
$(BIN)/ansi_c :	$(OBJ)
	cc $(CFLAGS) $(OBJ)/ansi_c
d15 2
a16 1
scan.o	: y.tab.h
d18 24
d43 2
a44 1
	rm -f y.tab.h y.output *.o
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/RCS/Makefile,v`; if test $1 -ne 1437
then
	echo ERROR: oxDistG1.04/grammars/c/RCS/Makefile,v checksum is $1 should be 1437
fi
set `wc -lwc <oxDistG1.04/grammars/c/RCS/Makefile,v`
if test $1$2$3 != 1092221353
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/RCS/Makefile,v are $* should be 109 222 1353
fi

chmod 755 oxDistG1.04/grammars/c/RCS/Makefile,v

if test -f oxDistG1.04/grammars/c/RCS/README,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/RCS/README,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/RCS/README,v
	if test -f oxDistG1.04/grammars/c/RCS/README,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c/RCS/README,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/RCS/README,v
sed 's/^@//' >oxDistG1.04/grammars/c/RCS/README,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @# @;


1.3
date     93.11.07.01.16.52;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.16.18.48.23;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.16.17.48.55;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@Jeff Lee's original C grammar, to be adapted to Ox.
@@


1.3
log
@@*** empty log message ***
@@
text
@@$Header: README,v 1.2 93/10/16 18:48:23 bischoff Exp $

The code in this directory originated as a Yacc/Lex specification 
for a parser for the C language.  It came from an archive mentioned 
in the comp.compilers monthly message.  It was built by Jeff Lee. 

This is an adaptation for use with Ox of Jeff Lee's code.  The Yacc 
input specification file `gram.y', the Lex input specification file 
`scan.l', and the main program file `main.c' are unchanged from the
original.  Only `Makefile' and this `README' have been modified.  All 
of the originals are in the RCS directory as revision 1.1.  

Inputting the original files to Ox results in a parser that behaves
in every way as the original Yacc/Lex parser, except that it builds
a `dummy' parse tree, (i.e., one without attributes).  `gram.y' and
`scan.l' are ready for augmentation with Ox constructs, which results
in a parser that constructs a parse tree bearing inherited and/or
synthesized attributes.  Code for tree construction, decoration,
and traversal are generated automatically by Ox.  For further 
information, see the Ox Tuturial Introduction and the Ox User
Reference Manual, which accompany the Ox distribution.  
 
Below the line of asterisks is the  text of Jeff Lee's original `README'.  

--Kurt Bischoff, Sat Oct 16 14:38:18 EDT 1993
*************************************************************************


The files in this directory contain the ANSI C grammar from the April 30, 1985
draft of the proposed standard. This copy also incorporates all bug fixes I
have seen since the last two postings. With a little work this grammar can
be made to parse the C that most of us know and love (sort of).

There is one bug fix to the grammar that is in this posting. On line 295
of gram.y it previously read declaration_specifiers instead of
type_specifier_list as it does now. I believe the folks at the ANSI committee
made a mistake since if you replace the line with what the original read
you will end up with 16 shift/reduce errors and 2 reduce/reduce errors
(the good ones). As it is, it only has 1 shift/reduce error that occurs
on the if/else construct. YACC creates the correct parser and I don't want
to ugly my grammar up.

Anyway, all cumquats unite and generate this sucker. Then just sit and play
with it. Remember, the grammar accepts things like

	"Hello, world"++;
	--1.23456;
	*'a'

but this is not a bug, but simply a shuffling of the checking into the
semantic analysis. If you want to hack it up to do lvalue and rvalue
checking, I'm sure the ANSI committee would be glad to have your changes.
Don't send'em to me though. I don't want'em. Wear this in good health.

Jeff Lee
gatech!jeff	jeff@@gatech	jeff%gatech.CSNet@@CSNet-Relay.ARPA
@@


1.2
log
@@*** empty log message ***
@@
text
@@d1 1
a1 1
$Header$
@@


1.1
log
@@Initial revision
@@
text
@@d1 28
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/RCS/README,v`; if test $1 -ne 36497
then
	echo ERROR: oxDistG1.04/grammars/c/RCS/README,v checksum is $1 should be 36497
fi
set `wc -lwc <oxDistG1.04/grammars/c/RCS/README,v`
if test $1$2$3 != 1105353296
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/RCS/README,v are $* should be 110 535 3296
fi

chmod 755 oxDistG1.04/grammars/c/RCS/README,v

if test -f oxDistG1.04/grammars/c/RCS/gram.y,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/RCS/gram.y,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/RCS/gram.y,v
	if test -f oxDistG1.04/grammars/c/RCS/gram.y,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c/RCS/gram.y,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/RCS/gram.y,v
sed 's/^@//' >oxDistG1.04/grammars/c/RCS/gram.y,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.11.07.01.16.57;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.16.18.48.43;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.16.17.49.09;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@Jeff Lee's original C grammar, to be adapted to Ox.
@@


1.3
log
@@changed VOID to VOIDx to avoid conflicts with curses library
@@
text
@@%token IDENTIFIER CONSTANT STRING_LITERAL SIZEOF
%token PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP
%token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN
%token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN
%token XOR_ASSIGN OR_ASSIGN TYPE_NAME

%token TYPEDEF EXTERN STATIC AUTO REGISTER
%token CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE CONST VOLATILE VOIDx
%token STRUCT UNION ENUM ELIPSIS RANGE

%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN

%start file
%%

primary_expr
	: identifier
	| CONSTANT
	| STRING_LITERAL
	| '(' expr ')'
	;

postfix_expr
	: primary_expr
	| postfix_expr '[' expr ']'
	| postfix_expr '(' ')'
	| postfix_expr '(' argument_expr_list ')'
	| postfix_expr '.' identifier
	| postfix_expr PTR_OP identifier
	| postfix_expr INC_OP
	| postfix_expr DEC_OP
	;

argument_expr_list
	: assignment_expr
	| argument_expr_list ',' assignment_expr
	;

unary_expr
	: postfix_expr
	| INC_OP unary_expr
	| DEC_OP unary_expr
	| unary_operator cast_expr
	| SIZEOF unary_expr
	| SIZEOF '(' type_name ')'
	;

unary_operator
	: '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'
	;

cast_expr
	: unary_expr
	| '(' type_name ')' cast_expr
	;

multiplicative_expr
	: cast_expr
	| multiplicative_expr '*' cast_expr
	| multiplicative_expr '/' cast_expr
	| multiplicative_expr '%' cast_expr
	;

additive_expr
	: multiplicative_expr
	| additive_expr '+' multiplicative_expr
	| additive_expr '-' multiplicative_expr
	;

shift_expr
	: additive_expr
	| shift_expr LEFT_OP additive_expr
	| shift_expr RIGHT_OP additive_expr
	;

relational_expr
	: shift_expr
	| relational_expr '<' shift_expr
	| relational_expr '>' shift_expr
	| relational_expr LE_OP shift_expr
	| relational_expr GE_OP shift_expr
	;

equality_expr
	: relational_expr
	| equality_expr EQ_OP relational_expr
	| equality_expr NE_OP relational_expr
	;

and_expr
	: equality_expr
	| and_expr '&' equality_expr
	;

exclusive_or_expr
	: and_expr
	| exclusive_or_expr '^' and_expr
	;

inclusive_or_expr
	: exclusive_or_expr
	| inclusive_or_expr '|' exclusive_or_expr
	;

logical_and_expr
	: inclusive_or_expr
	| logical_and_expr AND_OP inclusive_or_expr
	;

logical_or_expr
	: logical_and_expr
	| logical_or_expr OR_OP logical_and_expr
	;

conditional_expr
	: logical_or_expr
	| logical_or_expr '?' logical_or_expr ':' conditional_expr
	;

assignment_expr
	: conditional_expr
	| unary_expr assignment_operator assignment_expr
	;

assignment_operator
	: '='
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	| LEFT_ASSIGN
	| RIGHT_ASSIGN
	| AND_ASSIGN
	| XOR_ASSIGN
	| OR_ASSIGN
	;

expr
	: assignment_expr
	| expr ',' assignment_expr
	;

constant_expr
	: conditional_expr
	;

declaration
	: declaration_specifiers ';'
	| declaration_specifiers init_declarator_list ';'
	;

declaration_specifiers
	: storage_class_specifier
	| storage_class_specifier declaration_specifiers
	| type_specifier
	| type_specifier declaration_specifiers
	;

init_declarator_list
	: init_declarator
	| init_declarator_list ',' init_declarator
	;

init_declarator
	: declarator
	| declarator '=' initializer
	;

storage_class_specifier
	: TYPEDEF
	| EXTERN
	| STATIC
	| AUTO
	| REGISTER
	;

type_specifier
	: CHAR
	| SHORT
	| INT
	| LONG
	| SIGNED
	| UNSIGNED
	| FLOAT
	| DOUBLE
	| CONST
	| VOLATILE
	| VOIDx
	| struct_or_union_specifier
	| enum_specifier
	| TYPE_NAME
	;

struct_or_union_specifier
	: struct_or_union identifier '{' struct_declaration_list '}'
	| struct_or_union '{' struct_declaration_list '}'
	| struct_or_union identifier
	;

struct_or_union
	: STRUCT
	| UNION
	;

struct_declaration_list
	: struct_declaration
	| struct_declaration_list struct_declaration
	;

struct_declaration
	: type_specifier_list struct_declarator_list ';'
	;

struct_declarator_list
	: struct_declarator
	| struct_declarator_list ',' struct_declarator
	;

struct_declarator
	: declarator
	| ':' constant_expr
	| declarator ':' constant_expr
	;

enum_specifier
	: ENUM '{' enumerator_list '}'
	| ENUM identifier '{' enumerator_list '}'
	| ENUM identifier
	;

enumerator_list
	: enumerator
	| enumerator_list ',' enumerator
	;

enumerator
	: identifier
	| identifier '=' constant_expr
	;

declarator
	: declarator2
	| pointer declarator2
	;

declarator2
	: identifier
	| '(' declarator ')'
	| declarator2 '[' ']'
	| declarator2 '[' constant_expr ']'
	| declarator2 '(' ')'
	| declarator2 '(' parameter_type_list ')'
	| declarator2 '(' parameter_identifier_list ')'
	;

pointer
	: '*'
	| '*' type_specifier_list
	| '*' pointer
	| '*' type_specifier_list pointer
	;

type_specifier_list
	: type_specifier
	| type_specifier_list type_specifier
	;

parameter_identifier_list
	: identifier_list
	| identifier_list ',' ELIPSIS
	;

identifier_list
	: identifier
	| identifier_list ',' identifier
	;

parameter_type_list
	: parameter_list
	| parameter_list ',' ELIPSIS
	;

parameter_list
	: parameter_declaration
	| parameter_list ',' parameter_declaration
	;

parameter_declaration
	: type_specifier_list declarator
	| type_name
	;

type_name
	: type_specifier_list
	| type_specifier_list abstract_declarator
	;

abstract_declarator
	: pointer
	| abstract_declarator2
	| pointer abstract_declarator2
	;

abstract_declarator2
	: '(' abstract_declarator ')'
	| '[' ']'
	| '[' constant_expr ']'
	| abstract_declarator2 '[' ']'
	| abstract_declarator2 '[' constant_expr ']'
	| '(' ')'
	| '(' parameter_type_list ')'
	| abstract_declarator2 '(' ')'
	| abstract_declarator2 '(' parameter_type_list ')'
	;

initializer
	: assignment_expr
	| '{' initializer_list '}'
	| '{' initializer_list ',' '}'
	;

initializer_list
	: initializer
	| initializer_list ',' initializer
	;

statement
	: labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;

labeled_statement
	: identifier ':' statement
	| CASE constant_expr ':' statement
	| DEFAULT ':' statement
	;

compound_statement
	: '{' '}'
	| '{' statement_list '}'
	| '{' declaration_list '}'
	| '{' declaration_list statement_list '}'
	;

declaration_list
	: declaration
	| declaration_list declaration
	;

statement_list
	: statement
	| statement_list statement
	;

expression_statement
	: ';'
	| expr ';'
	;

selection_statement
	: IF '(' expr ')' statement
	| IF '(' expr ')' statement ELSE statement
	| SWITCH '(' expr ')' statement
	;

iteration_statement
	: WHILE '(' expr ')' statement
	| DO statement WHILE '(' expr ')' ';'
	| FOR '(' ';' ';' ')' statement
	| FOR '(' ';' ';' expr ')' statement
	| FOR '(' ';' expr ';' ')' statement
	| FOR '(' ';' expr ';' expr ')' statement
	| FOR '(' expr ';' ';' ')' statement
	| FOR '(' expr ';' ';' expr ')' statement
	| FOR '(' expr ';' expr ';' ')' statement
	| FOR '(' expr ';' expr ';' expr ')' statement
	;

jump_statement
	: GOTO identifier ';'
	| CONTINUE ';'
	| BREAK ';'
	| RETURN ';'
	| RETURN expr ';'
	;

file
	: external_definition
	| file external_definition
	;

external_definition
	: function_definition
	| declaration
	;

function_definition
	: declarator function_body
	| declaration_specifiers declarator function_body
	;

function_body
	: compound_statement
	| declaration_list compound_statement
	;

identifier
	: IDENTIFIER
	;
%%

#include <stdio.h>

extern char yytext[];
extern int column;

yyerror(s)
char *s;
{
	fflush(stdout);
	printf("\n%*s\n%*s\n", column, "^", column, s);
}
@@


1.2
log
@@no change
@@
text
@@d8 1
a8 1
%token CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE CONST VOLATILE VOID
d194 1
a194 1
	| VOID
@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/RCS/gram.y,v`; if test $1 -ne 23920
then
	echo ERROR: oxDistG1.04/grammars/c/RCS/gram.y,v checksum is $1 should be 23920
fi
set `wc -lwc <oxDistG1.04/grammars/c/RCS/gram.y,v`
if test $1$2$3 != 48810268021
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/RCS/gram.y,v are $* should be 488 1026 8021
fi

chmod 755 oxDistG1.04/grammars/c/RCS/gram.y,v

if test -f oxDistG1.04/grammars/c/RCS/main.c,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/RCS/main.c,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/RCS/main.c,v
	if test -f oxDistG1.04/grammars/c/RCS/main.c,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c/RCS/main.c,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/RCS/main.c,v
sed 's/^@//' >oxDistG1.04/grammars/c/RCS/main.c,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.11.07.01.17.48;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.16.18.48.50;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.16.17.49.15;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@Jeff Lee's original C grammar, to be adapted to Ox.
@@


1.3
log
@@*** empty log message ***
@@
text
@@main()
{
	int yyparse();

	return(yyparse());
}
@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/RCS/main.c,v`; if test $1 -ne 11541
then
	echo ERROR: oxDistG1.04/grammars/c/RCS/main.c,v checksum is $1 should be 11541
fi
set `wc -lwc <oxDistG1.04/grammars/c/RCS/main.c,v`
if test $1$2$3 != 5688571
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/RCS/main.c,v are $* should be 56 88 571
fi

chmod 755 oxDistG1.04/grammars/c/RCS/main.c,v

if test -f oxDistG1.04/grammars/c/RCS/scan.l,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/RCS/scan.l,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/RCS/scan.l,v
	if test -f oxDistG1.04/grammars/c/RCS/scan.l,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c/RCS/scan.l,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/RCS/scan.l,v
sed 's/^@//' >oxDistG1.04/grammars/c/RCS/scan.l,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.11.07.01.17.52;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.16.18.48.57;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.16.17.49.21;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@Jeff Lee's original C grammar, to be adapted to Ox.
@@


1.3
log
@@
changed VOID to VOIDx to avoid conflict with curses library.
@@
text
@@D			[0-9]
L			[a-zA-Z_]
H			[a-fA-F0-9]
E			[Ee][+-]?{D}+
FS			(f|F|l|L)
IS			(u|U|l|L)*

%{
#include <stdio.h>
#include "y.tab.h"

void count();
%}

%%
"/*"			{ comment(); }

"auto"			{ count(); return(AUTO); }
"break"			{ count(); return(BREAK); }
"case"			{ count(); return(CASE); }
"char"			{ count(); return(CHAR); }
"const"			{ count(); return(CONST); }
"continue"		{ count(); return(CONTINUE); }
"default"		{ count(); return(DEFAULT); }
"do"			{ count(); return(DO); }
"double"		{ count(); return(DOUBLE); }
"else"			{ count(); return(ELSE); }
"enum"			{ count(); return(ENUM); }
"extern"		{ count(); return(EXTERN); }
"float"			{ count(); return(FLOAT); }
"for"			{ count(); return(FOR); }
"goto"			{ count(); return(GOTO); }
"if"			{ count(); return(IF); }
"int"			{ count(); return(INT); }
"long"			{ count(); return(LONG); }
"register"		{ count(); return(REGISTER); }
"return"		{ count(); return(RETURN); }
"short"			{ count(); return(SHORT); }
"signed"		{ count(); return(SIGNED); }
"sizeof"		{ count(); return(SIZEOF); }
"static"		{ count(); return(STATIC); }
"struct"		{ count(); return(STRUCT); }
"switch"		{ count(); return(SWITCH); }
"typedef"		{ count(); return(TYPEDEF); }
"union"			{ count(); return(UNION); }
"unsigned"		{ count(); return(UNSIGNED); }
"void"			{ count(); return(VOIDx); }
"volatile"		{ count(); return(VOLATILE); }
"while"			{ count(); return(WHILE); }

{L}({L}|{D})*		{ count(); return(check_type()); }

0[xX]{H}+{IS}?		{ count(); return(CONSTANT); }
0[xX]{H}+{IS}?		{ count(); return(CONSTANT); }
0{D}+{IS}?		{ count(); return(CONSTANT); }
0{D}+{IS}?		{ count(); return(CONSTANT); }
{D}+{IS}?		{ count(); return(CONSTANT); }
{D}+{IS}?		{ count(); return(CONSTANT); }
'(\\.|[^\\'])+'		{ count(); return(CONSTANT); }

{D}+{E}{FS}?		{ count(); return(CONSTANT); }
{D}*"."{D}+({E})?{FS}?	{ count(); return(CONSTANT); }
{D}+"."{D}*({E})?{FS}?	{ count(); return(CONSTANT); }

\"(\\.|[^\\"])*\"	{ count(); return(STRING_LITERAL); }

">>="			{ count(); return(RIGHT_ASSIGN); }
"<<="			{ count(); return(LEFT_ASSIGN); }
"+="			{ count(); return(ADD_ASSIGN); }
"-="			{ count(); return(SUB_ASSIGN); }
"*="			{ count(); return(MUL_ASSIGN); }
"/="			{ count(); return(DIV_ASSIGN); }
"%="			{ count(); return(MOD_ASSIGN); }
"&="			{ count(); return(AND_ASSIGN); }
"^="			{ count(); return(XOR_ASSIGN); }
"|="			{ count(); return(OR_ASSIGN); }
">>"			{ count(); return(RIGHT_OP); }
"<<"			{ count(); return(LEFT_OP); }
"++"			{ count(); return(INC_OP); }
"--"			{ count(); return(DEC_OP); }
"->"			{ count(); return(PTR_OP); }
"&&"			{ count(); return(AND_OP); }
"||"			{ count(); return(OR_OP); }
"<="			{ count(); return(LE_OP); }
">="			{ count(); return(GE_OP); }
"=="			{ count(); return(EQ_OP); }
"!="			{ count(); return(NE_OP); }
";"			{ count(); return(';'); }
"{"			{ count(); return('{'); }
"}"			{ count(); return('}'); }
","			{ count(); return(','); }
":"			{ count(); return(':'); }
"="			{ count(); return('='); }
"("			{ count(); return('('); }
")"			{ count(); return(')'); }
"["			{ count(); return('['); }
"]"			{ count(); return(']'); }
"."			{ count(); return('.'); }
"&"			{ count(); return('&'); }
"!"			{ count(); return('!'); }
"~"			{ count(); return('~'); }
"-"			{ count(); return('-'); }
"+"			{ count(); return('+'); }
"*"			{ count(); return('*'); }
"/"			{ count(); return('/'); }
"%"			{ count(); return('%'); }
"<"			{ count(); return('<'); }
">"			{ count(); return('>'); }
"^"			{ count(); return('^'); }
"|"			{ count(); return('|'); }
"?"			{ count(); return('?'); }

[ \t\v\n\f]		{ count(); }
@.			{ /* ignore bad characters */ }

%%

yywrap()
{
	return(1);
}

comment()
{
	char c, c1;

loop:
	while ((c = input()) != '*' && c != 0)
		putchar(c);

	if ((c1 = input()) != '/' && c != 0)
	{
		unput(c1);
		goto loop;
	}

	if (c != 0)
		putchar(c1);
}

int column = 0;

void count()
{
	int i;

	for (i = 0; yytext[i] != '\0'; i++)
		if (yytext[i] == '\n')
			column = 0;
		else if (yytext[i] == '\t')
			column += 8 - (column % 8);
		else
			column++;

	ECHO;
}

int check_type()
{
/*
* pseudo code --- this is what it should check
*
*	if (yytext == type_name)
*		return(TYPE_NAME);
*
*	return(IDENTIFIER);
*/

/*
*	it actually will only return IDENTIFIER
*/

	return(IDENTIFIER);
}
@@


1.2
log
@@no change
@@
text
@@d47 1
a47 1
"void"			{ count(); return(VOID); }
@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/RCS/scan.l,v`; if test $1 -ne 23537
then
	echo ERROR: oxDistG1.04/grammars/c/RCS/scan.l,v checksum is $1 should be 23537
fi
set `wc -lwc <oxDistG1.04/grammars/c/RCS/scan.l,v`
if test $1$2$3 != 2287004852
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/RCS/scan.l,v are $* should be 228 700 4852
fi

chmod 755 oxDistG1.04/grammars/c/RCS/scan.l,v

chmod 755 oxDistG1.04/grammars/c/RCS

if test -f oxDistG1.04/grammars/c/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/Makefile
	if test -f oxDistG1.04/grammars/c/Makefile
	then
		echo Error: could not remove oxDistG1.04/grammars/c/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/Makefile
cat >oxDistG1.04/grammars/c/Makefile <<'@EOF'
YFLAGS	= -dv
CFLAGS	=  
LFLAGS	=
CLIBS   =
OXFLAGS =
# CLIBS   = -lcurses -ltermcap
# OXFLAGS = -T

SRC	= gram.y scan.l main.c
OBJ	= gram.o scan.o main.o

ansi_c :	$(OBJ)
	cc $(CFLAGS) $(OBJ) -o ansi_c $(CLIBS)

oxout.y oxout.l: gram.y scan.l
	ox $(OXFLAGS) gram.y scan.l

y.tab.c:oxout.y
	yacc -dv oxout.y

lex.yy.c:oxout.l
	lex oxout.l

gram.o  : y.tab.c
	cc -c y.tab.c; mv y.tab.o gram.o

scan.o	: lex.yy.c y.tab.h
	cc -c lex.yy.c; mv lex.yy.o scan.o

main.o  : main.c
	cc -c main.c

gram.y: RCS/gram.y,v
	co gram.y

scan.l: RCS/scan.l,v
	co scan.l 

main.c: RCS/main.c,v
	co main.c 

clean	:
	rm -f y.tab.h y.tab.c y.output lex.yy.c oxout* *.o

@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/Makefile`; if test $1 -ne 32059
then
	echo ERROR: oxDistG1.04/grammars/c/Makefile checksum is $1 should be 32059
fi
set `wc -lwc <oxDistG1.04/grammars/c/Makefile`
if test $1$2$3 != 44101649
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/Makefile are $* should be 44 101 649
fi

chmod 755 oxDistG1.04/grammars/c/Makefile

if test -f oxDistG1.04/grammars/c/README
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/README
	if test -f oxDistG1.04/grammars/c/README
	then
		echo Error: could not remove oxDistG1.04/grammars/c/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/README
cat >oxDistG1.04/grammars/c/README <<'@EOF'
$Header: README,v 1.3 93/11/07 01:16:52 bischoff Exp $

The code in this directory originated as a Yacc/Lex specification 
for a parser for the C language.  It came from an archive mentioned 
in the comp.compilers monthly message.  It was built by Jeff Lee. 

This is an adaptation for use with Ox of Jeff Lee's code.  The Yacc 
input specification file `gram.y', the Lex input specification file 
`scan.l', and the main program file `main.c' are unchanged from the
original.  Only `Makefile' and this `README' have been modified.  All 
of the originals are in the RCS directory as revision 1.1.  

Inputting the original files to Ox results in a parser that behaves
in every way as the original Yacc/Lex parser, except that it builds
a `dummy' parse tree, (i.e., one without attributes).  `gram.y' and
`scan.l' are ready for augmentation with Ox constructs, which results
in a parser that constructs a parse tree bearing inherited and/or
synthesized attributes.  Code for tree construction, decoration,
and traversal are generated automatically by Ox.  For further 
information, see the Ox Tuturial Introduction and the Ox User
Reference Manual, which accompany the Ox distribution.  
 
Below the line of asterisks is the  text of Jeff Lee's original `README'.  

--Kurt Bischoff, Sat Oct 16 14:38:18 EDT 1993
*************************************************************************


The files in this directory contain the ANSI C grammar from the April 30, 1985
draft of the proposed standard. This copy also incorporates all bug fixes I
have seen since the last two postings. With a little work this grammar can
be made to parse the C that most of us know and love (sort of).

There is one bug fix to the grammar that is in this posting. On line 295
of gram.y it previously read declaration_specifiers instead of
type_specifier_list as it does now. I believe the folks at the ANSI committee
made a mistake since if you replace the line with what the original read
you will end up with 16 shift/reduce errors and 2 reduce/reduce errors
(the good ones). As it is, it only has 1 shift/reduce error that occurs
on the if/else construct. YACC creates the correct parser and I don't want
to ugly my grammar up.

Anyway, all cumquats unite and generate this sucker. Then just sit and play
with it. Remember, the grammar accepts things like

	"Hello, world"++;
	--1.23456;
	*'a'

but this is not a bug, but simply a shuffling of the checking into the
semantic analysis. If you want to hack it up to do lvalue and rvalue
checking, I'm sure the ANSI committee would be glad to have your changes.
Don't send'em to me though. I don't want'em. Wear this in good health.

Jeff Lee
gatech!jeff	jeff@gatech	jeff%gatech.CSNet@CSNet-Relay.ARPA
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/README`; if test $1 -ne 10591
then
	echo ERROR: oxDistG1.04/grammars/c/README checksum is $1 should be 10591
fi
set `wc -lwc <oxDistG1.04/grammars/c/README`
if test $1$2$3 != 564442731
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/README are $* should be 56 444 2731
fi

chmod 755 oxDistG1.04/grammars/c/README

if test -f oxDistG1.04/grammars/c/gram.y
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/gram.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/gram.y
	if test -f oxDistG1.04/grammars/c/gram.y
	then
		echo Error: could not remove oxDistG1.04/grammars/c/gram.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/gram.y
cat >oxDistG1.04/grammars/c/gram.y <<'@EOF'
%token IDENTIFIER CONSTANT STRING_LITERAL SIZEOF
%token PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP
%token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN
%token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN
%token XOR_ASSIGN OR_ASSIGN TYPE_NAME

%token TYPEDEF EXTERN STATIC AUTO REGISTER
%token CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE CONST VOLATILE VOIDx
%token STRUCT UNION ENUM ELIPSIS RANGE

%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN

%start file
%%

primary_expr
	: identifier
	| CONSTANT
	| STRING_LITERAL
	| '(' expr ')'
	;

postfix_expr
	: primary_expr
	| postfix_expr '[' expr ']'
	| postfix_expr '(' ')'
	| postfix_expr '(' argument_expr_list ')'
	| postfix_expr '.' identifier
	| postfix_expr PTR_OP identifier
	| postfix_expr INC_OP
	| postfix_expr DEC_OP
	;

argument_expr_list
	: assignment_expr
	| argument_expr_list ',' assignment_expr
	;

unary_expr
	: postfix_expr
	| INC_OP unary_expr
	| DEC_OP unary_expr
	| unary_operator cast_expr
	| SIZEOF unary_expr
	| SIZEOF '(' type_name ')'
	;

unary_operator
	: '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'
	;

cast_expr
	: unary_expr
	| '(' type_name ')' cast_expr
	;

multiplicative_expr
	: cast_expr
	| multiplicative_expr '*' cast_expr
	| multiplicative_expr '/' cast_expr
	| multiplicative_expr '%' cast_expr
	;

additive_expr
	: multiplicative_expr
	| additive_expr '+' multiplicative_expr
	| additive_expr '-' multiplicative_expr
	;

shift_expr
	: additive_expr
	| shift_expr LEFT_OP additive_expr
	| shift_expr RIGHT_OP additive_expr
	;

relational_expr
	: shift_expr
	| relational_expr '<' shift_expr
	| relational_expr '>' shift_expr
	| relational_expr LE_OP shift_expr
	| relational_expr GE_OP shift_expr
	;

equality_expr
	: relational_expr
	| equality_expr EQ_OP relational_expr
	| equality_expr NE_OP relational_expr
	;

and_expr
	: equality_expr
	| and_expr '&' equality_expr
	;

exclusive_or_expr
	: and_expr
	| exclusive_or_expr '^' and_expr
	;

inclusive_or_expr
	: exclusive_or_expr
	| inclusive_or_expr '|' exclusive_or_expr
	;

logical_and_expr
	: inclusive_or_expr
	| logical_and_expr AND_OP inclusive_or_expr
	;

logical_or_expr
	: logical_and_expr
	| logical_or_expr OR_OP logical_and_expr
	;

conditional_expr
	: logical_or_expr
	| logical_or_expr '?' logical_or_expr ':' conditional_expr
	;

assignment_expr
	: conditional_expr
	| unary_expr assignment_operator assignment_expr
	;

assignment_operator
	: '='
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	| LEFT_ASSIGN
	| RIGHT_ASSIGN
	| AND_ASSIGN
	| XOR_ASSIGN
	| OR_ASSIGN
	;

expr
	: assignment_expr
	| expr ',' assignment_expr
	;

constant_expr
	: conditional_expr
	;

declaration
	: declaration_specifiers ';'
	| declaration_specifiers init_declarator_list ';'
	;

declaration_specifiers
	: storage_class_specifier
	| storage_class_specifier declaration_specifiers
	| type_specifier
	| type_specifier declaration_specifiers
	;

init_declarator_list
	: init_declarator
	| init_declarator_list ',' init_declarator
	;

init_declarator
	: declarator
	| declarator '=' initializer
	;

storage_class_specifier
	: TYPEDEF
	| EXTERN
	| STATIC
	| AUTO
	| REGISTER
	;

type_specifier
	: CHAR
	| SHORT
	| INT
	| LONG
	| SIGNED
	| UNSIGNED
	| FLOAT
	| DOUBLE
	| CONST
	| VOLATILE
	| VOIDx
	| struct_or_union_specifier
	| enum_specifier
	| TYPE_NAME
	;

struct_or_union_specifier
	: struct_or_union identifier '{' struct_declaration_list '}'
	| struct_or_union '{' struct_declaration_list '}'
	| struct_or_union identifier
	;

struct_or_union
	: STRUCT
	| UNION
	;

struct_declaration_list
	: struct_declaration
	| struct_declaration_list struct_declaration
	;

struct_declaration
	: type_specifier_list struct_declarator_list ';'
	;

struct_declarator_list
	: struct_declarator
	| struct_declarator_list ',' struct_declarator
	;

struct_declarator
	: declarator
	| ':' constant_expr
	| declarator ':' constant_expr
	;

enum_specifier
	: ENUM '{' enumerator_list '}'
	| ENUM identifier '{' enumerator_list '}'
	| ENUM identifier
	;

enumerator_list
	: enumerator
	| enumerator_list ',' enumerator
	;

enumerator
	: identifier
	| identifier '=' constant_expr
	;

declarator
	: declarator2
	| pointer declarator2
	;

declarator2
	: identifier
	| '(' declarator ')'
	| declarator2 '[' ']'
	| declarator2 '[' constant_expr ']'
	| declarator2 '(' ')'
	| declarator2 '(' parameter_type_list ')'
	| declarator2 '(' parameter_identifier_list ')'
	;

pointer
	: '*'
	| '*' type_specifier_list
	| '*' pointer
	| '*' type_specifier_list pointer
	;

type_specifier_list
	: type_specifier
	| type_specifier_list type_specifier
	;

parameter_identifier_list
	: identifier_list
	| identifier_list ',' ELIPSIS
	;

identifier_list
	: identifier
	| identifier_list ',' identifier
	;

parameter_type_list
	: parameter_list
	| parameter_list ',' ELIPSIS
	;

parameter_list
	: parameter_declaration
	| parameter_list ',' parameter_declaration
	;

parameter_declaration
	: type_specifier_list declarator
	| type_name
	;

type_name
	: type_specifier_list
	| type_specifier_list abstract_declarator
	;

abstract_declarator
	: pointer
	| abstract_declarator2
	| pointer abstract_declarator2
	;

abstract_declarator2
	: '(' abstract_declarator ')'
	| '[' ']'
	| '[' constant_expr ']'
	| abstract_declarator2 '[' ']'
	| abstract_declarator2 '[' constant_expr ']'
	| '(' ')'
	| '(' parameter_type_list ')'
	| abstract_declarator2 '(' ')'
	| abstract_declarator2 '(' parameter_type_list ')'
	;

initializer
	: assignment_expr
	| '{' initializer_list '}'
	| '{' initializer_list ',' '}'
	;

initializer_list
	: initializer
	| initializer_list ',' initializer
	;

statement
	: labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;

labeled_statement
	: identifier ':' statement
	| CASE constant_expr ':' statement
	| DEFAULT ':' statement
	;

compound_statement
	: '{' '}'
	| '{' statement_list '}'
	| '{' declaration_list '}'
	| '{' declaration_list statement_list '}'
	;

declaration_list
	: declaration
	| declaration_list declaration
	;

statement_list
	: statement
	| statement_list statement
	;

expression_statement
	: ';'
	| expr ';'
	;

selection_statement
	: IF '(' expr ')' statement
	| IF '(' expr ')' statement ELSE statement
	| SWITCH '(' expr ')' statement
	;

iteration_statement
	: WHILE '(' expr ')' statement
	| DO statement WHILE '(' expr ')' ';'
	| FOR '(' ';' ';' ')' statement
	| FOR '(' ';' ';' expr ')' statement
	| FOR '(' ';' expr ';' ')' statement
	| FOR '(' ';' expr ';' expr ')' statement
	| FOR '(' expr ';' ';' ')' statement
	| FOR '(' expr ';' ';' expr ')' statement
	| FOR '(' expr ';' expr ';' ')' statement
	| FOR '(' expr ';' expr ';' expr ')' statement
	;

jump_statement
	: GOTO identifier ';'
	| CONTINUE ';'
	| BREAK ';'
	| RETURN ';'
	| RETURN expr ';'
	;

file
	: external_definition
	| file external_definition
	;

external_definition
	: function_definition
	| declaration
	;

function_definition
	: declarator function_body
	| declaration_specifiers declarator function_body
	;

function_body
	: compound_statement
	| declaration_list compound_statement
	;

identifier
	: IDENTIFIER
	;
%%

#include <stdio.h>

extern char yytext[];
extern int column;

yyerror(s)
char *s;
{
	fflush(stdout);
	printf("\n%*s\n%*s\n", column, "^", column, s);
}
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/gram.y`; if test $1 -ne 48591
then
	echo ERROR: oxDistG1.04/grammars/c/gram.y checksum is $1 should be 48591
fi
set `wc -lwc <oxDistG1.04/grammars/c/gram.y`
if test $1$2$3 != 4329177355
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/gram.y are $* should be 432 917 7355
fi

chmod 755 oxDistG1.04/grammars/c/gram.y

if test -f oxDistG1.04/grammars/c/main.c
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/main.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/main.c
	if test -f oxDistG1.04/grammars/c/main.c
	then
		echo Error: could not remove oxDistG1.04/grammars/c/main.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/main.c
cat >oxDistG1.04/grammars/c/main.c <<'@EOF'
main()
{
	int yyparse();

	return(yyparse());
}
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/main.c`; if test $1 -ne 46635
then
	echo ERROR: oxDistG1.04/grammars/c/main.c checksum is $1 should be 46635
fi
set `wc -lwc <oxDistG1.04/grammars/c/main.c`
if test $1$2$3 != 6648
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/main.c are $* should be 6 6 48
fi

chmod 755 oxDistG1.04/grammars/c/main.c

if test -f oxDistG1.04/grammars/c/scan.l
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/scan.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/scan.l
	if test -f oxDistG1.04/grammars/c/scan.l
	then
		echo Error: could not remove oxDistG1.04/grammars/c/scan.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/scan.l
sed 's/^@//' >oxDistG1.04/grammars/c/scan.l <<'@EOF'
D			[0-9]
L			[a-zA-Z_]
H			[a-fA-F0-9]
E			[Ee][+-]?{D}+
FS			(f|F|l|L)
IS			(u|U|l|L)*

%{
#include <stdio.h>
#include "y.tab.h"

void count();
%}

%%
"/*"			{ comment(); }

"auto"			{ count(); return(AUTO); }
"break"			{ count(); return(BREAK); }
"case"			{ count(); return(CASE); }
"char"			{ count(); return(CHAR); }
"const"			{ count(); return(CONST); }
"continue"		{ count(); return(CONTINUE); }
"default"		{ count(); return(DEFAULT); }
"do"			{ count(); return(DO); }
"double"		{ count(); return(DOUBLE); }
"else"			{ count(); return(ELSE); }
"enum"			{ count(); return(ENUM); }
"extern"		{ count(); return(EXTERN); }
"float"			{ count(); return(FLOAT); }
"for"			{ count(); return(FOR); }
"goto"			{ count(); return(GOTO); }
"if"			{ count(); return(IF); }
"int"			{ count(); return(INT); }
"long"			{ count(); return(LONG); }
"register"		{ count(); return(REGISTER); }
"return"		{ count(); return(RETURN); }
"short"			{ count(); return(SHORT); }
"signed"		{ count(); return(SIGNED); }
"sizeof"		{ count(); return(SIZEOF); }
"static"		{ count(); return(STATIC); }
"struct"		{ count(); return(STRUCT); }
"switch"		{ count(); return(SWITCH); }
"typedef"		{ count(); return(TYPEDEF); }
"union"			{ count(); return(UNION); }
"unsigned"		{ count(); return(UNSIGNED); }
"void"			{ count(); return(VOIDx); }
"volatile"		{ count(); return(VOLATILE); }
"while"			{ count(); return(WHILE); }

{L}({L}|{D})*		{ count(); return(check_type()); }

0[xX]{H}+{IS}?		{ count(); return(CONSTANT); }
0[xX]{H}+{IS}?		{ count(); return(CONSTANT); }
0{D}+{IS}?		{ count(); return(CONSTANT); }
0{D}+{IS}?		{ count(); return(CONSTANT); }
{D}+{IS}?		{ count(); return(CONSTANT); }
{D}+{IS}?		{ count(); return(CONSTANT); }
'(\\.|[^\\'])+'		{ count(); return(CONSTANT); }

{D}+{E}{FS}?		{ count(); return(CONSTANT); }
{D}*"."{D}+({E})?{FS}?	{ count(); return(CONSTANT); }
{D}+"."{D}*({E})?{FS}?	{ count(); return(CONSTANT); }

\"(\\.|[^\\"])*\"	{ count(); return(STRING_LITERAL); }

">>="			{ count(); return(RIGHT_ASSIGN); }
"<<="			{ count(); return(LEFT_ASSIGN); }
"+="			{ count(); return(ADD_ASSIGN); }
"-="			{ count(); return(SUB_ASSIGN); }
"*="			{ count(); return(MUL_ASSIGN); }
"/="			{ count(); return(DIV_ASSIGN); }
"%="			{ count(); return(MOD_ASSIGN); }
"&="			{ count(); return(AND_ASSIGN); }
"^="			{ count(); return(XOR_ASSIGN); }
"|="			{ count(); return(OR_ASSIGN); }
">>"			{ count(); return(RIGHT_OP); }
"<<"			{ count(); return(LEFT_OP); }
"++"			{ count(); return(INC_OP); }
"--"			{ count(); return(DEC_OP); }
"->"			{ count(); return(PTR_OP); }
"&&"			{ count(); return(AND_OP); }
"||"			{ count(); return(OR_OP); }
"<="			{ count(); return(LE_OP); }
">="			{ count(); return(GE_OP); }
"=="			{ count(); return(EQ_OP); }
"!="			{ count(); return(NE_OP); }
";"			{ count(); return(';'); }
"{"			{ count(); return('{'); }
"}"			{ count(); return('}'); }
","			{ count(); return(','); }
":"			{ count(); return(':'); }
"="			{ count(); return('='); }
"("			{ count(); return('('); }
")"			{ count(); return(')'); }
"["			{ count(); return('['); }
"]"			{ count(); return(']'); }
"."			{ count(); return('.'); }
"&"			{ count(); return('&'); }
"!"			{ count(); return('!'); }
"~"			{ count(); return('~'); }
"-"			{ count(); return('-'); }
"+"			{ count(); return('+'); }
"*"			{ count(); return('*'); }
"/"			{ count(); return('/'); }
"%"			{ count(); return('%'); }
"<"			{ count(); return('<'); }
">"			{ count(); return('>'); }
"^"			{ count(); return('^'); }
"|"			{ count(); return('|'); }
"?"			{ count(); return('?'); }

[ \t\v\n\f]		{ count(); }
@.			{ /* ignore bad characters */ }

%%

yywrap()
{
	return(1);
}

comment()
{
	char c, c1;

loop:
	while ((c = input()) != '*' && c != 0)
		putchar(c);

	if ((c1 = input()) != '/' && c != 0)
	{
		unput(c1);
		goto loop;
	}

	if (c != 0)
		putchar(c1);
}

int column = 0;

void count()
{
	int i;

	for (i = 0; yytext[i] != '\0'; i++)
		if (yytext[i] == '\n')
			column = 0;
		else if (yytext[i] == '\t')
			column += 8 - (column % 8);
		else
			column++;

	ECHO;
}

int check_type()
{
/*
* pseudo code --- this is what it should check
*
*	if (yytext == type_name)
*		return(TYPE_NAME);
*
*	return(IDENTIFIER);
*/

/*
*	it actually will only return IDENTIFIER
*/

	return(IDENTIFIER);
}
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/scan.l`; if test $1 -ne 7574
then
	echo ERROR: oxDistG1.04/grammars/c/scan.l checksum is $1 should be 7574
fi
set `wc -lwc <oxDistG1.04/grammars/c/scan.l`
if test $1$2$3 != 1746034245
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/scan.l are $* should be 174 603 4245
fi

chmod 755 oxDistG1.04/grammars/c/scan.l

echo mkdir - oxDistG1.04/grammars/c/samples
mkdir oxDistG1.04/grammars/c/samples

if test -f oxDistG1.04/grammars/c/samples/hello.c
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c/samples/hello.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c/samples/hello.c
	if test -f oxDistG1.04/grammars/c/samples/hello.c
	then
		echo Error: could not remove oxDistG1.04/grammars/c/samples/hello.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c/samples/hello.c
cat >oxDistG1.04/grammars/c/samples/hello.c <<'@EOF'
main()
  {
   printf("hello, world\n");
  }
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c/samples/hello.c`; if test $1 -ne 47311
then
	echo ERROR: oxDistG1.04/grammars/c/samples/hello.c checksum is $1 should be 47311
fi
set `wc -lwc <oxDistG1.04/grammars/c/samples/hello.c`
if test $1$2$3 != 4544
then
	echo ERROR: wc results of oxDistG1.04/grammars/c/samples/hello.c are $* should be 4 5 44
fi

chmod 755 oxDistG1.04/grammars/c/samples/hello.c

chmod 755 oxDistG1.04/grammars/c/samples

chmod 755 oxDistG1.04/grammars/c

echo mkdir - oxDistG1.04/grammars/ftn
mkdir oxDistG1.04/grammars/ftn

echo mkdir - oxDistG1.04/grammars/ftn/RCS
mkdir oxDistG1.04/grammars/ftn/RCS

if test -f oxDistG1.04/grammars/ftn/RCS/makefile,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/RCS/makefile,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/RCS/makefile,v
	if test -f oxDistG1.04/grammars/ftn/RCS/makefile,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/RCS/makefile,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/RCS/makefile,v
sed 's/^@//' >oxDistG1.04/grammars/ftn/RCS/makefile,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @# @;


1.3
date     93.10.31.15.54.43;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.19.27.29;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.27.47;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@##########################################################################
#     Fortran 77 Subset Parser - November 1988                           #
#     Copyright 1988 - John R. Levine.  All rights reserved.             #
#     Permission is hereby granted to make copies in modified or         #
#     unmodified form so long as this copyright notice is preserved      #
#     and such copies are not made for direct commercial advantage.      #
#                                                                        #
#     Any other use such as incorporation in whole or in part in a       #
#     product offered for sale requires separate permission.             #
#                                                                        #
#     John R. Levine                                                     #
#     P.O. Box 349                                                       #
#     Cambridge MA 02238-0349                                            #
#                                                                        #
#     Internet/uucp: Levine@@yale.edu    MCI Mail:  103-7498              #
#                                                                        #
##########################################################################

#########################################################################
# modified for use with Ox.  Fri Oct  8 19:58:23 EDT 1993  Kurt M. Bischoff
#########################################################################

WF=fmain.c fparse.y ftn.h ftnlex.c ftnlex1.c 

CFLAGS=-Aa
CC=cc
YFLAGS=-vdlt
OBJS=fparse.o ftnlex.o fmain.o
CLIBS= -ll -ly

ftn:	$(OBJS)
	${CC} $(CFLAGS) -o ftn $(OBJS) $(CLIBS)

fparse.o:	fparse.c ftn.h
		cc $(CFLAGS) -c fparse.c

fparse.c fparse.h:	oxout.y
		yacc $(YFLAGS) oxout.y
		mv y.tab.c fparse.c
		mv y.tab.h fparse.h

oxout.y oxout.l: fparse.y ftnlex1.c
	ox -I fparse.y -G ftnlex1.c

ftnlex.o:	ftnlex.c oxout.l fparse.h ftn.h
	${CC} $(CFLAGS) -c ftnlex.c

fmain.o:	fmain.c fparse.h ftn.h
	${CC} $(CFLAGS) -c fmain.c

clean:
	rm *.o oxout* fparse.c fparse.h ftn y.output
@@


1.2
log
@@modified for use with Ox.
@@
text
@@d23 2
@@


1.1
log
@@Initial revision
@@
text
@@d19 6
a24 2
CFLAGS=-g
CC=gcc
d27 1
d30 1
a30 1
	${CC} $(CFLAGS) -o $@@ $(OBJS)
d33 1
d35 2
a36 2
fparse.c fparse.h:	fparse.y
		yacc $(YFLAGS) fparse.y
d40 2
a41 1
ftnlex.o:	ftnlex.c fparse.h ftn.h
d43 3
d47 1
d49 2
a50 2
#%.o:	%.c
#	${CC} -c ${CFLAGS} $<
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/RCS/makefile,v`; if test $1 -ne 51601
then
	echo ERROR: oxDistG1.04/grammars/ftn/RCS/makefile,v checksum is $1 should be 51601
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/RCS/makefile,v`
if test $1$2$3 != 1253352852
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/RCS/makefile,v are $* should be 125 335 2852
fi

chmod 755 oxDistG1.04/grammars/ftn/RCS/makefile,v

if test -f oxDistG1.04/grammars/ftn/RCS/README,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/RCS/README,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/RCS/README,v
	if test -f oxDistG1.04/grammars/ftn/RCS/README,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/RCS/README,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/RCS/README,v
sed 's/^@//' >oxDistG1.04/grammars/ftn/RCS/README,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @# @;


1.3
date     93.10.31.15.54.27;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.19.22.57;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.26.49;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@$Header: README,v 1.2 93/10/17 19:22:57 bischoff Exp $

The code in this directory originated as a Yacc/C specification
for a parser for a subset of FORTRAN 77.  It came from an archive
mentioned in the comp.compilers monthly message.  It was written
by John Levine.

This is an adaptation for use with Ox of the code from the
archive.  The Yacc input specification file `fparse.y' is
unchanged from what I found in the archive.  Changes to the
scanner in `ftnlex.c' are described in comments in that file.  A
new file `ftnlex1.c', which is an excision of part of `ftnlex.c',
has been added.  `Makefile' is changed to cause preprocessing by
Ox.  The present file is an update of John Levine's `README'.  
All of the other original files from the archive are here
unchanged.  All of the originals are in the RCS directory as
revision 1.1.

Using the new `Makefile' and Ox results in a parser that behaves
in every way as the original Yacc/C parser, except that it builds
a `dummy' parse tree, (i.e., one without attributes), whereas the
original builds no parse tree.

`fparse.y' and `ftnlex1.l' are ready for augmentation with Ox
constructs, which results in a parser that constructs a parse
tree bearing inherited and/or synthesized attributes.  Code for
tree construction, decoration, and traversal are generated
automatically by Ox.  For further information, see the Ox
Tutorial Introduction and the Ox User Reference Manual, which
accompany the Ox distribution.

The text of John Levine's original `README' as well as the header
of the shar file from the archive follows the line of asterisks.

--Kurt Bischoff  10/17/93
*************************************************************************

This is a Fortran 77 subset parser that I knocked together in about a
week.  It does a decent job of tokenizing and parsing Fortran,
although it is quite incomplete.  It is provided as is without any
claim that it is suitable for any purpose nor with any promise of
support.  Copying is permitted so long as it is not for direct
commercial advantage.  See the copyright notice in each source file.

The general strategy is as follows:

	1.  Read each line, determine if it's a comment or
	continutation.
	2.  If not a comment, add into the current statement buffer,
	removing quoted literals and hollerith strings and replacing
	them by special tokens (a space followed by a digit.)
	3.  Once we have an entire statement, scan it to see if it
	looks like an assignment statement.  If not it must be a
	keyword	statement.
	4.  Call the yacc parser.  From this point, tokenizing is
	pretty simple -- see if any of the keyword or special
	character tokens that are allowed in the current context
	match, if not look for a number or a name. Statement numbers
	are treated as integer constants.

The one case where I know that I parse wrong is something like:

	real function a(34)

which dimensions the array functiona but parses incorrectly as a function
declaration with a bogus dummy argument.  This is hard to fix and is unlikely
to cause trouble in practice.

The language it parses includes some invalid constructs that would
need to be kicked out semantically, e.g.:

	dimension foo

because I treat dimension and explicit type statements the same.

If you want to extend this to parse more of Fortran, you'll obviously
need to add more yacc syntax (note that there is syntax in the
current parser that the lexer doesn't generate the tokens for,) more
lexer tokens, and more lexer states.  Lexer states you'll need
certainly include:

	-- Looking for the TO in an assign statement.
	-- Tokenizing format statements (unless you want to do
	it at runtime, a common approach)
	-- Looking for the zillion possible keywords in I/O
	statements.

There are doubtless more, you'll know them when you see them.

I have run this under Microsoft C 5.1 on a PC and under GCC 1.35.  It
should work on the regular unix PCC with minimal modifications,
mostly getting rid of a few ANSI function prototypes that I use and
perhaps adjusting the varargs constructs in emit().  It has parsed
many of the old IBM SSP routines, so I'm fairly confident that it
parses what it parses pretty well.

If you do anything interesting with this, I'd appreciate hearing
about it.

John Levine
P.O. Box 349
Cambridge MA 02238
+1 617 492 3869
Internet: Levine@@yale.edu or johnl@@esegue.segue.boston.ma.us
MCI Mail: 103-7498, WUI telex 6501037498 MCI UW
Genie: J.LEVINE3

***********************************************************************
Here is the header from the archived shar file for the original Yacc/C
parser.  --K.B.

#!/bin/sh
# shar:	Shell Archiver  (v1.22)
#
#	Run the following text with /bin/sh to create:
#	  README
#	  makefile
#	  ftnlex.c
#	  fparse.y
#	  fmain.c
#	  ftn.h
#
@@


1.2
log
@@augmentation of John Levine's original README.
@@
text
@@d1 1
a1 1
$Header$
@@


1.1
log
@@Initial revision
@@
text
@@d1 37
d107 16
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/RCS/README,v`; if test $1 -ne 832
then
	echo ERROR: oxDistG1.04/grammars/ftn/RCS/README,v checksum is $1 should be 832
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/RCS/README,v`
if test $1$2$3 != 1778645331
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/RCS/README,v are $* should be 177 864 5331
fi

chmod 755 oxDistG1.04/grammars/ftn/RCS/README,v

if test -f oxDistG1.04/grammars/ftn/RCS/fmain.c,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/RCS/fmain.c,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/RCS/fmain.c,v
	if test -f oxDistG1.04/grammars/ftn/RCS/fmain.c,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/RCS/fmain.c,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/RCS/fmain.c,v
sed 's/^@//' >oxDistG1.04/grammars/ftn/RCS/fmain.c,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.10.31.15.54.29;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.19.23.48;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.27.05;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@/*************************************************************************
*                                                                        *
*     Fortran 77 Subset Parser - November 1988                           *
*     Copyright 1988 - John R. Levine.  All rights reserved.             *
*     Permission is hereby granted to make copies in modified or         *
*     unmodified form so long as this copyright notice is preserved      *
*     and such copies are not made for direct commercial advantage.      *
*                                                                        *
*     Any other use such as incorporation in whole or in part in a       *
*     product offered for sale requires separate permission.             *
*                                                                        *
*     John R. Levine                                                     *
*     P.O. Box 349                                                       *
*     Cambridge MA 02238-0349                                            *
*                                                                        *
*     Internet/uucp: Levine@@yale.edu    MCI Mail:  103-7498              *
*                                                                        *
*************************************************************************/

/* simple main program that parses a statement at a time and emits Lisp
   expressions corresponding to the parsed tokens.
 */

#include <stdio.h>
#include <stdarg.h>
#include "ftn.h"
#include "fparse.h"

FILE *ifile;
FILE *ofile = stdout;
extern yydebug;

main(ac, av)
char **av;
{
	if(av[1][0] == '-') {
		yydebug++;
		av++;
		ac--;
	}

	ifile = fopen(av[1], "r");
	if(!ifile) {
		perror(av[1]);
		return 1;
	}
	if(ac > 2) {
		ofile = fopen(av[2], "w");
		if(!ofile) {
			perror(av[2]);
			return 1;
		}
	}

	while(lex0()) {		/* prescan a statement */
		yyparse();	/* then parse it */
		lex1();		/* then clean it up */
	}
	return 0;
}

char *relops[] = {
	"???", 	"EQ", "NE", "LT", "LE", "GT", "GE" 
};

/*VARARGS*/
void
emit(int tok,...)
{
	va_list vp;
	int ty;
	char *s;
	
	switch(tok) {
	case 0:		s = ""; break;
	case 1:		s = "STMT"; break;
	case AND:	s = "AND"; break;
	case CALL:	s = "CALL"; break;
	case CAT:	s = "CAT"; break;
	case CCON:	s = "CCON"; break;
	case CM:	s = "CM"; break;
	case COLON:	s = "COLON"; break;
	case COMMON:	s = "COMMON"; break;
	case CONTINUE:	s = "CONTINUE"; break;
	case CP:	s = "CP"; break;
	case DIV:	s = "DIV"; break;
	case DO:	s = "DO"; break;
	case END:	s = "END"; break;
	case EQ:	s = "EQ"; break;
	case EQV:	s = "EQV"; break;
	case FUNCTION:	s = "FUNCTION"; break;
	case GOTO:	s = "GOTO"; break;
	case ICON:	s = "ICON"; break;
	case IF:	s = "IF"; break;
	case MINUS:	s = "MINUS"; break;
	case NAME:	s = "NAME"; break;
	case NOT:	s = "NOT"; break;
	case OP:	s = "OP"; break;
	case OR:	s = "OR"; break;
	case PLUS:	s = "PLUS"; break;
	case POW:	s = "POW"; break;
	case RCON:	s = "RCON"; break;
	case RELOP:	s = "RELOP"; break;
	case RETURN:	s = "RETURN"; break;
	case STAR:	s = "STAR"; break;
	case SUBROUTINE:	s = "SUBROUTINE"; break;
	case TO:	s = "TO"; break;
	case TYPE:	s = "TYPE"; break;
	case UMINUS:	s = "UMINUS"; break;
	default:	s = "???"; break;
	} /* codes */

	fprintf(ofile, "(%s", s);
	
	va_start(vp, tok);
	switch(tok) {
	case FUNCTION:
		ty = va_arg(vp, type);
		s = va_arg(vp, char*);
		fprintf(ofile, " %d %d %s", TYTYPE(ty), TYLEN(ty), s);
		break;
	case CALL:
	case NAME:
	case SUBROUTINE:
	case TO:
		s = va_arg(vp, char*);
		if(!s || !*s)
			s = "Blank";
		fprintf(ofile, " %s", s);
		break;
	case TYPE:
		ty = va_arg(vp, type);
		fprintf(ofile, " %d %d", TYTYPE(ty), TYLEN(ty));
		break;
	case ICON:
	case DO:
	case GOTO:
	case 1:	/* hack for *NNN statement numbers in call statements */
		fprintf(ofile, " %ld", va_arg(vp, long));
		break;
	case CCON:
		fprintf(ofile, " \"%s\"", va_arg(vp, char *));
		break;
	case RCON:
		fprintf(ofile, " %g", va_arg(vp, double));
		break;
	case EQV:
		fprintf(ofile, " %sEQV", va_arg(vp, int)? "N": "");
		break;
	case RELOP:
		fprintf(ofile, " %s", relops[va_arg(vp, int)]);
		break;
	}
	fprintf(ofile, ")\n");
	va_end(vp);
} /* emit */
@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/RCS/fmain.c,v`; if test $1 -ne 59573
then
	echo ERROR: oxDistG1.04/grammars/ftn/RCS/fmain.c,v checksum is $1 should be 59573
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/RCS/fmain.c,v`
if test $1$2$3 != 2066614685
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/RCS/fmain.c,v are $* should be 206 661 4685
fi

chmod 755 oxDistG1.04/grammars/ftn/RCS/fmain.c,v

if test -f oxDistG1.04/grammars/ftn/RCS/fparse.y,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/RCS/fparse.y,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/RCS/fparse.y,v
	if test -f oxDistG1.04/grammars/ftn/RCS/fparse.y,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/RCS/fparse.y,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/RCS/fparse.y,v
sed 's/^@//' >oxDistG1.04/grammars/ftn/RCS/fparse.y,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.10.31.15.54.31;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.19.23.57;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.27.15;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@/*************************************************************************
*                                                                        *
*     Fortran 77 Subset Parser - November 1988                           *
*     Copyright 1988 - John R. Levine.  All rights reserved.             *
*     Permission is hereby granted to make copies in modified or         *
*     unmodified form so long as this copyright notice is preserved      *
*     and such copies are not made for direct commercial advantage.      *
*                                                                        *
*     Any other use such as incorporation in whole or in part in a       *
*     product offered for sale requires separate permission.             *
*                                                                        *
*     John R. Levine                                                     *
*     P.O. Box 349                                                       *
*     Cambridge MA 02238-0349                                            *
*                                                                        *
*     Internet/uucp: Levine@@yale.edu    MCI Mail:  103-7498              *
*                                                                        *
*************************************************************************/


%{
#include "ftn.h"
%}
%union {
	expr uuexp;
	long uulong;
	int uuint;
	type uutype;
}
/* generic tokens */
%token PLUS MINUS OP CP STAR POW DIV CAT CM EQ COLON
%token NOT AND OR
%token <uuint> RELOP EQV
%token <uuexp> NAME CONST ICON RCON LCON CCON

/* a zillion keywords */
%token IF THEN ELSE ELSEIF ENDIF DO GOTO ASSIGN TO CONTINUE STOP
%token <uuint> RDWR
%token OPEN CLOSE BACKSPACE REWIND ENDFILE FORMAT
%token PROGRAM FUNCTION SUBROUTINE ENTRY END CALL RETURN
%token <uutype> TYPE DIMENSION
%token COMMON EQUIVALENCE EXTERNAL PARAMETER INTRINSIC IMPLICIT
%token SAVE DATA

%left EQV
%left OR
%left AND
%nonassoc NOT
%nonassoc RELOP
%left CAT
%left PLUS MINUS
%left STAR DIV
%right POW
%nonassoc UMINUS

%type <uutype> opttype

%%

statement:	s	{ emit(0); }
	;

s:		PROGRAM NAME
	;

s:		opttype FUNCTION NAME { emit(FUNCTION, $1, $3.n.name); }
			OP funargs CP
	;

opttype:	/* empty */ { $$ = 0; }
	|	TYPE
	;

funargs:	funarg
	|	funargs CM funarg
	;

funarg:		NAME	{ emit(NAME, $1.n.name); }
	|	STAR	{ emit(STAR); }
	;

s:		ENTRY NAME
	|	ENTRY NAME OP funargs CP
	;

s:		SUBROUTINE NAME { emit(SUBROUTINE, $2.n.name); }
	|	SUBROUTINE NAME { emit(SUBROUTINE, $2.n.name); }
			OP funargs CP
	;

/* we give dimension and explicit type statements the same syntax here
   because I'm lazy.  This allows e.g. 
	   DIMENSION FOO
   which is easier to kick out semantically
 */

s:		DIMENSION { emit(TYPE, 0); } arydcllist
	|	TYPE { emit(TYPE, $1); } arydcllist
	;

arydcllist:	arydcl
	|	arydcllist CM arydcl
	;

arydcl:		NAME { emit(NAME, $1.n.name); } OP dclsublist CP
		{ emit(CP); }
	|	NAME { emit(NAME, $1.n.name); emit(CP); }
	;

dclsublist:	dclsub
	|	dclsublist CM { emit(CP); } dclsub
	;

dclsub:		exp
	|	exp COLON { emit(COLON); } exp
	|	STAR
	|	exp COLON STAR { emit(COLON); emit(STAR); }
	;

s:		COMMON { emit(COMMON); } commonlist
	;

commonlist:	arydcl
	|	commonlist CM arydcl
	|	blockname
	|	commonlist optcomma blockname
	;

optcomma:	CM
	|	/* nothing */
	;

/* note here that the // for blank common looks a lot like the catenation
   operator.  Fortunately, there's no semantic ambiguity */

blockname:	DIV NAME DIV { emit(TO, $2.n.name); }
	|	CAT { emit(TO, ""); }	/* blank common */
	;

s:		EQUIVALENCE quivlist
	;

quivlist:	quiv
	|	quivlist CM quiv
	;

quiv:		OP arydcllist CP
	;

s:		IMPLICIT impllist
	;

impllist:	impldcl
	|	impllist CM impldcl
	;

impldcl:	TYPE OP implletlist CP
	;

implletlist:	impllet
	|	implletlist CM impllet
	;

/* the NAMEs here actually have to be single letters, but it's easier to
   sort this out semantically than to make the parser only allow single
   letters for this one case */

impllet:	NAME
	|	NAME MINUS NAME
	;

exp:		NAME { emit(NAME, $1.n.name); }
	|	CONST {
			switch(TYTYPE($1.c.t)) {
			case TY_INTEGER:
				emit(ICON, $1.c.u.l);	break;
			case TY_REAL:
				emit(RCON, $1.c.u.d);	break;
			case TY_LOGICAL:
				emit(ICON, $1.c.u.l);	break;
			case TY_CHAR:
				emit(CCON, $1.c.u.c);	break;
			default:
				yyerror("Unsupported constant type");
				break;
			}
		}			

	|	OP exp CP
	|	exp PLUS exp { emit(PLUS); }
	|	exp MINUS exp { emit(MINUS); }
	|	exp STAR exp { emit(STAR); }
	|	exp DIV exp { emit(DIV); }
	|	exp POW exp { emit(POW); }
	|	exp CAT exp { emit(CAT); }
	|	exp RELOP exp { emit(RELOP, $2); }
	|	NOT exp { emit(NOT); }
	|	exp AND exp { emit(AND); }
	|	exp OR exp { emit(OR); }
	|	exp EQV exp { emit(EQV, $2); }
	|	MINUS exp	%prec UMINUS  { emit(UMINUS); }
	|	OP exp CM exp CP	/* complex constant, sort of */
	|	aryref
	
aryref:		NAME OP { emit(OP); emit(NAME, $1.n.name); } explist CP
			{ emit(CP); }
	;
		
explist:	exp
	|	explist CM { emit(CM); } exp
	;

/* assignment statement or arithmetic statement function, they're
	syntactically the same */

s:		lhs EQ exp { emit(EQ); }
	;

lhs:		NAME { emit(NAME, $1.n.name); }
	|	aryref
	;

s:		do CONST NAME EQ {
			emit(DO, $2.c.u.l);
			emit(NAME, $3.n.name);
		}
		exp CM { emit(CM); } exp optstep
	;

/* hack - normally you can parse statement numbers as numeric constants
	easily enough, except in a case like
		DO 10 E5 = 1,1000
	where 10E5 looks like a real number.  cxt_do tells the lexer only
	to recognize an integer here.
 */

do:		DO { context = cxt_do; }
	;

optstep:	CM { emit(CM); } exp
	|	/* empty */
	;

s:		CONTINUE { emit(CONTINUE); }
	;


s:		if exp ifcp s
	|	if exp ifcp CONST CM CONST CM CONST {
			emit(ICON, $4.c.u.l);
			emit(ICON, $6.c.u.l);
			emit(ICON, $8.c.u.l);
		}
	;

if:		IF OP	{ emit(IF); }
	;

	/* check ahead for target of IF statement */
	/* we have to use the same prescan to tell how to lex the target
	   statement of the IF.  Arithmetic IFs work OK because three
	   integers separated by commas don't look like an assignment
	   statement. */
	
ifcp:		CP {	if(prescan())
				context = cxt_norm;
			else
				context = cxt_stmt;
			emit(CP);
		}
	;

/* regular, assigned, and computed GOTO */

s:		GOTO CONST { emit(GOTO, $2.c.u.l); }
	|	GOTO NAME { emit(GOTO, 0L); emit(NAME, $2.n.name); }
		optstmtlist
	|	GOTO OP { emit(GOTO, 0L); } stmtlist CP { emit(CP); }
		optcomma exp
	;

optstmtlist:	CM OP stmtlist CP
	|	/* empty */
	;

stmtlist:	CONST { emit(ICON, $1.c.u.l); }
	|	stmtlist CM CONST { emit(ICON, $3.c.u.l); }
	;

s:		STOP
	;

s:		CALL NAME { emit(CALL, $2.n.name); }
	|	CALL NAME { emit(CALL, $2.n.name); } OP cexplist CP
	;

cexplist:	cexp
	|	cexplist CM { emit(CM); } cexp
	;

cexp:		exp
	|	STAR CONST { emit(1, $2.c.u.l); }
	;

s:		RETURN { emit(RETURN); }
	|	RETURN { emit(RETURN); } exp
	;
s:		END { emit(END); }
	;

%%

/* your standard error routine */
void yyerror(char *s)
{
	printf("%d: %s\n", lineno, s);
}
@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/RCS/fparse.y,v`; if test $1 -ne 28484
then
	echo ERROR: oxDistG1.04/grammars/ftn/RCS/fparse.y,v checksum is $1 should be 28484
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/RCS/fparse.y,v`
if test $1$2$3 != 36711497443
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/RCS/fparse.y,v are $* should be 367 1149 7443
fi

chmod 755 oxDistG1.04/grammars/ftn/RCS/fparse.y,v

if test -f oxDistG1.04/grammars/ftn/RCS/ftn.h,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/RCS/ftn.h,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/RCS/ftn.h,v
	if test -f oxDistG1.04/grammars/ftn/RCS/ftn.h,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/RCS/ftn.h,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/RCS/ftn.h,v
sed 's/^@//' >oxDistG1.04/grammars/ftn/RCS/ftn.h,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.10.31.15.54.34;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.19.24.05;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.27.25;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@/*************************************************************************
*                                                                        *
*     Fortran 77 Subset Parser - November 1988                           *
*     Copyright 1988 - John R. Levine.  All rights reserved.             *
*     Permission is hereby granted to make copies in modified or         *
*     unmodified form so long as this copyright notice is preserved      *
*     and such copies are not made for direct commercial advantage.      *
*                                                                        *
*     Any other use such as incorporation in whole or in part in a       *
*     product offered for sale requires separate permission.             *
*                                                                        *
*     John R. Levine                                                     *
*     P.O. Box 349                                                       *
*     Cambridge MA 02238-0349                                            *
*                                                                        *
*     Internet/uucp: Levine@@yale.edu    MCI Mail:  103-7498              *
*                                                                        *
*************************************************************************/


/* some headers for a Fortran parser */

typedef unsigned char uchar;
typedef unsigned short type;	/* stores a Fortran type, high byte type, */
				/* low byte length */

/* binary expression */
typedef struct _binexp {
	type t;
	int expop;
	union _expr *el;
	union _expr *er;
} binexp;

/* Fortran constant */
typedef struct _const {
	type t;
	union {
		long l;
		double d;
		char *c;
	} u;
} constant;

/* name reference */
typedef struct _name {
	type t;
	char name[32];
} name;

/* more or less generic expression */
typedef union _expr {
	struct _binexp b;
	struct _const c;
	struct _name n;
} expr;

/* The Fortran lexical analyzer is very context dependent, here we list the
   various contexts that it knows about.
 */

enum contexts {
	cxt_stmt = 0,	/* beginning of statement */
	cxt_norm,	/* normal in an expression */
	cxt_do,		/* DO stmt seen */
	cxt_type,	/* type seen */
} context;

/* keyword lookup table */
typedef struct _kwdtab {
	char *kwd;	/* text of the keyword */
	int ktok;	/* token code */
	int klex;	/* lexical value */
} kwdtab;


/* types */
#define TY_NONE		0	/* no type */
#define TY_CHAR		1
#define	TY_LOGICAL	2
#define TY_INTEGER	3
#define	TY_REAL		4
#define TY_COMPLEX	5

#define MTYPE(ty, len) ((TY_##ty)<<8|(len))
#define TYTYPE(x) ((x)>>8)	/* type part of a type */
#define TYLEN(x) ((x)&0377)	/* length part of a type */

/* relops */
enum relops {
	rel_eq = 1,
	rel_ne,
	rel_lt,
	rel_le,
	rel_gt,
	rel_ge
};

/* some random stuff */
extern int lineno;


/* some prototypes */
void yyerror(char *);
void emit(int,...);
@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/RCS/ftn.h,v`; if test $1 -ne 35457
then
	echo ERROR: oxDistG1.04/grammars/ftn/RCS/ftn.h,v checksum is $1 should be 35457
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/RCS/ftn.h,v`
if test $1$2$3 != 1554603402
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/RCS/ftn.h,v are $* should be 155 460 3402
fi

chmod 755 oxDistG1.04/grammars/ftn/RCS/ftn.h,v

if test -f oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v
	if test -f oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v
sed 's/^@//' >oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.10.31.15.54.37;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.19.24.59;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.27.36;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@/*************************************************************************
*                                                                        *
*     Fortran 77 Subset Parser - November 1988                           *
*     Copyright 1988 - John R. Levine.  All rights reserved.             *
*     Permission is hereby granted to make copies in modified or         *
*     unmodified form so long as this copyright notice is preserved      *
*     and such copies are not made for direct commercial advantage.      *
*                                                                        *
*     Any other use such as incorporation in whole or in part in a       *
*     product offered for sale requires separate permission.             *
*                                                                        *
*     John R. Levine                                                     *
*     P.O. Box 349                                                       *
*     Cambridge MA 02238-0349                                            *
*                                                                        *
*     Internet/uucp: Levine@@yale.edu    MCI Mail:  103-7498              *
*                                                                        *
*************************************************************************/

/* modified for use with Ox Fri Oct  8 21:02:25 EDT 1993 Kurt Bischoff.
   Excised a chunk containing all of the scanner's points of return 
   and placed them in a separate file intended as the L-file input to
   Ox, using the -G command-line option.
 */

#include "ftn.h"
#include "fparse.h"
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

extern FILE *ifile;

char stmtbuf[1321];	/* buffer a whole statement */
char linebuf[100];	/* buffer a line at a time */
char *lbcp;		/* start of text in linebuf; */
char *scp;		/* current location in stmtbuf */

long next_stno = -1;	/* statement number for next statement, from pre */
int lineno = 0;
enum contexts context;

/* first, we read in a statement */

/* After each statement is read, the read pointer is at the
   first line of the next statement because we needed to peek ahead and
   see if there was a continuation card.
*/

/* this reads a line, then looks to see if it's a continuation, and if
   not if there's a statement number.
   return values: -1 at EOF, 0 for first line, 1 for continuation */

int
rdstno()
{
	int flg;
	int colno;

	for(;;) {
		register char *cp;

		if(!fgets(linebuf, sizeof(linebuf), ifile))
			return -1;	/* EOF */
		lineno++;
		if(linebuf[0] == 'C' || linebuf[0] == 'c'
			|| linebuf[0] == '*')
			continue;	/* comment */
		/* check for totally blank line */
		/* and trim at column 72 */
		flg = 0;
		for(cp = linebuf, colno = 1; *cp; cp++, colno++) {
			if(*cp == '\n') {
				*cp = 0;
				break;
			}
			if(*cp == '\t' && colno < 5)
				colno = 5;	/* tab ahead */
			else if(*cp != ' ' && *cp != '\t')
				flg = 1;
			if(colno == 72) {
				cp[1] = 0;	/* white out seq cols */
				break;
			}
		}
		if(!flg)
			continue;	/* blank line comment */
		/* now, get the line number and comment flag */
		next_stno = 0;
		colno = 0;
		for(cp = linebuf; colno < 6; cp++, colno++) {
			if(isdigit(*cp))
				next_stno = 10*next_stno + *cp-'0';
			else if(*cp == '\t')
				colno = 5;
			else if(*cp != ' ')
				yyerror("Bad stmt label");
		}
		lbcp = cp;
		cp--;   /* point at continuation marker */
		return(*cp != ' ' && *cp != '\t' && *cp != '0');
	}
} /* rdstno */
		
int stmt_eof;

/* at prescan time quoted strings are pulled out and stashed here */
/* in the scanned statement, the literal string is replaced by a quote
   and a digit indicating which table entry it is */

char *string_tab[30];    /* quoted strings */
char **string_tabp = string_tab;

/* read and prescan a statement, pull out literal strings and squeeze out
   blanks.
   return 1 if statement read, 0 at eof */

int
rdstmt()
{
	char *cp;
	int c;
	int colno;
	int quoteflag = 0;	/* >0 means 3hfoo, -1 means 'foo' */
	int quotable = 0;       /* 1 if nnH allowed */
	char *quotep, *quotelim;
	
	/* make sure there's a line ready for us */
	if(next_stno < 0)
		stmt_eof = rdstno();

	if(stmt_eof < 0)
		return 0;

	/* at this point we might want to do something about the statement
	   number */
	
	/* now read and process lines until we find one that isn't a
	   continuation */
	
	cp = stmtbuf;
	do {
		char *icp;

		for(icp = lbcp; *icp; icp++) {

			c = *icp;
			/* process a card image */
			/* special case for literal strings, keep blanks */
			if(quoteflag) {
				if(quoteflag < 0 && c == '\'') {
					if(icp[1] != '\'') {
						*quotep = 0;
						string_tabp++;
						quoteflag = 0;
						continue;
					} else
						icp++;
				}

				if(quotep >= quotelim)
					yyerror("String too long");
				else
					*quotep++ = (char)c;
				if(quoteflag > 0)
					quoteflag--;
				if(quoteflag == 0) {
					*quotep = 0;
					string_tabp++;
					quoteflag = 0;
				}
				continue;
			}
			/* discard unquoted spaces */
			if(c == ' ' || c == '\t')
				continue;
			
			c = toupper(c);
			/* literal strings can only occur after (  = or / */
			/* consider  REAL*4HELLO */
			if(!quotable && (c == '=' || c == '/' || c == '('))
				quotable++;	/* could have string */

			/* check for quoted literal */
			if(c == '\'') {
				quoteflag = -1;
				*string_tabp = quotep = malloc(80);
				quotelim = quotep + 79;
				*cp++ = '\'';	/* string flag */
				*cp++ = '0'
				  + (string_tabp - string_tab);
				continue;
			}
			*cp = (char)c;
			/* check for counted (hollerith) literal */
			if(c == 'H' && quotable
			 && cp > stmtbuf && isdigit(cp[-1])) {
				char *tcp = cp-1;
				
				while(tcp > stmtbuf && isdigit(*tcp))
					tcp--;
				if(!isalnum(*tcp)) {	/* yes */
					tcp++;
					cp = tcp;	/* back over digs */
					quoteflag = 0;
					while(*tcp != 'H')
						quoteflag = quoteflag*10
							+ *tcp++ - '0';
					
					*string_tabp = quotep
					 = malloc(quoteflag+1);
					quotelim = quotep + quoteflag + 1;
					*cp++ = '\'';	/* string flag */
					*cp++ = '0'
					  + (string_tabp - string_tab);
					continue;
				}
			}
			cp++;
		} /* single line */
	} while((stmt_eof = rdstno()) == 1);
	if(quoteflag) {
		*quotep = 0;
		yyerror("Unterminated string");
	}
	*cp = 0;
	return 1;       /* found something */
} /* rdstmt */

/* prescan to see if this is an arithmetic statement */
/* returns 1 if it's an arithmetic stmt, 0 if not */
/* this hack involves looking for an equal sign not enclosed in parens
   and not followed by a comma not enclosed in parens.  Gross but effective.
 */

prescan()
{
	register char *cp;
	int parencount = 0;
	
	/* scan across counting parens and looking for an = */
	for(cp = scp; ; cp++) {
		switch(*cp) {
	case 0:		return 0;	/* no equal found */

	case '(':	parencount++;
			continue;

	case ')':	if(--parencount == 0) /* foo(a,...) = ... */
				if(cp[1] == '=')
					break;
				else
					return 0;	/* if(foo)... */
			continue;
	
	case '=':	if(parencount == 0)
				break;
	default:
			continue;       /* ignore anything else */
		}
		break;
	}

	/* found an equal, but might be a DO statement */
	/* now look for the comma which tells us it might be a DO loop */
	for(;;cp++) {
		switch(*cp) {
	case '(':	parencount++; break;
	case ')':	parencount--; break;
	case ',':	if(!parencount)
				return 0;
			break;
	case 0:		return 1;	/* it's an arith statement */
		} /* switch */
	} /* for */
} /* prescan */


/* keyword tables */

/* statement starting keywords */
kwdtab tab_stmt[] = {
	{ "CALL",	CALL,	0 },
	{ "COMMON",	COMMON, 0 },
	{ "CONTINUE",	CONTINUE,	0 },
	{ "DATA",	DATA, 0 },
	{ "DIMENSION",	DIMENSION,	0 },
	{ "DO",		DO,	0 },
	{ "ENDIF",	ENDIF,	0 },
	{ "END",	END, 0 },
	{ "ENTRY",	ENTRY,	0 },
	{ "EQUIVALENCE", EQUIVALENCE, 0 },
	{ "EXTERNAL",	EXTERNAL, 0 },
	{ "FORMAT",	FORMAT, 0 },
	{ "FUNCTION",	FUNCTION,	0 },
	{ "GOTO",	GOTO,	0 },
	{ "IF",		IF,	0 },
	{ "IMPLICIT",	IMPLICIT,	0 },
	{ "INTRINSIC",	INTRINSIC, 0 },
	{ "PROGRAM",	PROGRAM,	0 },
	{ "RETURN",	RETURN,	0 },
	{ "REWIND",	REWIND, 0 },
	{ "SAVE",	SAVE, 0 },
	{ "STOP",	STOP,	0 },
	{ "SUBROUTINE",	SUBROUTINE,	0 },
	{ "THEN",	THEN,	0 },
	NULL
};

/* type declarators */
kwdtab tab_type[] = {
	{ "DOUBLEPRECISION",	TYPE,	MTYPE(REAL, 8), },
	{ "REAL*8",	TYPE,	MTYPE(REAL, 8), },
	{ "REAL*4",	TYPE,	MTYPE(REAL, 4), },
	{ "REAL",	TYPE,	MTYPE(REAL, 4), },
	
	{ "INTEGER*4",	TYPE,	MTYPE(INTEGER, 4), },
	{ "INTEGER",	TYPE,	MTYPE(INTEGER, 4), },


	{ "LOGICAL*4",	TYPE,	MTYPE(LOGICAL, 4), },
	{ "LOGICAL",	TYPE,	MTYPE(LOGICAL, 4), },


	{ "DOUBLECOMPLEX",	TYPE,	MTYPE(COMPLEX, 16), },
	{ "COMPLEX*16",	TYPE,	MTYPE(COMPLEX, 16), },
	{ "COMPLEX*8",	TYPE,	MTYPE(COMPLEX, 8), },
	{ "COMPLEX",	TYPE,	MTYPE(COMPLEX, 4), },


	{ "CHARACTER",	TYPE,	MTYPE(CHAR, 1), },
	NULL
};

/* normal tokens */
kwdtab tab_toks[] = {
	{ "+",	PLUS,	0 },
	{ "-",	MINUS,	0 },
	{ "(",	OP,	0 },
	{ ")",	CP,	0 },
	{ "**",	POW,	0 },
	{ "*",	STAR,	0 },
	{ "//",	CAT,	0 },
	{ "/",	DIV,	0 },
	{ ",",	CM,	0 },
	{ "=",	EQ,	0 },
	{ ":",	COLON,	0 },
	{ ".NOT.",	NOT,	0 },
	{ ".AND.",	AND,	0 },
	{ ".OR.",	OR,	0 },
	{ ".EQV.",	EQV, 0 },
	{ ".NEQV.",	EQV, 1 },
	{ ".EQ.",	RELOP,	rel_eq },
	{ ".NE.",	RELOP,	rel_ne },
	{ ".LT.",	RELOP,	rel_lt },
	{ ".LE.",	RELOP,	rel_le },
	{ ".GT.",	RELOP,	rel_gt },
	{ ".GE.",	RELOP,	rel_ge },
	{ ".TRUE.",	CONST,	1 },
	{ ".FALSE.",	CONST,	0 },
	NULL
};


/* call this before parsing a statement */
/* returns 1 if there's a statement to parse */
/* also checks the statement type and sets the context appropriately */
lex0()
{
	if(!rdstmt())
		return 0;	/* EOF */
	scp = stmtbuf;
	if(prescan())
		context = cxt_norm;
	else
		context = cxt_stmt;
	return 1;
}

/* look to see if the next thing is a recognized keyword */
int
keyscan(tab)
register kwdtab *tab;
{
	while(tab->kwd) {
		int len = strlen(tab->kwd);
		
		if(!strncmp(scp, tab->kwd, len)) {
			scp += len;	/* skip over this */
			if(tab->ktok == CONST) {	/* hack */
				yylval.uuexp.c.t = MTYPE(LOGICAL, 4);
				yylval.uuexp.c.u.l = tab->klex;
			} else
			yylval.uuint = tab->klex;
			return tab->ktok;
		}
		tab++;
	}
	return 0;
} /* keyscan */

/* After all this setup, the lexer is quite simple.  It looks for the longest
   keyword legal in the current context or, failing that, for a number or
   name.  The various contexts are mostly set in the parser; the lexer resets
   the context to normal (name, number, or special character token) after
   each token. */

#include "oxout.l"

/* call this to clean up after lexing a statement */
/* It frees the entries in the string table, and emits the statement number
   for the next statement if there is one.
  */
lex1()
{
	while(string_tabp > string_tab)
		free(*--string_tabp);
	if(next_stno)
		emit(1, next_stno);
}
@@


1.2
log
@@excised the definition of yylex() and moved it to a new file ftnlex1.c,
so that it can be preprocessed by Ox.
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@d20 6
d29 1
a29 1
#include <malloc.h>
d409 1
a409 104
yylex()
 {
	int c;

	if(!*scp)
		return 0;	/* end of statement */

	switch(context) {
	case cxt_stmt:
		c = keyscan(tab_type);
		if(c)
			break;
		c = keyscan(tab_stmt);
		if(c)
			break;
		goto normal;	/* look for normal token */
	default:
		yyerror("Mystery context");
		context = cxt_norm;
	case cxt_norm:
	case cxt_do:
normal:
		c = keyscan(tab_toks);
		if(c)
			break;	/* found something */
		/* check for literal string */
		if(*scp == '\'') {
			char *str;

			c = CONST;
			scp++;
			str = string_tab[*scp++ - '0'];
			yylval.uuexp.c.t = MTYPE(CHAR, strlen(str));
			yylval.uuexp.c.u.c = str;
			break;
		}

		/* must be a number or name */
		if(isalpha(*scp)) {
			char *ocp = yylval.uuexp.n.name;

			yylval.uuexp.n.t = 0;
			while(isalnum(*scp)) {
				*ocp = *scp;
				ocp++;
				scp++;
			}
			*ocp = 0;
			c = NAME;
			break;
		} else {	/* constant */
			int dotseen = 0, expseen = 0;
			int mytype = MTYPE(INTEGER, 4);
			char *sbp;
			char sbuf[50];

			if(!isdigit(*scp) && *scp != '.') {
				yyerror("Unknown character");
				c = 0;
				break;
			}
			sbp = sbuf;
			for(;;) {
				if(isdigit(*scp)) {
					*sbp++ = *scp++;
					continue;
				}
				if(!dotseen && *scp == '.') {
					dotseen++;
					mytype = MTYPE(REAL, 4);
					*sbp++ = *scp++;
					continue;
				}
				if(!expseen && context != cxt_do
				 && (*scp == 'D' || *scp == 'E')) {
					expseen++;
					dotseen++;
					if(*scp == 'D')
						mytype = MTYPE(REAL, 8);
					else
						mytype = MTYPE(REAL, 4);
					*sbp++ = 'E';
					scp++;
					if(*scp == '+')
						scp++;
					else if(*scp == '-')
						*sbp++ = *scp++;
					continue;
				}
				break;  /* end of number */
			} /* for */
			*sbp = 0;
			yylval.uuexp.c.t = mytype;
			if(mytype == MTYPE(INTEGER, 4))
				yylval.uuexp.c.u.l = atol(sbuf);
			else
				yylval.uuexp.c.u.d = atof(sbuf);
			c = CONST;
			break;
		} /* name/const */
	} /* switch */
	context = cxt_norm;
	return c;
} /* yylex */
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v`; if test $1 -ne 7651
then
	echo ERROR: oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v checksum is $1 should be 7651
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v`
if test $1$2$3 != 582209813352
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v are $* should be 582 2098 13352
fi

chmod 755 oxDistG1.04/grammars/ftn/RCS/ftnlex.c,v

if test -f oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v
	if test -f oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v
sed 's/^@//' >oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.10.31.15.54.40;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.19.25.58;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@some code (namely the definition yylex()) excised from ftnlex.c.  This
is the L-file for Ox preprocessing.
@@


1.3
log
@@*** empty log message ***
@@
text
@@/* $Header: ftnlex1.c,v 1.2 93/10/17 19:25:58 bischoff Exp $ */ 

/*************************************************************************
*                                                                        *
*     Fortran 77 Subset Parser - November 1988                           *
*     Copyright 1988 - John R. Levine.  All rights reserved.             *
*     Permission is hereby granted to make copies in modified or         *
*     unmodified form so long as this copyright notice is preserved      *
*     and such copies are not made for direct commercial advantage.      *
*                                                                        *
*     Any other use such as incorporation in whole or in part in a       *
*     product offered for sale requires separate permission.             *
*                                                                        *
*     John R. Levine                                                     *
*     P.O. Box 349                                                       *
*     Cambridge MA 02238-0349                                            *
*                                                                        *
*     Internet/uucp: Levine@@yale.edu    MCI Mail:  103-7498              *
*                                                                        *
*************************************************************************/


yylex()
 {
	int c;

	if(!*scp)
		return 0;	/* end of statement */

	switch(context) {
	case cxt_stmt:
		c = keyscan(tab_type);
		if(c)
			break;
		c = keyscan(tab_stmt);
		if(c)
			break;
		goto normal;	/* look for normal token */
	default:
		yyerror("Mystery context");
		context = cxt_norm;
	case cxt_norm:
	case cxt_do:
normal:
		c = keyscan(tab_toks);
		if(c)
			break;	/* found something */
		/* check for literal string */
		if(*scp == '\'') {
			char *str;

			c = CONST;
			scp++;
			str = string_tab[*scp++ - '0'];
			yylval.uuexp.c.t = MTYPE(CHAR, strlen(str));
			yylval.uuexp.c.u.c = str;
			break;
		}

		/* must be a number or name */
		if(isalpha(*scp)) {
			char *ocp = yylval.uuexp.n.name;

			yylval.uuexp.n.t = 0;
			while(isalnum(*scp)) {
				*ocp = *scp;
				ocp++;
				scp++;
			}
			*ocp = 0;
			c = NAME;
			break;
		} else {	/* constant */
			int dotseen = 0, expseen = 0;
			int mytype = MTYPE(INTEGER, 4);
			char *sbp;
			char sbuf[50];

			if(!isdigit(*scp) && *scp != '.') {
				yyerror("Unknown character");
				c = 0;
				break;
			}
			sbp = sbuf;
			for(;;) {
				if(isdigit(*scp)) {
					*sbp++ = *scp++;
					continue;
				}
				if(!dotseen && *scp == '.') {
					dotseen++;
					mytype = MTYPE(REAL, 4);
					*sbp++ = *scp++;
					continue;
				}
				if(!expseen && context != cxt_do
				 && (*scp == 'D' || *scp == 'E')) {
					expseen++;
					dotseen++;
					if(*scp == 'D')
						mytype = MTYPE(REAL, 8);
					else
						mytype = MTYPE(REAL, 4);
					*sbp++ = 'E';
					scp++;
					if(*scp == '+')
						scp++;
					else if(*scp == '-')
						*sbp++ = *scp++;
					continue;
				}
				break;  /* end of number */
			} /* for */
			*sbp = 0;
			yylval.uuexp.c.t = mytype;
			if(mytype == MTYPE(INTEGER, 4))
				yylval.uuexp.c.u.l = atol(sbuf);
			else
				yylval.uuexp.c.u.d = atof(sbuf);
			c = CONST;
			break;
		} /* name/const */
	} /* switch */
	context = cxt_norm;
	return c;
} /* yylex */

@@


1.2
log
@@*** empty log message ***
@@
text
@@d1 1
a1 1
/* $Header$ */ 
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v`; if test $1 -ne 42553
then
	echo ERROR: oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v checksum is $1 should be 42553
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v`
if test $1$2$3 != 1684763849
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v are $* should be 168 476 3849
fi

chmod 755 oxDistG1.04/grammars/ftn/RCS/ftnlex1.c,v

chmod 755 oxDistG1.04/grammars/ftn/RCS

if test -f oxDistG1.04/grammars/ftn/README
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/README
	if test -f oxDistG1.04/grammars/ftn/README
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/README
cat >oxDistG1.04/grammars/ftn/README <<'@EOF'
$Header: README,v 1.3 93/10/31 15:54:27 bischoff Exp $

The code in this directory originated as a Yacc/C specification
for a parser for a subset of FORTRAN 77.  It came from an archive
mentioned in the comp.compilers monthly message.  It was written
by John Levine.

This is an adaptation for use with Ox of the code from the
archive.  The Yacc input specification file `fparse.y' is
unchanged from what I found in the archive.  Changes to the
scanner in `ftnlex.c' are described in comments in that file.  A
new file `ftnlex1.c', which is an excision of part of `ftnlex.c',
has been added.  `Makefile' is changed to cause preprocessing by
Ox.  The present file is an update of John Levine's `README'.  
All of the other original files from the archive are here
unchanged.  All of the originals are in the RCS directory as
revision 1.1.

Using the new `Makefile' and Ox results in a parser that behaves
in every way as the original Yacc/C parser, except that it builds
a `dummy' parse tree, (i.e., one without attributes), whereas the
original builds no parse tree.

`fparse.y' and `ftnlex1.l' are ready for augmentation with Ox
constructs, which results in a parser that constructs a parse
tree bearing inherited and/or synthesized attributes.  Code for
tree construction, decoration, and traversal are generated
automatically by Ox.  For further information, see the Ox
Tutorial Introduction and the Ox User Reference Manual, which
accompany the Ox distribution.

The text of John Levine's original `README' as well as the header
of the shar file from the archive follows the line of asterisks.

--Kurt Bischoff  10/17/93
*************************************************************************

This is a Fortran 77 subset parser that I knocked together in about a
week.  It does a decent job of tokenizing and parsing Fortran,
although it is quite incomplete.  It is provided as is without any
claim that it is suitable for any purpose nor with any promise of
support.  Copying is permitted so long as it is not for direct
commercial advantage.  See the copyright notice in each source file.

The general strategy is as follows:

	1.  Read each line, determine if it's a comment or
	continutation.
	2.  If not a comment, add into the current statement buffer,
	removing quoted literals and hollerith strings and replacing
	them by special tokens (a space followed by a digit.)
	3.  Once we have an entire statement, scan it to see if it
	looks like an assignment statement.  If not it must be a
	keyword	statement.
	4.  Call the yacc parser.  From this point, tokenizing is
	pretty simple -- see if any of the keyword or special
	character tokens that are allowed in the current context
	match, if not look for a number or a name. Statement numbers
	are treated as integer constants.

The one case where I know that I parse wrong is something like:

	real function a(34)

which dimensions the array functiona but parses incorrectly as a function
declaration with a bogus dummy argument.  This is hard to fix and is unlikely
to cause trouble in practice.

The language it parses includes some invalid constructs that would
need to be kicked out semantically, e.g.:

	dimension foo

because I treat dimension and explicit type statements the same.

If you want to extend this to parse more of Fortran, you'll obviously
need to add more yacc syntax (note that there is syntax in the
current parser that the lexer doesn't generate the tokens for,) more
lexer tokens, and more lexer states.  Lexer states you'll need
certainly include:

	-- Looking for the TO in an assign statement.
	-- Tokenizing format statements (unless you want to do
	it at runtime, a common approach)
	-- Looking for the zillion possible keywords in I/O
	statements.

There are doubtless more, you'll know them when you see them.

I have run this under Microsoft C 5.1 on a PC and under GCC 1.35.  It
should work on the regular unix PCC with minimal modifications,
mostly getting rid of a few ANSI function prototypes that I use and
perhaps adjusting the varargs constructs in emit().  It has parsed
many of the old IBM SSP routines, so I'm fairly confident that it
parses what it parses pretty well.

If you do anything interesting with this, I'd appreciate hearing
about it.

John Levine
P.O. Box 349
Cambridge MA 02238
+1 617 492 3869
Internet: Levine@yale.edu or johnl@esegue.segue.boston.ma.us
MCI Mail: 103-7498, WUI telex 6501037498 MCI UW
Genie: J.LEVINE3

***********************************************************************
Here is the header from the archived shar file for the original Yacc/C
parser.  --K.B.

#!/bin/sh
# shar:	Shell Archiver  (v1.22)
#
#	Run the following text with /bin/sh to create:
#	  README
#	  makefile
#	  ftnlex.c
#	  fparse.y
#	  fmain.c
#	  ftn.h
#
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/README`; if test $1 -ne 41623
then
	echo ERROR: oxDistG1.04/grammars/ftn/README checksum is $1 should be 41623
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/README`
if test $1$2$3 != 1227774767
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/README are $* should be 122 777 4767
fi

chmod 755 oxDistG1.04/grammars/ftn/README

if test -f oxDistG1.04/grammars/ftn/fmain.c
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/fmain.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/fmain.c
	if test -f oxDistG1.04/grammars/ftn/fmain.c
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/fmain.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/fmain.c
cat >oxDistG1.04/grammars/ftn/fmain.c <<'@EOF'
/*************************************************************************
*                                                                        *
*     Fortran 77 Subset Parser - November 1988                           *
*     Copyright 1988 - John R. Levine.  All rights reserved.             *
*     Permission is hereby granted to make copies in modified or         *
*     unmodified form so long as this copyright notice is preserved      *
*     and such copies are not made for direct commercial advantage.      *
*                                                                        *
*     Any other use such as incorporation in whole or in part in a       *
*     product offered for sale requires separate permission.             *
*                                                                        *
*     John R. Levine                                                     *
*     P.O. Box 349                                                       *
*     Cambridge MA 02238-0349                                            *
*                                                                        *
*     Internet/uucp: Levine@yale.edu    MCI Mail:  103-7498              *
*                                                                        *
*************************************************************************/

/* simple main program that parses a statement at a time and emits Lisp
   expressions corresponding to the parsed tokens.
 */

#include <stdio.h>
#include <stdarg.h>
#include "ftn.h"
#include "fparse.h"

FILE *ifile;
FILE *ofile = stdout;
extern yydebug;

main(ac, av)
char **av;
{
	if(av[1][0] == '-') {
		yydebug++;
		av++;
		ac--;
	}

	ifile = fopen(av[1], "r");
	if(!ifile) {
		perror(av[1]);
		return 1;
	}
	if(ac > 2) {
		ofile = fopen(av[2], "w");
		if(!ofile) {
			perror(av[2]);
			return 1;
		}
	}

	while(lex0()) {		/* prescan a statement */
		yyparse();	/* then parse it */
		lex1();		/* then clean it up */
	}
	return 0;
}

char *relops[] = {
	"???", 	"EQ", "NE", "LT", "LE", "GT", "GE" 
};

/*VARARGS*/
void
emit(int tok,...)
{
	va_list vp;
	int ty;
	char *s;
	
	switch(tok) {
	case 0:		s = ""; break;
	case 1:		s = "STMT"; break;
	case AND:	s = "AND"; break;
	case CALL:	s = "CALL"; break;
	case CAT:	s = "CAT"; break;
	case CCON:	s = "CCON"; break;
	case CM:	s = "CM"; break;
	case COLON:	s = "COLON"; break;
	case COMMON:	s = "COMMON"; break;
	case CONTINUE:	s = "CONTINUE"; break;
	case CP:	s = "CP"; break;
	case DIV:	s = "DIV"; break;
	case DO:	s = "DO"; break;
	case END:	s = "END"; break;
	case EQ:	s = "EQ"; break;
	case EQV:	s = "EQV"; break;
	case FUNCTION:	s = "FUNCTION"; break;
	case GOTO:	s = "GOTO"; break;
	case ICON:	s = "ICON"; break;
	case IF:	s = "IF"; break;
	case MINUS:	s = "MINUS"; break;
	case NAME:	s = "NAME"; break;
	case NOT:	s = "NOT"; break;
	case OP:	s = "OP"; break;
	case OR:	s = "OR"; break;
	case PLUS:	s = "PLUS"; break;
	case POW:	s = "POW"; break;
	case RCON:	s = "RCON"; break;
	case RELOP:	s = "RELOP"; break;
	case RETURN:	s = "RETURN"; break;
	case STAR:	s = "STAR"; break;
	case SUBROUTINE:	s = "SUBROUTINE"; break;
	case TO:	s = "TO"; break;
	case TYPE:	s = "TYPE"; break;
	case UMINUS:	s = "UMINUS"; break;
	default:	s = "???"; break;
	} /* codes */

	fprintf(ofile, "(%s", s);
	
	va_start(vp, tok);
	switch(tok) {
	case FUNCTION:
		ty = va_arg(vp, type);
		s = va_arg(vp, char*);
		fprintf(ofile, " %d %d %s", TYTYPE(ty), TYLEN(ty), s);
		break;
	case CALL:
	case NAME:
	case SUBROUTINE:
	case TO:
		s = va_arg(vp, char*);
		if(!s || !*s)
			s = "Blank";
		fprintf(ofile, " %s", s);
		break;
	case TYPE:
		ty = va_arg(vp, type);
		fprintf(ofile, " %d %d", TYTYPE(ty), TYLEN(ty));
		break;
	case ICON:
	case DO:
	case GOTO:
	case 1:	/* hack for *NNN statement numbers in call statements */
		fprintf(ofile, " %ld", va_arg(vp, long));
		break;
	case CCON:
		fprintf(ofile, " \"%s\"", va_arg(vp, char *));
		break;
	case RCON:
		fprintf(ofile, " %g", va_arg(vp, double));
		break;
	case EQV:
		fprintf(ofile, " %sEQV", va_arg(vp, int)? "N": "");
		break;
	case RELOP:
		fprintf(ofile, " %s", relops[va_arg(vp, int)]);
		break;
	}
	fprintf(ofile, ")\n");
	va_end(vp);
} /* emit */
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/fmain.c`; if test $1 -ne 56344
then
	echo ERROR: oxDistG1.04/grammars/ftn/fmain.c checksum is $1 should be 56344
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/fmain.c`
if test $1$2$3 != 1565864191
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/fmain.c are $* should be 156 586 4191
fi

chmod 755 oxDistG1.04/grammars/ftn/fmain.c

if test -f oxDistG1.04/grammars/ftn/fparse.y
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/fparse.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/fparse.y
	if test -f oxDistG1.04/grammars/ftn/fparse.y
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/fparse.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/fparse.y
cat >oxDistG1.04/grammars/ftn/fparse.y <<'@EOF'
/*************************************************************************
*                                                                        *
*     Fortran 77 Subset Parser - November 1988                           *
*     Copyright 1988 - John R. Levine.  All rights reserved.             *
*     Permission is hereby granted to make copies in modified or         *
*     unmodified form so long as this copyright notice is preserved      *
*     and such copies are not made for direct commercial advantage.      *
*                                                                        *
*     Any other use such as incorporation in whole or in part in a       *
*     product offered for sale requires separate permission.             *
*                                                                        *
*     John R. Levine                                                     *
*     P.O. Box 349                                                       *
*     Cambridge MA 02238-0349                                            *
*                                                                        *
*     Internet/uucp: Levine@yale.edu    MCI Mail:  103-7498              *
*                                                                        *
*************************************************************************/


%{
#include "ftn.h"
%}
%union {
	expr uuexp;
	long uulong;
	int uuint;
	type uutype;
}
/* generic tokens */
%token PLUS MINUS OP CP STAR POW DIV CAT CM EQ COLON
%token NOT AND OR
%token <uuint> RELOP EQV
%token <uuexp> NAME CONST ICON RCON LCON CCON

/* a zillion keywords */
%token IF THEN ELSE ELSEIF ENDIF DO GOTO ASSIGN TO CONTINUE STOP
%token <uuint> RDWR
%token OPEN CLOSE BACKSPACE REWIND ENDFILE FORMAT
%token PROGRAM FUNCTION SUBROUTINE ENTRY END CALL RETURN
%token <uutype> TYPE DIMENSION
%token COMMON EQUIVALENCE EXTERNAL PARAMETER INTRINSIC IMPLICIT
%token SAVE DATA

%left EQV
%left OR
%left AND
%nonassoc NOT
%nonassoc RELOP
%left CAT
%left PLUS MINUS
%left STAR DIV
%right POW
%nonassoc UMINUS

%type <uutype> opttype

%%

statement:	s	{ emit(0); }
	;

s:		PROGRAM NAME
	;

s:		opttype FUNCTION NAME { emit(FUNCTION, $1, $3.n.name); }
			OP funargs CP
	;

opttype:	/* empty */ { $$ = 0; }
	|	TYPE
	;

funargs:	funarg
	|	funargs CM funarg
	;

funarg:		NAME	{ emit(NAME, $1.n.name); }
	|	STAR	{ emit(STAR); }
	;

s:		ENTRY NAME
	|	ENTRY NAME OP funargs CP
	;

s:		SUBROUTINE NAME { emit(SUBROUTINE, $2.n.name); }
	|	SUBROUTINE NAME { emit(SUBROUTINE, $2.n.name); }
			OP funargs CP
	;

/* we give dimension and explicit type statements the same syntax here
   because I'm lazy.  This allows e.g. 
	   DIMENSION FOO
   which is easier to kick out semantically
 */

s:		DIMENSION { emit(TYPE, 0); } arydcllist
	|	TYPE { emit(TYPE, $1); } arydcllist
	;

arydcllist:	arydcl
	|	arydcllist CM arydcl
	;

arydcl:		NAME { emit(NAME, $1.n.name); } OP dclsublist CP
		{ emit(CP); }
	|	NAME { emit(NAME, $1.n.name); emit(CP); }
	;

dclsublist:	dclsub
	|	dclsublist CM { emit(CP); } dclsub
	;

dclsub:		exp
	|	exp COLON { emit(COLON); } exp
	|	STAR
	|	exp COLON STAR { emit(COLON); emit(STAR); }
	;

s:		COMMON { emit(COMMON); } commonlist
	;

commonlist:	arydcl
	|	commonlist CM arydcl
	|	blockname
	|	commonlist optcomma blockname
	;

optcomma:	CM
	|	/* nothing */
	;

/* note here that the // for blank common looks a lot like the catenation
   operator.  Fortunately, there's no semantic ambiguity */

blockname:	DIV NAME DIV { emit(TO, $2.n.name); }
	|	CAT { emit(TO, ""); }	/* blank common */
	;

s:		EQUIVALENCE quivlist
	;

quivlist:	quiv
	|	quivlist CM quiv
	;

quiv:		OP arydcllist CP
	;

s:		IMPLICIT impllist
	;

impllist:	impldcl
	|	impllist CM impldcl
	;

impldcl:	TYPE OP implletlist CP
	;

implletlist:	impllet
	|	implletlist CM impllet
	;

/* the NAMEs here actually have to be single letters, but it's easier to
   sort this out semantically than to make the parser only allow single
   letters for this one case */

impllet:	NAME
	|	NAME MINUS NAME
	;

exp:		NAME { emit(NAME, $1.n.name); }
	|	CONST {
			switch(TYTYPE($1.c.t)) {
			case TY_INTEGER:
				emit(ICON, $1.c.u.l);	break;
			case TY_REAL:
				emit(RCON, $1.c.u.d);	break;
			case TY_LOGICAL:
				emit(ICON, $1.c.u.l);	break;
			case TY_CHAR:
				emit(CCON, $1.c.u.c);	break;
			default:
				yyerror("Unsupported constant type");
				break;
			}
		}			

	|	OP exp CP
	|	exp PLUS exp { emit(PLUS); }
	|	exp MINUS exp { emit(MINUS); }
	|	exp STAR exp { emit(STAR); }
	|	exp DIV exp { emit(DIV); }
	|	exp POW exp { emit(POW); }
	|	exp CAT exp { emit(CAT); }
	|	exp RELOP exp { emit(RELOP, $2); }
	|	NOT exp { emit(NOT); }
	|	exp AND exp { emit(AND); }
	|	exp OR exp { emit(OR); }
	|	exp EQV exp { emit(EQV, $2); }
	|	MINUS exp	%prec UMINUS  { emit(UMINUS); }
	|	OP exp CM exp CP	/* complex constant, sort of */
	|	aryref
	
aryref:		NAME OP { emit(OP); emit(NAME, $1.n.name); } explist CP
			{ emit(CP); }
	;
		
explist:	exp
	|	explist CM { emit(CM); } exp
	;

/* assignment statement or arithmetic statement function, they're
	syntactically the same */

s:		lhs EQ exp { emit(EQ); }
	;

lhs:		NAME { emit(NAME, $1.n.name); }
	|	aryref
	;

s:		do CONST NAME EQ {
			emit(DO, $2.c.u.l);
			emit(NAME, $3.n.name);
		}
		exp CM { emit(CM); } exp optstep
	;

/* hack - normally you can parse statement numbers as numeric constants
	easily enough, except in a case like
		DO 10 E5 = 1,1000
	where 10E5 looks like a real number.  cxt_do tells the lexer only
	to recognize an integer here.
 */

do:		DO { context = cxt_do; }
	;

optstep:	CM { emit(CM); } exp
	|	/* empty */
	;

s:		CONTINUE { emit(CONTINUE); }
	;


s:		if exp ifcp s
	|	if exp ifcp CONST CM CONST CM CONST {
			emit(ICON, $4.c.u.l);
			emit(ICON, $6.c.u.l);
			emit(ICON, $8.c.u.l);
		}
	;

if:		IF OP	{ emit(IF); }
	;

	/* check ahead for target of IF statement */
	/* we have to use the same prescan to tell how to lex the target
	   statement of the IF.  Arithmetic IFs work OK because three
	   integers separated by commas don't look like an assignment
	   statement. */
	
ifcp:		CP {	if(prescan())
				context = cxt_norm;
			else
				context = cxt_stmt;
			emit(CP);
		}
	;

/* regular, assigned, and computed GOTO */

s:		GOTO CONST { emit(GOTO, $2.c.u.l); }
	|	GOTO NAME { emit(GOTO, 0L); emit(NAME, $2.n.name); }
		optstmtlist
	|	GOTO OP { emit(GOTO, 0L); } stmtlist CP { emit(CP); }
		optcomma exp
	;

optstmtlist:	CM OP stmtlist CP
	|	/* empty */
	;

stmtlist:	CONST { emit(ICON, $1.c.u.l); }
	|	stmtlist CM CONST { emit(ICON, $3.c.u.l); }
	;

s:		STOP
	;

s:		CALL NAME { emit(CALL, $2.n.name); }
	|	CALL NAME { emit(CALL, $2.n.name); } OP cexplist CP
	;

cexplist:	cexp
	|	cexplist CM { emit(CM); } cexp
	;

cexp:		exp
	|	STAR CONST { emit(1, $2.c.u.l); }
	;

s:		RETURN { emit(RETURN); }
	|	RETURN { emit(RETURN); } exp
	;
s:		END { emit(END); }
	;

%%

/* your standard error routine */
void yyerror(char *s)
{
	printf("%d: %s\n", lineno, s);
}
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/fparse.y`; if test $1 -ne 53341
then
	echo ERROR: oxDistG1.04/grammars/ftn/fparse.y checksum is $1 should be 53341
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/fparse.y`
if test $1$2$3 != 31710746949
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/fparse.y are $* should be 317 1074 6949
fi

chmod 755 oxDistG1.04/grammars/ftn/fparse.y

if test -f oxDistG1.04/grammars/ftn/ftn.h
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/ftn.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/ftn.h
	if test -f oxDistG1.04/grammars/ftn/ftn.h
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/ftn.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/ftn.h
cat >oxDistG1.04/grammars/ftn/ftn.h <<'@EOF'
/*************************************************************************
*                                                                        *
*     Fortran 77 Subset Parser - November 1988                           *
*     Copyright 1988 - John R. Levine.  All rights reserved.             *
*     Permission is hereby granted to make copies in modified or         *
*     unmodified form so long as this copyright notice is preserved      *
*     and such copies are not made for direct commercial advantage.      *
*                                                                        *
*     Any other use such as incorporation in whole or in part in a       *
*     product offered for sale requires separate permission.             *
*                                                                        *
*     John R. Levine                                                     *
*     P.O. Box 349                                                       *
*     Cambridge MA 02238-0349                                            *
*                                                                        *
*     Internet/uucp: Levine@yale.edu    MCI Mail:  103-7498              *
*                                                                        *
*************************************************************************/


/* some headers for a Fortran parser */

typedef unsigned char uchar;
typedef unsigned short type;	/* stores a Fortran type, high byte type, */
				/* low byte length */

/* binary expression */
typedef struct _binexp {
	type t;
	int expop;
	union _expr *el;
	union _expr *er;
} binexp;

/* Fortran constant */
typedef struct _const {
	type t;
	union {
		long l;
		double d;
		char *c;
	} u;
} constant;

/* name reference */
typedef struct _name {
	type t;
	char name[32];
} name;

/* more or less generic expression */
typedef union _expr {
	struct _binexp b;
	struct _const c;
	struct _name n;
} expr;

/* The Fortran lexical analyzer is very context dependent, here we list the
   various contexts that it knows about.
 */

enum contexts {
	cxt_stmt = 0,	/* beginning of statement */
	cxt_norm,	/* normal in an expression */
	cxt_do,		/* DO stmt seen */
	cxt_type,	/* type seen */
} context;

/* keyword lookup table */
typedef struct _kwdtab {
	char *kwd;	/* text of the keyword */
	int ktok;	/* token code */
	int klex;	/* lexical value */
} kwdtab;


/* types */
#define TY_NONE		0	/* no type */
#define TY_CHAR		1
#define	TY_LOGICAL	2
#define TY_INTEGER	3
#define	TY_REAL		4
#define TY_COMPLEX	5

#define MTYPE(ty, len) ((TY_##ty)<<8|(len))
#define TYTYPE(x) ((x)>>8)	/* type part of a type */
#define TYLEN(x) ((x)&0377)	/* length part of a type */

/* relops */
enum relops {
	rel_eq = 1,
	rel_ne,
	rel_lt,
	rel_le,
	rel_gt,
	rel_ge
};

/* some random stuff */
extern int lineno;


/* some prototypes */
void yyerror(char *);
void emit(int,...);
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/ftn.h`; if test $1 -ne 3067
then
	echo ERROR: oxDistG1.04/grammars/ftn/ftn.h checksum is $1 should be 3067
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/ftn.h`
if test $1$2$3 != 1053852908
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/ftn.h are $* should be 105 385 2908
fi

chmod 755 oxDistG1.04/grammars/ftn/ftn.h

if test -f oxDistG1.04/grammars/ftn/ftnlex.c
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/ftnlex.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/ftnlex.c
	if test -f oxDistG1.04/grammars/ftn/ftnlex.c
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/ftnlex.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/ftnlex.c
cat >oxDistG1.04/grammars/ftn/ftnlex.c <<'@EOF'
/*************************************************************************
*                                                                        *
*     Fortran 77 Subset Parser - November 1988                           *
*     Copyright 1988 - John R. Levine.  All rights reserved.             *
*     Permission is hereby granted to make copies in modified or         *
*     unmodified form so long as this copyright notice is preserved      *
*     and such copies are not made for direct commercial advantage.      *
*                                                                        *
*     Any other use such as incorporation in whole or in part in a       *
*     product offered for sale requires separate permission.             *
*                                                                        *
*     John R. Levine                                                     *
*     P.O. Box 349                                                       *
*     Cambridge MA 02238-0349                                            *
*                                                                        *
*     Internet/uucp: Levine@yale.edu    MCI Mail:  103-7498              *
*                                                                        *
*************************************************************************/

/* modified for use with Ox Fri Oct  8 21:02:25 EDT 1993 Kurt Bischoff.
   Excised a chunk containing all of the scanner's points of return 
   and placed them in a separate file intended as the L-file input to
   Ox, using the -G command-line option.
 */

#include "ftn.h"
#include "fparse.h"
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

extern FILE *ifile;

char stmtbuf[1321];	/* buffer a whole statement */
char linebuf[100];	/* buffer a line at a time */
char *lbcp;		/* start of text in linebuf; */
char *scp;		/* current location in stmtbuf */

long next_stno = -1;	/* statement number for next statement, from pre */
int lineno = 0;
enum contexts context;

/* first, we read in a statement */

/* After each statement is read, the read pointer is at the
   first line of the next statement because we needed to peek ahead and
   see if there was a continuation card.
*/

/* this reads a line, then looks to see if it's a continuation, and if
   not if there's a statement number.
   return values: -1 at EOF, 0 for first line, 1 for continuation */

int
rdstno()
{
	int flg;
	int colno;

	for(;;) {
		register char *cp;

		if(!fgets(linebuf, sizeof(linebuf), ifile))
			return -1;	/* EOF */
		lineno++;
		if(linebuf[0] == 'C' || linebuf[0] == 'c'
			|| linebuf[0] == '*')
			continue;	/* comment */
		/* check for totally blank line */
		/* and trim at column 72 */
		flg = 0;
		for(cp = linebuf, colno = 1; *cp; cp++, colno++) {
			if(*cp == '\n') {
				*cp = 0;
				break;
			}
			if(*cp == '\t' && colno < 5)
				colno = 5;	/* tab ahead */
			else if(*cp != ' ' && *cp != '\t')
				flg = 1;
			if(colno == 72) {
				cp[1] = 0;	/* white out seq cols */
				break;
			}
		}
		if(!flg)
			continue;	/* blank line comment */
		/* now, get the line number and comment flag */
		next_stno = 0;
		colno = 0;
		for(cp = linebuf; colno < 6; cp++, colno++) {
			if(isdigit(*cp))
				next_stno = 10*next_stno + *cp-'0';
			else if(*cp == '\t')
				colno = 5;
			else if(*cp != ' ')
				yyerror("Bad stmt label");
		}
		lbcp = cp;
		cp--;   /* point at continuation marker */
		return(*cp != ' ' && *cp != '\t' && *cp != '0');
	}
} /* rdstno */
		
int stmt_eof;

/* at prescan time quoted strings are pulled out and stashed here */
/* in the scanned statement, the literal string is replaced by a quote
   and a digit indicating which table entry it is */

char *string_tab[30];    /* quoted strings */
char **string_tabp = string_tab;

/* read and prescan a statement, pull out literal strings and squeeze out
   blanks.
   return 1 if statement read, 0 at eof */

int
rdstmt()
{
	char *cp;
	int c;
	int colno;
	int quoteflag = 0;	/* >0 means 3hfoo, -1 means 'foo' */
	int quotable = 0;       /* 1 if nnH allowed */
	char *quotep, *quotelim;
	
	/* make sure there's a line ready for us */
	if(next_stno < 0)
		stmt_eof = rdstno();

	if(stmt_eof < 0)
		return 0;

	/* at this point we might want to do something about the statement
	   number */
	
	/* now read and process lines until we find one that isn't a
	   continuation */
	
	cp = stmtbuf;
	do {
		char *icp;

		for(icp = lbcp; *icp; icp++) {

			c = *icp;
			/* process a card image */
			/* special case for literal strings, keep blanks */
			if(quoteflag) {
				if(quoteflag < 0 && c == '\'') {
					if(icp[1] != '\'') {
						*quotep = 0;
						string_tabp++;
						quoteflag = 0;
						continue;
					} else
						icp++;
				}

				if(quotep >= quotelim)
					yyerror("String too long");
				else
					*quotep++ = (char)c;
				if(quoteflag > 0)
					quoteflag--;
				if(quoteflag == 0) {
					*quotep = 0;
					string_tabp++;
					quoteflag = 0;
				}
				continue;
			}
			/* discard unquoted spaces */
			if(c == ' ' || c == '\t')
				continue;
			
			c = toupper(c);
			/* literal strings can only occur after (  = or / */
			/* consider  REAL*4HELLO */
			if(!quotable && (c == '=' || c == '/' || c == '('))
				quotable++;	/* could have string */

			/* check for quoted literal */
			if(c == '\'') {
				quoteflag = -1;
				*string_tabp = quotep = malloc(80);
				quotelim = quotep + 79;
				*cp++ = '\'';	/* string flag */
				*cp++ = '0'
				  + (string_tabp - string_tab);
				continue;
			}
			*cp = (char)c;
			/* check for counted (hollerith) literal */
			if(c == 'H' && quotable
			 && cp > stmtbuf && isdigit(cp[-1])) {
				char *tcp = cp-1;
				
				while(tcp > stmtbuf && isdigit(*tcp))
					tcp--;
				if(!isalnum(*tcp)) {	/* yes */
					tcp++;
					cp = tcp;	/* back over digs */
					quoteflag = 0;
					while(*tcp != 'H')
						quoteflag = quoteflag*10
							+ *tcp++ - '0';
					
					*string_tabp = quotep
					 = malloc(quoteflag+1);
					quotelim = quotep + quoteflag + 1;
					*cp++ = '\'';	/* string flag */
					*cp++ = '0'
					  + (string_tabp - string_tab);
					continue;
				}
			}
			cp++;
		} /* single line */
	} while((stmt_eof = rdstno()) == 1);
	if(quoteflag) {
		*quotep = 0;
		yyerror("Unterminated string");
	}
	*cp = 0;
	return 1;       /* found something */
} /* rdstmt */

/* prescan to see if this is an arithmetic statement */
/* returns 1 if it's an arithmetic stmt, 0 if not */
/* this hack involves looking for an equal sign not enclosed in parens
   and not followed by a comma not enclosed in parens.  Gross but effective.
 */

prescan()
{
	register char *cp;
	int parencount = 0;
	
	/* scan across counting parens and looking for an = */
	for(cp = scp; ; cp++) {
		switch(*cp) {
	case 0:		return 0;	/* no equal found */

	case '(':	parencount++;
			continue;

	case ')':	if(--parencount == 0) /* foo(a,...) = ... */
				if(cp[1] == '=')
					break;
				else
					return 0;	/* if(foo)... */
			continue;
	
	case '=':	if(parencount == 0)
				break;
	default:
			continue;       /* ignore anything else */
		}
		break;
	}

	/* found an equal, but might be a DO statement */
	/* now look for the comma which tells us it might be a DO loop */
	for(;;cp++) {
		switch(*cp) {
	case '(':	parencount++; break;
	case ')':	parencount--; break;
	case ',':	if(!parencount)
				return 0;
			break;
	case 0:		return 1;	/* it's an arith statement */
		} /* switch */
	} /* for */
} /* prescan */


/* keyword tables */

/* statement starting keywords */
kwdtab tab_stmt[] = {
	{ "CALL",	CALL,	0 },
	{ "COMMON",	COMMON, 0 },
	{ "CONTINUE",	CONTINUE,	0 },
	{ "DATA",	DATA, 0 },
	{ "DIMENSION",	DIMENSION,	0 },
	{ "DO",		DO,	0 },
	{ "ENDIF",	ENDIF,	0 },
	{ "END",	END, 0 },
	{ "ENTRY",	ENTRY,	0 },
	{ "EQUIVALENCE", EQUIVALENCE, 0 },
	{ "EXTERNAL",	EXTERNAL, 0 },
	{ "FORMAT",	FORMAT, 0 },
	{ "FUNCTION",	FUNCTION,	0 },
	{ "GOTO",	GOTO,	0 },
	{ "IF",		IF,	0 },
	{ "IMPLICIT",	IMPLICIT,	0 },
	{ "INTRINSIC",	INTRINSIC, 0 },
	{ "PROGRAM",	PROGRAM,	0 },
	{ "RETURN",	RETURN,	0 },
	{ "REWIND",	REWIND, 0 },
	{ "SAVE",	SAVE, 0 },
	{ "STOP",	STOP,	0 },
	{ "SUBROUTINE",	SUBROUTINE,	0 },
	{ "THEN",	THEN,	0 },
	NULL
};

/* type declarators */
kwdtab tab_type[] = {
	{ "DOUBLEPRECISION",	TYPE,	MTYPE(REAL, 8), },
	{ "REAL*8",	TYPE,	MTYPE(REAL, 8), },
	{ "REAL*4",	TYPE,	MTYPE(REAL, 4), },
	{ "REAL",	TYPE,	MTYPE(REAL, 4), },
	
	{ "INTEGER*4",	TYPE,	MTYPE(INTEGER, 4), },
	{ "INTEGER",	TYPE,	MTYPE(INTEGER, 4), },


	{ "LOGICAL*4",	TYPE,	MTYPE(LOGICAL, 4), },
	{ "LOGICAL",	TYPE,	MTYPE(LOGICAL, 4), },


	{ "DOUBLECOMPLEX",	TYPE,	MTYPE(COMPLEX, 16), },
	{ "COMPLEX*16",	TYPE,	MTYPE(COMPLEX, 16), },
	{ "COMPLEX*8",	TYPE,	MTYPE(COMPLEX, 8), },
	{ "COMPLEX",	TYPE,	MTYPE(COMPLEX, 4), },


	{ "CHARACTER",	TYPE,	MTYPE(CHAR, 1), },
	NULL
};

/* normal tokens */
kwdtab tab_toks[] = {
	{ "+",	PLUS,	0 },
	{ "-",	MINUS,	0 },
	{ "(",	OP,	0 },
	{ ")",	CP,	0 },
	{ "**",	POW,	0 },
	{ "*",	STAR,	0 },
	{ "//",	CAT,	0 },
	{ "/",	DIV,	0 },
	{ ",",	CM,	0 },
	{ "=",	EQ,	0 },
	{ ":",	COLON,	0 },
	{ ".NOT.",	NOT,	0 },
	{ ".AND.",	AND,	0 },
	{ ".OR.",	OR,	0 },
	{ ".EQV.",	EQV, 0 },
	{ ".NEQV.",	EQV, 1 },
	{ ".EQ.",	RELOP,	rel_eq },
	{ ".NE.",	RELOP,	rel_ne },
	{ ".LT.",	RELOP,	rel_lt },
	{ ".LE.",	RELOP,	rel_le },
	{ ".GT.",	RELOP,	rel_gt },
	{ ".GE.",	RELOP,	rel_ge },
	{ ".TRUE.",	CONST,	1 },
	{ ".FALSE.",	CONST,	0 },
	NULL
};


/* call this before parsing a statement */
/* returns 1 if there's a statement to parse */
/* also checks the statement type and sets the context appropriately */
lex0()
{
	if(!rdstmt())
		return 0;	/* EOF */
	scp = stmtbuf;
	if(prescan())
		context = cxt_norm;
	else
		context = cxt_stmt;
	return 1;
}

/* look to see if the next thing is a recognized keyword */
int
keyscan(tab)
register kwdtab *tab;
{
	while(tab->kwd) {
		int len = strlen(tab->kwd);
		
		if(!strncmp(scp, tab->kwd, len)) {
			scp += len;	/* skip over this */
			if(tab->ktok == CONST) {	/* hack */
				yylval.uuexp.c.t = MTYPE(LOGICAL, 4);
				yylval.uuexp.c.u.l = tab->klex;
			} else
			yylval.uuint = tab->klex;
			return tab->ktok;
		}
		tab++;
	}
	return 0;
} /* keyscan */

/* After all this setup, the lexer is quite simple.  It looks for the longest
   keyword legal in the current context or, failing that, for a number or
   name.  The various contexts are mostly set in the parser; the lexer resets
   the context to normal (name, number, or special character token) after
   each token. */

#include "oxout.l"

/* call this to clean up after lexing a statement */
/* It frees the entries in the string table, and emits the statement number
   for the next statement if there is one.
  */
lex1()
{
	while(string_tabp > string_tab)
		free(*--string_tabp);
	if(next_stno)
		emit(1, next_stno);
}
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/ftnlex.c`; if test $1 -ne 34449
then
	echo ERROR: oxDistG1.04/grammars/ftn/ftnlex.c checksum is $1 should be 34449
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/ftnlex.c`
if test $1$2$3 != 421172010769
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/ftnlex.c are $* should be 421 1720 10769
fi

chmod 755 oxDistG1.04/grammars/ftn/ftnlex.c

if test -f oxDistG1.04/grammars/ftn/ftnlex1.c
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/ftnlex1.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/ftnlex1.c
	if test -f oxDistG1.04/grammars/ftn/ftnlex1.c
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/ftnlex1.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/ftnlex1.c
cat >oxDistG1.04/grammars/ftn/ftnlex1.c <<'@EOF'
/* $Header: ftnlex1.c,v 1.3 93/10/31 15:54:40 bischoff Exp $ */ 

/*************************************************************************
*                                                                        *
*     Fortran 77 Subset Parser - November 1988                           *
*     Copyright 1988 - John R. Levine.  All rights reserved.             *
*     Permission is hereby granted to make copies in modified or         *
*     unmodified form so long as this copyright notice is preserved      *
*     and such copies are not made for direct commercial advantage.      *
*                                                                        *
*     Any other use such as incorporation in whole or in part in a       *
*     product offered for sale requires separate permission.             *
*                                                                        *
*     John R. Levine                                                     *
*     P.O. Box 349                                                       *
*     Cambridge MA 02238-0349                                            *
*                                                                        *
*     Internet/uucp: Levine@yale.edu    MCI Mail:  103-7498              *
*                                                                        *
*************************************************************************/


yylex()
 {
	int c;

	if(!*scp)
		return 0;	/* end of statement */

	switch(context) {
	case cxt_stmt:
		c = keyscan(tab_type);
		if(c)
			break;
		c = keyscan(tab_stmt);
		if(c)
			break;
		goto normal;	/* look for normal token */
	default:
		yyerror("Mystery context");
		context = cxt_norm;
	case cxt_norm:
	case cxt_do:
normal:
		c = keyscan(tab_toks);
		if(c)
			break;	/* found something */
		/* check for literal string */
		if(*scp == '\'') {
			char *str;

			c = CONST;
			scp++;
			str = string_tab[*scp++ - '0'];
			yylval.uuexp.c.t = MTYPE(CHAR, strlen(str));
			yylval.uuexp.c.u.c = str;
			break;
		}

		/* must be a number or name */
		if(isalpha(*scp)) {
			char *ocp = yylval.uuexp.n.name;

			yylval.uuexp.n.t = 0;
			while(isalnum(*scp)) {
				*ocp = *scp;
				ocp++;
				scp++;
			}
			*ocp = 0;
			c = NAME;
			break;
		} else {	/* constant */
			int dotseen = 0, expseen = 0;
			int mytype = MTYPE(INTEGER, 4);
			char *sbp;
			char sbuf[50];

			if(!isdigit(*scp) && *scp != '.') {
				yyerror("Unknown character");
				c = 0;
				break;
			}
			sbp = sbuf;
			for(;;) {
				if(isdigit(*scp)) {
					*sbp++ = *scp++;
					continue;
				}
				if(!dotseen && *scp == '.') {
					dotseen++;
					mytype = MTYPE(REAL, 4);
					*sbp++ = *scp++;
					continue;
				}
				if(!expseen && context != cxt_do
				 && (*scp == 'D' || *scp == 'E')) {
					expseen++;
					dotseen++;
					if(*scp == 'D')
						mytype = MTYPE(REAL, 8);
					else
						mytype = MTYPE(REAL, 4);
					*sbp++ = 'E';
					scp++;
					if(*scp == '+')
						scp++;
					else if(*scp == '-')
						*sbp++ = *scp++;
					continue;
				}
				break;  /* end of number */
			} /* for */
			*sbp = 0;
			yylval.uuexp.c.t = mytype;
			if(mytype == MTYPE(INTEGER, 4))
				yylval.uuexp.c.u.l = atol(sbuf);
			else
				yylval.uuexp.c.u.d = atof(sbuf);
			c = CONST;
			break;
		} /* name/const */
	} /* switch */
	context = cxt_norm;
	return c;
} /* yylex */

@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/ftnlex1.c`; if test $1 -ne 50738
then
	echo ERROR: oxDistG1.04/grammars/ftn/ftnlex1.c checksum is $1 should be 50738
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/ftnlex1.c`
if test $1$2$3 != 1273963354
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/ftnlex1.c are $* should be 127 396 3354
fi

chmod 755 oxDistG1.04/grammars/ftn/ftnlex1.c

if test -f oxDistG1.04/grammars/ftn/makefile
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/makefile
	if test -f oxDistG1.04/grammars/ftn/makefile
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/makefile
cat >oxDistG1.04/grammars/ftn/makefile <<'@EOF'
##########################################################################
#     Fortran 77 Subset Parser - November 1988                           #
#     Copyright 1988 - John R. Levine.  All rights reserved.             #
#     Permission is hereby granted to make copies in modified or         #
#     unmodified form so long as this copyright notice is preserved      #
#     and such copies are not made for direct commercial advantage.      #
#                                                                        #
#     Any other use such as incorporation in whole or in part in a       #
#     product offered for sale requires separate permission.             #
#                                                                        #
#     John R. Levine                                                     #
#     P.O. Box 349                                                       #
#     Cambridge MA 02238-0349                                            #
#                                                                        #
#     Internet/uucp: Levine@yale.edu    MCI Mail:  103-7498              #
#                                                                        #
##########################################################################

#########################################################################
# modified for use with Ox.  Fri Oct  8 19:58:23 EDT 1993  Kurt M. Bischoff
#########################################################################

WF=fmain.c fparse.y ftn.h ftnlex.c ftnlex1.c 

CFLAGS=-Aa
CC=cc
YFLAGS=-vdlt
OBJS=fparse.o ftnlex.o fmain.o
CLIBS= -ll -ly

ftn:	$(OBJS)
	${CC} $(CFLAGS) -o ftn $(OBJS) $(CLIBS)

fparse.o:	fparse.c ftn.h
		cc $(CFLAGS) -c fparse.c

fparse.c fparse.h:	oxout.y
		yacc $(YFLAGS) oxout.y
		mv y.tab.c fparse.c
		mv y.tab.h fparse.h

oxout.y oxout.l: fparse.y ftnlex1.c
	ox -I fparse.y -G ftnlex1.c

ftnlex.o:	ftnlex.c oxout.l fparse.h ftn.h
	${CC} $(CFLAGS) -c ftnlex.c

fmain.o:	fmain.c fparse.h ftn.h
	${CC} $(CFLAGS) -c fmain.c

clean:
	rm *.o oxout* fparse.c fparse.h ftn y.output
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/makefile`; if test $1 -ne 11847
then
	echo ERROR: oxDistG1.04/grammars/ftn/makefile checksum is $1 should be 11847
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/makefile`
if test $1$2$3 != 522042082
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/makefile are $* should be 52 204 2082
fi

chmod 755 oxDistG1.04/grammars/ftn/makefile

echo mkdir - oxDistG1.04/grammars/ftn/samples
mkdir oxDistG1.04/grammars/ftn/samples

if test -f oxDistG1.04/grammars/ftn/samples/t1
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/samples/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/samples/t1
	if test -f oxDistG1.04/grammars/ftn/samples/t1
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/samples/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/samples/t1
cat >oxDistG1.04/grammars/ftn/samples/t1 <<'@EOF'
       do 50 i=1,10
50     continue
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/samples/t1`; if test $1 -ne 52853
then
	echo ERROR: oxDistG1.04/grammars/ftn/samples/t1 checksum is $1 should be 52853
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/samples/t1`
if test $1$2$3 != 2536
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/samples/t1 are $* should be 2 5 36
fi

chmod 755 oxDistG1.04/grammars/ftn/samples/t1

if test -f oxDistG1.04/grammars/ftn/samples/t2
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/ftn/samples/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/ftn/samples/t2
	if test -f oxDistG1.04/grammars/ftn/samples/t2
	then
		echo Error: could not remove oxDistG1.04/grammars/ftn/samples/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/ftn/samples/t2
cat >oxDistG1.04/grammars/ftn/samples/t2 <<'@EOF'
       j = 0; 
       do 50 i=1,10
       j = j + 1; 
50     continue
       
@EOF
set `sum $sumopt <oxDistG1.04/grammars/ftn/samples/t2`; if test $1 -ne 23840
then
	echo ERROR: oxDistG1.04/grammars/ftn/samples/t2 checksum is $1 should be 23840
fi
set `wc -lwc <oxDistG1.04/grammars/ftn/samples/t2`
if test $1$2$3 != 51378
then
	echo ERROR: wc results of oxDistG1.04/grammars/ftn/samples/t2 are $* should be 5 13 78
fi

chmod 755 oxDistG1.04/grammars/ftn/samples/t2

chmod 755 oxDistG1.04/grammars/ftn/samples

chmod 755 oxDistG1.04/grammars/ftn

echo mkdir - oxDistG1.04/grammars/pascal
mkdir oxDistG1.04/grammars/pascal

echo mkdir - oxDistG1.04/grammars/pascal/RCS
mkdir oxDistG1.04/grammars/pascal/RCS

if test -f oxDistG1.04/grammars/pascal/RCS/Makefile,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/RCS/Makefile,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/RCS/Makefile,v
	if test -f oxDistG1.04/grammars/pascal/RCS/Makefile,v
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/RCS/Makefile,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/RCS/Makefile,v
sed 's/^@//' >oxDistG1.04/grammars/pascal/RCS/Makefile,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @# @;


1.3
date     93.10.31.22.02.17;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.17.59.15;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.16.45.15;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@# $Header: Makefile,v 1.2 93/10/17 17:59:15 bischoff Exp $

YACC=yacc
LEX=lex
OBJECTS=y.tab.o misc.o lex.yy.o token_name.o
CLIBS=-ll -ly 
OXFLAGS=
YFLAGS=-dv

# CLIBS = -ll -ly -lcurses -ltermcap
# OXFLAGS=-u -T
#

all:		extract-ids

extract-ids:	$(OBJECTS)
		cc -o extract-ids $(OBJECTS) $(CLIBS) 

y.tab.o:	y.tab.c
		cc -c y.tab.c

y.tab.c y.tab.h: oxout.y
		$(YACC) $(YFLAGS) oxout.y

lex.yy.c:	oxout.l
		$(LEX) oxout.l

lex.yy.o:	lex.yy.c tokens.h
		cc -c lex.yy.c

tokens.h:	y.tab.h
		-cmp -s y.tab.h tokens.h || cp y.tab.h tokens.h

token_name.c:	mktoken_name tokens.h
		sh mktoken_name

misc.o:		misc.c
		cc -c misc.c

token_name.o:	token_name.c
		cc -c token_name.c

install:	extract-ids
		if [ -d "$(BIN)" ] ; then cp extract-ids ident-list $(BIN)/ ; \
			     chmod 755 $(BIN)/extract-ids $(BIN)/ident-list ; fi
		
clean:
		rm *.o lex.yy.c y.tab.c y.tab.h y.output oxout.? \
		token_name.c tokens.h extract-ids

oxout.y oxout.l:pascal.y pascal.l
	ox $(OXFLAGS) pascal.y pascal.l

@@


1.2
log
@@restructuring of the original Makefile for use with Ox.
@@
text
@@d1 1
a1 1
# $Header$
@@


1.1
log
@@Initial revision
@@
text
@@d1 1
a1 1
OBJECTS = y.tab.o misc.o lex.yy.o token_name.o
d3 9
d13 1
d15 1
d17 14
a30 6
		cc -o extract-ids $(OBJECTS) -ly -ll
y.tab.c y.tab.h:	pascal.y
		yacc -vd pascal.y
lex.yy.c:	pascal.l
		lex pascal.l
lex.yy.o:	tokens.h
d33 1
d37 6
d48 6
a53 1
		rm -f *.o lex.yy.c y.* token_name.c tokens.h
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/RCS/Makefile,v`; if test $1 -ne 36076
then
	echo ERROR: oxDistG1.04/grammars/pascal/RCS/Makefile,v checksum is $1 should be 36076
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/RCS/Makefile,v`
if test $1$2$3 != 1252651845
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/RCS/Makefile,v are $* should be 125 265 1845
fi

chmod 755 oxDistG1.04/grammars/pascal/RCS/Makefile,v

if test -f oxDistG1.04/grammars/pascal/RCS/misc.c,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/RCS/misc.c,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/RCS/misc.c,v
	if test -f oxDistG1.04/grammars/pascal/RCS/misc.c,v
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/RCS/misc.c,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/RCS/misc.c,v
sed 's/^@//' >oxDistG1.04/grammars/pascal/RCS/misc.c,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.10.31.22.02.25;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.17.59.59;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.16.45.41;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@#include <stdio.h>


char  *create_string(s)
char	*s;
{
    char *p = (char *) malloc(strlen(s) + 1);
    if(p==NULL) internal_error("Cannot malloc in create-string");
    strcpy(p,s);
    return p;
}

int max(a,b)
int	a,b;
{
    return  a>b ? a : b;
}
@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/RCS/misc.c,v`; if test $1 -ne 15234
then
	echo ERROR: oxDistG1.04/grammars/pascal/RCS/misc.c,v checksum is $1 should be 15234
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/RCS/misc.c,v`
if test $1$2$3 != 67111746
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/RCS/misc.c,v are $* should be 67 111 746
fi

chmod 755 oxDistG1.04/grammars/pascal/RCS/misc.c,v

if test -f oxDistG1.04/grammars/pascal/RCS/ident-list,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/RCS/ident-list,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/RCS/ident-list,v
	if test -f oxDistG1.04/grammars/pascal/RCS/ident-list,v
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/RCS/ident-list,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/RCS/ident-list,v
sed 's/^@//' >oxDistG1.04/grammars/pascal/RCS/ident-list,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @# @;


1.3
date     93.10.31.22.02.21;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.17.59.49;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.16.45.30;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@#!/bin/sh
#
#	ident-list [-s] <program>
#
tmp1=/tmp/a$$X
tmp2=/tmp/a$$Y
sflag="$1"
if [ "x$sflag" = "x-s" ]
then shift
fi

cat $* | extract-ids >$tmp1
if [ "x$sflag" = "x-s" ]
then
	sed -e '/^program/d
/^field/d
/^external-file/d
s/^conformant-bound/parameter/
s/^procedure-parameter/parameter/
s/^function-parameter/parameter/
s/^var-parameter/parameter/
s/^value-parameter/parameter/
s/^enumerated-literal/constant/' <$tmp1 >$tmp2
	mv $tmp2 $tmp1
fi
sort -uf +0 -1 +1 -2 <$tmp1 |
awk '
func tabulate(title,n) {
	columns = int(pagewidth/(maxlen+3));
	colwidth = int(pagewidth/columns);
	rows = int((n+columns-1)/columns);
	format = sprintf("%%-%ds", colwidth);
	for(i=1;i<=rows; i++)
	{
	    printf "%-19s| ", title; title=""
	    for(j=0; j<columns; j++)
	    {
		x = i + j*rows
		if(x<=n)printf(format, s[x]);
	    }
	    print ""
	}
	print ""
}

BEGIN { itemtype="";  pagewidth=59
bar="---------------------------------------------------------------"}
{
	if($1 != itemtype)
	{
		if(n>0)  tabulate(itemtype,n)
		itemtype = $1; n=0; maxlen=0;
	}
	s[++n] = $2;  len = length($2);  if(len>maxlen)maxlen=len;
}
END { if(n>0)  tabulate(itemtype,n) }'

rm -f $tmp1
@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/RCS/ident-list,v`; if test $1 -ne 7917
then
	echo ERROR: oxDistG1.04/grammars/pascal/RCS/ident-list,v checksum is $1 should be 7917
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/RCS/ident-list,v`
if test $1$2$3 != 1082081654
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/RCS/ident-list,v are $* should be 108 208 1654
fi

chmod 755 oxDistG1.04/grammars/pascal/RCS/ident-list,v

if test -f oxDistG1.04/grammars/pascal/RCS/pascal.l,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/RCS/pascal.l,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/RCS/pascal.l,v
	if test -f oxDistG1.04/grammars/pascal/RCS/pascal.l,v
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/RCS/pascal.l,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/RCS/pascal.l,v
sed 's/^@//' >oxDistG1.04/grammars/pascal/RCS/pascal.l,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.10.31.22.02.33;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.18.00.14;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.16.46.04;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@%{
/******************************************************************************
		LEXICAL ANALYSER for ISO standard Pascal
		----------------------------------------

This lexical analyser satisfies the following requirements in British
Standards Institution Specification for Computer programming language Pascal
BS6192:1982 (ISO 7185:1983)

6.1.1	6.1.2	6.1.3	6.1.4	6.1.5	6.1.6	6.1.7
6.1.8	(except ^Z is considered to be a space)
6.1.9
******************************************************************************/

#include "y.tab.h"
int	character_no = -1;

#undef input
#undef unput
int  input()
{
    if(yysptr > yysbuf)
    {
	yytchar = U(*--yysptr);
    } else
	yytchar = getc(yyin);
    character_no++;
    if(yytchar == 10)  yylineno ++;
    if(yytchar == 0)   yytchar= ' ';
    if(yytchar == EOF) yytchar= 0;
    return yytchar;
}

unput(c)
int c;
{
    yytchar = c;
    if (yytchar == '\n') yylineno--;
    *yysptr++ = yytchar;
    character_no--;
}

comment()
{
    char c, lastc=' ';
    while(c = yyinput())
	if(c == '}' || (lastc=='*' && c==')'))
	    break;
        else
	    lastc = c;
}

char *laststring;
strings()
{
    char  *create_string();
    char  buf[256];
    char  c, *p = buf;
    while(c = yyinput())
        switch(c) {
	    case '\'' : if((c = yyinput()) == '\'')
			    *p++ = c;
			else
			{   unput(c); *p++ = '\0';
			    laststring = create_string(buf);
			    return;
			}
			break;
	    case '\n' :
	    case '\014' :
	    case '\015': yyerror("String not terminated");
			return;
	    default   : *p++ = c;
			break;
	}
}

char	numbertext[80];
char    lastident[128];

%}

A	[Aa]
B	[Bb]
C	[Cc]
D	[Dd]
E	[Ee]
F	[Ff]
G	[Gg]
H	[Hh]
I	[Ii]
J	[Jj]
K	[Kk]
L	[Ll]
M	[Mm]
N	[Nn]
O	[Oo]
P	[Pp]
Q	[Qq]
R	[Rr]
S	[Ss]
T	[Tt]
U	[Uu]
V	[Vv]
W	[Ww]
X	[Xx]
Y	[Yy]
Z	[Zz]
%%
\n				;
[ \t\32]			;
{A}{N}{D}			{ return(AND);		}
{A}{R}{R}{A}{Y}			{ return(ARRAY);	}
{B}{E}{G}{I}{N}			{ return(SBEGIN);	}
{C}{A}{S}{E}			{ return(CASE);		}
{C}{O}{N}{S}{T}			{ return(CONST);	}
{D}{I}{V}			{ return(DIV);		}
{D}{O}{W}{N}{T}{O}		{ return(DOWNTO);	}
{D}{O}				{ return(DO);		}
{E}{L}{S}{E}			{ return(ELSE);		}
{E}{N}{D}			{ return(END);		}
{F}{I}{L}{E}			{ return(SFILE);	}
{F}{O}{R}			{ return(FOR);		}
{F}{U}{N}{C}{T}{I}{O}{N}	{ return(FUNCTION);	}
{G}{O}{T}{O}			{ return(GOTO);		}
{I}{F}				{ return(IF);		}
{I}{N}				{ return(IN);		}
{L}{A}{B}{E}{L}			{ return(LABEL);	}
{M}{O}{D}			{ return(MOD);		}
{N}{I}{L}			{ return(NIL);		}
{N}{O}{T}			{ return(NOT);		}
{O}{F}				{ return(OF);		}
{O}{R}				{ return(OR);		}
{P}{A}{C}{K}{E}{D}		{ return(PACKED);	}
{P}{R}{O}{C}{E}{D}{U}{R}{E}	{ return(PROCEDURE);	}
{P}{R}{O}{G}{R}{A}{M}		{ return(PROGRAM);	}
{R}{E}{C}{O}{R}{D}		{ return(RECORD);	}
{R}{E}{P}{E}{A}{T}		{ return(REPEAT);	}
{S}{E}{T}			{ return(SET);		}
{T}{H}{E}{N}			{ return(THEN);		}
{T}{O}				{ return(TO);		}
{T}{Y}{P}{E}			{ return(TYPE);		}
{U}{N}{T}{I}{L}			{ return(UNTIL);	}
{V}{A}{R}			{ return(VAR);		}
{W}{H}{I}{L}{E}			{ return(WHILE);	}
{W}{I}{T}{H}			{ return(WITH);		}

[a-zA-Z][a-zA-Z0-9_]*		{ strcpy(lastident, yytext);
				  return(IDENTIFIER);
						/*if strict check no '_' */}
"<="				{ return(LE);	}
">="				{ return(GE);	}
"<>"				{ return(NE);	}
":="				{ return(BECOMES);	}
".."				{ return(DOTDOT);	}
"(."				{ return('[');	}
".)"				{ return(']');	}
"-"	|
"+"	|
"*"	|
"/"	|
"="	|
"<"	|
">"	|
"("	|
")"	|
"["	|
"]"	|
"."	|
","	|
";"	|
":"	|
"^"	{ return(yytext[0]); }
"@@"	{ return('^');	}
[0-9]+("."[0-9]+)?[eE][+-]?[0-9]+	|
[0-9]+"."[0-9]+				{ strcpy(numbertext,yytext);
					  return(UNSIGNED_REAL);	}
[0-9]+	{ strcpy(numbertext,yytext); return(UNSIGNED_INT);	}

"{"	comment();
"(*"	comment();
'	{ strings(); return(STRING); }
"}"	yyerror("'}' not in comment");
@.	{ char m[40];
	  sprintf(m,"Illegal character '\\%o'", (int)yytext[0]);
	  yyerror(m);
	}
@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/RCS/pascal.l,v`; if test $1 -ne 10176
then
	echo ERROR: oxDistG1.04/grammars/pascal/RCS/pascal.l,v checksum is $1 should be 10176
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/RCS/pascal.l,v`
if test $1$2$3 != 2375834311
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/RCS/pascal.l,v are $* should be 237 583 4311
fi

chmod 755 oxDistG1.04/grammars/pascal/RCS/pascal.l,v

if test -f oxDistG1.04/grammars/pascal/RCS/mktoken_name,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/RCS/mktoken_name,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/RCS/mktoken_name,v
	if test -f oxDistG1.04/grammars/pascal/RCS/mktoken_name,v
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/RCS/mktoken_name,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/RCS/mktoken_name,v
sed 's/^@//' >oxDistG1.04/grammars/pascal/RCS/mktoken_name,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @# @;


1.3
date     93.10.31.22.02.28;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.18.00.06;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.16.45.51;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@#!/bin/sh
#
#	Make a symbol name
#
(
echo 'char *token_name(i)
int i;
{
    static char buf[10];
    switch(i)
    {
	default  : if(i<256)
		   {
		       if(i<32 || i>126)
			   sprintf(buf, "0%o", i);
		       else
		           sprintf(buf, "'%c'", i);
		       return buf;
		   }
		   else
		       return("<Unknown token>");
	case   0 : return("<End of input>");'
awk '{printf"	case %d : return(\"%s\");\n",  $4, $3}'	< y.tab.h
echo '    }
}'
)  > token_name.c
@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/RCS/mktoken_name,v`; if test $1 -ne 61664
then
	echo ERROR: oxDistG1.04/grammars/pascal/RCS/mktoken_name,v checksum is $1 should be 61664
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/RCS/mktoken_name,v`
if test $1$2$3 != 76137957
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/RCS/mktoken_name,v are $* should be 76 137 957
fi

chmod 755 oxDistG1.04/grammars/pascal/RCS/mktoken_name,v

if test -f oxDistG1.04/grammars/pascal/RCS/pascal.y,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/RCS/pascal.y,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/RCS/pascal.y,v
	if test -f oxDistG1.04/grammars/pascal/RCS/pascal.y,v
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/RCS/pascal.y,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/RCS/pascal.y,v
sed 's/^@//' >oxDistG1.04/grammars/pascal/RCS/pascal.y,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.10.31.22.02.36;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.18.00.23;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.16.46.13;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@fixed argument lists of internal_error and warning to silence errors
from SGI compiler.
@@
text
@@%{
#include <stdio.h>
#include "types.h"

extern	int	yylineno;
extern	char	yytext[];
extern	char	numbertext[80];
extern	char	*laststring;
extern	char	lastident[];

extern  char	*create_string();

#define YYSTYPE item


int	lexical_level = 0;

static	int	param_level = 0;
static	char *its_a = "error - uninitialised";

%}

%start program

%token UNSIGNED_INT UNSIGNED_REAL STRING IDENTIFIER
%token NE LE GE BECOMES DIV MOD NIL IN OR AND NOT DOTDOT
%token IF THEN ELSE CASE OF REPEAT UNTIL WHILE DO FOR TO DOWNTO
%token SBEGIN END WITH GOTO CONST VAR TYPE ARRAY RECORD SET SFILE FUNCTION
%token PROCEDURE LABEL PACKED PROGRAM

%%   /*start of rules*/
program		: PROGRAM {its_a="program";} newident external_files ';' 
			block '.'
		;
external_files  : /*empty*/
		| '(' {its_a="external-file";} newident_list ')'
		;

block		: opt_declarations  statement_part
		;
opt_declarations: /*empty*/
		| declarations
		;
declarations	: declarations declaration	/*should be left-recursive*/
		| declaration
		;
declaration	: label_dcl_part
		| const_dcl_part
		| type_dcl_part
		| var_dcl_part
		| proc_dcl_part
		;

label_dcl_part	: LABEL labels ';'
		;
labels		: labels ',' label
		| label
		;
label		: UNSIGNED_INT		/* 0 <= value <= 9999 [6.1.6] */
		;

const_dcl_part	: CONST const_defs ';'
		;
const_defs	: const_defs ';' const_def
		| const_def
		;
const_def	: {its_a="constant";} newident '=' constant
		;

constant	: unsigned_num
		| '+' unsigned_num
		| '-' unsigned_num
		| ident				/*check it is constant*/
		| '+' ident
		| '-' ident
		| STRING			/*type is char if len=1*/
		;

unsigned_num	: UNSIGNED_INT
		| UNSIGNED_REAL
		;

type_dcl_part	: TYPE type_defs ';'
		;
type_defs	: type_defs ';' type_def
		| type_def
		;
type_def	: {its_a="type";} newident '=' type
		;

type		: simple_type
		| PACKED struct_type
		| struct_type
		| '^' IDENTIFIER    /*check forward reference semantics*/
		;

simple_type	: '(' {its_a="enumerated-literal";} newident_list ')'
		| constant DOTDOT constant
		| ident
		;

struct_type	: ARRAY '[' index_t_list ']' OF type
		| RECORD /*consider this a scope*/ field_list END
		| SET OF simple_type
		| SFILE OF type
		;
index_t_list	: index_t_list ',' simple_type
		| simple_type
		;
field_list	: fixed_part
		| fixed_part ';' variant_part
		| variant_part
		;
fixed_part	: fixed_part ';' record_section
		| record_section
		;
record_section	: {its_a="field";} newident_list ':' type
		| /*empty*/
		;
variant_part	: CASE {its_a="field";} tag_field OF variants
		;
tag_field	: newident ':' ident 
		| ident /*type*/
		;
variants	: variants ';' variant
		| variant
		;
variant		: case_label_list ':' '(' field_list ')'
		| /*empty*/
		;

var_dcl_part	: VAR variable_dcls ';'
		;
variable_dcls	: variable_dcls ';' variable_dcl
		| variable_dcl
		;
variable_dcl	: {its_a="variable";} newident_list ':' type
		;
newident_list	: new_id_list {its_a="don't know";}
		;
new_id_list	: new_id_list ',' newident
		| newident
		;

proc_dcl_part	: proc_or_func
		;
proc_or_func	: proc_heading ';' body ';'     /*check if forward or fwd refd*/
			{lexical_level--;
			}
		| func_heading ';' body ';'  /*also func heading may be -type */
			{lexical_level--;
			}
		;
proc_heading	: PROCEDURE
			{if(param_level==0)its_a="procedure";}
		  newident {lexical_level++;}
			formal_params
		;
func_heading	: FUNCTION
			{if(param_level==0)its_a="function";}
		  newident {lexical_level++;}
			function_form
		;
function_form	: /*empty*/			/*if forward referenced*/
		| formal_params ':' ident
		;

body		: block
			/* result determined in block */
		| IDENTIFIER				/*directive-FORWARD*/
		;
formal_params	: /*empty*/
		| '(' {param_level++;} formal_p_sects ')' {param_level--;}
		;
formal_p_sects	: formal_p_sects ';' formal_p_sect
		| formal_p_sect
		;
formal_p_sect	: {its_a="value-parameter";} param_group
		| VAR {its_a="var-parameter";} param_group
		| {its_a="procedure-parameter";} proc_heading
			{lexical_level--;}
		| {its_a="function-parameter";} func_heading  {lexical_level--;}
		;
param_group	: newident_list ':' paramtype
		;
paramtype	: ident
		| ARRAY '[' index_specs ']' OF paramtype
		| PACKED ARRAY '[' index_spec ']' OF ident
		;
index_specs	: index_specs ';' index_spec
		| index_spec
		;
index_spec	: {its_a="conformant-bound";} newident DOTDOT newident ':' ident
		;

statement_part	: compound_stmt
		;
compound_stmt	: SBEGIN statements END
		;
statements	: statements ';' statement
		| statement
		;
statement	: /*empty*/
		| label ':' statement
		| compound_stmt
		| assignment
		| procedure_call
		| GOTO label
		| IF expression THEN statement
		| IF expression THEN statement ELSE statement
		| CASE expression OF case_list END
		| WHILE expression DO statement
		| REPEAT statements UNTIL expression
		| FOR ident BECOMES expression direction expression DO statement
		| WITH rec_var_list DO statement 
		;
direction	: TO
		| DOWNTO
		;

assignment	: variable BECOMES expression	/* must test for fn_ident */
	/*	| ident BECOMES expression	*/
		;

procedure_call	: ident actual_params
		;

actual_params	:  /*empty*/
		| '(' actuals_list ')'
		;
actuals_list	: actuals_list ',' actual_param
		| actual_param
		;
actual_param	: expression    /* which could be a variable or a proc/fn id */
		| expression colon_things  /* only in i/o */
		;
colon_things    : ':' expression	/*integer*/
		| ':' expression ':' expression 
		;

case_list	: case_list ';' case_list_elem
		| case_list_elem
		;
case_list_elem	: case_label_list ':' statement
		| /*empty*/
		;
case_label_list	: case_label_list ',' case_label
		| case_label
		;
case_label	: constant
		;

rec_var_list	: rec_var_list ',' record_var
		| record_var
		;

expression	: simple_expr
		| simple_expr relational_op simple_expr
		;
relational_op	: '='
		| '<'
		| '>'
		| LE
		| GE
		| NE
		| IN
		;

simple_expr	: term
		| '+' term
		| '-' term
		| simple_expr add_op term
		;
add_op		: '+'
		| '-'
		| OR
		;

term		: factor
		| term mult_op factor
		;
mult_op		: '*'
		| '/'
		| DIV
		| MOD
		| AND
		;

factor		: variable		/* could be a const_ident of fn_call*/
		| unsigned_lit
		| '(' expression ')'
	/*	| function_call		*/
		| set
		| NOT factor
		;

unsigned_lit	: unsigned_num
		| STRING			/*type is char if len=1*/
		| NIL
		;
/*
function_call	: ident actual_params
		;
*/

set		: '[' member_list ']'
		;
member_list	: /*empty*/
		| members
		;
members		: members ',' member
		| member
		;
member		: expression
		| expression DOTDOT expression
		;

/* kludge */
variable	: ident actual_params	/* check variable, const_id, fn_call */
		| variable '[' expressions ']'
		| variable '.' ident
		| variable '^'
		;
expressions	: expressions ',' expression
		| expression
		;
record_var	: variable
		;
ident		: IDENTIFIER
		;
newident	: IDENTIFIER
		    { 
			if(param_level<2)
			    printf("%s\t%s\n", its_a, lastident);
		    }
		;
%%   /*start of routines*/

yyerror(msg) char *msg;
{
    if(msg==NULL || *msg=='\0')
	fprintf(stderr, "Error at %s near line %d\n",
				token_name(yychar), yylineno);
    else
	fprintf(stderr, "Error at %s near line %d : %s\n",
				token_name(yychar), yylineno, msg);
    exit(1);
}

parser_info()
{
    printf("\n%d line%s parsed\n", yylineno, plural(yylineno));
}


internal_error(s,a1,a2,a3,a4)
char *s;
{
    fprintf(stderr, "Internal error: ");
    fprintf(stderr, s, a1, a2, a3, a4);
    exit(2);
}

warning(fmt, a1, a2, a3, a4)
char *fmt;
{
    fprintf(stderr, "Warning line %d: ", yylineno);
    fprintf(stderr, fmt, a1, a2, a3, a4);
    fprintf(stderr, "\n");
}

main()
{
    yyparse();
}
@@


1.2
log
@@replaced string-constant token ":" with character-constant token ':'.

String-constant tokens are not supported by Ox.
@@
text
@@d357 1
d365 1
@@


1.1
log
@@Initial revision
@@
text
@@d237 2
a238 2
colon_things    : ":" expression	/*integer*/
		| ":" expression ":" expression 
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/RCS/pascal.y,v`; if test $1 -ne 24815
then
	echo ERROR: oxDistG1.04/grammars/pascal/RCS/pascal.y,v checksum is $1 should be 24815
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/RCS/pascal.y,v`
if test $1$2$3 != 43411458302
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/RCS/pascal.y,v are $* should be 434 1145 8302
fi

chmod 755 oxDistG1.04/grammars/pascal/RCS/pascal.y,v

if test -f oxDistG1.04/grammars/pascal/RCS/types.h,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/RCS/types.h,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/RCS/types.h,v
	if test -f oxDistG1.04/grammars/pascal/RCS/types.h,v
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/RCS/types.h,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/RCS/types.h,v
sed 's/^@//' >oxDistG1.04/grammars/pascal/RCS/types.h,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @ * @;


1.3
date     93.10.31.22.04.07;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.18.02.00;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.16.46.24;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@original from archive
@@


1.3
log
@@*** empty log message ***
@@
text
@@#define pluralsuffix(num,suffix)	((num)==1?"":(suffix))
#define plural(num)	pluralsuffix(num,"s")
#define item int
@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/RCS/types.h,v`; if test $1 -ne 14912
then
	echo ERROR: oxDistG1.04/grammars/pascal/RCS/types.h,v checksum is $1 should be 14912
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/RCS/types.h,v`
if test $1$2$3 != 5384608
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/RCS/types.h,v are $* should be 53 84 608
fi

chmod 755 oxDistG1.04/grammars/pascal/RCS/types.h,v

if test -f oxDistG1.04/grammars/pascal/RCS/README,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/RCS/README,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/RCS/README,v
	if test -f oxDistG1.04/grammars/pascal/RCS/README,v
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/RCS/README,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/RCS/README,v
sed 's/^@//' >oxDistG1.04/grammars/pascal/RCS/README,v <<'@EOF'
head     1.3;
access   ;
symbols  ;
locks    bischoff:1.3; strict;
comment  @# @;


1.3
date     93.10.31.22.02.01;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.17.58.10;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@README for the Ox adaptation of a Pascal grammar found in the comp.compilers
archive.
@@


1.3
log
@@*** empty log message ***
@@
text
@@$Header: README,v 1.2 93/10/17 17:58:10 bischoff Exp $

The code in this directory originated as a Yacc/Lex specification
for a parser for the Pascal language.  It came from an archive
mentioned in the comp.compilers monthly message.  I don't know
who wrote it.

This is an adaptation for use with Ox of the code from the
archive. Two lines of the Yacc input specification file
`pascal.y' are changed from what I found in the archive.  Those
changes replace the Yacc string token ":" with the character
constant token ':'.  Allowing such string tokens is usually
considered an obsolete feature of Yacc, and is not supported by
Ox.  `Makefile' is changed to cause preprocessing by Ox.  All of
the other original files from the archive are here unchanged,
including the Lex input specification file `pascal.l'.  `README'
(this file) was not present in the original archived parser.  All
of the originals are in the RCS directory as revision 1.1.

Using the new `Makefile' and Ox results in a parser that behaves
in every way as the original Yacc/Lex parser, except that it
builds a `dummy' parse tree, (i.e., one without attributes),
whereas the original builds no parse tree.

`pascal.y' and `pascal.l' are ready for augmentation with Ox
constructs, which results in a parser that constructs a parse
tree bearing inherited and/or synthesized attributes.  Code for
tree construction, decoration, and traversal are generated
automatically by Ox.  For further information, see the Ox
Tutorial Introduction and the Ox User Reference Manual, which
accompany the Ox distribution.

Below the line of asterisks is the header of the original shar
file taken from the archive.

--Kurt Bischoff  10/17/93
*************************************************************************

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	ident-list
#	Makefile
#	misc.c
#	mktoken_name
#	pascal.l
#	pascal.y
#	types.h
# This archive created: Thu Nov 26 22:10:37 1987
@@


1.2
log
@@*** empty log message ***
@@
text
@@d1 1
a1 1
$Header$
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/RCS/README,v`; if test $1 -ne 60538
then
	echo ERROR: oxDistG1.04/grammars/pascal/RCS/README,v checksum is $1 should be 60538
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/RCS/README,v`
if test $1$2$3 != 924082555
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/RCS/README,v are $* should be 92 408 2555
fi

chmod 755 oxDistG1.04/grammars/pascal/RCS/README,v

chmod 755 oxDistG1.04/grammars/pascal/RCS

if test -f oxDistG1.04/grammars/pascal/README
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/README
	if test -f oxDistG1.04/grammars/pascal/README
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/README
cat >oxDistG1.04/grammars/pascal/README <<'@EOF'
$Header: README,v 1.3 93/10/31 22:02:01 bischoff Exp $

The code in this directory originated as a Yacc/Lex specification
for a parser for the Pascal language.  It came from an archive
mentioned in the comp.compilers monthly message.  I don't know
who wrote it.

This is an adaptation for use with Ox of the code from the
archive. Two lines of the Yacc input specification file
`pascal.y' are changed from what I found in the archive.  Those
changes replace the Yacc string token ":" with the character
constant token ':'.  Allowing such string tokens is usually
considered an obsolete feature of Yacc, and is not supported by
Ox.  `Makefile' is changed to cause preprocessing by Ox.  All of
the other original files from the archive are here unchanged,
including the Lex input specification file `pascal.l'.  `README'
(this file) was not present in the original archived parser.  All
of the originals are in the RCS directory as revision 1.1.

Using the new `Makefile' and Ox results in a parser that behaves
in every way as the original Yacc/Lex parser, except that it
builds a `dummy' parse tree, (i.e., one without attributes),
whereas the original builds no parse tree.

`pascal.y' and `pascal.l' are ready for augmentation with Ox
constructs, which results in a parser that constructs a parse
tree bearing inherited and/or synthesized attributes.  Code for
tree construction, decoration, and traversal are generated
automatically by Ox.  For further information, see the Ox
Tutorial Introduction and the Ox User Reference Manual, which
accompany the Ox distribution.

Below the line of asterisks is the header of the original shar
file taken from the archive.

--Kurt Bischoff  10/17/93
*************************************************************************

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	ident-list
#	Makefile
#	misc.c
#	mktoken_name
#	pascal.l
#	pascal.y
#	types.h
# This archive created: Thu Nov 26 22:10:37 1987
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/README`; if test $1 -ne 64427
then
	echo ERROR: oxDistG1.04/grammars/pascal/README checksum is $1 should be 64427
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/README`
if test $1$2$3 != 513332090
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/README are $* should be 51 333 2090
fi

chmod 755 oxDistG1.04/grammars/pascal/README

if test -f oxDistG1.04/grammars/pascal/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/Makefile
	if test -f oxDistG1.04/grammars/pascal/Makefile
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/Makefile
cat >oxDistG1.04/grammars/pascal/Makefile <<'@EOF'
# $Header: Makefile,v 1.3 93/10/31 22:02:17 bischoff Exp $

YACC=yacc
LEX=lex
OBJECTS=y.tab.o misc.o lex.yy.o token_name.o
CLIBS=-ll -ly 
OXFLAGS=
YFLAGS=-dv

# CLIBS = -ll -ly -lcurses -ltermcap
# OXFLAGS=-u -T
#

all:		extract-ids

extract-ids:	$(OBJECTS)
		cc -o extract-ids $(OBJECTS) $(CLIBS) 

y.tab.o:	y.tab.c
		cc -c y.tab.c

y.tab.c y.tab.h: oxout.y
		$(YACC) $(YFLAGS) oxout.y

lex.yy.c:	oxout.l
		$(LEX) oxout.l

lex.yy.o:	lex.yy.c tokens.h
		cc -c lex.yy.c

tokens.h:	y.tab.h
		-cmp -s y.tab.h tokens.h || cp y.tab.h tokens.h

token_name.c:	mktoken_name tokens.h
		sh mktoken_name

misc.o:		misc.c
		cc -c misc.c

token_name.o:	token_name.c
		cc -c token_name.c

install:	extract-ids
		if [ -d "$(BIN)" ] ; then cp extract-ids ident-list $(BIN)/ ; \
			     chmod 755 $(BIN)/extract-ids $(BIN)/ident-list ; fi
		
clean:
		rm *.o lex.yy.c y.tab.c y.tab.h y.output oxout.? \
		token_name.c tokens.h extract-ids

oxout.y oxout.l:pascal.y pascal.l
	ox $(OXFLAGS) pascal.y pascal.l

@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/Makefile`; if test $1 -ne 58473
then
	echo ERROR: oxDistG1.04/grammars/pascal/Makefile checksum is $1 should be 58473
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/Makefile`
if test $1$2$3 != 53125990
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/Makefile are $* should be 53 125 990
fi

chmod 755 oxDistG1.04/grammars/pascal/Makefile

if test -f oxDistG1.04/grammars/pascal/ident-list
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/ident-list\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/ident-list
	if test -f oxDistG1.04/grammars/pascal/ident-list
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/ident-list, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/ident-list
cat >oxDistG1.04/grammars/pascal/ident-list <<'@EOF'
#!/bin/sh
#
#	ident-list [-s] <program>
#
tmp1=/tmp/a$$X
tmp2=/tmp/a$$Y
sflag="$1"
if [ "x$sflag" = "x-s" ]
then shift
fi

cat $* | extract-ids >$tmp1
if [ "x$sflag" = "x-s" ]
then
	sed -e '/^program/d
/^field/d
/^external-file/d
s/^conformant-bound/parameter/
s/^procedure-parameter/parameter/
s/^function-parameter/parameter/
s/^var-parameter/parameter/
s/^value-parameter/parameter/
s/^enumerated-literal/constant/' <$tmp1 >$tmp2
	mv $tmp2 $tmp1
fi
sort -uf +0 -1 +1 -2 <$tmp1 |
awk '
func tabulate(title,n) {
	columns = int(pagewidth/(maxlen+3));
	colwidth = int(pagewidth/columns);
	rows = int((n+columns-1)/columns);
	format = sprintf("%%-%ds", colwidth);
	for(i=1;i<=rows; i++)
	{
	    printf "%-19s| ", title; title=""
	    for(j=0; j<columns; j++)
	    {
		x = i + j*rows
		if(x<=n)printf(format, s[x]);
	    }
	    print ""
	}
	print ""
}

BEGIN { itemtype="";  pagewidth=59
bar="---------------------------------------------------------------"}
{
	if($1 != itemtype)
	{
		if(n>0)  tabulate(itemtype,n)
		itemtype = $1; n=0; maxlen=0;
	}
	s[++n] = $2;  len = length($2);  if(len>maxlen)maxlen=len;
}
END { if(n>0)  tabulate(itemtype,n) }'

rm -f $tmp1
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/ident-list`; if test $1 -ne 4986
then
	echo ERROR: oxDistG1.04/grammars/pascal/ident-list checksum is $1 should be 4986
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/ident-list`
if test $1$2$3 != 581341162
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/ident-list are $* should be 58 134 1162
fi

chmod 755 oxDistG1.04/grammars/pascal/ident-list

if test -f oxDistG1.04/grammars/pascal/misc.c
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/misc.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/misc.c
	if test -f oxDistG1.04/grammars/pascal/misc.c
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/misc.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/misc.c
cat >oxDistG1.04/grammars/pascal/misc.c <<'@EOF'
#include <stdio.h>


char  *create_string(s)
char	*s;
{
    char *p = (char *) malloc(strlen(s) + 1);
    if(p==NULL) internal_error("Cannot malloc in create-string");
    strcpy(p,s);
    return p;
}

int max(a,b)
int	a,b;
{
    return  a>b ? a : b;
}
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/misc.c`; if test $1 -ne 8427
then
	echo ERROR: oxDistG1.04/grammars/pascal/misc.c checksum is $1 should be 8427
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/misc.c`
if test $1$2$3 != 1736253
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/misc.c are $* should be 17 36 253
fi

chmod 755 oxDistG1.04/grammars/pascal/misc.c

if test -f oxDistG1.04/grammars/pascal/mktoken_name
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/mktoken_name\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/mktoken_name
	if test -f oxDistG1.04/grammars/pascal/mktoken_name
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/mktoken_name, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/mktoken_name
cat >oxDistG1.04/grammars/pascal/mktoken_name <<'@EOF'
#!/bin/sh
#
#	Make a symbol name
#
(
echo 'char *token_name(i)
int i;
{
    static char buf[10];
    switch(i)
    {
	default  : if(i<256)
		   {
		       if(i<32 || i>126)
			   sprintf(buf, "0%o", i);
		       else
		           sprintf(buf, "'%c'", i);
		       return buf;
		   }
		   else
		       return("<Unknown token>");
	case   0 : return("<End of input>");'
awk '{printf"	case %d : return(\"%s\");\n",  $4, $3}'	< y.tab.h
echo '    }
}'
)  > token_name.c
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/mktoken_name`; if test $1 -ne 55468
then
	echo ERROR: oxDistG1.04/grammars/pascal/mktoken_name checksum is $1 should be 55468
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/mktoken_name`
if test $1$2$3 != 2663465
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/mktoken_name are $* should be 26 63 465
fi

chmod 755 oxDistG1.04/grammars/pascal/mktoken_name

if test -f oxDistG1.04/grammars/pascal/pascal.l
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/pascal.l\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/pascal.l
	if test -f oxDistG1.04/grammars/pascal/pascal.l
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/pascal.l, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/pascal.l
sed 's/^@//' >oxDistG1.04/grammars/pascal/pascal.l <<'@EOF'
%{
/******************************************************************************
		LEXICAL ANALYSER for ISO standard Pascal
		----------------------------------------

This lexical analyser satisfies the following requirements in British
Standards Institution Specification for Computer programming language Pascal
BS6192:1982 (ISO 7185:1983)

6.1.1	6.1.2	6.1.3	6.1.4	6.1.5	6.1.6	6.1.7
6.1.8	(except ^Z is considered to be a space)
6.1.9
******************************************************************************/

#include "y.tab.h"
int	character_no = -1;

#undef input
#undef unput
int  input()
{
    if(yysptr > yysbuf)
    {
	yytchar = U(*--yysptr);
    } else
	yytchar = getc(yyin);
    character_no++;
    if(yytchar == 10)  yylineno ++;
    if(yytchar == 0)   yytchar= ' ';
    if(yytchar == EOF) yytchar= 0;
    return yytchar;
}

unput(c)
int c;
{
    yytchar = c;
    if (yytchar == '\n') yylineno--;
    *yysptr++ = yytchar;
    character_no--;
}

comment()
{
    char c, lastc=' ';
    while(c = yyinput())
	if(c == '}' || (lastc=='*' && c==')'))
	    break;
        else
	    lastc = c;
}

char *laststring;
strings()
{
    char  *create_string();
    char  buf[256];
    char  c, *p = buf;
    while(c = yyinput())
        switch(c) {
	    case '\'' : if((c = yyinput()) == '\'')
			    *p++ = c;
			else
			{   unput(c); *p++ = '\0';
			    laststring = create_string(buf);
			    return;
			}
			break;
	    case '\n' :
	    case '\014' :
	    case '\015': yyerror("String not terminated");
			return;
	    default   : *p++ = c;
			break;
	}
}

char	numbertext[80];
char    lastident[128];

%}

A	[Aa]
B	[Bb]
C	[Cc]
D	[Dd]
E	[Ee]
F	[Ff]
G	[Gg]
H	[Hh]
I	[Ii]
J	[Jj]
K	[Kk]
L	[Ll]
M	[Mm]
N	[Nn]
O	[Oo]
P	[Pp]
Q	[Qq]
R	[Rr]
S	[Ss]
T	[Tt]
U	[Uu]
V	[Vv]
W	[Ww]
X	[Xx]
Y	[Yy]
Z	[Zz]
%%
\n				;
[ \t\32]			;
{A}{N}{D}			{ return(AND);		}
{A}{R}{R}{A}{Y}			{ return(ARRAY);	}
{B}{E}{G}{I}{N}			{ return(SBEGIN);	}
{C}{A}{S}{E}			{ return(CASE);		}
{C}{O}{N}{S}{T}			{ return(CONST);	}
{D}{I}{V}			{ return(DIV);		}
{D}{O}{W}{N}{T}{O}		{ return(DOWNTO);	}
{D}{O}				{ return(DO);		}
{E}{L}{S}{E}			{ return(ELSE);		}
{E}{N}{D}			{ return(END);		}
{F}{I}{L}{E}			{ return(SFILE);	}
{F}{O}{R}			{ return(FOR);		}
{F}{U}{N}{C}{T}{I}{O}{N}	{ return(FUNCTION);	}
{G}{O}{T}{O}			{ return(GOTO);		}
{I}{F}				{ return(IF);		}
{I}{N}				{ return(IN);		}
{L}{A}{B}{E}{L}			{ return(LABEL);	}
{M}{O}{D}			{ return(MOD);		}
{N}{I}{L}			{ return(NIL);		}
{N}{O}{T}			{ return(NOT);		}
{O}{F}				{ return(OF);		}
{O}{R}				{ return(OR);		}
{P}{A}{C}{K}{E}{D}		{ return(PACKED);	}
{P}{R}{O}{C}{E}{D}{U}{R}{E}	{ return(PROCEDURE);	}
{P}{R}{O}{G}{R}{A}{M}		{ return(PROGRAM);	}
{R}{E}{C}{O}{R}{D}		{ return(RECORD);	}
{R}{E}{P}{E}{A}{T}		{ return(REPEAT);	}
{S}{E}{T}			{ return(SET);		}
{T}{H}{E}{N}			{ return(THEN);		}
{T}{O}				{ return(TO);		}
{T}{Y}{P}{E}			{ return(TYPE);		}
{U}{N}{T}{I}{L}			{ return(UNTIL);	}
{V}{A}{R}			{ return(VAR);		}
{W}{H}{I}{L}{E}			{ return(WHILE);	}
{W}{I}{T}{H}			{ return(WITH);		}

[a-zA-Z][a-zA-Z0-9_]*		{ strcpy(lastident, yytext);
				  return(IDENTIFIER);
						/*if strict check no '_' */}
"<="				{ return(LE);	}
">="				{ return(GE);	}
"<>"				{ return(NE);	}
":="				{ return(BECOMES);	}
".."				{ return(DOTDOT);	}
"(."				{ return('[');	}
".)"				{ return(']');	}
"-"	|
"+"	|
"*"	|
"/"	|
"="	|
"<"	|
">"	|
"("	|
")"	|
"["	|
"]"	|
"."	|
","	|
";"	|
":"	|
"^"	{ return(yytext[0]); }
"@"	{ return('^');	}
[0-9]+("."[0-9]+)?[eE][+-]?[0-9]+	|
[0-9]+"."[0-9]+				{ strcpy(numbertext,yytext);
					  return(UNSIGNED_REAL);	}
[0-9]+	{ strcpy(numbertext,yytext); return(UNSIGNED_INT);	}

"{"	comment();
"(*"	comment();
'	{ strings(); return(STRING); }
"}"	yyerror("'}' not in comment");
@.	{ char m[40];
	  sprintf(m,"Illegal character '\\%o'", (int)yytext[0]);
	  yyerror(m);
	}
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/pascal.l`; if test $1 -ne 62673
then
	echo ERROR: oxDistG1.04/grammars/pascal/pascal.l checksum is $1 should be 62673
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/pascal.l`
if test $1$2$3 != 1875083817
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/pascal.l are $* should be 187 508 3817
fi

chmod 755 oxDistG1.04/grammars/pascal/pascal.l

if test -f oxDistG1.04/grammars/pascal/pascal.y
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/pascal.y\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/pascal.y
	if test -f oxDistG1.04/grammars/pascal/pascal.y
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/pascal.y, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/pascal.y
cat >oxDistG1.04/grammars/pascal/pascal.y <<'@EOF'
%{
#include <stdio.h>
#include "types.h"

extern	int	yylineno;
extern	char	yytext[];
extern	char	numbertext[80];
extern	char	*laststring;
extern	char	lastident[];

extern  char	*create_string();

#define YYSTYPE item


int	lexical_level = 0;

static	int	param_level = 0;
static	char *its_a = "error - uninitialised";

%}

%start program

%token UNSIGNED_INT UNSIGNED_REAL STRING IDENTIFIER
%token NE LE GE BECOMES DIV MOD NIL IN OR AND NOT DOTDOT
%token IF THEN ELSE CASE OF REPEAT UNTIL WHILE DO FOR TO DOWNTO
%token SBEGIN END WITH GOTO CONST VAR TYPE ARRAY RECORD SET SFILE FUNCTION
%token PROCEDURE LABEL PACKED PROGRAM

%%   /*start of rules*/
program		: PROGRAM {its_a="program";} newident external_files ';' 
			block '.'
		;
external_files  : /*empty*/
		| '(' {its_a="external-file";} newident_list ')'
		;

block		: opt_declarations  statement_part
		;
opt_declarations: /*empty*/
		| declarations
		;
declarations	: declarations declaration	/*should be left-recursive*/
		| declaration
		;
declaration	: label_dcl_part
		| const_dcl_part
		| type_dcl_part
		| var_dcl_part
		| proc_dcl_part
		;

label_dcl_part	: LABEL labels ';'
		;
labels		: labels ',' label
		| label
		;
label		: UNSIGNED_INT		/* 0 <= value <= 9999 [6.1.6] */
		;

const_dcl_part	: CONST const_defs ';'
		;
const_defs	: const_defs ';' const_def
		| const_def
		;
const_def	: {its_a="constant";} newident '=' constant
		;

constant	: unsigned_num
		| '+' unsigned_num
		| '-' unsigned_num
		| ident				/*check it is constant*/
		| '+' ident
		| '-' ident
		| STRING			/*type is char if len=1*/
		;

unsigned_num	: UNSIGNED_INT
		| UNSIGNED_REAL
		;

type_dcl_part	: TYPE type_defs ';'
		;
type_defs	: type_defs ';' type_def
		| type_def
		;
type_def	: {its_a="type";} newident '=' type
		;

type		: simple_type
		| PACKED struct_type
		| struct_type
		| '^' IDENTIFIER    /*check forward reference semantics*/
		;

simple_type	: '(' {its_a="enumerated-literal";} newident_list ')'
		| constant DOTDOT constant
		| ident
		;

struct_type	: ARRAY '[' index_t_list ']' OF type
		| RECORD /*consider this a scope*/ field_list END
		| SET OF simple_type
		| SFILE OF type
		;
index_t_list	: index_t_list ',' simple_type
		| simple_type
		;
field_list	: fixed_part
		| fixed_part ';' variant_part
		| variant_part
		;
fixed_part	: fixed_part ';' record_section
		| record_section
		;
record_section	: {its_a="field";} newident_list ':' type
		| /*empty*/
		;
variant_part	: CASE {its_a="field";} tag_field OF variants
		;
tag_field	: newident ':' ident 
		| ident /*type*/
		;
variants	: variants ';' variant
		| variant
		;
variant		: case_label_list ':' '(' field_list ')'
		| /*empty*/
		;

var_dcl_part	: VAR variable_dcls ';'
		;
variable_dcls	: variable_dcls ';' variable_dcl
		| variable_dcl
		;
variable_dcl	: {its_a="variable";} newident_list ':' type
		;
newident_list	: new_id_list {its_a="don't know";}
		;
new_id_list	: new_id_list ',' newident
		| newident
		;

proc_dcl_part	: proc_or_func
		;
proc_or_func	: proc_heading ';' body ';'     /*check if forward or fwd refd*/
			{lexical_level--;
			}
		| func_heading ';' body ';'  /*also func heading may be -type */
			{lexical_level--;
			}
		;
proc_heading	: PROCEDURE
			{if(param_level==0)its_a="procedure";}
		  newident {lexical_level++;}
			formal_params
		;
func_heading	: FUNCTION
			{if(param_level==0)its_a="function";}
		  newident {lexical_level++;}
			function_form
		;
function_form	: /*empty*/			/*if forward referenced*/
		| formal_params ':' ident
		;

body		: block
			/* result determined in block */
		| IDENTIFIER				/*directive-FORWARD*/
		;
formal_params	: /*empty*/
		| '(' {param_level++;} formal_p_sects ')' {param_level--;}
		;
formal_p_sects	: formal_p_sects ';' formal_p_sect
		| formal_p_sect
		;
formal_p_sect	: {its_a="value-parameter";} param_group
		| VAR {its_a="var-parameter";} param_group
		| {its_a="procedure-parameter";} proc_heading
			{lexical_level--;}
		| {its_a="function-parameter";} func_heading  {lexical_level--;}
		;
param_group	: newident_list ':' paramtype
		;
paramtype	: ident
		| ARRAY '[' index_specs ']' OF paramtype
		| PACKED ARRAY '[' index_spec ']' OF ident
		;
index_specs	: index_specs ';' index_spec
		| index_spec
		;
index_spec	: {its_a="conformant-bound";} newident DOTDOT newident ':' ident
		;

statement_part	: compound_stmt
		;
compound_stmt	: SBEGIN statements END
		;
statements	: statements ';' statement
		| statement
		;
statement	: /*empty*/
		| label ':' statement
		| compound_stmt
		| assignment
		| procedure_call
		| GOTO label
		| IF expression THEN statement
		| IF expression THEN statement ELSE statement
		| CASE expression OF case_list END
		| WHILE expression DO statement
		| REPEAT statements UNTIL expression
		| FOR ident BECOMES expression direction expression DO statement
		| WITH rec_var_list DO statement 
		;
direction	: TO
		| DOWNTO
		;

assignment	: variable BECOMES expression	/* must test for fn_ident */
	/*	| ident BECOMES expression	*/
		;

procedure_call	: ident actual_params
		;

actual_params	:  /*empty*/
		| '(' actuals_list ')'
		;
actuals_list	: actuals_list ',' actual_param
		| actual_param
		;
actual_param	: expression    /* which could be a variable or a proc/fn id */
		| expression colon_things  /* only in i/o */
		;
colon_things    : ':' expression	/*integer*/
		| ':' expression ':' expression 
		;

case_list	: case_list ';' case_list_elem
		| case_list_elem
		;
case_list_elem	: case_label_list ':' statement
		| /*empty*/
		;
case_label_list	: case_label_list ',' case_label
		| case_label
		;
case_label	: constant
		;

rec_var_list	: rec_var_list ',' record_var
		| record_var
		;

expression	: simple_expr
		| simple_expr relational_op simple_expr
		;
relational_op	: '='
		| '<'
		| '>'
		| LE
		| GE
		| NE
		| IN
		;

simple_expr	: term
		| '+' term
		| '-' term
		| simple_expr add_op term
		;
add_op		: '+'
		| '-'
		| OR
		;

term		: factor
		| term mult_op factor
		;
mult_op		: '*'
		| '/'
		| DIV
		| MOD
		| AND
		;

factor		: variable		/* could be a const_ident of fn_call*/
		| unsigned_lit
		| '(' expression ')'
	/*	| function_call		*/
		| set
		| NOT factor
		;

unsigned_lit	: unsigned_num
		| STRING			/*type is char if len=1*/
		| NIL
		;
/*
function_call	: ident actual_params
		;
*/

set		: '[' member_list ']'
		;
member_list	: /*empty*/
		| members
		;
members		: members ',' member
		| member
		;
member		: expression
		| expression DOTDOT expression
		;

/* kludge */
variable	: ident actual_params	/* check variable, const_id, fn_call */
		| variable '[' expressions ']'
		| variable '.' ident
		| variable '^'
		;
expressions	: expressions ',' expression
		| expression
		;
record_var	: variable
		;
ident		: IDENTIFIER
		;
newident	: IDENTIFIER
		    { 
			if(param_level<2)
			    printf("%s\t%s\n", its_a, lastident);
		    }
		;
%%   /*start of routines*/

yyerror(msg) char *msg;
{
    if(msg==NULL || *msg=='\0')
	fprintf(stderr, "Error at %s near line %d\n",
				token_name(yychar), yylineno);
    else
	fprintf(stderr, "Error at %s near line %d : %s\n",
				token_name(yychar), yylineno, msg);
    exit(1);
}

parser_info()
{
    printf("\n%d line%s parsed\n", yylineno, plural(yylineno));
}


internal_error(s,a1,a2,a3,a4)
char *s;
{
    fprintf(stderr, "Internal error: ");
    fprintf(stderr, s, a1, a2, a3, a4);
    exit(2);
}

warning(fmt, a1, a2, a3, a4)
char *fmt;
{
    fprintf(stderr, "Warning line %d: ", yylineno);
    fprintf(stderr, fmt, a1, a2, a3, a4);
    fprintf(stderr, "\n");
}

main()
{
    yyparse();
}
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/pascal.y`; if test $1 -ne 6037
then
	echo ERROR: oxDistG1.04/grammars/pascal/pascal.y checksum is $1 should be 6037
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/pascal.y`
if test $1$2$3 != 37510317530
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/pascal.y are $* should be 375 1031 7530
fi

chmod 755 oxDistG1.04/grammars/pascal/pascal.y

if test -f oxDistG1.04/grammars/pascal/types.h
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/types.h\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/types.h
	if test -f oxDistG1.04/grammars/pascal/types.h
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/types.h, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/types.h
cat >oxDistG1.04/grammars/pascal/types.h <<'@EOF'
#define pluralsuffix(num,suffix)	((num)==1?"":(suffix))
#define plural(num)	pluralsuffix(num,"s")
#define item int
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/types.h`; if test $1 -ne 65103
then
	echo ERROR: oxDistG1.04/grammars/pascal/types.h checksum is $1 should be 65103
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/types.h`
if test $1$2$3 != 39115
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/types.h are $* should be 3 9 115
fi

chmod 755 oxDistG1.04/grammars/pascal/types.h

echo mkdir - oxDistG1.04/grammars/pascal/samples
mkdir oxDistG1.04/grammars/pascal/samples

if test -f oxDistG1.04/grammars/pascal/samples/t1
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/samples/t1\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/samples/t1
	if test -f oxDistG1.04/grammars/pascal/samples/t1
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/samples/t1, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/samples/t1
cat >oxDistG1.04/grammars/pascal/samples/t1 <<'@EOF'
program fun;

procedure 
funny (var i: integer);
begin
i := 1;
end;

begin
end.

@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/samples/t1`; if test $1 -ne 16153
then
	echo ERROR: oxDistG1.04/grammars/pascal/samples/t1 checksum is $1 should be 16153
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/samples/t1`
if test $1$2$3 != 111481
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/samples/t1 are $* should be 11 14 81
fi

chmod 755 oxDistG1.04/grammars/pascal/samples/t1

if test -f oxDistG1.04/grammars/pascal/samples/t2
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/samples/t2\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/samples/t2
	if test -f oxDistG1.04/grammars/pascal/samples/t2
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/samples/t2, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/samples/t2
cat >oxDistG1.04/grammars/pascal/samples/t2 <<'@EOF'
program greet;

begin
writeln('hello, world');
end.
@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/samples/t2`; if test $1 -ne 25505
then
	echo ERROR: oxDistG1.04/grammars/pascal/samples/t2 checksum is $1 should be 25505
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/samples/t2`
if test $1$2$3 != 5652
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/samples/t2 are $* should be 5 6 52
fi

chmod 755 oxDistG1.04/grammars/pascal/samples/t2

if test -f oxDistG1.04/grammars/pascal/samples/t3
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/samples/t3\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/samples/t3
	if test -f oxDistG1.04/grammars/pascal/samples/t3
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/samples/t3, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/samples/t3
cat >oxDistG1.04/grammars/pascal/samples/t3 <<'@EOF'
program fun;

procedure funny (var i: integer);
    procedure funny (var i: integer);
    begin
    i := 1;
    end;
begin
i := 1;
end;

begin
end.

@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/samples/t3`; if test $1 -ne 28381
then
	echo ERROR: oxDistG1.04/grammars/pascal/samples/t3 checksum is $1 should be 28381
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/samples/t3`
if test $1$2$3 != 1424149
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/samples/t3 are $* should be 14 24 149
fi

chmod 755 oxDistG1.04/grammars/pascal/samples/t3

if test -f oxDistG1.04/grammars/pascal/samples/t4
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/pascal/samples/t4\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/pascal/samples/t4
	if test -f oxDistG1.04/grammars/pascal/samples/t4
	then
		echo Error: could not remove oxDistG1.04/grammars/pascal/samples/t4, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/pascal/samples/t4
cat >oxDistG1.04/grammars/pascal/samples/t4 <<'@EOF'
program fun;

procedure funny (var i: integer);
    procedure funny (var i: integer);
        procedure funny (var i: integer);
            procedure funny (var i: integer);
                procedure funny (var i: integer);
                begin
                i := 1;
                end;
            begin
            i := 1;
            end;
        begin
        i := 1;
        end;
    begin
    i := 1;
    end;
begin
i := 1;
end;

begin
end.

@EOF
set `sum $sumopt <oxDistG1.04/grammars/pascal/samples/t4`; if test $1 -ne 40462
then
	echo ERROR: oxDistG1.04/grammars/pascal/samples/t4 checksum is $1 should be 40462
fi
set `wc -lwc <oxDistG1.04/grammars/pascal/samples/t4`
if test $1$2$3 != 2654452
then
	echo ERROR: wc results of oxDistG1.04/grammars/pascal/samples/t4 are $* should be 26 54 452
fi

chmod 755 oxDistG1.04/grammars/pascal/samples/t4

chmod 755 oxDistG1.04/grammars/pascal/samples

chmod 755 oxDistG1.04/grammars/pascal

echo mkdir - oxDistG1.04/grammars/c++
mkdir oxDistG1.04/grammars/c++

echo mkdir - oxDistG1.04/grammars/c++/RCS
mkdir oxDistG1.04/grammars/c++/RCS

if test -f oxDistG1.04/grammars/c++/RCS/c4.y,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/RCS/c4.y,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/RCS/c4.y,v
	if test -f oxDistG1.04/grammars/c++/RCS/c4.y,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/RCS/c4.y,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/RCS/c4.y,v
sed 's/^@//' >oxDistG1.04/grammars/c++/RCS/c4.y,v <<'@EOF'
head     1.4;
access   ;
symbols  ;
locks    bischoff:1.4; strict;
comment  @ * @;


1.4
date     93.10.31.15.52.05;  author bischoff;  state Exp;
branches ;
next     1.3;

1.3
date     93.10.24.21.37.13;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.16.26.54;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.00.34;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@unpacked original from comp.compilers archive
@@


1.4
log
@@*** empty log message ***
@@
text
@@%{

    /* Copyright (C) 1989,1990 James A. Roskind, All rights reserved.
    This grammar was developed  and  written  by  James  A.  Roskind. 
    Copying  of  this  grammar  description, as a whole, is permitted 
    providing this notice is intact and applicable  in  all  complete 
    copies.   Translations as a whole to other parser generator input 
    languages  (or  grammar  description  languages)   is   permitted 
    provided  that  this  notice is intact and applicable in all such 
    copies,  along  with  a  disclaimer  that  the  contents  are   a 
    translation.   The reproduction of derived text, such as modified 
    versions of this grammar, or the output of parser generators,  is 
    permitted,  provided  the  resulting  work includes the copyright 
    notice "Portions Copyright (c)  1989,  1990  James  A.  Roskind". 
    Derived products, such as compilers, translators, browsers, etc., 
    that  use  this  grammar,  must also provide the notice "Portions 
    Copyright  (c)  1989,  1990  James  A.  Roskind"  in   a   manner 
    appropriate  to  the  utility,  and in keeping with copyright law 
    (e.g.: EITHER displayed when first invoked/executed; OR displayed 
    continuously on display terminal; OR via placement in the  object 
    code  in  form  readable in a printout, with or near the title of 
    the work, or at the end of the file).  No royalties, licenses  or 
    commissions  of  any  kind are required to copy this grammar, its 
    translations, or derivative products, when the copies are made in 
    compliance with this notice. Persons or corporations that do make 
    copies in compliance with this notice may charge  whatever  price 
    is  agreeable  to  a  buyer, for such copies or derivative works. 
    THIS GRAMMAR IS PROVIDED ``AS IS'' AND  WITHOUT  ANY  EXPRESS  OR 
    IMPLIED  WARRANTIES,  INCLUDING,  WITHOUT LIMITATION, THE IMPLIED 
    WARRANTIES  OF  MERCHANTABILITY  AND  FITNESS  FOR  A  PARTICULAR 
    PURPOSE.

    James A. Roskind
    Independent Consultant
    516 Latania Palm Drive
    Indialantic FL, 32903
    (407)729-4348
    jar@@ileaf.com
    or ...!uunet!leafusa!jar


    ---end of copyright notice---


This file is a companion file to a C++ grammar description file.

*/


/* FILENAME: C.Y */

/*  This  is a grammar file for the dpANSI C language.  This file was 
last modified by J. Roskind on 3/7/90. Version 1.00 */




/* ACKNOWLEDGMENT:

Without the effort expended by the ANSI C standardizing committee,  I 
would  have been lost.  Although the ANSI C standard does not include 
a fully disambiguated syntax description, the committee has at  least 
provided most of the disambiguating rules in narratives.

Several  reviewers  have also recently critiqued this grammar, and/or 
assisted in discussions during it's preparation.  These reviewers are 
certainly not responsible for the errors I have committed  here,  but 
they  are responsible for allowing me to provide fewer errors.  These 
colleagues include: Bruce Blodgett, and Mark Langley. */


%}

/* This refined grammar resolves several typedef ambiguities  in  the 
draft  proposed  ANSI  C  standard  syntax  down  to  1  shift/reduce 
conflict, as reported by a YACC process.  Note  that  the  one  shift 
reduce  conflicts  is the traditional if-if-else conflict that is not 
resolved by the grammar.  This ambiguity can  be  removed  using  the 
method  described in the Dragon Book (2nd edition), but this does not 
appear worth the effort.

There was quite a bit of effort made to reduce the conflicts to  this 
level,  and  an  additional effort was made to make the grammar quite 
similar to the C++ grammar being developed in  parallel.   Note  that 
this grammar resolves the following ANSI C ambiguity as follows:

ANSI  C  section  3.5.6,  "If  the [typedef name] is redeclared at an 
inner scope, the type specifiers shall not be omitted  in  the  inner 
declaration".   Supplying type specifiers prevents consideration of T 
as a typedef name in this grammar.  Failure to supply type specifiers 
forced the use of the TYPEDEFname as a type specifier.
              
ANSI C section 3.5.4.3, "In a parameter declaration, a single typedef 
name in parentheses is  taken  to  be  an  abstract  declarator  that 
specifies  a  function  with  a  single  parameter,  not as redundant 
parentheses around the identifier".  This is extended  to  cover  the 
following cases:

typedef float T;
int noo(const (T[5]));
int moo(const (T(int)));
@...

Where  again the '(' immediately to the left of 'T' is interpreted as 
being the start of a parameter type list,  and  not  as  a  redundant 
paren around a redeclaration of T.  Hence an equivalent code fragment 
is:

typedef float T;
int noo(const int identifier1 (T identifier2 [5]));
int moo(const int identifier1 (T identifier2 (int identifier3)));
@...

*/




/* Define terminal tokens */


/* keywords */
%token AUTO            DOUBLE          INT             STRUCT
%token BREAK           ELSE            LONG            SWITCH
%token CASE            ENUM            REGISTER        TYPEDEF
%token CHAR            EXTERN          RETURN          UNION
%token CONST           FLOAT           SHORT           UNSIGNED
%token CONTINUE        FOR             SIGNED          VOID
%token DEFAULT         GOTO            SIZEOF          VOLATILE
%token DO              IF              STATIC          WHILE

/* ANSI Grammar suggestions */
%token IDENTIFIER              STRINGliteral
%token FLOATINGconstant        INTEGERconstant        CHARACTERconstant
%token OCTALconstant           HEXconstant

/* New Lexical element, whereas ANSI suggested non-terminal */

%token TYPEDEFname /* Lexer will tell the difference between this and 
    an  identifier!   An  identifier  that is CURRENTLY in scope as a 
    typedef name is provided to the parser as a TYPEDEFname.*/

/* Multi-Character operators */
%token  ARROW            /*    ->                              */
%token  ICR DECR         /*    ++      --                      */
%token  LS RS            /*    <<      >>                      */
%token  LE GE EQ NE      /*    <=      >=      ==      !=      */
%token  ANDAND OROR      /*    &&      ||                      */
%token  ELLIPSIS         /*    ...                             */

/* modifying assignment operators */
%token MULTassign  DIVassign    MODassign   /*   *=      /=      %=      */
%token PLUSassign  MINUSassign              /*   +=      -=              */
%token LSassign    RSassign                 /*   <<=     >>=             */
%token ANDassign   ERassign     ORassign    /*   &=      ^=      |=      */

%start prog.start

%%
prog.start:
        translation.unit
        ;

/* CONSTANTS */
constant:
        FLOATINGconstant
        | INTEGERconstant
        /* We are not including ENUMERATIONconstant here  because  we 
        are  treating  it like a variable with a type of "enumeration 
        constant".  */
        | OCTALconstant
        | HEXconstant
        | CHARACTERconstant
        ;

/* STRING LITERALS */
string.literal.list:
                STRINGliteral
                | string.literal.list STRINGliteral
                ;


/* EXPRESSIONS */
primary.expression:
        IDENTIFIER  /* We cannot use a typedef name as a variable */
        | constant
        | string.literal.list
        | '(' expression ')'
        ;

postfix.expression:
        primary.expression
        | postfix.expression '[' expression ']'
        | postfix.expression '(' ')'
        | postfix.expression '(' argument.expression.list ')'
        | postfix.expression '.' identifier.or.typedef.name
        | postfix.expression ARROW identifier.or.typedef.name
        | postfix.expression ICR
        | postfix.expression DECR
        ;

argument.expression.list:
        assignment.expression
        | argument.expression.list ',' assignment.expression
        ;

unary.expression:
        postfix.expression
        | ICR unary.expression
        | DECR unary.expression
        | unary.operator cast.expression
        | SIZEOF unary.expression
        | SIZEOF '(' type.name ')'
        ;

unary.operator:
        '&'
        | '*'
        | '+'
        | '-'
        | '~'
        | '!'
        ;

cast.expression:
        unary.expression
        | '(' type.name ')' cast.expression
        ;

multiplicative.expression:
        cast.expression
        | multiplicative.expression '*' cast.expression
        | multiplicative.expression '/' cast.expression
        | multiplicative.expression '%' cast.expression
        ;

additive.expression:
        multiplicative.expression
        | additive.expression '+' multiplicative.expression
        | additive.expression '-' multiplicative.expression
        ;

shift.expression:
        additive.expression
        | shift.expression LS additive.expression
        | shift.expression RS additive.expression
        ;

relational.expression:
        shift.expression
        | relational.expression '<' shift.expression
        | relational.expression '>' shift.expression
        | relational.expression LE shift.expression
        | relational.expression GE shift.expression
        ;

equality.expression:
        relational.expression
        | equality.expression EQ relational.expression
        | equality.expression NE relational.expression
        ;

AND.expression:
        equality.expression
        | AND.expression '&' equality.expression
        ;

exclusive.OR.expression:
        AND.expression
        | exclusive.OR.expression '^' AND.expression
        ;

inclusive.OR.expression:
        exclusive.OR.expression
        | inclusive.OR.expression '|' exclusive.OR.expression
        ;

logical.AND.expression:
        inclusive.OR.expression
        | logical.AND.expression ANDAND inclusive.OR.expression
        ;

logical.OR.expression:
        logical.AND.expression
        | logical.OR.expression OROR logical.AND.expression
        ;

conditional.expression:
        logical.OR.expression
        | logical.OR.expression '?' expression ':'
                conditional.expression
        ;

assignment.expression:
        conditional.expression
        | unary.expression assignment.operator assignment.expression
        ;

assignment.operator:
        '='
        | MULTassign
        | DIVassign
        | MODassign
        | PLUSassign
        | MINUSassign
        | LSassign
        | RSassign
        | ANDassign
        | ERassign
        | ORassign
        ;

expression:
        assignment.expression
        | expression ',' assignment.expression
        ;

constant.expression:
        conditional.expression
        ;

    /* The following was used for clarity */
expression.opt:
        /* Nothing */
        | expression
        ;



/* DECLARATIONS */

    /* The following is different from the ANSI C specified  grammar.  
    The  changes  were  made  to  disambiguate  typedef's presence in 
    declaration.specifiers (vs.  in the declarator for redefinition); 
    to allow struct/union/enum tag declarations without  declarators, 
    and  to  better  reflect the parsing of declarations (declarators 
    must be combined with declaration.specifiers ASAP  so  that  they 
    are visible in scope).

    Example  of  typedef  use  as either a declaration.specifier or a 
    declarator:

      typedef int T;
      struct S { T T;}; /* redefinition of T as member name * /

    Example of legal and illegal statements detected by this grammar:

      int; /* syntax error: vacuous declaration * /
      struct S;  /* no error: tag is defined or elaborated * /

    Example of result of proper declaration binding:
        
        int a=sizeof(a); /* note that "a" is declared with a type  in 
            the name space BEFORE parsing the initializer * /

        int b, c[sizeof(b)]; /* Note that the first declarator "b" is 
             declared  with  a  type  BEFORE the second declarator is 
             parsed * /

    */

declaration:
        sue.declaration.specifier ';'
        | sue.type.specifier ';'
        | declaring.list ';'
        | default.declaring.list ';'
        ;

    /* Note that if a typedef were  redeclared,  then  a  declaration 
    specifier must be supplied */

default.declaring.list:  /* Can't  redeclare typedef names */
        declaration.qualifier.list identifier.declarator {} initializer.opt
        | type.qualifier.list identifier.declarator {} initializer.opt
        | default.declaring.list ',' identifier.declarator {} initializer.opt
        ;

declaring.list:
        declaration.specifier declarator {} initializer.opt
        | type.specifier declarator {} initializer.opt
        | declaring.list ',' declarator {} initializer.opt
        ;

declaration.specifier:
        basic.declaration.specifier        /* Arithmetic or void */
        | sue.declaration.specifier          /* struct/union/enum */
        | typedef.declaration.specifier      /* typedef*/
        ;

type.specifier:
        basic.type.specifier                 /* Arithmetic or void */
        | sue.type.specifier                 /* Struct/Union/Enum */
        | typedef.type.specifier             /* Typedef */
        ;


declaration.qualifier.list:  /* const/volatile, AND storage class */
        storage.class
        | type.qualifier.list storage.class
        | declaration.qualifier.list declaration.qualifier
        ;

type.qualifier.list:
        type.qualifier
        | type.qualifier.list type.qualifier
        ;

declaration.qualifier:
        type.qualifier                  /* const or volatile */
        | storage.class
        ;

type.qualifier:
        CONST
        | VOLATILE
        ;

basic.declaration.specifier:      /*StorageClass+Arithmetic or void*/
        basic.type.specifier  storage.class
        | declaration.qualifier.list basic.type.name
        | basic.declaration.specifier declaration.qualifier
        | basic.declaration.specifier basic.type.name
        ;

basic.type.specifier:
        basic.type.name            /* Arithmetic or void */
        | type.qualifier.list basic.type.name
        | basic.type.specifier type.qualifier
        | basic.type.specifier basic.type.name
        ;

sue.declaration.specifier:          /* StorageClass + struct/union/enum */
        sue.type.specifier storage.class
        | declaration.qualifier.list elaborated.type.name
        | sue.declaration.specifier declaration.qualifier
        ;

sue.type.specifier:
        elaborated.type.name              /* struct/union/enum */
        | type.qualifier.list elaborated.type.name
        | sue.type.specifier type.qualifier
        ;


typedef.declaration.specifier:       /*Storage Class + typedef types */
        typedef.type.specifier storage.class
        | declaration.qualifier.list TYPEDEFname
        | typedef.declaration.specifier declaration.qualifier
        ;

typedef.type.specifier:              /* typedef types */
        TYPEDEFname
        | type.qualifier.list TYPEDEFname
        | typedef.type.specifier type.qualifier
        ;

storage.class:
        TYPEDEF
        | EXTERN
        | STATIC
        | AUTO
        | REGISTER
        ;

basic.type.name:
        VOID
        | CHAR
        | SHORT
        | INT
        | LONG
        | FLOAT
        | DOUBLE
        | SIGNED
        | UNSIGNED
        ;

elaborated.type.name:
        struct.or.union.specifier
        | enum.specifier
        ;

struct.or.union.specifier:
        struct.or.union '{' struct.declaration.list '}'
        | struct.or.union identifier.or.typedef.name
                '{' struct.declaration.list '}'
        | struct.or.union identifier.or.typedef.name
        ;

struct.or.union:
        STRUCT
        | UNION
        ;

struct.declaration.list:
        struct.declaration
        | struct.declaration.list struct.declaration
        ;

struct.declaration:
        struct.declaring.list ';'
        | struct.default.declaring.list ';'
        ;

struct.default.declaring.list:        /* doesn't redeclare typedef*/
        type.qualifier.list struct.identifier.declarator
        | struct.default.declaring.list ',' struct.identifier.declarator
        ;

struct.declaring.list:        
        type.specifier struct.declarator
        | struct.declaring.list ',' struct.declarator
        ;


struct.declarator:
        declarator bit.field.size.opt
        | bit.field.size
        ;

struct.identifier.declarator:
        identifier.declarator bit.field.size.opt
        | bit.field.size
        ;

bit.field.size.opt:
        /* nothing */
        | bit.field.size
        ;

bit.field.size:
        ':' constant.expression
        ;

enum.specifier:
        ENUM '{' enumerator.list '}'
        | ENUM identifier.or.typedef.name '{' enumerator.list '}'
        | ENUM identifier.or.typedef.name
        ;



enumerator.list:
        identifier.or.typedef.name enumerator.value.opt
        | enumerator.list ',' identifier.or.typedef.name enumerator.value.opt
        ;

enumerator.value.opt:
        /* Nothing */
        | '=' constant.expression
        ;

parameter.type.list:
        parameter.list
        | parameter.list ',' ELLIPSIS
        ;

parameter.list:
        parameter.declaration
        | parameter.list ',' parameter.declaration
        ;

parameter.declaration:
        declaration.specifier
        | declaration.specifier abstract.declarator
        | declaration.specifier identifier.declarator
        | declaration.specifier parameter.typedef.declarator
        | declaration.qualifier.list 
        | declaration.qualifier.list abstract.declarator
        | declaration.qualifier.list identifier.declarator
        | type.specifier
        | type.specifier abstract.declarator
        | type.specifier identifier.declarator
        | type.specifier parameter.typedef.declarator
        | type.qualifier.list 
        | type.qualifier.list abstract.declarator
        | type.qualifier.list identifier.declarator
        ;

    /*  ANSI  C  section  3.7.1  states  "An identifier declared as a 
    typedef name shall not be redeclared as a parameter".  Hence  the 
    following is based only on IDENTIFIERs */

identifier.list:
        IDENTIFIER
        | identifier.list ',' IDENTIFIER
        ;

identifier.or.typedef.name:
        IDENTIFIER
        | TYPEDEFname
        ;

type.name:
        type.specifier
        | type.specifier abstract.declarator
        | type.qualifier.list 
        | type.qualifier.list abstract.declarator
        ;

initializer.opt:
        /* nothing */
        | '=' initializer
        ;

initializer:
        '{' initializer.list '}'
        | '{' initializer.list ',' '}'
        | assignment.expression
        ;

initializer.list:
        initializer
        | initializer.list ',' initializer
        ;


/* STATEMENTS */
statement:
        labeled.statement
        | compound.statement
        | expression.statement
        | selection.statement
        | iteration.statement
        | jump.statement
        ;

labeled.statement:
        identifier.or.typedef.name ':' statement
        | CASE constant.expression ':' statement
        | DEFAULT ':' statement
        ;

compound.statement:
        '{' '}'
        | '{' declaration.list '}'
        | '{' statement.list '}'
        | '{' declaration.list statement.list '}'
        ;

declaration.list:
        declaration
        | declaration.list declaration
        ;

statement.list:
        statement
        | statement.list statement
        ;

expression.statement:
        expression.opt ';'
        ;

selection.statement:
        IF '(' expression ')' statement
        | IF '(' expression ')' statement ELSE statement
        | SWITCH '(' expression ')' statement
        ;

iteration.statement:
        WHILE '(' expression ')' statement
        | DO statement WHILE '(' expression ')' ';'
        | FOR '(' expression.opt ';' expression.opt ';'
                expression.opt ')' statement
        ;

jump.statement:
        GOTO identifier.or.typedef.name ';'
        | CONTINUE ';'
        | BREAK ';'
        | RETURN expression.opt ';'
        ;


/* EXTERNAL DEFINITIONS */

translation.unit:
        external.definition
        | translation.unit external.definition
        ;

external.definition:
        function.definition
        | declaration
        ;

function.definition:
                                     identifier.declarator compound.statement
        | declaration.specifier      identifier.declarator compound.statement
        | type.specifier             identifier.declarator compound.statement
        | declaration.qualifier.list identifier.declarator compound.statement
        | type.qualifier.list        identifier.declarator compound.statement

        |                            old.function.declarator compound.statement 
        | declaration.specifier      old.function.declarator compound.statement
        | type.specifier             old.function.declarator compound.statement
        | declaration.qualifier.list old.function.declarator compound.statement
        | type.qualifier.list        old.function.declarator compound.statement

        |                            old.function.declarator declaration.list 
                compound.statement
        | declaration.specifier      old.function.declarator declaration.list
                compound.statement
        | type.specifier             old.function.declarator declaration.list
                compound.statement
        | declaration.qualifier.list old.function.declarator declaration.list
                compound.statement
        | type.qualifier.list        old.function.declarator declaration.list
                compound.statement
        ;

declarator:
        typedef.declarator
        | identifier.declarator
        ;

typedef.declarator:
        paren.typedef.declarator  /* would be ambiguous as parameter*/
        | parameter.typedef.declarator   /* not ambiguous as param*/
        ;

parameter.typedef.declarator:
        TYPEDEFname 
        | TYPEDEFname postfixing.abstract.declarator
        | clean.typedef.declarator
        ;

    /*  The  following have at least one '*'. There is no (redundant) 
    '(' between the '*' and the TYPEDEFname. */

clean.typedef.declarator:
        clean.postfix.typedef.declarator
        | '*' parameter.typedef.declarator
        | '*' type.qualifier.list parameter.typedef.declarator  
        ;

clean.postfix.typedef.declarator:
        '(' clean.typedef.declarator ')'
        | '(' clean.typedef.declarator ')' postfixing.abstract.declarator
        ;

    /* The following have a redundant '(' placed immediately  to  the 
    left of the TYPEDEFname */

paren.typedef.declarator:
        paren.postfix.typedef.declarator
        | '*' '(' simple.paren.typedef.declarator ')' /* redundant paren */
        | '*' type.qualifier.list  
                '(' simple.paren.typedef.declarator ')' /* redundant paren */
        | '*' paren.typedef.declarator
        | '*' type.qualifier.list paren.typedef.declarator
        ;
        
paren.postfix.typedef.declarator: /* redundant paren to left of tname*/
        '(' paren.typedef.declarator ')'
        | '(' simple.paren.typedef.declarator postfixing.abstract.declarator ')' /* redundant paren */
        | '(' paren.typedef.declarator ')' postfixing.abstract.declarator
        ;

simple.paren.typedef.declarator:
        TYPEDEFname
        | '(' simple.paren.typedef.declarator ')'
        ;

identifier.declarator:
        unary.identifier.declarator
        | paren.identifier.declarator
        ;

unary.identifier.declarator:
        postfix.identifier.declarator
        | '*' identifier.declarator
        | '*' type.qualifier.list identifier.declarator
        ;
        
postfix.identifier.declarator:
        paren.identifier.declarator postfixing.abstract.declarator
        | '(' unary.identifier.declarator ')'
        | '(' unary.identifier.declarator ')' postfixing.abstract.declarator
        ;

paren.identifier.declarator:
        IDENTIFIER
        | '(' paren.identifier.declarator ')'
        ;

old.function.declarator:
        postfix.old.function.declarator
        | '*' old.function.declarator
        | '*' type.qualifier.list old.function.declarator
        ;

postfix.old.function.declarator:
        paren.identifier.declarator '(' identifier.list ')'
        | '(' old.function.declarator ')'
        | '(' old.function.declarator ')' postfixing.abstract.declarator
        ;

abstract.declarator:
        unary.abstract.declarator
        | postfix.abstract.declarator
        | postfixing.abstract.declarator
        ;

postfixing.abstract.declarator:
        array.abstract.declarator
        | '(' ')'
        | '(' parameter.type.list ')'
        ;

array.abstract.declarator:
        '[' ']'
        | '[' constant.expression ']'
        | array.abstract.declarator '[' constant.expression ']'
        ;

unary.abstract.declarator:
        '*' 
        | '*' type.qualifier.list 
        | '*' abstract.declarator
        | '*' type.qualifier.list abstract.declarator
        ;

postfix.abstract.declarator:
        '(' unary.abstract.declarator ')'
        | '(' postfix.abstract.declarator ')'
        | '(' postfixing.abstract.declarator ')'
        | '(' unary.abstract.declarator ')' postfixing.abstract.declarator
        ;

%%
/* ----end of grammar----*/


@@


1.3
log
@@*** empty log message ***
@@
text
@@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/RCS/c4.y,v`; if test $1 -ne 12127
then
	echo ERROR: oxDistG1.04/grammars/c++/RCS/c4.y,v checksum is $1 should be 12127
fi
set `wc -lwc <oxDistG1.04/grammars/c++/RCS/c4.y,v`
if test $1$2$3 != 897246726064
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/RCS/c4.y,v are $* should be 897 2467 26064
fi

chmod 755 oxDistG1.04/grammars/c++/RCS/c4.y,v

if test -f oxDistG1.04/grammars/c++/RCS/cpp4.l,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/RCS/cpp4.l,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/RCS/cpp4.l,v
	if test -f oxDistG1.04/grammars/c++/RCS/cpp4.l,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/RCS/cpp4.l,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/RCS/cpp4.l,v
sed 's/^@//' >oxDistG1.04/grammars/c++/RCS/cpp4.l,v <<'@EOF'
head     1.4;
access   ;
symbols  ;
locks    bischoff:1.4; strict;
comment  @ * @;


1.4
date     93.10.31.15.52.08;  author bischoff;  state Exp;
branches ;
next     1.3;

1.3
date     93.10.24.21.37.16;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.16.27.07;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.01.34;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@unpacked original from comp.compilers archive
@@


1.4
log
@@*** empty log message ***
@@
text
@@%{
    /* Copyright (C) 1989,1990 James A. Roskind, All rights reserved. 
    This lexer description was written by James A.  Roskind.  Copying 
    of  this  file, as a whole, is permitted providing this notice is 
    intact  and  applicable   in   all   complete   copies.    Direct 
    translations  as a whole to other lexer generator input languages 
    (or lexical description languages)  is  permitted  provided  that 
    this  notice  is  intact and applicable in all such copies, along 
    with a disclaimer that  the  contents  are  a  translation.   The 
    reproduction  of derived files or text, such as modified versions 
    of this file, or the output of scanner generators, is  permitted, 
    provided   the  resulting  work  includes  the  copyright  notice 
    "Portions Copyright (c) 1989, 1990 James  A.   Roskind".  Derived 
    products  must  also  provide  the notice "Portions Copyright (c) 
    1989, 1990 James A.  Roskind" in  a  manner  appropriate  to  the 
    utility,   and  in  keeping  with  copyright  law  (e.g.:  EITHER 
    displayed when first invoked/executed; OR displayed  continuously 
    on  display terminal; OR via placement in the object code in form 
    readable in a printout, with or near the title of the work, or at 
    the end of the file).  No royalties, licenses or  commissions  of 
    any  kind  are  required  to copy this file, its translations, or 
    derivative products, when the copies are made in compliance  with 
    this  notice.  Persons  or  corporations  that  do make copies in 
    compliance  with  this  notice  may  charge  whatever  price   is 
    agreeable  to  a buyer, for such copies or derivative works. THIS 
    FILE IS PROVIDED ``AS IS'' AND WITHOUT  ANY  EXPRESS  OR  IMPLIED 
    WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES 
    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

    James A. Roskind
    Independent Consultant
    516 Latania Palm Drive
    Indialantic FL, 32903
    (407)729-4348
    jar@@ileaf.com
    or ...!uunet!leafusa!jar

    ---end of copyright notice---


COMMENTS-

My  goal  is  to  see  software  developers adopt my C++ grammar as a 
standard until such time as a better  standard  is  accessible.   The 
only  way  to  get it to become a standard, is to be sure that people 
know that derivations are based on a specific work.   The  intent  of 
releasing  this Flex input file is to facilitate experimentation with 
my C++ grammar. The intent  of  the  copyright  notice  is  to  allow 
arbitrary  commercial and non-commercial use of this file, as long as 
reference is given to my standardization effort.   Without  reference 
to  a specific standard, many alternative grammars would develop.  By 
referring to the standard, the C++ grammar is given publicity,  which 
should  lead  to further use in compatible products and systems.  The 
benefits  of  such  a  standard  to  commercial  products  (browsers, 
beautifiers,  translators,  compilers,  ...) should be obvious to the 
developers, in that other compatible products will  emerge,  and  the 
value  of  all  conforming  products  will rise.  Most developers are 
aware of the value of acquiring  a  fairly  complete  grammar  for  a 
language,  and  the  copyright  notice (and the resulting affiliation 
with my work) should not be too high a price to pay.  By copyrighting 
my work, I have some minor control over what this standard is, and  I 
can  (hopefully)  keep it from degrading without my approval.  I will 
consistently attempt to provide upgraded grammars that are  compliant 
with  the  current  art, and the ANSI C++ Committee recommendation in 
particular.  A  developer  is  never  prevented  from  modifying  the 
grammar or this file to improve it in whatever way is seen fit. There 
is  also  no  restriction on the sale of copies, or derivative works, 
providing the request in the copyright notice are satisfied.

If you are not "copying" my work, but  are  rather  only  abstracting 
some of my work, an acknowledgment with references to such a standard 
would  be  appreciated.  Specifically, agreements with my grammar and 
its resolution of otherwise ambiguous constructs, should be noted.

Simply put: "make whatever use you would like of the grammar and this 
file, but include the ``portions Copyright ...'' as  a  reference  to 
this standard."


*/


/* Last modified 3/7/90, Version 1.00 */


/* File CPP4.L, becomes yy.lex.c after processing by FLEX  */

/* This file is a dramatically cut down version  of  the  FLEX  input 
file  used in my ANSI C Preprocessor.  The executable version of my C 
preprocessor is available on many platforms (shareware), but this  is 
the  only source extract that is currently being distributed.  If you 
need  a  full  ANSI  C  preprocessor,   with   extensive   diagnostic 
capabilities  and  customization facilities, please contact me at the 
addresses given above.  Current platforms  include  IBMPC  (DOS/OS2), 
Sun  (SPARC  and  Motorola),  and  IBM R/6000.  ... end of commercial 
announcement.

This file is being distributed to facilitate experimentation and  use 
of my C and C++ grammar.


Comment  removal  must be done during the lexing, as context (such as 
enclosure in string literals) must be observed.   For  this  cut-down 
lexer,  we  will assume that comments have been removed (don't assume 
this if you are writing a compiler or browser!).   The  justification 
for   this   assumption   is   a   view   that   we   are  processing 
post-preprocessed source, and hence comment removal was taken care of 
during that phase. Note that in real life, comments CANNOT always  be 
removed  prior  to  lexing,  as  the  sequence of characters '/*' may 
appear within a string literal, and hence NOT indicate the start of a 
comment.

For each IDENTIFIER like string that  is  found,  there  are  several 
distinct interpretations that can be applied:

1)  The  preprocessor  may  interpret  the string as a "keyword" in a 
directive (eg: "pragma" or "include", "defined").

2) The parser may interpret the string as a keyword. (eg: "int").

3) Both parser and preprocessor may interpret the string as a keyword 
(eg: "if").

Since this file is based on source that actually  lexically  analyses 
text  for both preprocessing and parsing, macro definitions were used 
throughout.  The macro definitions supplied here have been customized 
to a C++ parse only, and all  preprocessor  keywords  are  passed  as 
IDENTIFIER  or  TYPEDEFname.  Also, since there is no symbol table to 
interrogate to decide whether a string is  a  TYPEDEFname,  I  simply 
assume  that  any identifier beginning with an upper case letter is a 
TYPEDEFname.  This hack should  allow  you  to  check  out  how  code 
segments  are  parsed using my grammar.  Unfortunately, if you really 
want to parse major league code, you have to write  a  symbol  table, 
and maintain appropriate scoping information.  :-), sorry...

*/


/* Included code before lex code */
/*************** Includes and Defines *****************************/


#include "y.tab.h" /* YACC generated definitions based on C++ parser input*/

typedef char * YYSTYPE; /* interface with lexer: should be in header file*/

char * yylval; /* We will always point at the text of the lexeme.
    This  makes  it  easy  to  print  out  nice trees when YYDEBUG is 
    enabled  (see  the  C++  grammar  file,  and  its  definition  of 
    YYDEBUG_LEXER_TEXT to be "yylval") */

    
#define WHITE_RETURN(x)  /* do nothing,  */

#define NEW_LINE_RETURN() WHITE_RETURN('\n')

#define PA_KEYWORD_RETURN(x)   RETURN_VAL(x)  /* standard C PArser Keyword */
#define CPP_KEYWORD_RETURN(x)  PA_KEYWORD_RETURN(x)  /* C++ keyword */
#define PPPA_KEYWORD_RETURN(x) RETURN_VAL(x)  /* both PreProcessor and PArser keyword */
#define PP_KEYWORD_RETURN(x)   IDENTIFIER_RETURN()

#define IDENTIFIER_RETURN() RETURN_VAL(isaTYPE(yytext)?TYPEDEFname:IDENTIFIER) 

#define PPOP_RETURN(x)       RETURN_VAL((int)*yytext) /* PreProcess and Parser operator */
#define NAMED_PPOP_RETURN(x) /* error: PreProcessor ONLY operator;  Do nothing */
#define ASCIIOP_RETURN(x)    RETURN_VAL((int)*yytext) /* a single character operator */
#define NAMEDOP_RETURN(x)    RETURN_VAL(x)            /* a multichar operator, with a name */

#define NUMERICAL_RETURN(x) RETURN_VAL(x)            /* some sort of constant */
#define LITERAL_RETURN(x)   RETURN_VAL(x)            /* a string literal */

#define RETURN_VAL(x) yylval = yytext; return(x);


%}

identifier [a-zA-Z_][0-9a-zA-Z_]*

exponent_part [eE][-+]?[0-9]+
fractional_constant ([0-9]*"."[0-9]+)|([0-9]+".")
floating_constant (({fractional_constant}{exponent_part}?)|([0-9]+{exponent_part}))[FfLl]?

integer_suffix_opt ([uU]?[lL]?)|([lL][uU])
decimal_constant [1-9][0-9]*{integer_suffix_opt}
octal_constant "0"[0-7]*{integer_suffix_opt}
hex_constant "0"[xX][0-9a-fA-F]+{integer_suffix_opt}

simple_escape [abfnrtv'"?\\]
octal_escape  [0-7]{1,3}
hex_escape "x"[0-9a-fA-F]+

escape_sequence [\\]({simple_escape}|{octal_escape}|{hex_escape})
c_char [^'\\\n]|{escape_sequence}
s_char [^"\\\n]|{escape_sequence}

h_tab [\011]
form_feed [\014]
v_tab [\013]
c_return [\015]

horizontal_white [ ]|{h_tab}

%%


{horizontal_white}+     {
                        WHITE_RETURN(' ');
                        }

({v_tab}|{c_return}|{form_feed})+   { 
                        WHITE_RETURN(' ');
                        }


({horizontal_white}|{v_tab}|{c_return}|{form_feed})*"\n"   {
                        NEW_LINE_RETURN();
                        }

auto                {PA_KEYWORD_RETURN(AUTO);}
break               {PA_KEYWORD_RETURN(BREAK);}
case                {PA_KEYWORD_RETURN(CASE);}
char                {PA_KEYWORD_RETURN(CHAR);}
const               {PA_KEYWORD_RETURN(CONST);}
continue            {PA_KEYWORD_RETURN(CONTINUE);}
default             {PA_KEYWORD_RETURN(DEFAULT);}
define             {PP_KEYWORD_RETURN(DEFINE);}
defined            {PP_KEYWORD_RETURN(OPDEFINED);}
do                  {PA_KEYWORD_RETURN(DO);}
double              {PA_KEYWORD_RETURN(DOUBLE);}
elif                {PP_KEYWORD_RETURN(ELIF);}
else              {PPPA_KEYWORD_RETURN(ELSE);}
endif              {PP_KEYWORD_RETURN(ENDIF);}
enum                {PA_KEYWORD_RETURN(ENUM);}
error              {PP_KEYWORD_RETURN(ERROR);}
extern              {PA_KEYWORD_RETURN(EXTERN);}
float               {PA_KEYWORD_RETURN(FLOAT);}
for                 {PA_KEYWORD_RETURN(FOR);}
goto                {PA_KEYWORD_RETURN(GOTO);}
if                {PPPA_KEYWORD_RETURN(IF);}
ifdef              {PP_KEYWORD_RETURN(IFDEF);}
ifndef             {PP_KEYWORD_RETURN(IFNDEF);}
include            {PP_KEYWORD_RETURN(INCLUDE); }
int                 {PA_KEYWORD_RETURN(INT);}
line               {PP_KEYWORD_RETURN(LINE);}
long                {PA_KEYWORD_RETURN(LONG);}
pragma             {PP_KEYWORD_RETURN(PRAGMA);}
register            {PA_KEYWORD_RETURN(REGISTER);}
return              {PA_KEYWORD_RETURN(RETURN);}
short               {PA_KEYWORD_RETURN(SHORT);}
signed              {PA_KEYWORD_RETURN(SIGNED);}
sizeof              {PA_KEYWORD_RETURN(SIZEOF);}
static              {PA_KEYWORD_RETURN(STATIC);}
struct              {PA_KEYWORD_RETURN(STRUCT);}
switch              {PA_KEYWORD_RETURN(SWITCH);}
typedef             {PA_KEYWORD_RETURN(TYPEDEF);}
undef              {PP_KEYWORD_RETURN(UNDEF);}
union               {PA_KEYWORD_RETURN(UNION);}
unsigned            {PA_KEYWORD_RETURN(UNSIGNED);}
void                {PA_KEYWORD_RETURN(VOID);}
volatile            {PA_KEYWORD_RETURN(VOLATILE);}
while               {PA_KEYWORD_RETURN(WHILE);}


class               {CPP_KEYWORD_RETURN(CLASS);}
delete              {CPP_KEYWORD_RETURN(DELETE);}
friend              {CPP_KEYWORD_RETURN(FRIEND);}
inline              {CPP_KEYWORD_RETURN(INLINE);}
new                 {CPP_KEYWORD_RETURN(NEW);}
operator            {CPP_KEYWORD_RETURN(OPERATOR);}
overload            {CPP_KEYWORD_RETURN(OVERLOAD);}
protected           {CPP_KEYWORD_RETURN(PROTECTED);}
private             {CPP_KEYWORD_RETURN(PRIVATE);}
public              {CPP_KEYWORD_RETURN(PUBLIC);}
this                {CPP_KEYWORD_RETURN(THIS);}
virtual             {CPP_KEYWORD_RETURN(VIRTUAL);}

{identifier}          {IDENTIFIER_RETURN();}

{decimal_constant}  {NUMERICAL_RETURN(INTEGERconstant);}
{octal_constant}    {NUMERICAL_RETURN(OCTALconstant);}
{hex_constant}      {NUMERICAL_RETURN(HEXconstant);}
{floating_constant} {NUMERICAL_RETURN(FLOATINGconstant);}


"L"?[']{c_char}+[']     {
                        NUMERICAL_RETURN(CHARACTERconstant);
                        }


"L"?["]{s_char}*["]     {
                        LITERAL_RETURN(STRINGliteral);}


"("                  {PPOP_RETURN(LP);}
")"                  {PPOP_RETURN(RP);}
","                  {PPOP_RETURN(COMMA);}
"#"                  {NAMED_PPOP_RETURN('#') ;} 
"##"                 {NAMED_PPOP_RETURN(POUNDPOUND);}

"{"                  {ASCIIOP_RETURN(LC);}
"}"                  {ASCIIOP_RETURN(RC);}
"["                  {ASCIIOP_RETURN(LB);}
"]"                  {ASCIIOP_RETURN(RB);}
"."                  {ASCIIOP_RETURN(DOT);}
"&"                  {ASCIIOP_RETURN(AND);}
"*"                  {ASCIIOP_RETURN(STAR);}
"+"                  {ASCIIOP_RETURN(PLUS);}
"-"                  {ASCIIOP_RETURN(MINUS);}
"~"                  {ASCIIOP_RETURN(NEGATE);}
"!"                  {ASCIIOP_RETURN(NOT);}
"/"                  {ASCIIOP_RETURN(DIV);}
"%"                  {ASCIIOP_RETURN(MOD);}
"<"                  {ASCIIOP_RETURN(LT);}
">"                  {ASCIIOP_RETURN(GT);}
"^"                  {ASCIIOP_RETURN(XOR);}
"|"                  {ASCIIOP_RETURN(PIPE);}
"?"                  {ASCIIOP_RETURN(QUESTION);}
":"                  {ASCIIOP_RETURN(COLON);}
";"                  {ASCIIOP_RETURN(SEMICOLON);}
"="                  {ASCIIOP_RETURN(ASSIGN);}

".*"                 {NAMEDOP_RETURN(DOTstar);}
"::"                 {NAMEDOP_RETURN(CLCL);}
"->"                 {NAMEDOP_RETURN(ARROW);}
"->*"                {NAMEDOP_RETURN(ARROWstar);}
"++"                 {NAMEDOP_RETURN(ICR);}
"--"                 {NAMEDOP_RETURN(DECR);}
"<<"                 {NAMEDOP_RETURN(LS);}
">>"                 {NAMEDOP_RETURN(RS);}
"<="                 {NAMEDOP_RETURN(LE);}
">="                 {NAMEDOP_RETURN(GE);}
"=="                 {NAMEDOP_RETURN(EQ);}
"!="                 {NAMEDOP_RETURN(NE);}
"&&"                 {NAMEDOP_RETURN(ANDAND);}
"||"                 {NAMEDOP_RETURN(OROR);}
"*="                 {NAMEDOP_RETURN(MULTassign);}
"/="                 {NAMEDOP_RETURN(DIVassign);}
"%="                 {NAMEDOP_RETURN(MODassign);}
"+="                 {NAMEDOP_RETURN(PLUSassign);}
"-="                 {NAMEDOP_RETURN(MINUSassign);}
"<<="                {NAMEDOP_RETURN(LSassign);}
">>="                {NAMEDOP_RETURN(RSassign);}
"&="                 {NAMEDOP_RETURN(ANDassign);}
"^="                 {NAMEDOP_RETURN(ERassign);}
"|="                 {NAMEDOP_RETURN(ORassign);}
"..."                {NAMEDOP_RETURN(ELLIPSIS);}



%%

/*  I won't bother to provide any error recovery. I won't even handle 
unknown characters */

/*******************************************************************/
int isaTYPE(string)
char * string;
{  

    /*  We  should  really  be  maintaining  a  symbol  table, and be 
      carefully keeping track of what the current scope is (or in the 
      case of "rescoped" stuff, what scope to  look  in).  Since  the 
      grammar  is  not annotated with actions to track transitions to 
      various scopes, and there is no symbol table, we will supply  a 
      hack  to  allow  folks  to test the grammar out.  THIS IS NOT A 
      COMPLETE IMPLEMENTATION!!!! */

    return ('A' <= string[0] && 'Z' >= string[0]);
}
@@


1.3
log
@@*** empty log message ***
@@
text
@@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/RCS/cpp4.l,v`; if test $1 -ne 51844
then
	echo ERROR: oxDistG1.04/grammars/c++/RCS/cpp4.l,v checksum is $1 should be 51844
fi
set `wc -lwc <oxDistG1.04/grammars/c++/RCS/cpp4.l,v`
if test $1$2$3 != 432171216481
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/RCS/cpp4.l,v are $* should be 432 1712 16481
fi

chmod 755 oxDistG1.04/grammars/c++/RCS/cpp4.l,v

if test -f oxDistG1.04/grammars/c++/RCS/cpp4.y,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/RCS/cpp4.y,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/RCS/cpp4.y,v
	if test -f oxDistG1.04/grammars/c++/RCS/cpp4.y,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/RCS/cpp4.y,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/RCS/cpp4.y,v
sed 's/^@//' >oxDistG1.04/grammars/c++/RCS/cpp4.y,v <<'@EOF'
head     1.4;
access   ;
symbols  ;
locks    bischoff:1.4; strict;
comment  @ * @;


1.4
date     93.10.31.15.52.11;  author bischoff;  state Exp;
branches ;
next     1.3;

1.3
date     93.10.24.21.37.46;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.16.27.15;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.01.54;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@unpacked original from comp.compilers archive
@@


1.4
log
@@*** empty log message ***
@@
text
@@%{

    /* Copyright (C) 1989,1990 James A. Roskind, All rights reserved.
    This grammar was developed  and  written  by  James  A.  Roskind.
    Copying  of  this  grammar  description, as a whole, is permitted
    providing this notice is intact and applicable  in  all  complete
    copies.   Translations as a whole to other parser generator input
    languages  (or  grammar  description  languages)   is   permitted
    provided  that  this  notice is intact and applicable in all such
    copies,  along  with  a  disclaimer  that  the  contents  are   a
    translation.   The reproduction of derived text, such as modified
    versions of this grammar, or the output of parser generators,  is
    permitted,  provided  the  resulting  work includes the copyright
    notice "Portions Copyright (c)  1989,  1990  James  A.  Roskind".
    Derived products, such as compilers, translators, browsers, etc.,
    that  use  this  grammar,  must also provide the notice "Portions
    Copyright  (c)  1989,  1990  James  A.  Roskind"  in   a   manner
    appropriate  to  the  utility,  and in keeping with copyright law
    (e.g.: EITHER displayed when first invoked/executed; OR displayed
    continuously on display terminal; OR via placement in the  object
    code  in  form  readable in a printout, with or near the title of
    the work, or at the end of the file).  No royalties, licenses  or
    commissions  of  any  kind are required to copy this grammar, its
    translations, or derivative products, when the copies are made in
    compliance with this notice. Persons or corporations that do make
    copies in compliance with this notice may charge  whatever  price
    is  agreeable  to  a  buyer, for such copies or derivative works.
    THIS GRAMMAR IS PROVIDED ``AS IS'' AND  WITHOUT  ANY  EXPRESS  OR
    IMPLIED  WARRANTIES,  INCLUDING,  WITHOUT LIMITATION, THE IMPLIED
    WARRANTIES  OF  MERCHANTABILITY  AND  FITNESS  FOR  A  PARTICULAR
    PURPOSE.

    James A. Roskind
    Independent Consultant
    516 Latania Palm Drive
    Indialantic FL, 32903
    (407)729-4348
    jar@@ileaf.com
    or ...!uunet!leafusa!jar

    ---end of copyright notice---

MOTIVATION-

My  goal  is  to  see  software  developers  adopt  this grammar as a
standard until such time as a better  standard  is  accessible.   The
only  way  to  get it to become a standard, is to be sure that people
know that derivations are based on a specific work.   The  intent  of
releasing  this  grammar is to provide a publicly accessible standard
grammar for C++.  The intent of the  copyright  notice  is  to  allow
arbitrary  commercial  and non-commercial use of the grammar, as long
as reference is given to the original standard.  Without reference to
a specific standard, many alternative  grammars  would  develop.   By
referring  to  the  standard,  this grammar is given publicity, which
should lead to further use in compatible products and  systems.   The
benefits  of  such  a  standard  to  commercial  products  (browsers,
beautifiers, translators, compilers, ...) should be  obvious  to  the
developers,  in  that  other compatible products will emerge, and the
value of all conforming products  will  rise.   Most  developers  are
aware  of  the  value  of  acquiring  a fairly complete grammar for a
language, and the copyright notice  (and  the  resulting  affiliation
with my work) should not be too high a price to pay.  By copyrighting
this  grammar,  I have some minor control over what this standard is,
and I can (hopefully) keep it from degrading without my approval.   I
will  consistently  attempt  to  provide  upgraded  grammars that are
compliant  with  the  current  art,  and  the  ANSI   C++   Committee
recommendation  in  particular.   A developer is never prevented from
modifying the grammar to improve it in  whatever  way  is  seen  fit.
There  is  also  no  restriction on the sale of copies, or derivative
works, providing the request in the copyright notice are satisfied.

If you are not "copying" my work, but  are  rather  only  abstracting
some  of  the  standard,  an acknowledgment with references to such a
standard would be appreciated.  Specifically,  agreements  with  this
standard  as  to  the  resolution  of otherwise ambiguous constructs,
should be noted.

Simply put: "make whatever use you would like  of  the  grammar,  but
include  the  ``portions  Copyright  ...''  as  a  reference  to this
standard."


*/

/* File CPP4.Y is translated by YACC to y.tab.c
                                Version 1.1, last modified 5/25/90 */

/* ACKNOWLEDGMENT: Without Bjarne Stroustrup and his many  co-workers 
at  Bell  Labs, there would be no C++ Language for which to provide a 
syntax description. Bjarne has also been especially helpful and  open 
in  discussions,  and  by  permitting me to review his texts prior to 
their publication, allowed me a wonderful vantage point of clarity.

Without the effort expended by the ANSI C standardizing committee,  I 
would  have been lost.  Although the ANSI C standard does not include 
a fully disambiguated syntax description, the committee has at  least 
provided  most  of  the disambiguating rules in narratives.  This C++ 
grammar is intended to be a superset of an ANSI C compatible  grammar 
that is provided in an related file.

Several  reviewers  have  also  recently  critiqued this grammar, the 
related C  grammar,  and  or  assisted  in  discussions  during  it's 
preparation.   These  reviewers are certainly not responsible for the 
errors I have committed here, but they are responsible  for  allowing 
me   to  provide  fewer  errors.   These  colleagues  include:  Bruce 
Blodgett, Mark Langley, Joe Fialli, Greg Perkins, and Ron Guilmette.
*/ 

%}

/* Interesting ambiguity:
Usually
        typename ( typename2 ) ...
or
        typename ( typename2 [4] ) ...
etc.
is a redeclaration of typename2.

Inside a structure elaboration, it is sometimes the declaration of  a 
constructor!   Note,  this  only  counts  if  typename IS the current 
containing class name. (Note this can't conflict with ANSI C  because 
ANSI  C  would  call  it a redefinition, but claim it is semantically 
illegal because you can't have a member declared the same type as the 
containing struct!) Since the ambiguity is only reached when a ';' is 
found,  there  is  no  problem  with  the  fact  that  the   semantic 
interpretation  is  providing  the  true  resolution.   As  currently 
implemented, the constructor semantic actions must be able to process 
an ordinary declaration.  I may reverse this in the future,  to  ease 
semantic implementation. 
*/



/*

INTRO TO ANSI C GRAMMAR (provided in a separate file):

The refined grammar resolves several typedef ambiguities in the draft 
proposed  ANSI  C standard syntax down to 1 shift/reduce conflict, as 
reported by a YACC process.  Note that the one shift reduce conflicts 
is the traditional if-if-else conflict that is not  resolved  by  the 
grammar.  This ambiguity can be removed using the method described in 
the  Dragon  Book  (2nd  edition), but this does not appear worth the 
effort.

There was quite a bit of effort made to reduce the conflicts to  this 
level,  and  an  additional effort was made to make the grammar quite 
similar to the C++ grammar being developed in  parallel.   Note  that 
this grammar resolves the following ANSI C ambiguities:

ANSI  C  section  3.5.6,  "If  the [typedef name] is redeclared at an 
inner scope, the type specifiers shall not be omitted  in  the  inner 
declaration".   Supplying type specifiers prevents consideration of T 
as a typedef name in this grammar.  Failure to supply type specifiers 
forced the use of the TYPEDEFname as a type specifier.  This is taken 
to an (unnecessary) extreme by this implementation.  The ambiguity is 
only a problem with the first declarator in  a  declaration,  but  we 
restrict   ALL   declarators  whenever  the  users  fails  to  use  a 
type.specifier.
              
ANSI C section 3.5.4.3, "In a parameter declaration, a single typedef 
name in parentheses is  taken  to  be  an  abstract  declarator  that 
specifies  a  function  with  a  single  parameter,  not as redundant 
parentheses around the identifier".  This is extended  to  cover  the 
following cases:

typedef float T;
int noo(const (T[5]));
int moo(const (T(int)));
@...

Where  again the '(' immediately to the left of 'T' is interpreted as 
being the start of a parameter type list,  and  not  as  a  redundant 
paren around a redeclaration of T.  Hence an equivalent code fragment 
is:

typedef float T;
int noo(const int identifier1 (T identifier2 [5]));
int moo(const int identifier1 (T identifier2 (int identifier3)));
@...

*/


%{
/*************** Includes and Defines *****************************/
#define YYDEBUG_LEXER_TEXT (yylval) /* our lexer loads this up each time */
#define YYDEBUG 1        /* Force the pretty debugging code to compile*/
#define YYSTYPE  char *  /* interface with flex: should be in header file */
/*************** Standard ytab.c continues here *********************/
%}

/*************************************************************************/



%token AUTO            DOUBLE          INT             STRUCT
%token BREAK           ELSE            LONG            SWITCH
%token CASE            ENUM            REGISTER        TYPEDEF
%token CHAR            EXTERN          RETURN          UNION
%token CONST           FLOAT           SHORT           UNSIGNED
%token CONTINUE        FOR             SIGNED          VOID
%token DEFAULT         GOTO            SIZEOF          VOLATILE
%token DO              IF              STATIC          WHILE

/* The following are used in C++ only.  ANSI C would call these IDENTIFIERs */
%token NEW             DELETE
%token THIS            
%token OPERATOR
%token CLASS           
%token PUBLIC          PROTECTED       PRIVATE
%token VIRTUAL         FRIEND
%token INLINE          OVERLOAD        

/* ANSI C Grammar suggestions */
%token IDENTIFIER              STRINGliteral
%token FLOATINGconstant        INTEGERconstant        CHARACTERconstant
%token OCTALconstant           HEXconstant

/* New Lexical element, whereas ANSI C suggested non-terminal */
%token TYPEDEFname 

/* Multi-Character operators */
%token  ARROW            /*    ->                              */
%token  ICR DECR         /*    ++      --                      */
%token  LS RS            /*    <<      >>                      */
%token  LE GE EQ NE      /*    <=      >=      ==      !=      */
%token  ANDAND OROR      /*    &&      ||                      */
%token  ELLIPSIS         /*    ...                             */
                 /* Following are used in C++, not ANSI C        */
%token  CLCL             /*    ::                              */
%token  DOTstar ARROWstar/*    .*       ->*                    */
 
/* modifying assignment operators */
%token MULTassign  DIVassign    MODassign   /*   *=      /=      %=      */
%token PLUSassign  MINUSassign              /*   +=      -=              */
%token LSassign    RSassign                 /*   <<=     >>=             */
%token ANDassign   ERassign     ORassign    /*   &=      ^=      |=      */


/*************************************************************************/

%start prog.start

/*************************************************************************/

%%
prog.start:
        /*nothing*/
        | translation.unit
        ;

/* CONSTANTS */
constant:
        FLOATINGconstant
        | INTEGERconstant
        /*  We are not including ENUMERATIONconstant here because we
          are treating it like a variable with a type of "enumeration
          constant".  */
        | OCTALconstant
        | HEXconstant
        | CHARACTERconstant
        ;

/* STRING LITERALS */
string.literal.list:
                STRINGliteral
                | string.literal.list STRINGliteral
                ;


/* EXPRESSIONS */

    /* The following can be used in an identifier  based  declarator.  
    (Declarators   that  redefine  an  existing  TYPEDEFname  require 
    special handling, and are not included here).  In  addition,  the 
    following are all valid "identifiers" in an expression, whereas a 
    TYPEDEFname is NOT.*/
    
rescoped.identifier:
        IDENTIFIER  /* ANSI C: We cannot use a TYPEDEFname as a variable */
        | operator.function.name /* C++, not ANSI C*/
        | class.rescoped.identifier
        ;


    /* When nested types are supported, an action must be taken prior 
    to  the  CLCL  in each of the following productions to notify the 
    lexer of a temporary change in scope. This change will allow  the 
    lexer to deduce whether the name that follows the CLCL is that of 
    an  IDENTIFIER  (member),  or  of a TYPEDEFname (locally declared 
    type).  This lexical distinction is critical to continued  syntax 
    analysis. */

class.rescoped.identifier:
        TYPEDEFname CLCL identifier.or.typedef.name /* C++, not ANSI C */
        | TYPEDEFname CLCL operator.function.name /* C++, not ANSI C */
        | TYPEDEFname CLCL '~' TYPEDEFname /* C++, not ANSI C */
        | TYPEDEFname CLCL class.rescoped.identifier /* C++, not ANSI C */
        ;

    /* Note that the following MUST come before primary.expression so 
    that  the  reduce/reduce conflict is properly resolved (according 
    to Stroustrup: "If it can be a declaration, then it  should  be".  
    I  just  give  up  and  go  in  that  direction  after  I see the 
    declarator, whereas cfront tries to lex  ahead  to  disambiguate.  
    My reduce-reduce conflict disambiguates this situation at a point 
    where human readers cannot generally disambiguate (mentally). */
    
paren.identifier.declarator:
        rescoped.identifier
        | '(' paren.identifier.declarator ')'
        ;

    /*  Note that CLCL IDENTIFIER is NOT part of rescoped.identifier. 
    It is ONLY valid for referring to an identifier,  and  NOT  valid 
    for  declaring  (or  importing  an  external  declaration  of) an 
    identifier.  This disambiguates the following code,  which  would 
    otherwise be syntactically and semantically ambiguous:

            class base {
                static int i; // element i;
                float member_funct(void);
                };
            base i; // global i
            float base::member_function(void) {
                i; // refers to static int element "i" of base
                ::i; // refers to global "i", with type "base"
                    {
                    base :: i; // import of global "i", like "base (::i);"?
                                // OR reference to global??
                    }
                }
        */
primary.expression:
        CLCL identifier.or.typedef.name  /* C++, not ANSI C */
        | CLCL operator.function.name /* C++, not ANSI C */
        | THIS   /* C++, not ANSI C */
        | rescoped.identifier
        | constant
        | string.literal.list
        | '(' expression ')'
        ;

    /*  The  following  introduces  MANY  conflicts.   Requiring  and 
    allowing '(' ')' around the `type' when the type is complex would 
    help a lot. */

operator.function.name:
        OPERATOR any.operator
        | OPERATOR type.specifier.or.name  operator.function.ptr.opt
        | OPERATOR type.qualifier.list     operator.function.ptr.opt
        ;

    /* The following causes several ambiguities on *  and  &.   These 
    conflicts  would also be removed if parens around the `type' were 
    required in the derivations for operator.function.name */

    /*  Interesting  aside:  The  use  of  right  recursion  in   the 
    production  for  operator.function.ptr.opt gives both the correct 
    parsing, AND removes a conflict!   Right  recursion  permits  the 
    parser   to   defer   reductions  (aka:  delay  resolution),  and 
    effectively make a second pass! */
        
operator.function.ptr.opt:
        /* nothing */
        | pointer.operator operator.function.ptr.opt
        | indirect.or.reference operator.function.ptr.opt
        ;

any.operator:
        '+'
        | '-'
        | '*'
        | '/'
        | '%'
        | '^'
        | '&'
        | '|'
        | '~'
        | '!'
        | '<'
        | '>'
        | LS
        | RS
        | ANDAND
        | OROR
        | ARROW
        | ARROWstar
        | '.' /* can we overload this? */
        | DOTstar
        | ICR
        | DECR
        | LE
        | GE
        | EQ
        | NE
        | assignment.operator
        | '(' ')'
        | '[' ']'
        | NEW
        | DELETE
        | ','
        ;

    /* The following production for type.qualifier.list was specially 
    placed BEFORE the definition of postfix.expression to  resolve  a 
    reduce-reduce conflict correctly */        

type.qualifier.list.opt:
        /* Nothing */
        | type.qualifier.list
        ;

    /*  Note  that  the next set of productions in this grammar gives 
    post-increment a higher precedence that pre-increment.   This  is 
    not  clearly  stated  in  the  C++  Reference manual, and is only 
    implied by the grammar in the ANSI C Standard. */

postfix.expression:
        primary.expression
        | postfix.expression '[' expression ']'
        | postfix.expression '(' ')'
        | postfix.expression '(' argument.expression.list ')'
        | postfix.expression '.' rescoped.identifier.or.typedef.name
        | postfix.expression ARROW rescoped.identifier.or.typedef.name
        | postfix.expression ICR
        | postfix.expression DECR

                /* The next 4 rules are the source of cast ambiguity */
        | TYPEDEFname '(' ')'
        | TYPEDEFname '(' argument.expression.list ')'
        | basic.type.name '(' assignment.expression ')'
                /* If the following rule is added to the grammar, there will
                be 3 additional reduce-reduce conflicts.  They will all be
                resolved in favor of NOT using the following rule, so no harm
                will be done.  However, since the rule is semantically
                illegal we will omit it until we are enhancing the grammar
                for error recovery */
/*      | basic.type.name '(' ')'  Illegal: no such constructor*/
        ;

rescoped.identifier.or.typedef.name:
        TYPEDEFname 
        | rescoped.identifier
        ;

argument.expression.list:
        assignment.expression
        | argument.expression.list ',' assignment.expression
        ;

unary.expression:
        postfix.expression
        | ICR unary.expression
        | DECR unary.expression
        | indirect.or.reference cast.expression
        | '-' cast.expression
        | '+' cast.expression
        | '~' cast.expression
        | '!' cast.expression
        | SIZEOF unary.expression
        | SIZEOF '(' type.name ')'
        | allocation.expression
        ;


    /* Note that I could have moved the  newstore  productions  to  a 
    lower  precedence  level  than  multiplication  (binary '*'), and 
    lower than bitwise AND (binary '&').  These moves  are  the  nice 
    way  to  disambiguate a trailing unary '*' or '&' at the end of a 
    freestore expression.  Since the freestore expression (with  such 
    a  grammar  and  hence  precedence  given)  can never be the left 
    operand of a binary '*' or '&', the ambiguity would  be  removed.  
    These  problems  really  surface when the binary operators '*' or 
    '&' are overloaded, but this must be syntactically  disambiguated 
    before the semantic checking is performed...  Unfortunately, I am 
    not  creating  the language, only writing a grammar that reflects 
    its specification, and  hence  I  cannot  change  its  precedence 
    assignments.   If  I  had  my  druthers,  I would probably prefer 
    surrounding the type with parens all the time, and  avoiding  the 
    dangling * and & problem all together.*/

       /* Following are C++, not ANSI C */
allocation.expression:
        operator.new                                  '(' type.name ')'
                operator.new.initializer.opt
        | operator.new '(' argument.expression.list ')' '(' type.name ')'
                operator.new.initializer.opt
                /* next two rules are the source of * and & ambiguities */
        | operator.new                                  operator.new.type
        | operator.new '(' argument.expression.list ')' operator.new.type
        ;

operator.new:
        NEW
        | CLCL NEW
        ;

    /*  Note:  the  otherwise  "silly" inline expansion in the next 4 
    productions is necessary to allow such expressions as:

      new const T :: * ;
      new const T ;

    to be parsed correctly.  */

operator.new.type:
        type.qualifier.list      operator.new.declarator.opt
                        operator.new.initializer.opt
        | type.specifier.or.name operator.new.declarator.opt
                        operator.new.initializer.opt
        ;

    /* Perhaps I should move  the  following  to  a  more  consistent 
    position, but for now I will just leave it here. */

    /*  Note that the following does not include type.qualifier.list. 
    Hence, whenever type.specifier.or.name is used, an adjacent  rule 
    is  supplied containing type.qualifier.list.  It is not generally 
    possible    to    know    immediately    (i.e.,     reduce)     a 
    type.qualifier.list,  as  a TYPEDEFname that follows might not be 
    part of a type specifier, but might instead  be  "TYPEDEFname  :: 
    *". */

type.specifier.or.name:
        type.specifier
        | basic.type.name
        | TYPEDEFname
        ;

    /*  Right  recursion  is critical in the following productions to 
    avoid a conflict on TYPEDEFname */

operator.new.declarator.opt:
        /* Nothing */
        | operator.new.array.declarator
        | indirect.or.reference operator.new.declarator.opt
        | pointer.operator      operator.new.declarator.opt
        ;

operator.new.array.declarator:
        '[' ']'
        | '[' expression ']'
        | operator.new.array.declarator '[' expression ']'
        ;

operator.new.initializer.opt:
        /* Nothing */
        | '(' ')'
        | '(' argument.expression.list ')'
        ;

cast.expression:
        unary.expression
        | '(' type.name ')' cast.expression
        ;

    /* Following are C++, not ANSI C */
deallocation.expression:
        cast.expression
        | clcl.opt.delete deallocation.expression
        | clcl.opt.delete '[' expression ']' deallocation.expression  /* archaic */
        | clcl.opt.delete '[' ']' deallocation.expression
        ;

    /* Following are C++, not ANSI C */
clcl.opt.delete:
        DELETE
        | CLCL DELETE
        ;

    /* Following are C++, not ANSI C */
point.member.expression:
        deallocation.expression
        | point.member.expression DOTstar  deallocation.expression
        | point.member.expression ARROWstar  deallocation.expression
        ;
        
multiplicative.expression:
        point.member.expression
        | multiplicative.expression '*' point.member.expression
        | multiplicative.expression '/' point.member.expression
        | multiplicative.expression '%' point.member.expression
        ;

additive.expression:
        multiplicative.expression
        | additive.expression '+' multiplicative.expression
        | additive.expression '-' multiplicative.expression
        ;

shift.expression:
        additive.expression
        | shift.expression LS additive.expression
        | shift.expression RS additive.expression
        ;

relational.expression:
        shift.expression
        | relational.expression '<' shift.expression
        | relational.expression '>' shift.expression
        | relational.expression LE shift.expression
        | relational.expression GE shift.expression
        ;

equality.expression:
        relational.expression
        | equality.expression EQ relational.expression
        | equality.expression NE relational.expression
        ;

AND.expression:
        equality.expression
        | AND.expression '&' equality.expression
        ;

exclusive.OR.expression:
        AND.expression
        | exclusive.OR.expression '^' AND.expression
        ;

inclusive.OR.expression:
        exclusive.OR.expression
        | inclusive.OR.expression '|' exclusive.OR.expression
        ;

logical.AND.expression:
        inclusive.OR.expression
        | logical.AND.expression ANDAND inclusive.OR.expression
        ;

logical.OR.expression:
        logical.AND.expression
        | logical.OR.expression OROR logical.AND.expression
        ;

conditional.expression:
        logical.OR.expression
        | logical.OR.expression '?' expression ':'
                conditional.expression
        ;

assignment.expression:
        conditional.expression
        | unary.expression assignment.operator assignment.expression
        ;

assignment.operator:
        '='
        | MULTassign
        | DIVassign
        | MODassign
        | PLUSassign
        | MINUSassign
        | LSassign
        | RSassign
        | ANDassign
        | ERassign
        | ORassign
        ;

expression:
        assignment.expression
        | expression ',' assignment.expression
        ;

constant.expression:
        conditional.expression
        ;

    /* The following was used for clarity */
expression.opt:
        /* Nothing */
        | expression
        ;



/* DECLARATIONS */

    /* The following are notably different from the ANSI  C  Standard 
    specified  grammar,  but  are  present  in  my  ANSI C compatible 
    grammar.  The changes were made to disambiguate typedefs presence 
    in   declaration.specifiers   (vs.    in   the   declarator   for 
    redefinition);  to allow struct/union/enum/class tag declarations 
    without  declarators,  and  to  better  reflect  the  parsing  of 
    declarations     (declarators     must     be    combined    with 
    declaration.specifiers ASAP, so that they can immediately  become 
    visible in the current scope). */

declaration:
        sue.declaration.specifier ';' { /* this is semantic error, as it
                                        includes a storage class!?!*/ }
        | sue.type.specifier ';'
        | declaring.list ';'
        | default.declaring.list ';'
        ;

    /*  Note  that  if  a typedef were redeclared, then a declaration 
    specifier must be supplied (re: ANSI C spec).  The following  are 
    declarations  wherein  no  declaration.specifier is supplied, and 
    hence the 'default' must be used.  An example of this is

        const a;

    which by default, is the same as:

        const int a;

    `a' must NOT be a typedef in the above example. */


    /* The presence of `{}' in the following rules  indicates  points 
    at  which  the symbol table MUST be updated so that the tokenizer 
    can IMMEDIATELY  continue  to  maintain  the  proper  distinction 
    between a TYPEDEFname and an IDENTIFIER. */
    

default.declaring.list:  /* Can't  redeclare typedef names */
        declaration.qualifier.list   identifier.declarator {} initializer.opt
        | type.qualifier.list        identifier.declarator {} initializer.opt
        | default.declaring.list ',' identifier.declarator {} initializer.opt

        | declaration.qualifier.list constructed.identifier.declarator
        | type.qualifier.list        constructed.identifier.declarator
        | default.declaring.list ',' constructed.identifier.declarator
        ;

    /*  Note  how  type.qualifier.list  is  NOT used in the following 
    productions.   Qualifiers  are   NOT   sufficient   to   redefine 
    typedef-names (as prescribed by the ANSI C standard).*/
    
declaring.list:
        declaration.specifier  declarator {} initializer.opt
        | type.specifier       declarator {} initializer.opt
        | basic.type.name      declarator {} initializer.opt
        | TYPEDEFname          declarator {} initializer.opt
        | declaring.list ','   declarator {} initializer.opt

        | declaration.specifier constructed.declarator
        | type.specifier        constructed.declarator
        | basic.type.name       constructed.declarator
        | TYPEDEFname           constructed.declarator
        | declaring.list ','    constructed.declarator
        ;

    /*  Declarators  with  parenthesized  initializers  present a big 
    problem.  Typically a declarator that looks  like:  "*a(...)"  is 
    supposed  to bind FIRST to the "(...)", and then to the "*". This 
    binding presumes that the "(...)" stuff  is  a  prototype  scope.  
    With  constructed  declarators,  we  must (officially) finish the 
    binding to the "*" (finishing forming a good declarator) and THEN 
    connect with the argument list.  Unfortunately, by  the  time  we 
    realize  it  is  an  argument  list (and not a prototype) we have 
    pushed the separate declarator tokens "*a" onto  the  yacc  stack 
    WITHOUT combining them. The solution is to use odd productions to 
    carry   the   incomplete  declarator  along  with  the  "argument 
    expression list" back up the yacc stack.  We would then  actually 
    instantiate  the  symbol  table after we have fully decorated the 
    symbol with all the leading "*" stuff. Actually, since  we  don't 
    have  all  the  type  information in one spot till we reduce to a 
    declaring.list, this delay is not a problem.  Note that  ordinary 
    initializers  REQUIRE (ANSI C Standard) that the symbol be placed 
    into the symbol table BEFORE its initializer is read, but in  the 
    case  of  parenthesized  initializers,  this  is not possible (we 
    don't even know we have  an  initializer  till  have  passed  the 
    opening "(". )*/

constructed.declarator:
        nonunary.constructed.identifier.declarator
        | constructed.paren.typedef.declarator 
        | simple.paren.typedef.declarator '(' argument.expression.list ')'  
        | simple.paren.typedef.declarator postfixing.abstract.declarator 
                                          '(' argument.expression.list ')'  /* semantic error*/
        | constructed.parameter.typedef.declarator 
        | indirect.or.reference constructed.declarator
        | pointer.operator      constructed.declarator
        ;

constructed.paren.typedef.declarator:
        '(' paren.typedef.declarator ')'                                         
                    '(' argument.expression.list ')'  
        | '(' paren.typedef.declarator ')' postfixing.abstract.declarator        
                   '(' argument.expression.list ')'  
        | '(' simple.paren.typedef.declarator postfixing.abstract.declarator ')' 
                   '(' argument.expression.list ')'  
        | '(' TYPEDEFname postfixing.abstract.declarator ')'                     
                   '(' argument.expression.list ')'  
        ;

constructed.parameter.typedef.declarator:
        TYPEDEFname    '(' argument.expression.list ')' 
        | TYPEDEFname postfixing.abstract.declarator                       
                       '(' argument.expression.list ')'  /* semantic error */
        | '(' clean.typedef.declarator ')'                                 
                       '(' argument.expression.list ')'
        | '(' clean.typedef.declarator ')'  postfixing.abstract.declarator
                       '(' argument.expression.list ')'
        ;



constructed.identifier.declarator:
        nonunary.constructed.identifier.declarator
        | indirect.or.reference constructed.identifier.declarator
        | pointer.operator      constructed.identifier.declarator
        ;

    /*  The  following  are  restricted to NOT begin with any pointer
    operators.  This includes both "*" and "T::*"  modifiers.   Aside 
    from   this   restriction,   the   following   would  have  been: 
    identifier.declarator '(' argument.expression.list ')' */

nonunary.constructed.identifier.declarator:
        paren.identifier.declarator   '(' argument.expression.list ')'
        | paren.identifier.declarator postfixing.abstract.declarator   
                       '(' argument.expression.list ')'  /* semantic error*/
        | '(' unary.identifier.declarator ')' 
                       '(' argument.expression.list ')'
        | '(' unary.identifier.declarator ')' postfixing.abstract.declarator  
                       '(' argument.expression.list ')'
        ;


declaration.specifier:
        basic.declaration.specifier        /* Arithmetic or void */
        | sue.declaration.specifier          /* struct/union/enum/class */
        | typedef.declaration.specifier      /* typedef*/
        ;

type.specifier:
        basic.type.specifier                 /* Arithmetic or void */
        | sue.type.specifier                 /* Struct/Union/Enum/Class */
        | typedef.type.specifier             /* Typedef */
        ;


declaration.qualifier.list:  /* storage class and optional const/volatile */
        storage.class
        | type.qualifier.list storage.class
        | declaration.qualifier.list declaration.qualifier
        ;

type.qualifier.list:
        type.qualifier
        | type.qualifier.list type.qualifier
        ;

declaration.qualifier:
        type.qualifier                  /* const or volatile */
        | storage.class
        ;

type.qualifier:
        CONST
        | VOLATILE
        ;

basic.declaration.specifier:      /*Storage Class+Arithmetic or void*/
        basic.type.specifier  storage.class
        | basic.type.name     storage.class
        | declaration.qualifier.list basic.type.name
        | basic.declaration.specifier declaration.qualifier
        | basic.declaration.specifier basic.type.name
        ;

basic.type.specifier:
        basic.type.name        basic.type.name /* Arithmetic or void */
        | basic.type.name      type.qualifier
        | type.qualifier.list  basic.type.name
        | basic.type.specifier type.qualifier
        | basic.type.specifier basic.type.name
        ;

sue.declaration.specifier:          /* Storage Class + struct/union/enum/class */
        sue.type.specifier storage.class
        | declaration.qualifier.list elaborated.type.name
        | sue.declaration.specifier declaration.qualifier
        ;

sue.type.specifier:
        elaborated.type.name              /* struct/union/enum/class */
        | type.qualifier.list elaborated.type.name
        | sue.type.specifier type.qualifier
        ;


typedef.declaration.specifier:       /*Storage Class + typedef types */
        typedef.type.specifier storage.class
        | TYPEDEFname          storage.class
        | declaration.qualifier.list TYPEDEFname
        | typedef.declaration.specifier declaration.qualifier
        ;

typedef.type.specifier:              /* typedef types */
        TYPEDEFname              type.qualifier
        | type.qualifier.list    TYPEDEFname
        | typedef.type.specifier type.qualifier
        ;

    /* There are really several  distinct  sets  of  storage.classes.  
    The  sets  vary  depending  on whether the declaration is at file 
    scope, is a  declaration  within  a  struct/class,  is  within  a 
    function body, or in a function declaration/definition (prototype 
    parameter  declarations).  They  are grouped here to simplify the 
    grammar,  and  can  be  semantically  checked.   Note  that  this 
    approach  tends to ease the syntactic restrictions in the grammar 
    slightly, but allows for future language development,  and  tends 
    to  provide  superior  diagnostics  and  error  recovery (i.e.: a 
    syntax error does not disrupt the parse).


                File    File    Member  Member  Local   Local  Formal
                Var     Funct   Var     Funct   Var     Funct  Params
TYPEDEF         x       x       x       x       x       x
EXTERN          x       x                       x       x
STATIC          x       x       x       x       x
AUTO                                            x              x
REGISTER                                        x              x
FRIEND                                  x       
OVERLOAD                x               x               x
INLINE                  x               x               x
VIRTUAL                                 x               x
*/

storage.class:
        TYPEDEF 
        | EXTERN
        | STATIC 
        | AUTO
        | REGISTER
        | FRIEND   /* C++, not ANSI C */
        | OVERLOAD /* C++, not ANSI C */
        | INLINE   /* C++, not ANSI C */
        | VIRTUAL  /* C++, not ANSI C */
        ;

basic.type.name:
        VOID
        | CHAR
        | SHORT
        | INT
        | LONG
        | FLOAT
        | DOUBLE
        | SIGNED
        | UNSIGNED
        ;

elaborated.type.name:
        aggregate.name
        | enum.name
        ;


    /* Since the expression "new type.name" MIGHT use  an  elaborated 
    type  and a derivation, it MIGHT have a ':'.  This fact conflicts 
    with the requirement that a new expression can be placed  between 
    a '?' and a ':' in a conditional expression (at least it confuses 
    most LR(1) parsers). */

    /*  The derivation.opt reduction was placed DELIBERATELY in front 
    of aggregate.name to resolve  a  reduce-reduce  on  '{'  conflict 
    properly */
    
derivation.opt:
        /* nothing */
        | ':' derivation.list
        ;

    /*  The  intermediate  actions  {}  represent points at which the 
    database of typedef names  must  be  updated  in  C++.   This  is 
    critical to the lexer, which must begin to tokenize based on this 
    new information. */

aggregate.name:
        aggregate.key                             derivation.opt {}
                '{' member.declaration.list.opt '}'
        | aggregate.key identifier.or.typedef.name derivation.opt  {}
                '{' member.declaration.list.opt '}'
        | aggregate.key identifier.or.typedef.name                 {}
        ;

derivation.list:
        parent.class
        | derivation.list ',' parent.class
        ;

parent.class:
        TYPEDEFname
        | VIRTUAL access.specifier.opt TYPEDEFname
        | access.specifier virtual.opt TYPEDEFname
        ;

virtual.opt:
        /* nothing */
        | VIRTUAL
        ;

access.specifier.opt:
        /* nothing */
        | access.specifier
        ;

access.specifier:
        PUBLIC
        | PRIVATE
        | PROTECTED /* not syntactically valid, but nice for error reporting*/
        ;

aggregate.key:
        STRUCT
        | UNION
        | CLASS /* C++, not ANSI C */
        ;

    /* Note that an empty list is ONLY allowed under C++. The grammar 
    can  be modified so that this stands out.  The trick is to define 
    member.declaration.list, and have that referenced for non-trivial 
    lists. */

member.declaration.list.opt:
        /* nothing */ 
        | member.declaration.list.opt member.declaration
        ;

member.declaration:
        member.declaring.list ';'
        | member.default.declaring.list ';'
        | PUBLIC ':'                      /* C++, not ANSI C */
        | PRIVATE ':'                     /* C++, not ANSI C */
        | PROTECTED ':'                   /* C++, not ANSI C */
        | new.function.definition         /* C++, not ANSI C */
        | constructor.function.in.class   /* C++, not ANSI C */
        | destructor.function             /* C++, not ANSI C */
        | sue.type.specifier ';'       /* nested tag elaborations*/ /* C++, not ANSI C */
        | class.rescoped.identifier ';' /*access modification*/     /* C++, not ANSI C */
        | typedef.declaration.specifier ';' /* friend T */   /* C++, not ANSI C */
        | sue.declaration.specifier ';'  /* friend class C*/  /* C++, not ANSI C */
        ;

member.default.declaring.list:        /* doesn't redeclare typedef*/
        type.qualifier.list          
                identifier.declarator member.pure.opt
        | declaration.qualifier.list 
                identifier.declarator member.pure.opt /* C++, not ANSI C */
        | member.default.declaring.list ',' 
                identifier.declarator member.pure.opt

        | type.qualifier.list           bit.field.identifier.declarator 
        | declaration.qualifier.list    bit.field.identifier.declarator /* C++, not ANSI C */
        | member.default.declaring.list ','  bit.field.identifier.declarator 
        ;

member.declaring.list:        /* Can possibly redeclare typedefs */
        type.specifier     declarator member.pure.opt
        | basic.type.name  declarator member.pure.opt
        | member.conflict.declaring.item

        | member.declaring.list ',' declarator member.pure.opt

        | type.specifier        bit.field.declarator 
        | basic.type.name       bit.field.declarator 
        | TYPEDEFname           bit.field.declarator 
        | declaration.specifier bit.field.declarator /* C++? not ANSI C */
        | member.declaring.list ',' bit.field.declarator 
        ;

    /* The following conflict with constructors-
      member.conflict.declaring.item:
        TYPEDEFname           declarator member.pure.opt
        | declaration.specifier declarator member.pure.opt /* C++, not ANSI C * /
        ;
    so we inline expand declarator to get the following productions...
    */
member.conflict.declaring.item:
        TYPEDEFname             identifier.declarator            member.pure.opt
        | TYPEDEFname           parameter.typedef.declarator     member.pure.opt
        | declaration.specifier identifier.declarator            member.pure.opt
        | declaration.specifier parameter.typedef.declarator     member.pure.opt
        | TYPEDEFname           simple.paren.typedef.declarator  member.pure.opt
        | declaration.specifier simple.paren.typedef.declarator  member.pure.opt

        | member.conflict.paren.declaring.item
        ;

    /* The following still conflicts with constructors-
      member.conflict.paren.declaring.item:
        TYPEDEFname           paren.typedef.declarator     member.pure.opt
        | declaration.specifier paren.typedef.declarator     member.pure.opt
        ;
    so paren.typedef.declarator is expanded inline to get...*/

member.conflict.paren.declaring.item:
        TYPEDEFname   indirect.or.reference 
                '(' simple.paren.typedef.declarator ')' member.pure.opt
        | TYPEDEFname pointer.operator
                '(' simple.paren.typedef.declarator ')' member.pure.opt
        | TYPEDEFname indirect.or.reference
                '(' TYPEDEFname ')'                     member.pure.opt
        | TYPEDEFname pointer.operator
                '(' TYPEDEFname ')'                     member.pure.opt
        | TYPEDEFname indirect.or.reference
                 paren.typedef.declarator               member.pure.opt
        | TYPEDEFname pointer.operator
                 paren.typedef.declarator               member.pure.opt
        | declaration.specifier indirect.or.reference
                '(' simple.paren.typedef.declarator ')' member.pure.opt
        | declaration.specifier pointer.operator
                '(' simple.paren.typedef.declarator ')' member.pure.opt
        | declaration.specifier indirect.or.reference
                '(' TYPEDEFname ')'                     member.pure.opt
        | declaration.specifier pointer.operator
                '(' TYPEDEFname ')'                     member.pure.opt
        | declaration.specifier indirect.or.reference
                paren.typedef.declarator                member.pure.opt
        | declaration.specifier pointer.operator
                paren.typedef.declarator                member.pure.opt

        | member.conflict.paren.postfix.declaring.item
        ;

    /* but we still have the following conflicts with constructors-
    member.conflict.paren.postfix.declaring.item:
      TYPEDEFname           paren.postfix.typedef.declarator member.pure.opt
      | declaration.specifier paren.postfix.typedef.declarator member.pure.opt
      ;
    so we expand paren.postfix.typedef inline and get...*/

member.conflict.paren.postfix.declaring.item:
        TYPEDEFname     '(' paren.typedef.declarator ')'
                                                           member.pure.opt
        | TYPEDEFname   '(' simple.paren.typedef.declarator
                        postfixing.abstract.declarator ')' member.pure.opt
        | TYPEDEFname   '(' TYPEDEFname
                        postfixing.abstract.declarator ')' member.pure.opt
        | TYPEDEFname   '(' paren.typedef.declarator ')'
                        postfixing.abstract.declarator     member.pure.opt

        | declaration.specifier '(' paren.typedef.declarator ')' 
                                                           member.pure.opt
        | declaration.specifier '(' simple.paren.typedef.declarator
                        postfixing.abstract.declarator ')' member.pure.opt
        | declaration.specifier '(' TYPEDEFname
                        postfixing.abstract.declarator ')' member.pure.opt
        | declaration.specifier '(' paren.typedef.declarator ')' 
                        postfixing.abstract.declarator     member.pure.opt
        ;


member.pure.opt:
        /* nothing */
        | '=' OCTALconstant /* C++, not ANSI C */ /* Pure function*/
        ;

    /* Note that bit field names cannot be parenthesized in C++  (due 
    to  ambiguities),  and  hence this part of the grammar is simpler 
    than ANSI C. :-) */

bit.field.declarator:
        bit.field.identifier.declarator
        | TYPEDEFname {} ':' constant.expression
        ;

    /* The actions taken in the "{}" above and below are probably not 
    really required (re: putting the symbol into the symbol table  as 
    part  of  the  struct), as there is (I think) no way to reference 
    them until the struct is complete.  Hence there is no  real  risk 
    that  the constant.expression would make reference to them (e.g., 
    "name : sizeof  name").   For  cleanliness,  we  will  leave  the 
    actions in this form. */

bit.field.identifier.declarator:
        ':' constant.expression
        | IDENTIFIER {} ':' constant.expression
        ;

enum.name:
        ENUM '{' enumerator.list '}'
        | ENUM identifier.or.typedef.name '{' enumerator.list '}'
        | ENUM identifier.or.typedef.name
        ;

enumerator.list:
        enumerator.list.no.trailing.comma
        | enumerator.list.no.trailing.comma ',' /* C++, not ANSI C */
        ;

    /*  Note  that we do not need to rush to add an enumerator to the 
    symbol table until *AFTER* the  enumerator.value.opt  is  parsed.  
    The  enumerated  value  is  only in scope AFTER its definition is 
    complete.  Hence the following is legal: "enum {a, b=a+10};"  but 
    the  following is (assuming no external matching of names) is not 
    legal: "enum {c, d=sizeof(d)};" ("d" not defined when sizeof  was 
    applied.)  This  is  notably  contrasted  with declarators, which 
    enter scope as soon as the declarator is complete. */

enumerator.list.no.trailing.comma:
        identifier.or.typedef.name enumerator.value.opt
        | enumerator.list.no.trailing.comma ',' 
               identifier.or.typedef.name enumerator.value.opt
        ;

enumerator.value.opt:
        /* Nothing */
        | '=' constant.expression
        ;

    /* We special case the lone type.name which has no storage  class 
    (even  though  it should be an example of a parameter.type.list). 
    This helped to disambiguate type-names in parenthetical casts.*/

parameter.type.list: 
        '(' ')'                             type.qualifier.list.opt
        | '(' type.name ')'                 type.qualifier.list.opt
        | '(' type.name initializer ')'     type.qualifier.list.opt /* C++, not ANSI C */
        | '(' named.parameter.type.list ')' type.qualifier.list.opt
        ;
    
    /* The following are used in old style function definitions, when 
    a complex return type includes the "function returning" modifier.  
    Note the  subtle  distinction  from  parameter.type.list.   These 
    parameters are NOT the parameters for the function being defined, 
    but are simply part of the type definition.  An example would be:

        int(*f(   a  ))(float) long a; {...}

    which is equivalent to the full new style definition:

        int(*f(long a))(float) {...}

    The    type    list    `(float)'    is    an    example   of   an 
    old.parameter.type.list.  The bizarre point here is that  an  old 
    function  definition  declarator  can be followed by a type list, 
    which can start with a qualifier `const'.   This  conflicts  with 
    the  new  syntactic  construct for const member functions!?! As a 
    result, an old style function definition cannot be  used  in  all 
    cases for a member function.  */

old.parameter.type.list: 
        '(' ')' 
        | '(' type.name ')' 
        | '(' type.name initializer ')'  /* C++, not ANSI C */
        | '(' named.parameter.type.list ')' 
        ;

named.parameter.type.list:  /* WARNING: excludes lone type.name*/
        parameter.list
        | parameter.list comma.opt.ellipsis
        | type.name comma.opt.ellipsis
        | type.name initializer comma.opt.ellipsis  /* C++, not ANSI C */
        | ELLIPSIS /* C++, not ANSI C */
        ;


comma.opt.ellipsis:
        ELLIPSIS       /* C++, not ANSI C */
        | ',' ELLIPSIS
        ;

parameter.list: 
        named.parameter.declaration
        | named.parameter.declaration initializer /* C++, not ANSI C */
        | type.name             ',' parameter.declaration
        | type.name initializer ',' parameter.declaration  /* C++, not ANSI C */
        | parameter.list ',' parameter.declaration
        ;

    /*  There  is  some very subtle disambiguation going on here.  Do 
    not be tempted to make further use of the following production in 
    parameter.list, or else the conflict count will grow  noticeably.  
    Specifically,  the  next  set  of  rules  has already been inline 
    expanded for the first parameter in a parameter.list to support a 
    deferred disambiguation. */
     
parameter.declaration:
        type.name
        | type.name initializer  /* C++, not ANSI C */
        | named.parameter.declaration
        | named.parameter.declaration initializer /* C++, not ANSI C */
        ;

    /* One big thing implemented here is that a TYPEDEFname CANNOT be 
    redeclared when we don't have declaration.specifiers! Notice that 
    when we do use a TYPEDEFname based declarator, only the "special" 
    (non-ambiguous  in  this  context)  typedef.declarator  is  used. 
    Everything else that is "missing" shows up as a type.name. */

named.parameter.declaration: /*have names or storage classes */
        declaration.specifier
        | declaration.specifier abstract.declarator
        | declaration.specifier identifier.declarator
        | declaration.specifier parameter.typedef.declarator

        | declaration.qualifier.list 
        | declaration.qualifier.list abstract.declarator
        | declaration.qualifier.list identifier.declarator
        | type.specifier identifier.declarator
        | type.specifier parameter.typedef.declarator

        | basic.type.name identifier.declarator
        | basic.type.name parameter.typedef.declarator

        | TYPEDEFname identifier.declarator
        | TYPEDEFname parameter.typedef.declarator

        | type.qualifier.list identifier.declarator
        ;
    
identifier.or.typedef.name:
        IDENTIFIER
        | TYPEDEFname 
        ;

type.name:
        type.specifier
        | basic.type.name 
        | TYPEDEFname 
        | type.qualifier.list 

        | type.specifier abstract.declarator
        | basic.type.name abstract.declarator
        | TYPEDEFname abstract.declarator
        | type.qualifier.list abstract.declarator
        ;

initializer.opt:
        /* nothing */
        | initializer
        ;

initializer:
        '=' initializer.group
        ;

initializer.group:        
        '{' initializer.list '}'
        | '{' initializer.list ',' '}'
        | assignment.expression
        ;

initializer.list:
        initializer.group
        | initializer.list ',' initializer.group
        ;


/* STATEMENTS */
statement:
        labeled.statement
        | compound.statement
        | expression.statement
        | selection.statement
        | iteration.statement
        | jump.statement
        ;

labeled.statement:
        identifier.or.typedef.name ':' statement
        | CASE constant.expression ':' statement
        | DEFAULT ':' statement
        ;

    /*  I sneak declarations into statement.list to support C++.  The 
    grammar is a little clumsy this  way,  but  the  violation  of  C 
    syntax is heavily localized */

compound.statement:
        '{' '}'
        | '{' declaration.list '}'
        | '{' statement.list '}'
        | '{' declaration.list statement.list '}'
        ;

declaration.list:
        declaration
        | declaration.list declaration
        ;

statement.list:
        statement
        | statement.list statement
        | statement.list declaration /* C++, not ANSI C */
        ;

expression.statement:
        expression.opt ';'
        ;

selection.statement:
        IF '(' expression ')' statement
        | IF '(' expression ')' statement ELSE statement
        | SWITCH '(' expression ')' statement
        ;

iteration.statement:
        WHILE '(' expression ')' statement
        | DO statement WHILE '(' expression ')' ';'
        | FOR '(' expression.opt ';' expression.opt ';'
                expression.opt ')' statement
        | FOR '(' declaration        expression.opt ';'
                expression.opt ')' statement  /* C++, not ANSI C */
        ;

jump.statement:
        GOTO identifier.or.typedef.name ';'
        | CONTINUE ';'
        | BREAK ';'
        | RETURN expression.opt ';'
        ;


/* EXTERNAL DEFINITIONS */

translation.unit:
        external.definition
        | translation.unit external.definition
        ;

external.definition:
        function.declaration
        | function.definition
        | declaration
        | linkage.specifier function.declaration     /* C++, not ANSI C*/
        | linkage.specifier function.definition      /* C++, not ANSI C*/
        | linkage.specifier declaration              /* C++, not ANSI C*/
        | linkage.specifier '{' translation.unit '}' /* C++, not ANSI C*/
        ;

linkage.specifier:
        EXTERN STRINGliteral
        ;

    /* Note that declaration.specifiers are left out of the following 
    function declarations.  This is something of an anomaly in C, but 
    an  unfortunately  common  coding practice.  It is also sometimes 
    necessary in C++, in instances where no  return  type  should  be 
    specified (e.g., a conversion operator).*/

function.declaration:
        identifier.declarator ';' /* semantically verify it is a function */
        ;
        
function.definition:
        new.function.definition
        | old.function.definition
        | constructor.function.definition
        ;

new.function.definition:
                                     identifier.declarator compound.statement
        | declaration.specifier      identifier.declarator compound.statement
        | type.specifier             identifier.declarator compound.statement
        | basic.type.name            identifier.declarator compound.statement
        | TYPEDEFname                identifier.declarator compound.statement
        | declaration.qualifier.list identifier.declarator compound.statement
        | type.qualifier.list        identifier.declarator compound.statement
        ;

old.function.definition:
                                     old.function.declarator compound.statement 
        | declaration.specifier      old.function.declarator compound.statement
        | type.specifier             old.function.declarator compound.statement
        | basic.type.name            old.function.declarator compound.statement
        | TYPEDEFname                old.function.declarator compound.statement
        | declaration.qualifier.list old.function.declarator compound.statement
        | type.qualifier.list        old.function.declarator compound.statement

        |                            old.function.declarator declaration.list 
                compound.statement
        | declaration.specifier      old.function.declarator declaration.list
                compound.statement
        | type.specifier             old.function.declarator declaration.list
                compound.statement
        | basic.type.name            old.function.declarator declaration.list
                compound.statement
        | TYPEDEFname                old.function.declarator declaration.list
                compound.statement
        | declaration.qualifier.list old.function.declarator declaration.list
                compound.statement
        | type.qualifier.list        old.function.declarator declaration.list
                compound.statement
        ;
    
    /* I needed to add some storage class options to the constructors 
    and  destructors  (e.g.: virtual, inline, ...  ) These were added 
    using declaration.qualifier.list, but they should be semantically 
    verified to be inline or virtual ONLY. If I don't have  to  allow 
    BOTH,  then  I  COULD be explicit (and not increase ambiguities). 
    With this LR(1) grammar, I have to reduce the  list  to  standard 
    declaration.qualifier.list ASAP.*/

destructor.function:
        declaration.qualifier.list '~' TYPEDEFname void.opt.param.list
                        destructor.function.body
        | '~' TYPEDEFname void.opt.param.list destructor.function.body
        ;

void.opt.param.list:
        '('        ')' type.qualifier.list.opt
        | '(' VOID ')' type.qualifier.list.opt
        ;

destructor.function.body:
        compound.statement  /* an actual destructor definition */
        | ';'               /* only a destructor declaration */
        ;

    /*  Semantically  verify that the following identifier.declarator 
    are:
    
        TYPEDEFname :: TYPEDEFname (parameter.type.list).  

    We use the more general form to prevent a clash  with  a  typical 
    function  definition  (which  won't have a constructor.init.list) 
    The ONLY valid declaration qualifier is INLINE. */

constructor.function.definition:
                                     identifier.declarator  
                                constructor.init.list compound.statement
        | declaration.qualifier.list identifier.declarator  
                                constructor.init.list compound.statement
        ;

    /* The following use of declaration.specifiers are made to  allow 
    for  a TYPEDEFname preceded by an INLINE modifier. This fact must 
    be verified semantically.  It should also be  verified  that  the 
    TYPEDEFname  is  ACTUALLY  the  class name being elaborated. Note 
    that we could break out typedef.declaration.specifier from within 
    declaration.specifier, and we  might  narrow  down  the  conflict 
    region a bit. A second alternative (to what is done) for cleaning 
    up  this  stuff  is  to  let the tokenizer specially identify the 
    current class being elaborated as a special token, and not just a 
    typedef.name. Unfortunately, things would get very confusing  for 
    the  lexer,  as  we may pop into enclosed tag elaboration scopes; 
    into function definitions; or into both recursively! */
    
constructor.function.in.class:
        declaration.specifier   constructor.parameter.list.and.body
        | TYPEDEFname           constructor.parameter.list.and.body
        ;

    /* The following conflicts with member declarations-
    constructor.parameter.list.and.body:
          parameter.type.list ';'
          | parameter.type.list constructor.init.list.opt compound.statement
          ;
    so parameter.type.list was expanded inline to get */

constructor.parameter.list.and.body:
          '('                           ')' type.qualifier.list.opt ';'
        | '(' type.name initializer     ')' type.qualifier.list.opt ';' /* C++, not ANSI C */
        | '(' named.parameter.type.list ')' type.qualifier.list.opt ';'
        | '('                           ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement
        | '(' type.name initializer     ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement  /* C++, not ANSI C */
        | '(' named.parameter.type.list ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement
        | constructor.conflicting.parameter.list.and.body
        ;

    /* The following conflicted with member declaration-
    constructor.conflicting.parameter.list.and.body:
        '(' type.name ')'                 type.qualifier.list.opt ';'
        | '(' type.name ')'                 type.qualifier.list.opt
                constructor.init.list.opt compound.statement
        ;
    so type.name was inline expanded to get the following... */

constructor.conflicting.parameter.list.and.body:
        '(' type.specifier ')' type.qualifier.list.opt
                ';'
        | '(' basic.type.name  ')' type.qualifier.list.opt
                ';'
        | '(' TYPEDEFname  ')' 
                ';'
        | '(' TYPEDEFname  ')' type.qualifier.list
                ';'

        | '(' type.qualifier.list  ')' type.qualifier.list.opt
                ';'
        | '(' type.specifier abstract.declarator ')' type.qualifier.list.opt
                ';'
        | '(' basic.type.name abstract.declarator ')' type.qualifier.list.opt
                ';'
        | '(' type.qualifier.list abstract.declarator ')' type.qualifier.list.opt
                ';'

        | '(' type.specifier ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement
        | '(' basic.type.name  ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement
        | '(' TYPEDEFname  ')' 
                constructor.init.list.opt compound.statement
        | '(' TYPEDEFname  ')' type.qualifier.list
                constructor.init.list.opt compound.statement

        | '(' type.qualifier.list  ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement
        | '(' type.specifier abstract.declarator ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement
        | '(' basic.type.name abstract.declarator ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement
        | '(' type.qualifier.list abstract.declarator ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement
        | constructor.conflicting.typedef.declarator
        ;


    /* The following have ambiguities with member declarations-
    constructor.conflicting.typedef.declarator:
      '(' TYPEDEFname abstract.declarator ')' type.qualifier.list.opt
                ';'
      |  '(' TYPEDEFname abstract.declarator ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement
      ;
    which can be deferred by expanding abstract.declarator, and in two 
    cases parameter.qualifier.list, resulting in ...*/

constructor.conflicting.typedef.declarator:
        '(' TYPEDEFname unary.abstract.declarator ')' type.qualifier.list.opt
                ';'
        | '(' TYPEDEFname unary.abstract.declarator ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement

        | '(' TYPEDEFname postfix.abstract.declarator ')' type.qualifier.list.opt
                ';'
        | '(' TYPEDEFname postfix.abstract.declarator ')' type.qualifier.list.opt
                constructor.init.list.opt compound.statement

        | '(' TYPEDEFname postfixing.abstract.declarator ')' type.qualifier.list
                ';'
        | '(' TYPEDEFname postfixing.abstract.declarator ')' type.qualifier.list
                constructor.init.list.opt compound.statement

        | '(' TYPEDEFname postfixing.abstract.declarator ')' 
                ';'
        | '(' TYPEDEFname postfixing.abstract.declarator ')' 
                constructor.init.list.opt compound.statement
        ;


constructor.init.list.opt:
        /* nothing */
        | constructor.init.list
        ;

constructor.init.list:
        ':' constructor.init
        | constructor.init.list ',' constructor.init
        ;

constructor.init:
        identifier.or.typedef.name   '(' argument.expression.list ')'
        | identifier.or.typedef.name '('                          ')'
        | '(' argument.expression.list ')' /* Single inheritance ONLY*/
        | '(' ')' /* Is this legal? It might be default! */
        ;        

declarator:
        typedef.declarator
        | identifier.declarator
        ;
        
typedef.declarator:
        paren.typedef.declarator  /* would be ambiguous as parameter*/
        | simple.paren.typedef.declarator /* also ambiguous */
        | parameter.typedef.declarator   /* not ambiguous as param*/
        ;

parameter.typedef.declarator:
        TYPEDEFname
        | TYPEDEFname postfixing.abstract.declarator
        | clean.typedef.declarator
        ;

    /* The following have at  least  one  '*'or  '&'.   There  is  no 
    (redundant) '(' between the '*'/'&' and the TYPEDEFname. */
    
clean.typedef.declarator:
        clean.postfix.typedef.declarator
        | indirect.or.reference parameter.typedef.declarator
        | pointer.operator      parameter.typedef.declarator  
        ;

clean.postfix.typedef.declarator:
        '(' clean.typedef.declarator ')'
        | '(' clean.typedef.declarator ')' postfixing.abstract.declarator
        ;

    /*  The  following have a redundant '(' placed immediately to the 
    left of the TYPEDEFname */
    
paren.typedef.declarator:
        paren.postfix.typedef.declarator
        | indirect.or.reference '(' simple.paren.typedef.declarator ')'
        | pointer.operator      '(' simple.paren.typedef.declarator ')'
        | indirect.or.reference '(' TYPEDEFname ')' /* redundant paren */
        | pointer.operator      '(' TYPEDEFname ')' /* redundant paren */
        | indirect.or.reference paren.typedef.declarator
        | pointer.operator      paren.typedef.declarator
        ;
        
paren.postfix.typedef.declarator:
        '(' paren.typedef.declarator ')'
        | '(' simple.paren.typedef.declarator postfixing.abstract.declarator ')' 
        | '(' TYPEDEFname postfixing.abstract.declarator ')' /* redundant paren */
        | '(' paren.typedef.declarator ')' postfixing.abstract.declarator
        ;

    /* The following excludes lone TYPEDEFname to help in a  conflict 
    resolution.   We  have  special cased lone TYPEDEFname along side 
    all uses */
    
simple.paren.typedef.declarator:
        '(' TYPEDEFname ')'
        | '(' simple.paren.typedef.declarator ')'
        ;

identifier.declarator:
        unary.identifier.declarator  
        | paren.identifier.declarator
        ;

    /* The following allows "function return array  of"  as  well  as 
    "array  of  function  returning".  It COULD be cleaned up the way 
    abstract declarators have been.  This change might make  it  hard 
    to  recover from user's syntax errors, whereas now they appear as 
    simple semantic errors. */

unary.identifier.declarator:
        postfix.identifier.declarator
        | indirect.or.reference identifier.declarator
        | pointer.operator      identifier.declarator
        ;

postfix.identifier.declarator:
        paren.identifier.declarator postfixing.abstract.declarator
        | '(' unary.identifier.declarator ')'
        | '(' unary.identifier.declarator ')' postfixing.abstract.declarator
        ;

old.function.declarator:
        postfix.old.function.declarator
        | indirect.or.reference old.function.declarator
        | pointer.operator      old.function.declarator
        ;

    /* ANSI C section 3.7.1  states  "An  identifier  declared  as  a 
    typedef  name shall not be redeclared as a parameter".  Hence the 
    following is based only on IDENTIFIERs.
    
    Instead of identifier.lists, an argument.expression.list is  used 
    in   old   style   function   definitions.   The  ambiguity  with 
    constructors required the use of argument lists, with a  semantic 
    verification   of   the   list  (e.g.:  check  to  see  that  the 
    "expressions" consisted of lone identifiers).  
    
    An interesting ambiguity appeared:
        const constant=5;
        int foo(constant) ...

    Is this an old function definition or constructor?  The  decision 
    is made later by THIS grammar based on trailing context :-). This 
    ambiguity  is probably what caused many parsers to give up on old 
    style function definitions. */

postfix.old.function.declarator:
        paren.identifier.declarator '(' argument.expression.list ')'
        | '(' old.function.declarator ')'
        | '(' old.function.declarator ')' old.postfixing.abstract.declarator
        ;

old.postfixing.abstract.declarator:
        array.abstract.declarator /* array modifiers */
        | old.parameter.type.list  /* function returning modifiers */
        ;

abstract.declarator:
        unary.abstract.declarator
        | postfix.abstract.declarator
        | postfixing.abstract.declarator
        ;

postfixing.abstract.declarator:
        array.abstract.declarator
        | parameter.type.list
        ;

array.abstract.declarator:
        '[' ']'
        | '[' constant.expression ']'
        | array.abstract.declarator '[' constant.expression ']'
        ;

unary.abstract.declarator:
        indirect.or.reference 
        | pointer.operator 
        | indirect.or.reference abstract.declarator
        | pointer.operator      abstract.declarator
        ;

postfix.abstract.declarator:
        '(' unary.abstract.declarator ')'
        | '(' postfix.abstract.declarator ')'
        | '(' postfixing.abstract.declarator ')'
        | '(' unary.abstract.declarator ')' postfixing.abstract.declarator
        ;

indirect.or.reference:
        '*'
        | '&'
        ;

pointer.operator:
        TYPEDEFname CLCL '*' type.qualifier.list.opt
        | indirect.or.reference type.qualifier.list
        ;
%%
yyerror(string)
char*string;
{
    printf("parser error: %s\n", string);
}


main()
{
    yyparse();
}
@@


1.3
log
@@*** empty log message ***
@@
text
@@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/RCS/cpp4.y,v`; if test $1 -ne 64188
then
	echo ERROR: oxDistG1.04/grammars/c++/RCS/cpp4.y,v checksum is $1 should be 64188
fi
set `wc -lwc <oxDistG1.04/grammars/c++/RCS/cpp4.y,v`
if test $1$2$3 != 1895718471409
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/RCS/cpp4.y,v are $* should be 1895 7184 71409
fi

chmod 755 oxDistG1.04/grammars/c++/RCS/cpp4.y,v

if test -f oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v
	if test -f oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v
sed 's/^@//' >oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v <<'@EOF'
head     1.4;
access   ;
symbols  ;
locks    bischoff:1.4; strict;
comment  @# @;


1.4
date     93.10.31.15.52.14;  author bischoff;  state Exp;
branches ;
next     1.3;

1.3
date     93.10.24.21.37.52;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.16.27.22;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.02.26;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@unpacked original from comp.compilers archive
@@


1.4
log
@@*** empty log message ***
@@
text
@@FILENAME: FREEGRAM4.TXT
AUTHOR: Jim Roskind
        Independent Consultant
        516 Latania Palm Drive
        Indialantic FL 32903
        (407)729-4348
        jar@@ileaf.com
        or ...uunet!leafusa!jar
        

                                                        6/6/90

Dear C++ and C Grammar User,

I have written a YACC debugging tool, and a set of grammars for C and 
C++ in order to use them within my own personal project  development.  
I  have made my work in this area available to other developers at no 
charge with the hope that they would use  my  work.   I  believe  the 
entire  C++  community can benefit from such standardization.  If any 
of the copyright notices on the grammars  (which  are  VERY  liberal) 
prevent using my work, please notify me of the problem.

Note  that  the  grammars can each be processed by YACC, but they are 
very clean, and make NO USE of the precedence setting  (i.e.:  %prec) 
or  associativity  setting  (i.e.:%assoc)  constructs  of YACC.  This 
feature should make them easily portable to  other  parser  generator 
input  format.  This "cleanliness" fact also provides brutal exposure 
of all the complex constructs in  C++,  and  the  complexity  of  the 
grammar as a whole (the C++ grammar is 2 to 3 times as large as the C 
grammar) reflects this exposure.

The files included in this set are:

    FREEGRM4.TXT    This introductory file
    GRAMMAR4.TXT    Parsing ambiguities in C++, and in my grammar
    CPP4.Y          My YACC compatible C++ grammar
    C4.Y            My YACC compatible, ANSI C conformant grammar
    CPP4.L          Flex input file defining a C++ lexical analyser
    SKELGRPH.C      A hacked file from the Berkeley YACC distribution.

Aside from the addition of several files, this release of my  grammar 
corrects  a  few  problems located in my prior release.  This release 
will hopefully conclude compliance with C++  2.0,  and  allow  me  to 
release a C++ 2.1 compliant grammar (re: nested types).

Since my first public release of my grammar, I have received a number 
of requests.  One of the most  common  requests  was  for  a  lexical 
analyser  to  go  with  the  grammar.   This  release  of the grammar 
provides such a a "bare bones" lexical analyser.  The  analyser  does 
not  support  preprocessing,  or  even comment removal.  In addition, 
since I have not included a symbol table, or semantic actions in  the 
grammar  to  maintain  proper  context (i.e., current scope), typedef 
names and struct/class/union/enum tags are not *really* defined.   To 
allow  users to experiment with my grammar without a symbol table, my 
lexer assumes that if the first letter of the  name  is  upper  case, 
then  then name is a type name.  This hack is far from sufficient for 
parsing full blown programs, but  it  is  more  than  sufficient  for 
experimenting  with  the  grammar to determine the acceptability of a 
token sequence, and to understand how my grammar parsed the sequence.

Since I did not believe  that  a  lexical  analyser  alone  would  be 
sufficient to assist many people with playing with my grammar, I have 
also provided the basis for a tool  to  explain  what  a  grammar  is 
doing.   Specifically, I have modified a file that is included in the 
Berkeley YACC distribution so that parsers generated by such  a  YACC 
would  automatically  display a syntax tree in graphical-ASCII format 
during a parse.  The instructions for using and  building  this  yacc 
tool  are  presented  in  the  next  section.  Note that there are no 
significant special hooks in my grammar or parser to excite this yacc 
tool,  and  the tool can be used equally well on any grammar that you 
are working with.

I have posted all 6 files to comp.lang.c++, to make this  information 
as  available  as possible to users and developers.  I will also post 
this introductory note to  comp.compilers,  and  comp.lang.c.   I  am 
arranging  for  archival  support  via several ftp sites, and updates 
will be posted to those sites.  I will also try to get the source  to 
Berkeley  YACC  posted  to  these ftp sites, although it is certainly 
available at more central sites.


HOW TO USE THE DISTRIBUTION FILES TO PLAY WITH THE C++ GRAMMAR

Note that  the  following  instructions  assume  that  you  have  the 
Berkeley  YACC  source  on  hand.   You  can actually use any YACC to 
process the grammar, but running the resulting  demo  (which  has  no 
semantic  actions)  will  tend  to be quite boring.  If you can't get 
hold of the Berkeley YACC, you should at  least  try  to  enable  the 
"debugging options" in your parser to so that you can see in some way 
what reductions are taking  place.  (Hint:  search  for  the  letters 
"debug" in the C file that your yacc produces...).

        1) Get the entire source for Berkeley YACC 1.4 2/25/90
        2) Verify that you can make the YACC
        3) Rename SKELETON.C to SKELOLD.C, and implant my SKELGRPH.C
                in that directory as SKELETON.C
        4) Make the yacc using this new SKELETON.C
        5) Using the above yacc, process my CPP4.Y file
                yacc -dvl cpp4.y
           The result should be a file y.tab.c, and y.tab.h
        6) Using Flex (replacement for lex) process my CPP4.L file
                flex cpp4.l
           the result should be yy.lex.c
        7) Compile the two files
                cc -o cpp4  y.tab.c yy.lex.c
           the result should be an executable called cpp4
        8) Set the environment variable YYDEBUG to 6
                setenv YYDEBUG 6
           If you don't do this, the graphical output will not appear!
        9) Run the program cpp4
                cpp4
        10) Try the input:
                int a;
        11) You should see a nice parse tree.  Enjoy.  Note that
            the lexer DOES NOT INCLUDE A SYMBOL TABLE, and does
            NOT KEEP TRACK OF CURRENT SCOPES.  The hack (see the
            CPP4.L file for details) is to assume that any identifier
            that begins with a capital letter is a typedef name
            Send complaints about code that doesn't parse "correctly".


INTRODUCTION TO 3/3/90 Version of my release

In   light   of   the   recent  debate  on  comp.lang.c++  about  the 
"impossibility" of generating a YACC grammar for  C++  (that  doesn't 
also  accept  every  possible  string  of  tokens),  providing  these 
grammars at this point is especially nice.   Rather  than  addressing 
each of the ad hoc arguments that such an endeavor is impossible (the 
least convincing  of  which  said  effectively:  "...  heard  it  was 
impossible,  ...  something  about LALR ...", and the most correct of 
which said: "...it is not possible to create a  simple  YACC  grammar 
for  C++.."),  I  am  offering  my  grammars  as  my  rather complete 
commentary on the topic. (I'll probably get some flaming due to  this 
comment,  but  I had to read all the stuff that was posted, that told 
me what I had done was impossible. ;-) ) My general feeling  is  that 
it  is  a  shame  for  opinions  to  be  confused with facts, and for 
impossibility to be confused with difficulty or complexity.

Developing the C grammar (that is intended to be compatible with  the 
ANSI C standard) was relatively straight forward (compared to the C++ 
grammar).  The one difficulty in this process was the desire to avoid 
use  of  %prec  and  %assoc  constructs  in YACC, which would tend to 
obscure ambiguities.  Since I didn't know what ambiguities were lying 
in  wait  in  C++,  obscuring  ambiguities was unacceptable.  It took 
several weeks to remove the conflicts that typically appear, and  the 
tedious  process  exposed  several ambiguities that are not currently 
disambiguated by the ANSI standard.  The quality of the C grammar  is 
(IMHO)  dramatically  higher than what has been made available within 
the  public  domain.   Specifically,  a  C   grammar's   support   of 
redefinition of typedef names within inner scopes (the most difficult 
area of  the  grammar)  is  typically  excluded  from  public  domain 
grammar,  and  even  excluded  from  most  grammars that are supplied 
commercially with parser generators!  I expect that this grammar will 
be very useful in the development of C related tools.

The development of the C++ grammar (initially compatible with version 
1.2, but enhanced to support version 2.0 specifications as they  were 
made  available)  was anything but straight forward.  The requirement 
that I set to NOT USE %prec and %assoc proved both a blessing  and  a 
curse.   The  blessing was that I could see what the problems were in 
the language, the curse was that there were A LOT of conflicts (I can 
recall  times  during  the  development  effort  when  the  number of 
conflicts was well in excess of 200).  Initially I was  unaware  that 
many  other  attempts  had  been  made  and  failed, and I went ahead 
"blindly" trying to resolve  the  conflicts  in  my  grammar.   After 
raising  the  issues  that I noticed with Bjarne Stroustrup, I became 
aware that there were some very significant  syntactical  ambiguities 
within  the  current  C++ language.  Fortunately, by the time I first 
spoke to Dr. Stroustrup, I had  already  derived  some  results  that 
other  attempts  had  not  uncovered.   Encouraged  by  my results, I 
continued on despite hearing ever louder  claims  that  my  goal  was 
"impossible".

Towards  the  end  of  the development of the C++ grammar, which took 
roughly 3 months of my time, I began to see the folly in part  of  my 
quest.   I  came to the conclusion that further attempts to modify my 
grammar, so as to defer resolutions of ambiguities, would lead to  an 
unreadable language. Specifically, my feeling was that I was entering 
into a battle of  wits  with  the  compiler,  and  the  compiler  was 
starting  to  win.   It  was beginning to be the case that the parser 
COULD figure out what I said, but I couldn't.  Indeed, even  examples 
in  a  version  of  the  C++  2.0  reference manual demonstrated this 
problem (my parser could parse some examples that neither I  nor  the 
authors parsed correctly!).  At this point I decided to stop my quest 
to FURTHER defer resolutions of  ambiguities,  and  let  the  grammar 
commit  in  one  direction  (always in favor of declarations), at the 
late point that is provided by my grammar.  If this direction  proved 
"incorrect in light of the context that followed", then I generated a 
syntax error.  I  believe  this  strategy  provides  ample  room  for 
expressiveness.  In  support of this expressiveness, I have (based on 
my discussions with language  experts)  deferred  disambiguation  far 
longer  than  other  attempts at producing an LR(1) grammar.  I would 
strongly argue that any code that my grammar identifies as  having  a 
"syntax  error"  (based  on  "premature"  disambiguation), but cfront 
allows, should ABSOLUTELY be rewritten in a less ambiguous (and hence 
more portable) form.  As a final comment, by virtue of the consistent 
methodology used to build my grammar, there are a number  of  clearly 
unambiguous  constructs  that  my  grammar  CAN parse, and cfront 2.0 
cannot (not to mention recent versions of GNU's G++ and Zortech's C++ 
compiler).

One  major  motivation for using the C++ grammar that I have provided 
is that it is capable of supporting old  style  function  definitions 
(e.g.:  main(argc,  argv)  int  argc;  char*argv[];  {...}  ).  To my 
knowledge, no other C++ parser is currently capable of this  feat.  I 
believe  this  capability  was  removed from the C++ specification in 
order to reduce ambiguities in a specific implementation (cfront). As 
my  grammar  demonstrates,  this action was not necessary. Supporting 
old style function definition GREATLY eases the transition to the use 
of  C++  from  traditional C.  I expect that as some parsers begin to 
support this option, that other parsing engines  will  be  forced  in 
this  direction  by a competitive marketplace.  Using my grammar, and 
the standards it  implies,  appears  to  be  a  very  straightforward 
approach to this support.

A  second motivation for using my grammar is that it can be processed 
by YACC.  The advantage in this fact lies with YACC's  capability  to 
identify  ambiguities.   For  software manufacturers that are heavily 
concerned with correctness, this  is  an  INCREDIBLE  advantage.   My 
experience  with  hand  written  parsers  (which  usually represent a 
translation by a fallible human from a grammar to  parsing  code)  is 
that  they evolve and become more correct with time.  Ambiguous cases 
are often misparsed, without the author ever realizing  there  was  a 
conflict!  In  contrast,  either  a  YACC  grammar  supports  a given 
construct, or it doesn't.  If a YACC grammar  supports  a  construct, 
the  semantic interpretation is usually rather straight forward.  The 
likelihood  of  internal  errors   in   the   parser   is   therefore 
SIGNIFICANTLY  reduced. The fact the the grammars I supplied are free 
of %assoc  and  %prec  operators,  implies  the  grammar  are  fairly 
portable,  and  the  conflicts  are open to peer code review (and not 
obscured).

If you find any errors in my grammars, I would be DELIGHTED  to  hear 
mention  of  them!!!!   These  should  fall into one of the following 
categories:

        1) The grammar left out the following features of C++...
        or
        2) The grammar mis-parses the following sequences...
        or
        3) The discussion of the following ambiguity is
        incorrect...
        4) The grammar could be simplified as follows...

Please send correspondence of this form to jar@@ileaf.com. My response 
to  1's  will  be  to add the feature (if possible!); feel sad that I 
made a mistake; and feel glad that YOU  found  it.   I  will  have  a 
similar  response  to  2's.   Responses  of  type  3 are GREAT, but I 
haven't found many folks that really get into YACC ambiguities, so  I 
have  low expectations... feel free to surprise me!!! :-) :-).  Items 
of type 3 are interesting, but since simplicity is in the eye of  the 
beholder,  such  suggestions  are  subject  to  debate.   I  would be 
interested in seeing suggestions in this  area  with  the  constraint 
that  they  do  not  increase the number of conflicts in the grammar!  
Please use YACC to check your suggestions before submitting them. (It 
is  often  AMAZING how the slightest change in the grammar can change 
the number of conflicts, and it took a great deal of  work  to  reach 
the current state). Distribution site(s) will be set up to distribute 
updates  and  or  corrections.   Postings  about  the   presence   of 
corrections will be made on the net.

Since  the  two  grammars (C and C++) were generated in parallel, you 
should  be  able  to  compare  non-terminals  directly.   This   will 
hopefully  make  it easier to identify the complexities involved with 
the C++ grammar, and "ignore" those that result from standard ANSI C. 
In  both  cases I have left the standard if-if-else ambiguity intact. 
In the case of ANSI C grammar, this is the only shift-reduce conflict 
in  the grammar.  Although there are a number of conflicts in the C++ 
grammar, there are actually very few classes of problems. In order to 
disambiguate  the C++ grammar enough that YACC can figure out what to 
do, I was commonly forced to "inline expand" non-terminals  found  in 
the  C  grammar.  This expansion allowed YACC to defer disambiguation 
until it was possible for an LR(1) parser to understand the  context. 
The  unfortunate  consequence  of  this  inline  expansion is a large 
growth in the number of rules,  and  the  presence  of  an  effective 
"multiplier" in most cases where conflicts do occur. As a result, any 
conflicts that arise are multiplied by a factor corresponding to  the 
number  of  rules  I  had to list separately.  I have grouped the C++ 
grammar conflicts in the "Status" section of the  GRAMMAR.TXT  paper, 
but  you  are  welcome to explore my grammars using YACC directly (be 
warned that you will need a robust version of YACC to handle the  C++ 
sized  grammar).  PLEASE do not be put off by the number of conflicts 
in the C++ grammar.  There are VERY FEW CONFLICTS, but my  elaborated 
grammar confuses the count.

The  GRAMMAR4.TXT  paper is FAR from a publishable quality paper, but 
it discusses many  of  the  issues  involved  in  ambiguities  in  my 
grammar,  and more generally in the C++ language. I hope GRAMMAR4.TXT 
it is a vast improvement over "nothing  at  all",  but  apologize  in 
advance  for  lack  of  polished  structure, and the presence of many 
typos  (which  must  surely  be  present).  I  hope  you  find   this 
almost-paper  interesting.  My attempts at documenting conflicts have 
certainly clarified the problems in my mind. Based on  my  experience 
with  the  conflicts  I  have  identified, most current compilers and 
translator fall prey to the situations that I have uncovered.  I hope 
that other compilers, that do not make use of the grammar I have made 
available, will at least seek to standardize the  resolution  of  the 
problems identified.

As  a  small commercial message... I am a freelance consultant, and I 
travel far and wide to perform contracts.  If you like the work  that 
I  am  presenting in this group of documents, and would like to see a 
resume or at least talk, please feel free to contact me.

I hope that the grammars that I have  provided,  will  lead  to  many 
successful C++ processing projects.

Jim Roskind
Independent Consultant
516 Latania Palm Drive
Indialantic FL 32903
(407)729-4348
jar@@ileaf.com
or ...!uunet!leafusa!jar

@@


1.3
log
@@*** empty log message ***
@@
text
@@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v`; if test $1 -ne 32308
then
	echo ERROR: oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v checksum is $1 should be 32308
fi
set `wc -lwc <oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v`
if test $1$2$3 != 378285318446
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v are $* should be 378 2853 18446
fi

chmod 755 oxDistG1.04/grammars/c++/RCS/freegrm4.txt,v

if test -f oxDistG1.04/grammars/c++/RCS/grammar4.txt,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/RCS/grammar4.txt,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/RCS/grammar4.txt,v
	if test -f oxDistG1.04/grammars/c++/RCS/grammar4.txt,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/RCS/grammar4.txt,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/RCS/grammar4.txt,v
sed 's/^@//' >oxDistG1.04/grammars/c++/RCS/grammar4.txt,v <<'@EOF'
head     1.4;
access   ;
symbols  ;
locks    bischoff:1.4; strict;
comment  @# @;


1.4
date     93.10.31.15.52.17;  author bischoff;  state Exp;
branches ;
next     1.3;

1.3
date     93.10.24.21.57.24;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.16.27.32;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.02.49;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@unpacked original from comp.compilers archive
@@


1.4
log
@@*** empty log message ***
@@
text
@@Copyright (C) 1989.1990, James  A.   Roskind,  All  rights  reserved. 
Abstracting  with credit is permitted.  The contents of this file may 
be reproduced electronically, or in printed  form,  IN  ITS  ENTIRETY 
with  no  changes, providing that this copyright notice is intact and 
applicable in the copy.  No other copying is  permitted  without  the 
expressed written consent of the author.

FILENAME: GRAMMAR4.TXT
AUTHOR: Jim Roskind
        Independent Consultant
        516 Latania Palm Drive
        Indialantic FL 32903
        (407)729-4348
        jar@@ileaf.com
        or ...!uunet!leafusa!jar


    A YACC-able C++ 2.0 GRAMMAR, AND THE RESULTING AMBIGUITIES
                                        (Release 1.1 Updated 6/90)

ABSTRACT

This  paper describes ambiguous aspects of the C++ language that have 
been exposed by the construction of a YACC-able grammar for C++.  The 
grammar  is  provided  in  a  separate  file, but there are extensive 
references to the actual grammar.  In light of the fact that not  all 
readers  will have access to a YACC capable of processing my grammar, 
I have also included (in an appendix) a significant excerpt from  the 
verbose output of running YACC on my grammar.

This  release  of  the grammars is provided to add some final touches 
identified by the many users that picked up my  original  posting  in 
3/90.   As with my first posting, nested types have been omitted from 
this release of the grammar.   The  decision  to  incorporate  nested 
types into the C++ language was only clarified with AT&T's release of 
version 2.1 of C++.  Since the addition of nested  types  appears  to 
notably  complicate  the  interaction required between the parser and 
the lexer, it seemed appropriate to release an update to the  grammar 
that  tries  to  correct  all  known  deficiencies  found in my first 
release.  A future release should incorporate all enhancements needed 
for nested types.

Theoretical  Note  (skip if you hate theory): My C++ grammar does not 
make use of the %prec or %assoc features of YACC, and hence conflicts 
are  never hidden within my grammar.  The wondrous result is that, to 
the extent to which my grammar can be seen to span the syntax of  the 
language,  in all places where YACC reports no conflicts, the grammar 
is a totally unambiguous statement of the  syntax  of  the  language.  
This  result  is  remarkable (I think), because the "general case" of 
deciding whether a grammar is ambiguous or not, is equivalent to (the 
unsolvable) halting problem.

Although  this  paper  is  terse,  and  perhaps  poorly  (or at least 
hastily) formed, I believe that its content is so significant  to  my 
results  that  it  had to be included.  I am sorry that I do not have 
the time at this point to better arrange its contents.


CONTENTS
        
        INTRODUCTION
        REVIEW: STANDARD LEXICAL ANALYSIS HACK: TYPEDEFname VS IDENTIFIER
        STATUS OF MY "DISAMBIGUATED" GRAMMAR
        18 EASY CONFLICTS, WITH HAPPY ENDINGS
        2 REDUCTION CONFLICTS WITH STRAIGHT FORWARD DISAMBIGUATION
        3 NOVEL CONFLICT THAT YIELD TO SEMANTIC DISAMBIGUATION
        THE TOUGH AMBIGUITIES: FUNCTION LIKE CASTS AND COMPANY
        SAMPLE RESOLUTIONS OF AMBIGUITIES BY MY C++ GRAMMAR
        DIFFICULT AMBIGUITIES FOR C++ 2.0 PARSER TO TRY
        COMMENTARY ON CURRENT C++ DISAMBIGUATING RULES
        SOURCE OF CONFLICTS IN C++ (MIXING TYPES AND EXPRESSIONS)
        FUNCTION LIKE CAST vs DECLARATION : THE TOUGH EXAMPLE
        CONCLUSION

        APPENDIX A:
            PROPOSED GRAMMAR MODIFICATIONS (fixing '*', '&' and ':'
                                        conflicts)
        APPENDIX B:
            AMBIGUITIES IN MY C++ GRAMMAR AS LISTED BY YACC VERBOSE OPTION


        APPENDIX C:
            ADVANCED TUTORIAL ON YACC CONFLICTS

INTRODUCTION

This paper is intended  to  go  into  significant  detail  about  the 
ambiguities  that I have seen in the C++ 2.0 language, and exposed by 
attempting to develop a YACC compatible (i.e., LALR(1))  grammar.   I 
must point out that this is NOT meant as an attack on the language or 
the originators thereof, but rather an  R&D  effort  to  disambiguate 
some  details.  (I  personally  believe that Stroustrup et.  al.  are 
doing a GREAT job).  I have the vague hope that the extensive hacking 
that  I  have done with YACC on the C++ grammar has given me a rather 
novel vantage point. (I have  expressed  my  observations  to  Bjarne 
Stroustrup,  and  in  doing  so  verified  that  other  folks had not 
previously  identified  several  of  my  points).   In  light  of  my 
activities,  this  paper  includes a fair amount of philosophizing. I 
hope that none of this paper assumes too greatly that I have  insight 
that  is  beyond  that  of  the readers, and certainly no insults are 
intended.

If you like investigating grammars directly (rather than reading what 
I  have to say), I would strongly suggest you read the ANSI C grammar 
before looking at the C++ grammar.  The C++ grammar is pretty  large, 
and  you can expect the following stats if you have a similar YACC to 
that I am using:

Berkeley YACC (1.4 2/25/90):

25 shift/reduce conflicts, 7 reduce/reduce conflicts.
103 terminals, 161 nonterminals
609 grammar rules, 1157 states


AT&T YACC (with large table sizes):

123/127 terminals, 160/200 nonterminals
609/650 grammar rules, 1157/1200 states
25 shift/reduce, 7 reduce/reduce conflicts reported
243/350 working sets used
memory: states,etc. 13727/60000, parser 10871/12000
495/600 distinct lookahead sets
756 extra closures
7300 shift entries, 25 exceptions
1797 goto entries
4731 entries saved by goto default
Optimizer space used: input 18036/60000, output 8092/12000
8092 table entries, 3568 zero
maximum spread: 351, maximum offset: 1148



REVIEW: STANDARD LEXICAL ANALYSIS HACK: TYPEDEFname VS IDENTIFIER

This section is targeted  at  readers  that  are  not  familiar  with 
parsing  C  with a context free grammar.  The reader should note that 
there are two distinct forms of `identifiers' gathered during lexical 
analysis,  and  identified as terminal tokens in both of my grammars.  
The  terminal  tokens   are   called   IDENTIFIER   and   TYPEDEFname 
respectively. This distinction is a required by a fundamental element 
of the C language.  The definition of a  "TYPEDEFname"  is  a  lexeme 
that  looks  like  a standard identifier, but is currently defined in 
the symbol table as being declared a typedef (or class, struct,  enum 
tag)  name. All other lexemes that appear as identifiers (and are not 
keywords) are  tokenized  as  IDENTIFIERs.   The  remainder  of  this 
section will review the motivation for this approach.

Consider the following sample code, which uses the C language:

        ...
        int main() { f (*a) [4] ; ...

Most  reader  will intuitively parse the above sequence as a function 
call to "f", with an argument "*a", the  return  value  of  which  is 
(probably)  a  pointer,  and  hence  can  be indexed by "4".  Such an 
interpretation presumes that the prior context was something like:

        ...
        extern float *a;
        char * f(float);
        int main() { f (*a) [4] ; ...

However, if the prior context was **INSTEAD**:

        ...
        typedef int f;
        extern float a;
        int main() { f (*a) [4] ; ...

then the interpretation of  the  code  is  entirely  different.   The 
fragment  in  question actually redeclares a local variable "a", such 
that the type of "a" is "pointer to array of 4 int's"!  So we see  in 
this   example  that  the  statement  "f(*a)[4];"  cannot  be  parsed 
independent of context.

The standard solution to the above ambiguity is to allow the  lexical 
analyser  to  form  different tokens based on contextual information. 
The contextual  information  that  is  used  is  the  answer  to  the 
question:  "Is a given identifier defined as a typedef name (or class 
name) at the current point in the  parse"?   I  will  refer  to  this 
feedback  loop  (from  the parser that stores information in a symbol 
table, wherein the lexer extracts the information) as the "lex hack".  
With  this  lex  hack in place the code fragment "f(*a)[4];" would be 
provided by the lexer as either:

        IDENTIFIER '(' '*' IDENTIFIER ')' '[' INTEGERconstant ']' ';'

or

        TYPEDEFname '(' '*' IDENTIFIER ')' '[' INTEGERconstant ']' ';'

The two case are very easy for a context free grammar to distinguish, 
and  the  ambiguity vanishes.  Note that the fact that such a hack is 
used (out of necessity) demonstrates that C is  not  a  context  free 
language,  but the hack allows us to continue to use an LR(1) parser, 
and a context free grammar.

Note that this hack is, of necessity, also made use  of  in  the  C++ 
grammar,  but no additional feedback (a.k.a.: hack) is required.  The 
interested reader should also  note  that  this  feedback  loop  (re: 
updating  the  symbol  table)  must be swift, as the lexical analyser 
cannot proceed very far without this  contextual  information.   This 
constraint  on  the  feedback  time  often  prevents  the parser from 
"deferring" actions, and hence increases the pressure on  the  parser 
to rapidly disambiguate token sequences.

(Although  this  version  of  the C++ grammar does not support nested 
types, the advanced reader is encouraged to consider their impact  on 
the  above problem.  Specifically, code fragments such as "T::f" must 
syntactically distinguish themselves as either typenames, or members.  
Problems in this area can be expected to stress the above hack almost 
to its breaking point.   The  resolution  to  this  problem  will  be 
discussed in the next release of the grammar,... so stay tuned.).


STATUS OF MY "DISAMBIGUATED" GRAMMAR

My  grammar  is  now  fairly  complete.  Several independent reviews, 
which provided a front end lexical analyser and parsed  existing  C++ 
code,  have  verified  that  the  grammars  span  of the C++ language 
appears complete.  I  have  not  incorporated  parametric  types  nor 
exception  handling into the grammars at this point, as they continue 
to be in a state of flux.

The grammar does (I believe) support all the features provided in C++ 
2.0,  including  multiple inheritance and the enhanced operator "new" 
syntax (includes placement expression). I believe  that,  except  for 
the  minor  change  involving  not  permitting parentheses around bit 
field names during a declaration, my C++ grammar supports a  superset 
of  my  ANSI  C  grammar. Note that I haven't inline expanded all the 
rules in the C grammar that were required for C++ disambiguation (re: 
deferring  reductions),  and  hence a `diff' of the two grammars will 
not provide a trivial comparison.  The resulting major  advantage  of 
this  grammar over every other current C++ parser (that I know of) is 
that it supports old style function definitions AS WELL  AS  all  the 
standard  C++.   (It  is  my  personal  belief  that such support was 
dropped by many compilers and translators in  order  to  resolve  the 
many  syntax problems that appear within C++.  I believe this grammar 
shows that such a decision was premature).

My list of shift-reduce and reduce-reduce conflicts is currently:  25 
shift/reduce,  7  reduce/reduce conflicts reported.  I have chosen to 
leave so many conflicts in the grammar because I hope to see  changes 
to the syntax that will remove them, rather than making changes to my 
grammar that will firmly accept and disambiguate  them.  (Considering 
the  detailed  analysis  presented  here, such changes would only add 
unnecessary complications to the grammar).

8 SR caused by operator function name with trailing * or &
8 SR caused by freestore              with trailing * or &
1 SR caused by operator function name OR freestore, with trailing :
1 SR caused by dangling else and my laziness

1 SR and 1 RR caused by operator function name and trailing {

3 SR caused by constructor declaration vs member declaration

3 RR caused by function-like cast vs identifier declaration ambiguity
3 RR caused by function-like cast vs typedef redeclaration ambiguity
3 SR caused by redundant parened TYPEDEFname redeclaration vs old style cast


Of these conflicts, the ones that most C++ parser authors are  mainly 
concerned    with   are   the   last   9   conflicts,   relating   to 
function-like-cast vs declaration, and redundant parened  TYPEDEFname 
redeclaration  vs  old  style  cast.   The  following sections breeze 
through the "easy" conflicts, and then talk at  length  about  the  9 
tough ones.


18 EASY CONFLICTS, WITH HAPPY ENDINGS

The first group of 18 SR conflicts:

8 SR caused by operator function name with trailing * or &
8 SR caused by freestore              with trailing * or &
1 SR caused by operator function name OR freestore, with trailing :
1 SR caused by dangling else and my laziness

have very simple resolutions.  If you are reading this, I assume that 
you are already familiar with the if-if-else conflict.

The trailing ':' has to do with the use of the  colon  in  a  ternary 
"... ? ... : ..." expression.  The easiest example is:

        void * p = boolean ? new struct S : ...

The  problem  is  that this MIGHT be the first mention of "struct S", 
and this MIGHT be where the elaboration of the structure is provided!  
Under  such circumstances, what follows the ':' MIGHT be a base class 
name, and the entire curly braced elaboration for S (ugh!).

My resolution of this SR conflict is that "the longest possible  type 
is constructed by the parser".  Hence the ':' is construed to be part 
of the type "struct S".  This is in keeping with the subtle statement 
on  in  section  7.1 of the C++ 2.0 Ref Man: "The longest sequence of 
decl-specifier that could possibly be a type name  is  taken  as  the 
decl-specifiers of a declaration".


The  8 conflicts based "freestore with trailing * or &" can be hinted 
at by the example:

        a = new int * * object;

Is the above the same as:

        a = (new int) * (* T);
or:
        a = (new (int *)) * T;

Again the "longest possible type" is isolated  by  my  grammar.   The 
result is:

        a = (new (int * * )) ...

which  leads  to  a  syntax  error in my example!  This resolution is 
indeed what is quietly specified for  C++  2.0  (and  implemented  in 
cfront).   The  critical statement and example in the C++ 2.0 Ref Man 
at the end of section 5.3.3 makes this resolution clear.

The 8 conflicts involving "operator function names with trailing * or 
&"  are  quite similar to what was just presented.  The critical fact 
is that "operator typename" is allowed in the  grammar  to  define  a 
function.   Whenever  a  function  is provided, but NOT followed by a 
'(', the address of the function is implicitly taken and used in  the 
expression  (see  draft ANSI C standard for finer details).  For some 
class T, the following MIGHT all be valid statements:

        operator T;
        operator T*;
        operator T**;

If the above are valid, then the interpretation of the  following  is 
ambiguous:

        operator T * * a;

The above might be interpreted as:

        (operator T) * (* a);
or
        (operator (T *)) * a;

The default LR rules parse the largest possible type, and lead to:

        (operator (T * * )) ...

which  in  our  example  leads  to  a  syntax  error.  Here again the 
"longest possible type..." rule supports my grammar.  Note that  this 
rule  is  actually  a  consequence  (in  my  opinion)  of  the cfront 
implementation via a YACC grammar,  and  the  default  resolution  of 
conflicts in that grammar.


2 REDUCTION CONFLICTS WITH STRAIGHT FORWARD DISAMBIGUATION

The two conflicts that were described as:

   1 SR and 1 RR caused by operator function name and trailing {

occur  when  there is an ambiguity as to whether the '{' is the start 
of a function body in a  function  definition,  or  the  start  of  a 
structure/class/enum  elaboration.  In part, this ambiguity is caused 
by the fact that an  arbitrary  declarator  is  used  in  a  function 
definition,  but  semantics require the declarator in a definition to 
have  type  "function  returning  ...".   This  subtlety  causes  the 
following  to  be  a  syntactically  valid  function definition, even 
though it is semantically invalid:

        void func { int a; } ...

Semantic requirements on the declarator demand something more like:

        void func() { int a; }  ...

By using "operator struct S" in place of "func" in the first  example 
we get:

        void operator struct S { int a; } ...

My  C++  grammar  attempts to assemble the longest possible type, and 
hence parses this example as equivalent to:

        void operator (struct S { int a;} ) ...

Interestingly enough, this resolution not only supports the  "longest 
possible type" rule, but also avoids the semantically invalid parse.


3 NOVEL CONFLICTS THAT YIELD TO SEMANTIC DISAMBIGUATION

The  conflicts  that are discussed in this section have been deferred 
(by A LOT of work, and A LOT of inline expansion) to occur when a ';' 
is  reached.   At  that point, semantic information in the tokens can 
safely be used to decide which of two cases are at hand.

The conflicts referred to as:

    3 SR caused by constructor declaration vs member declaration

occur during a  class/struct  elaboration.   Consider  the  following 
class elaborations:

        typedef int T1, T2, T3  ;
        class GOO { int a;} ;
        class FOO {
                GOO    T1  ; // clearly a redefinition of T1
                FOO  ( T2 ); // clearly a constructor
                GOO  ( T3 ); // redefinition of T3
                };

Note  that  the  last two entries in FOO's elaboration "FOO(T2);" and 
"GOO(T3);" are tokenized  IDENTICALLY,  but  must  have  dramatically 
different  meanings.  When I first found this ambiguity I was hopeful 
that I could extend the lex hack that distinguishes TYPEDEFnames from 
random  IDENTIFIERs, and distinguish something like CURRENTCLASSname. 
Unfortunately, the potential  for  elaborations  within  elaborations 
appears  to  make such a hack unworkable.  In addition, once I got my 
grammar to defer all such ambiguous cases until a  ';'  was  seen,  I 
felt  confident that the ambiguity was resolved (and the introduction 
of an additional "hack" was unnecessary).


THE TOUGH AMBIGUITIES: FUNCTION LIKE CASTS AND COMPANY

The ambiguities  listed  in  this  section  pertain  to  attempts  to 
distinguish  declaration/types-names  from  expressions  names.   For 
example:

    char *b ="external" ; // declare a variable to confuse us :-)
    main () {
        class S;
        S (*b)[5]; // redeclare "b" pointer to array of 5 S's ?
               // OR ELSE indirect through b; cast to S; index using 5 ?
        }

The above is what I call  the  "declaration  vs  function  like  cast 
ambiguity".   Awareness  about this ambiguity in this context appears 
fairly widespread among C++ parser authors.   The  C++  2.0  Ref  Man 
makes  explicit  reference  to this problem in section 6.8 "Ambiguity 
Resolution".  I believe the underlying  philosophy  provided  by  the 
Reference  Manual  is that if a token stream can be interpreted by an 
ANSI C compiler to be a  declaration,  then  a  C++  compiler  should 
disambiguate  in  favor of a declaration.  Unfortunately, section 6.8 
goes on to say:

    "To disambiguate, the whole statement may have to be examined  to 
    determine  if  it  is  an expression-statement, or a declaration.  
    ... The disambiguation is purely syntactic; that is, the  meaning 
    of  the  names, beyond whether they are type-names or not, is not 
    used in the disambiguation".

The above  advice  only  forestalls  the  inevitable  ambiguity,  and 
complicates  the  language  in the process.  The examples that follow 
will demonstrate the difficulties.

There are several other contexts where such ambiguities  (typedef  vs 
expression) arise:

        1) Where a statement is valid (as shown above).
        2) As the argument to sizeof()
        3) Following "new", with the C++ syntax allowing a placement
                expression
        4) Immediately following a left paren  in  an  expression  (it 
                might be an old style cast, and hence a type name)
        5)  Following  a  left paren, arguments to constructors can be 
                confused with prototype type-names.
        6) Recursively in any of the above,  following  a  left  paren 
                (what  follows might be argument expressions, or might 
                be function prototype parameter typing)

Examples of simple versions of the sizeof context are:

        class T;
        sizeof ( T    ); // sizeof (type-name)
        sizeof ( T[5] ); // again a type name
        sizeof ( T(5) ); // sizeof (expression)
        sizeof ( T()  ); // semantic error: sizeof "function returning T"?
                        // OR ELSE sizeof result of function like cast

Examples  of  the  old  style cast ambiguity context, which are still 
ambiguous when the '(' after the 'T' has been seen:

        class T { /* put required declarations here */ 
                };
        a = (T(      5));  // function like cast of 5
        b = (T(      )) 0; // semantic error: cast of 0 to type "function
                        // returning T"

In constructors the following demonstrates the problems:

        class T;
        T (b)(int  d ); // same as "T b(int);", a function declaration
        T (d)(int (5)); // same as "T d(5);", an identifier declaration
        T (d)(int ( )); // ambiguous

The problem can appear recursively in  the  following  examples.   By 
"recursively"  I  mean that an ambiguity in the left-context has left 
the parser unsure of whether an "expression" or  a  "type"  is  being 
parsed,  and the ambiguity is continued by the token sequence.  After 
the parser can determine what this subsequence is, it will in turn be 
able to disambiguating what the prior tokens were.

Recursion on the statement/declaration context:

        class S;
        class T;
        S (*b)(T); // declare b "pointer to function taking T returning S"
        S (*c)(T dummy); // same declaration as for "b"
        int dummy;
        S (*d)(T (dummy)); // This T might be casting dummy

Recursion  on  the sizeof context is shown in the following examples. 
As before, the examples include semantic errors.

        class T;
        class S;
        sizeof ( T(S dummy) ); // sizeof "function taking S returning T"
        int dummy;
        sizeof ( T(S (dummy)) ); // sizeof "function taking S returning T"
                // OR ELSE cast dummy to S, and then cast that to T, which
                        // is the same as "sizeof T;"


The following are the precise conflicts, along with typical contexts.  
I  have derived the contexts by manually walking backwards through my 
verbose  YACC  output.   Note  that  I  have  deleted  some  of   the 
insignificant  rules  from  the  verbose  state  descriptions in this 
section  (insignificant  in  that  they  are  not  involved  in   the 
conflict).   To  see  the complete details of each conflict state see 
the appendix at the end of this paper.


WARNING: THE REMAINDER OF THIS SECTION IS  VERY  DETAILED  AND  TERSE 
(PERHAPS  EVEN  CRYPTIC);  DO NOT TRY TO READ IT CAREFULLY UNLESS YOU 
HAVE A LOT OF TIME TO KILL, AND A LOT OF  INTEREST  IN  THE  GRAMMAR.  
(You  can skip to the next section, which is a bit less technical and 
terse).

---------------------------------------------------------------------
        Minimal left context:   "main() { int ( identifier"
                Is the identifier being declared?
                Is the identifier a function name?
                Is the identifier an array name?
                   (The last two cases use function like casting into 
                   type "int")

        Left context can include an arbitrary number of '*', '&',  or 
                '('  immediately  to the left of the identifier.  The 
                basic.type.name    "int"    can    also    be     any 
                simple.type.name (e.g., a TYPEDEFname)

        My Default is to become a declarator, which then forms a 
        declaration

642: reduce/reduce conflict (red'ns 17 and 22 ) on (
642: reduce/reduce conflict (red'ns 17 and 22 ) on )
642: reduce/reduce conflict (red'ns 17 and 22 ) on [
state 642
        paren.identifier.declarator :  rescoped.identifier_    (17)
        primary.expression :  rescoped.identifier_    (22)

---------------------------------------------------------------------
        Required left context:   "... ( TYPEDEFname ()",
            where "..." includes a type.specifier.
            It is assumed that "function returning TYPEDEFname"
                is a valid "type.name".  Semantically this is
                rarely legal, but the focus is on syntax here.

            The above sequence could eventually parse into:
            ... ( declarator             )
            ... ( type.name              ) cast.expression
            ... ( expression             )
            ... ( parameter.decl.list    )
            Note that parameter.decl.list is:
                    type.name
                    type.name = default.value , ...
                    type.name , parameter.decl.list
            Expanded examples are:
                sizeof ( expression )
                sizeof ( type.name  )
                   where the argument to "sizeof" is one of the following:
                int ( typename2 ( TYPEDEFname() )
                int ( typename2 ( TYPEDEFname()  ,
                int ( typename2 ( TYPEDEFname() = expression
                int ( TYPEDEFname()
            Is the TYPEDEFname a declaration specifier?
            Is TYPEDEFname used as function like cast of 0 args?

        Left  context can include an arbitrary number of '*', '&', or 
                '(' immediately to the left  of  the "(TYPEDEFname".

        Default is to become a type.qualifier.list, 
            which becomes the trailing section of a  parameter.type.list,
            which becomes a function.returning.modifier for a declarator,
            which forces a redeclaration of TYPEDEFname,
             (semantics may outlaw this redeclaration of TYPEDEFname
                as a function WITHOUT use of "extern"!!!)

740: reduce/reduce conflict (red'ns 74 and 64 ) on )
740: reduce/reduce conflict (red'ns 74 and 64 ) on ,
740: reduce/reduce conflict (red'ns 74 and 64 ) on =
state 740
        postfix.expression :  TYPEDEFname ( )_    (74)
        parameter.type.list :  ( )_type.qualifier.list.opt
        type.qualifier.list.opt : _    (64)

---------------------------------------------------------------------
        Minimal left context:   "main() { int ( ( TYPEDEFname"
                Is the TYPEDEFname being redeclared?
                Is TYPEDEFname in parenthesis the start as old style cast?

        Left context can include an arbitrary number of '*', '&',  or 
                '('  between the two '('s.  The basic.type.name "int" 
                can also be any simple.type.name (e.g., a TYPEDEFname)

        Default is to become a typedef.declarator,
            which leads to the redeclaration of the TYPEDEFname

782: shift/reduce conflict (shift 595, red'n 418) on )
state 782
        type.name :  TYPEDEFname_    (418)
        simple.paren.typedef.declarator :  ( TYPEDEFname_)

---------------------------------------------------------------------
        Minimal left context:   "main() { int ( ( TYPEDEFname[2]"
         OR
        Minimal left context:   "main() { int ( ( TYPEDEFname(float)"
                Is the TYPEDEFname being redeclared?
                Is "array of TYPEDEFname" the type for
                        an old style cast?  The result of the cast
                        expression will undergo a function like cast into
                        an int.

        Left context can include an arbitrary number of '*', '&',  or 
                '('  between the two '('s.  The basic.type.name "int" 
                can also be any simple.type.name (e.g., a TYPEDEFname)

        Default to form a typedef.declarator,
                 which leads to a redeclaration of the  TYPEDEFname.
                (Semantics preclude cast to this type anyway, so we have
                actually syntactically disallowed a semantic error)

874: shift/reduce conflict (shift 838, red'n 591) on )
state 874
        paren.postfix.typedef.declarator :  ( TYPEDEFname postfixing.abstract.declarator_)
        abstract.declarator :  postfixing.abstract.declarator_    (591)

---------------------------------------------------------------------
        Minimal left context:   "main() { int ( * ( TYPEDEFname"
                Is the TYPEDEFname being redeclared?
                Is TYPEDEFname in parenthesis the start as old style
                    cast? The result of the cast will undergo and 
                    indirection, and the result of that will be 
                    cast to int by a function like cast!

        Left context can include an arbitrary number of '*', '&',  or 
                '('  to the left of the '*'.  The basic.type.name "int" 
                can also be any simple.type.name (e.g., a TYPEDEFname)

        Default to form a typedef.declarator,
                which leads to a redeclaration of the  TYPEDEFname.

875: shift/reduce conflict (shift 840, red'n 418) on )
state 875
        type.name :  TYPEDEFname_    (418)
        paren.typedef.declarator :  indirect.or.reference ( TYPEDEFname_)

---------------------------------------------------------------------


SAMPLE RESOLUTIONS OF AMBIGUITIES BY MY C++ GRAMMAR


Of the "hard examples" given in the C++ reference manual  (r6.8),  my 
grammar  can  only "properly" detect a "statement-expression" for the 
stream:

        T(a,5)>>c;

All the other examples default to  a  declarator  after  the  closing 
parenthesis  following  the  identifier.   (See  my  comments  in the 
conclusion section of this paper).

I actually am not sure I agree with all the examples in the  C++  2.0 
Reference Manual. Specifically, the example in section 6.8:

        T (*d) (double(3));  // expression statement

In  the  example  "T"  is  specified  to be a simple-type-name, which 
includes all the basic  types  as  well  as  class-names,  and  more. 
Considering the following are valid declarations:

        void *a (0);
        void *b (int(0));
        void (*c)(int(0));

I am unable to see the "syntactic" difference between this last token 
stream and the  example  just  cited  in  the  reference  manual.  My 
simplistic  parser  gives  me  the result that I at least expect.  It 
concludes (prematurely, but seemingly correctly) that the stream is a 
declaration (with a new style initializer).

As  a  positive note, my grammar is able to parse the example given a 
while back in comp.lang.c++, that Zortech 1.07 cannot parse:

        a = (double(a)/double(b))...;

Apparently,  upon  seeing  "(double"  some  parsers   commit   to   a 
parenthesized  type-name for a cast expression, and cannot proceed to 
parse a parenthesized expression.  No  mention  of  this  problem  is 
listed in my conflict list, as resolution of this problem is simply a 
matter of letting the LR parser wait long enough  before  committing.  
Specifically, my grammar has not yet committed when all of:

        a = (double(a)

has  been  seen!   The  next  character  ('/')  allows the grammar to 
unambiguously  conclude  that  the  sequence  "double(a)..."  is   an 
expression.


DIFFICULT AMBIGUITIES FOR A "C++ 2.0" COMPATIBLE PARSER TO TRY

Having  seen  the  above contexts, I would be curious to see if other 
C++ front ends with "smart lexers" (such as cfront)  can  handle  the 
following.   These  examples  are  not  guaranteed  to  be  evaluated 
correctly by my grammar, but I expect them to demonstrate  weaknesses 
in  many other parsers.  The interpretation of these examples per C++ 
2.0  definitions  requires  massive  lookahead.   In  addition,   the 
examples  are  generally  unreadable by humans, and rarely parsed the 
same way by any two implementations.

    main()
      {
      class T 
        { 
        /* ... */
        } a;
      typedef T T1,T2,T3,T4,T5,T7,T8,T9,Ta,Tb,Tc,Td;
        { /* start inner scope */
        T((T1)         ); // declaration
        T((T2)    a    ); // Statement expression
        T((T3)(       )); // declaration of T3
        T((T4)(T      )); // declaration of T4
        T((T5)(T  a   )); // declaration of T5
        T((T6)(T((a) ))); // declaration of T6
        T((T7)(T((T) ))); // declaration of T7
        T((T8)(T((T)b))); // statement expression

        T(b[5]); // declaration
        T(c());  // declaration
        T(d()[5]);  // statement expression ? (function returning array 
                      // is semantically illegal, but syntactically proper)
        T(e[5]());  // statement expression ? (No array of functions)
        T(f)[5]();  // statement expression ?  "                   "
        
        T(*Ta() )[5] [4];  //declaration
        T(*Tb() [5]) [4];  //statement expression ? (function returning array)

        T(*Tc()) [3 +2];  //declaration
        T(*Td()) [3 ]+2;  //statement expression

        }
      }        


COMMENTARY ON C++ 2.0 DISAMBIGUATING RULES

There are two distinct thrusts in conflict disambiguation as provided 
by  AT&T's efforts to define a standard for C++.  The first thrust is 
"parse tokens into the longest possible declarator, and identify  the 
syntax  errors  that  result".   The second thrust is to "use massive 
external technology ("smart lexer", a.k.a.: "recursive decent  parser 
that  helps  the  lexer",  a.k.a.  LALEX)  to look ahead, so that the 
parser doesn't mis-parse a function-like-cast as  a  declaration  and 
induce  a  syntax  error".   The  first  is a commitment to LR parser 
technology, and an existing grammar (which could be cleaned up).  The 
second  is a commitment to NOT use an LR parser, and to the use of an 
existing implementation.

It is my belief that LR parsers are well understood, and the addition 
of  a  "smart  lexer" destroys all structure in a parser.  The result 
can be anticipated to become a quagmire of code and hacks.  With this 
firm  conviction,  I  have  provided  my  grammar in the hopes that a 
standard can emerge that IS well defined, and is  implementable,  and 
is readable by humans.



SOURCE OF CONFLICTS IN C++ (MIXING TYPES AND EXPRESSIONS)

One  fundamental strength in C is the similarity between declarations 
and expressions.  The syntax of  the  two  is  intended  to  be  very 
similar, and the result is a clean declaration and expression syntax. 
(It takes some getting used to,  but  it  is  in  my  opinion  good).  
Unfortunately,  there  are some slight distinctions between types and 
expressions, which Ritchie et.  al.  apparently noticed.  It  is  for 
this  reason  (I  am guessing) that the C cast operator REQUIRES that 
the type be enclosed in parenthesis.  Moreover, there is also a clear 
separator   in   a   declaration   between  the  declarator  and  the 
initializing expression (the '=') (as some of you know, there is some 
interesting  history  in  this area.).  The bottom line (as seen with 
20-20 hindsight) is: "keep declarations  and  expressions  separate".  
Each violation of this basic rule has induced conflicts.


To  be  concrete about the differences between types and expressions, 
the following two distinctions are apparent:

    1) Abstract declarators are permitted.  No analogy is provided in 
    expressions.    The   notable   distinction   is   that  abstract 
    declarators include the possibility of trailing '*' tokens.
        
    2) The binding of elements in a  declaration  is  very  different 
    from  any  expression.   Notably,  the declaration-specifiers are 
    bound separately to each declarator in the comma  separated  list 
    of  declarators  (example:  int  a, b, c;).  With (most forms of) 
    expressions,  a  comma  provides  a   major   isolation   between 
    expressions.

C  also  used  reserved  names  to  GREATLY  reduce the complexity of 
parsing.  The introduction of typedef names increased the  complexity 
(it  made  the language context sensitive), but a simple hack between 
lex and YACC overcame the problem.  An example is the statement:

        name (*b)[4];

Note that this  is  ambiguous,  EVEN  in  ANSI  C,  IF  there  is  no 
distinction  between type-names and function names!  (i.e., "b" could 
be getting redeclared to be of type "pointer to array  of  name",  OR 
the function "name" could be called with argument "*b", the result of 
which is indexed to the 4th element). In C, the two  kinds  of  names 
(TYPEDEFnames  and  function  names  (a.k.a.:  declared identifiers)) 
share a name space, and at every point in a source program the (hack) 
contextual  distinction can be made by the tokenizer.  Hacks are neat 
things in that the less you use them, the more  likely  they  are  to 
work  when  you  REALLY need them (i.e., you don't have to fight with 
existing hacks).  Having worked on designing  and  implementing  a  C 
compiler,  I  was  pleasantly  amazed  at how the constructs all fell 
together.

The  major  violations  of  this  approach  (i.e.,  keep  declaration 
separate from expressions) that come to mind with C++ are: 

        function-like-casts,
        freestore expressions without parens around the type,
        conversion function names using arbitrary type specifiers,
        parenthesized initializers that drive constructors.

The  last  problem, parenthesized initializers, provides two areas of 
conflicts.  The first is really an interference issue with old  style 
C function definitions, which only bothers folks at file scope (GNU's 
G++ compiler considered this to be too great an  obstacle,  and  they 
don't  currently  support old style C definitions!).  The second part 
of this conflict  involves  a  more  subtle  separation  between  the 
declarator,  and  the  initializer. (K&R eventually provided an equal 
sign as an unequivocal separator, but parens used in C++ are  already 
TOO  overloaded to separate anything).  The significance of this lack 
of a clear separator is that it  is  difficult  to  decide  that  the 
"declarator"  is complete, and that the declared name should be added 
to the scope.  The last problem does interact in a nasty way with the 
function-like  cast  vs  declaration conflicts (the problem slows the 
feedback loop to the symbol table, which  is  critical  to  continued 
lexing).  The parened initializers also provide another context where 
it is difficult to distinguish between expressions (a  true  argument 
list for the constructor) and a declaration continuation (a parameter 
type list).  

The second problem listed falls out of the "new-expression"  with  an 
unparenthesized type.  This form of freestore (such as "new int * *") 
allows types to be placed adjacent to expressions, and  the  trailing 
'*'  ambiguity  rears  its head.  I can easily prove that this is the 
culprit in terms of specific  ambiguities,  in  that  removing  these 
(unnecessary?) forms significantly disambiguates the grammar.  (It is 
rather nice to use YACC  as  a  tool  to  prove  that  a  grammar  is 
unambiguous!).  It is interesting to note that if only the derivation 
of a freestore expression were limited  to  (using  the  non-terminal 
names of the form that the C++ Reference manual uses):

        new placement-opt ( type-name )  parened-arg-list-opt

then  all  the  LR(1)  reduce  conflicts  based on this problem would 
vanish.  Indeed, the culprit can clearly be shown to be:

        new placement-opt  restricted-type-name parened-arg-list-opt

The characters which excite these reduction conflicts are  '*',  '&', 
and ':'.  The context in which the ':' is significant occurs when the 
freestore expression is the middle expression of the ternary operator 
set  "?:".   In this ternary operator context, the use of a type name 
such as "class a" leaves the LR(1) parser confused about the  meaning 
of a ':' that follows.

The     third    problem    that    I    indicated    involves    the 
conversion-function-name.  Here again, if the syntax were  restricted 
to ONLY:

        operator simple-type-name

then  the  LR(1)  conflicts  would vanish.  It is interesting to note 
that the keyword "operator" serves as the  left  separator,  and  the 
restriction  to  "simple-type-name"  results  in  an  implicit  right 
separator  (simple-type-names  are  exactly  one  token  long).   The 
conflicts  appear  when multiple tokens are allowed for a declaration 
specifier, and an optional pointer-modifier list may be  added  as  a 
postfix.   The  conflicts  that  result  from this lack of separation 
include  all  those  provided  by  the  freestore  example,  and   an 
additional   set   as   well.    The  additional  conflicts  are  not 
semantically significant, but  they  are  noticeable  to  a  compiler 
writer.  The interesting new trailing character conflict is '{'.  The 
context for this conflict involves the  definition  of  a  conversion 
function,  which  always  includes  a  function  body (with a leading 
character of '{' ).  A simple grammar does not SYNTACTICALLY  require 
that      "function      returning      modifier"      follow     the 
conversion-function-name in  all  declarations/definitions,  although 
semantics  do  require such.  Hence an LR(1) conflict occurs when the 
type-name is of  the  form  "struct  A",  and  a  possible  structure 
elaboration may follow (with leading character '{' ).

Here  again (as with the unambiguous version of freestore) the syntax 
could be extended to:

operator.function.name :
        OPERATOR any.operator
        | OPERATOR basic.type.name
        | OPERATOR TYPEDEFname
        | OPERATOR type.qualifier
        | OPERATOR '(' type.name ')'
        ;

instead of:

operator.function.name :
        OPERATOR any.operator
        | OPERATOR type.specifier.or.name  operator.function.ptr.opt
        | OPERATOR type.qualifier.list     operator.function.ptr.opt
        ;

and the ambiguities would vanish (and the expressivity would  not  be 
diminished).


FUNCTION LIKE CAST VS DECLARATION AMBIGUITIES

The real big culprit (i.e., my anti-favorite) in this whole ambiguity 
set  (re:  keeping   types   and   expressions   separate)   is   the 
function-like-cast.   The  reason  why it is so significant (to an LR 
parser)  is  that  the  binding  of  a  type-name,  when  used  in  a 
function-like-cast,   is  directly  to  the  following  parenthesized 
argument list.  In contrast, the binding of a type-name when used  in 
a  declaration  is  to  all  the  "stuff"  that  follows,  up until a 
declarator termination mark like a ',', ';' or '='. Life really  gets 
tough  for LR folks when the parse tree MUST be reduced, but you just 
can't tell how yet.  With this problem, the  hacks  began  to  appear 
(re:  the  "smart  lexer").  Note that these new style casts are much 
more than a notational convenience  in  C++.  The  necessity  of  the 
function like cast lies in the fact that such a cast can take several 
arguments, whereas the old style cast is ALWAYS a unary operator.

I was (past tense) actually working towards  resolving  this  problem 
via some standard methods that I have developed (re: inline expansion 
of rules to provide deferred reduction).  I  was  (past  tense)  also 
using one more sneaky piece of work to defer the reductions, as I was 
carefully making use of right recursion (instead of the standard left 
recursion)  in  order  to  give  the parser a chance to build up more 
context.   I  can  demonstrate  the  usefulness  of  right  recursive 
grammars  in disambiguating difficult toy grammars.  Unfortunately, I 
realized at some point that I NEEDED to perform certain actions (such 
as  add  identifiers  to  the  symbol table) in order to complete the 
parse!?!  This was my catch 22.  I could POSSIBLY parse using an LALR 
grammar,  if I could only defer actions until I had enough context to 
disambiguate.  Unfortunately, I HAD to perform certain  actions  (re: 
modify  the  symbol table, which changed the action of the tokenizer) 
BEFORE I could continue to examine tokens!  In some  terrible  sense, 
the typedef hack had come back to haunt me.

I backed off a bit in my grammar after reaching this wall, and now my 
grammar only waits until it reaches the identifier in  the  would  be 
declarator.   I  really  didn't  want  to  parse  the stuff after the 
identifier name (sour grapes?), because  I  knew  I  would  not  (for 
example)  be  able  to  identify  a "constant expression" in an array 
subscript (most of the time, if it isn't constant, then it can't be a 
declaration).   I  don't  believe that a compiler should compete in a 
battle of wits with  the  programmer,  and  the  parser  was  already 
beginning  to outwit me (i.e., I was having a hard time parsing stuff 
mentally that is provided as examples in the 2.0 Reference Manual).   


FUNCTION LIKE CAST vs DECLARATION : THE TOUGH EXAMPLE:        
        
The following is about the nastiest example that I have been able  to 
construct  for this ambiguity group.  I am presenting it here just in 
case someone is left with a thought that there is "an easy way out".

The  fact  that  identifiers  can  remain  ambiguous  SO  LONG  after 
encountering  them  can  cause  no end of trouble to the parser.  The 
following example does not succumb to static (re: no  change  to  the 
symbol  table)  anticipatory  lexing  of  a  statement.   As such, it 
demonstrates the futility of attempting to use  a  "smart  lexer"  to 
support  the  philosophy: "If it can be interpreted as a declaration, 
then so be it;  otherwise  it  is  an  expression".   This  ambiguous 
example  exploits  the  fact  that  declarators  MUST be added to the 
symbol table as soon as  they  are  complete  (and  hence  they  mask 
external declarations).

First I will present the example without comments:

class Type1 {
            Type1 operator()(int);
            } ;
class wasType2 { ...}; 
int (*c2)(Type1 dummy);

main ()
    {
    const int    a1  = 0, new_var  (4), (*c1)(int     (a1));
    Type1       (a2) = 3, wasType2 (4), (*c2)(wasType2(a1));
    }




Now to repeat the example with comments:

class Type1 {....
            Type1 operator()(int);
            } ;
class wasType2 { ....}; /* we will almost redeclare this typename!?! */
int (*c2)(Type1 dummy); /* we will NOT redeclare Type1 */

main ()
    {
    /* The first line is indeed simple.  It is simply placed here
    to hint at how the second line MIGHT analogously be parsed. */
    
    const int    a1  = 0, new_var  (4), (*c1)(int     (a1));

    /*  As  a review, "a1" is declared to be a constant with value 0. 
        "new_var" is declared to be another constant, but with  value 
        4.  Finally,  "c1"  is  declared  to  be a pointer to a const 
        integer, and the initial value of this pointer is  "int(a1)", 
        which  is  the  same  as "int(0)", or simply "0" (a.k.a., the 
        null pointer). It is significant that "a1" entered the symbol 
        table  quickly  so  that  it  could  be  used  later  in  the 
        declaration. */

    /* Static lexing of what follows will suggest that the  following 
    is  also  a  declaration.   This  statement  is  actually 3 comma 
    separated expressions!! The explanation that follows  shows  that 
    assuming   the   2nd  statement  is  a  declaration  leads  to  a 
    contradiction. */
    
    Type1      (a2) = 3, wasType2 (4), (*c2)(wasType2(a1));
    
    /* Assume this second statement is a declaration.  Note  that  by 
    the  time  "c2" is parsed, "wasType2" has been redeclared to be a 
    variable of type "Type1".  Hence  "wasType2(a1)"  is  actually  a 
    function  call  to  "wasType2.operator()(a1)",  and  it  is not a 
    function    prototype    arg    list.     It     follows     that 
    "(*c2)(wasType2(a1))"  is  an  expression,  and NOT a declarator!  
    Since this last entry is not a declarator, the  entire  statement 
    must  be an expression (ugh! it is time to backtrack). After much 
    work on my part, I think it might even be  a  semantically  valid 
    expression.   Once this backtracking is complete, we see that the 
    first expression "Type1 (a2) = 3" is  an  assignment  to  a  cast 
    expression.  The second expression "wasType2 (4)", is a cast of a 
    constant.  The  third  expression  "(*c2)(wasType2(a1))",  is  an 
    indirect  function  call.  The argument of the call is the result 
    of a cast.  Note that "wasType2" is  actually  never  redeclared, 
    but it was close! */
    
    /*  For  those of you who can parse this stuff in your sleep, and 
    noticed the slight error  in  the  above  argument,  I  have  the 
    following "fix".  The error is that the 

        "(*c2)(wasType2(a1))" 

    could actually be a declaration with a parenthesized initializer.  
    I could have change this token subsequence to:

        "(*(*c2)(wasType2(a1)))(int(a1))"

    and avoid the constructor ambiguity, but it would only complicate 
    the  discussion.   Note that in this form, if "wasType2" is not a 
    type, the the quoted text cannot be a declaration.*/

    /* Two parens are all a user would need to  add  to  the  cryptic 
    example  to  unambiguously  specify  that  this  statement  is an 
    expression.  Specifically: */
    
       (Type1) (a2) = 3, wasType2 (4), (*c2)(wasType2(a1));
    /* or ...*/
       (Type1 (a2) = 3), wasType2 (4), (*c2)(wasType2(a1));

    /* I would vote for a syntax error in such ambiguous stream, with 
    an  early  decision that it was a declaration.  After seeing this 
    example, I doubt that I could quickly assert that I could produce 
    a non-backtracking parser that disambiguates statements according 
    to the C++ 2.0 rule.  I am sure  I  can  forget  about  a  simple 
    lex-YACC combination doing it. */

    }


Most  simply  put,  if  a  "smart  lexer"  understands these: a) I am 
impressed, b) Why use a parser when a lexer can parse so well?

The bottom line is that disambiguation of declarations via "If it can 
be  a  declaration,  then it is one", seems to require a backtracking 
parser. (Or some very fancy parsing approach).  I am not even sure if 
the above examples are as bad as it can get!


CONCLUSION

I  believe that the C++ grammar that I have made available represents 
a viable machine readable standard for the syntax description of  the 
C++  language.   In  cases where the ambiguities are still exposed by 
conflicts (as noted by YACC), to further defer  resolution  would  be 
detrimental  to  a  user.   I see no benefit in describing a computer 
language that must support human writers, but cannot be understood by 
humans.    Any   code  that  exploits  such  deferral  is  inherently 
non-portable, and deserves to be diagnosed as an  error  (my  grammar 
asserts  a  "syntax  error").   Rather than dragging the C++ language 
into support for a ad-hoc parser implementations such as cfront  (and 
the "smart lexer"), I would heavily suggest the use of my grammar.  I 
do not believe that my grammar would "break" much existing code,  but 
in cases where it would, the code would not be portable anyway (other 
than to a port of an IDENTICAL parser).

I hope to see a great deal of use of my grammars, and I believe  that 
standardizing  on  the represented syntax will unify the C++ language 
greatly.

        Jim Roskind
        Independent Consultant
        516 Latania Palm Drive
        Indialantic FL 32903
        (407)729-4348
        ...uunet!leafusa!jar


APPENDIX A:
  PROPOSED GRAMMAR MODIFICATIONS (fixing '*', '&' and ':' conflicts)

Based on the other  items  described  above,  I  have  the  following 
suggestions  for  cleaning up the grammar definition.  Unfortunately, 
it provides subtle variations from the "C++ 2.0" standard.


Current Grammar:

operator.function.name :
        OPERATOR any.operator
        | OPERATOR type.specifier.or.name  operator.function.ptr.opt
        | OPERATOR type.qualifier.list     operator.function.ptr.opt
        ;


operator.new.type:
        type.qualifier.list      operator.new.declarator.opt
                        operator.new.initializer.opt
        | type.specifier.or.name operator.new.declarator.opt
                        operator.new.initializer.opt
        ;

Proposed new grammar (which requires parens around complex types):

operator.function.name :
        OPERATOR any.operator
        | OPERATOR basic.type.name
        | OPERATOR TYPEDEFname
        | OPERATOR type.qualifier
        | OPERATOR '(' type.name ')'
        ;

operator.new.type:
        basic.type.name    operator.new.initializer.opt 
        | TYPEDEFname      operator.new.initializer.opt 
        | type.qualifier   operator.new.initializer.opt 
        | '(' type.name ') operator.new.initializer.opt 
        ;

The impact of the above changes is that all complex type names (i.e.: 
names that are not simply a typedef/class name, or a basic type names 
like char) must be enclosed in parenthesis  in  both  `new  ...'  and 
`operator  ...' expressions. Both of the above changes would clear up 
a number of ambiguities.  In some sense, the current "disambiguation" 
(of  trailing  '*', '&', and ':') is really a statement that whatever 
an LR(1) parser cannot disambiguate is a syntax error.  In  contrast, 
the above rules define an unambiguous grammar.


APPENDIX B:
  AMBIGUITIES IN MY C++ GRAMMAR AS LISTED BY YACC VERBOSE OPTION

The  following  are  the  list of conflicts that were reported in the 
verbose output from an AT&T compatible YACC.  I have only listed  the 
conflict states here, as the entire file is well in excess of 500K.


182: shift/reduce conflict (shift 183, red'n 286) on :
182: reduce/reduce conflict (red'ns 286 and 280 ) on {
state 182
        aggregate.name :  aggregate.key identifier.or.typedef.name_derivation.opt $$284 { member.declaration.list.opt }
        aggregate.name :  aggregate.key identifier.or.typedef.name_    (286)
        derivation.opt : _    (280)

        :  shift 183
        {  reduce 280
        .  reduce 286

        derivation.opt  goto 415


187: shift/reduce conflict (shift 427, red'n 369) on {
state 187
        enum.name :  ENUM identifier.or.typedef.name_{ enumerator.list }
        enum.name :  ENUM identifier.or.typedef.name_    (369)

        {  shift 427
        .  reduce 369


189: shift/reduce conflict (shift 50, red'n 29) on *
189: shift/reduce conflict (shift 51, red'n 29) on &
state 189
        operator.function.name :  OPERATOR type.specifier.or.name_operator.function.ptr.opt
        operator.function.ptr.opt : _    (29)

        TYPEDEFname  shift 431
        *  shift 50
        &  shift 51
        .  reduce 29

        operator.function.ptr.opt  goto 428
        pointer.operator  goto 429
        indirect.or.reference  goto 430


190: shift/reduce conflict (shift 50, red'n 29) on *
190: shift/reduce conflict (shift 51, red'n 29) on &
state 190
        operator.function.name :  OPERATOR type.qualifier.list_operator.function.ptr.opt
        type.qualifier.list :  type.qualifier.list_type.qualifier
        basic.type.specifier :  type.qualifier.list_basic.type.name
        sue.type.specifier :  type.qualifier.list_elaborated.type.name
        typedef.type.specifier :  type.qualifier.list_TYPEDEFname
        operator.function.ptr.opt : _    (29)

        DOUBLE  shift 42
        INT  shift 39
        STRUCT  shift 68
        LONG  shift 40
        ENUM  shift 66
        CHAR  shift 37
        UNION  shift 69
        CONST  shift 63
        FLOAT  shift 41
        SHORT  shift 38
        UNSIGNED  shift 44
        SIGNED  shift 43
        VOID  shift 36
        VOLATILE  shift 64
        CLASS  shift 70
        TYPEDEFname  shift 433
        *  shift 50
        &  shift 51
        .  reduce 29

        operator.function.ptr.opt  goto 432
        pointer.operator  goto 429
        indirect.or.reference  goto 430
        basic.type.name  goto 151
        type.qualifier  goto 150
        elaborated.type.name  goto 152
        aggregate.name  goto 48
        enum.name  goto 49
        aggregate.key  goto 65


429: shift/reduce conflict (shift 50, red'n 29) on *
429: shift/reduce conflict (shift 51, red'n 29) on &
state 429
        operator.function.ptr.opt :  pointer.operator_operator.function.ptr.opt
        operator.function.ptr.opt : _    (29)

        TYPEDEFname  shift 431
        *  shift 50
        &  shift 51
        .  reduce 29

        operator.function.ptr.opt  goto 636
        pointer.operator  goto 429
        indirect.or.reference  goto 430


430: shift/reduce conflict (shift 50, red'n 29) on *
430: shift/reduce conflict (shift 51, red'n 29) on &
state 430
        operator.function.ptr.opt :  indirect.or.reference_operator.function.ptr.opt
        pointer.operator :  indirect.or.reference_type.qualifier.list
        operator.function.ptr.opt : _    (29)

        CONST  shift 63
        VOLATILE  shift 64
        TYPEDEFname  shift 431
        *  shift 50
        &  shift 51
        .  reduce 29

        operator.function.ptr.opt  goto 637
        type.qualifier.list  goto 166
        pointer.operator  goto 429
        indirect.or.reference  goto 430
        type.qualifier  goto 46


484: shift/reduce conflict (shift 50, red'n 103) on *
484: shift/reduce conflict (shift 51, red'n 103) on &
state 484
        operator.new.type :  type.qualifier.list_operator.new.declarator.opt operator.new.initializer.opt
        type.qualifier.list :  type.qualifier.list_type.qualifier
        basic.type.specifier :  type.qualifier.list_basic.type.name
        sue.type.specifier :  type.qualifier.list_elaborated.type.name
        typedef.type.specifier :  type.qualifier.list_TYPEDEFname
        operator.new.declarator.opt : _    (103)

        DOUBLE  shift 42
        INT  shift 39
        STRUCT  shift 68
        LONG  shift 40
        ENUM  shift 66
        CHAR  shift 37
        UNION  shift 69
        CONST  shift 63
        FLOAT  shift 41
        SHORT  shift 38
        UNSIGNED  shift 44
        SIGNED  shift 43
        VOID  shift 36
        VOLATILE  shift 64
        CLASS  shift 70
        TYPEDEFname  shift 433
        *  shift 50
        &  shift 51
        [  shift 678
        .  reduce 103

        pointer.operator  goto 677
        indirect.or.reference  goto 676
        basic.type.name  goto 151
        operator.new.declarator.opt  goto 674
        operator.new.array.declarator  goto 675
        type.qualifier  goto 150
        elaborated.type.name  goto 152
        aggregate.name  goto 48
        enum.name  goto 49
        aggregate.key  goto 65


485: shift/reduce conflict (shift 50, red'n 103) on *
485: shift/reduce conflict (shift 51, red'n 103) on &
state 485
        operator.new.type :  type.specifier.or.name_operator.new.declarator.opt operator.new.initializer.opt
        operator.new.declarator.opt : _    (103)

        TYPEDEFname  shift 431
        *  shift 50
        &  shift 51
        [  shift 678
        .  reduce 103

        pointer.operator  goto 677
        indirect.or.reference  goto 676
        operator.new.declarator.opt  goto 679
        operator.new.array.declarator  goto 675


642: reduce/reduce conflict (red'ns 17 and 22 ) on (
642: reduce/reduce conflict (red'ns 17 and 22 ) on )
642: reduce/reduce conflict (red'ns 17 and 22 ) on [
state 642
        paren.identifier.declarator :  rescoped.identifier_    (17)
        primary.expression :  rescoped.identifier_    (22)

        (  reduce 17
        )  reduce 17
        [  reduce 17
        .  reduce 22


676: shift/reduce conflict (shift 50, red'n 103) on *
676: shift/reduce conflict (shift 51, red'n 103) on &
state 676
        operator.new.declarator.opt :  indirect.or.reference_operator.new.declarator.opt
        pointer.operator :  indirect.or.reference_type.qualifier.list
        operator.new.declarator.opt : _    (103)

        CONST  shift 63
        VOLATILE  shift 64
        TYPEDEFname  shift 431
        *  shift 50
        &  shift 51
        [  shift 678
        .  reduce 103

        type.qualifier.list  goto 166
        pointer.operator  goto 677
        indirect.or.reference  goto 676
        operator.new.declarator.opt  goto 802
        operator.new.array.declarator  goto 675
        type.qualifier  goto 46


677: shift/reduce conflict (shift 50, red'n 103) on *
677: shift/reduce conflict (shift 51, red'n 103) on &
state 677
        operator.new.declarator.opt :  pointer.operator_operator.new.declarator.opt
        operator.new.declarator.opt : _    (103)

        TYPEDEFname  shift 431
        *  shift 50
        &  shift 51
        [  shift 678
        .  reduce 103

        pointer.operator  goto 677
        indirect.or.reference  goto 676
        operator.new.declarator.opt  goto 803
        operator.new.array.declarator  goto 675


740: reduce/reduce conflict (red'ns 74 and 64 ) on )
740: reduce/reduce conflict (red'ns 74 and 64 ) on ,
740: reduce/reduce conflict (red'ns 74 and 64 ) on =
state 740
        postfix.expression :  TYPEDEFname ( )_    (74)
        parameter.type.list :  ( )_type.qualifier.list.opt
        type.qualifier.list.opt : _    (64)

        )  reduce 64
        ,  reduce 64
        CONST  shift 63
        VOLATILE  shift 64
        ELLIPSIS  reduce 64
        =  reduce 64
        .  reduce 74

        type.qualifier.list  goto 533
        type.qualifier.list.opt  goto 532
        type.qualifier  goto 46


782: shift/reduce conflict (shift 595, red'n 418) on )
state 782
        class.rescoped.identifier :  TYPEDEFname_CLCL identifier.or.typedef.name
        class.rescoped.identifier :  TYPEDEFname_CLCL operator.function.name
        class.rescoped.identifier :  TYPEDEFname_CLCL ~ TYPEDEFname
        class.rescoped.identifier :  TYPEDEFname_CLCL class.rescoped.identifier
        postfix.expression :  TYPEDEFname_( )
        postfix.expression :  TYPEDEFname_( argument.expression.list )
        typedef.type.specifier :  TYPEDEFname_type.qualifier
        type.name :  TYPEDEFname_    (418)
        type.name :  TYPEDEFname_abstract.declarator
        paren.postfix.typedef.declarator :  ( TYPEDEFname_postfixing.abstract.declarator )
        simple.paren.typedef.declarator :  ( TYPEDEFname_)
        pointer.operator :  TYPEDEFname_CLCL * type.qualifier.list.opt

        (  shift 687
        )  shift 595
        CONST  shift 63
        VOLATILE  shift 64
        TYPEDEFname  shift 431
        CLCL  shift 129
        *  shift 50
        &  shift 51
        [  shift 98
        .  error

        pointer.operator  goto 684
        indirect.or.reference  goto 683
        postfixing.abstract.declarator  goto 874
        type.qualifier  goto 133
        parameter.type.list  goto 97
        abstract.declarator  goto 561
        unary.abstract.declarator  goto 548
        postfix.abstract.declarator  goto 549
        array.abstract.declarator  goto 96


874: shift/reduce conflict (shift 838, red'n 591) on )
state 874
        paren.postfix.typedef.declarator :  ( TYPEDEFname postfixing.abstract.declarator_)
        abstract.declarator :  postfixing.abstract.declarator_    (591)

        )  shift 838
        .  error


875: shift/reduce conflict (shift 840, red'n 418) on )
state 875
        class.rescoped.identifier :  TYPEDEFname_CLCL identifier.or.typedef.name
        class.rescoped.identifier :  TYPEDEFname_CLCL operator.function.name
        class.rescoped.identifier :  TYPEDEFname_CLCL ~ TYPEDEFname
        class.rescoped.identifier :  TYPEDEFname_CLCL class.rescoped.identifier
        postfix.expression :  TYPEDEFname_( )
        postfix.expression :  TYPEDEFname_( argument.expression.list )
        typedef.type.specifier :  TYPEDEFname_type.qualifier
        type.name :  TYPEDEFname_    (418)
        type.name :  TYPEDEFname_abstract.declarator
        paren.typedef.declarator :  indirect.or.reference ( TYPEDEFname_)
        paren.postfix.typedef.declarator :  ( TYPEDEFname_postfixing.abstract.declarator )
        pointer.operator :  TYPEDEFname_CLCL * type.qualifier.list.opt

        (  shift 687
        )  shift 840
        CONST  shift 63
        VOLATILE  shift 64
        TYPEDEFname  shift 431
        CLCL  shift 129
        *  shift 50
        &  shift 51
        [  shift 98
        .  error

        pointer.operator  goto 684
        indirect.or.reference  goto 683
        postfixing.abstract.declarator  goto 874
        type.qualifier  goto 133
        parameter.type.list  goto 97
        abstract.declarator  goto 561
        unary.abstract.declarator  goto 548
        postfix.abstract.declarator  goto 549
        array.abstract.declarator  goto 96


876: shift/reduce conflict (shift 950, red'n 451) on ELSE
state 876
        selection.statement :  IF ( expression ) statement_    (451)
        selection.statement :  IF ( expression ) statement_ELSE statement

        ELSE  shift 950
        .  reduce 451


1026: shift/reduce conflict (shift 1066, red'n 571) on ;
state 1026
        constructor.conflicting.parameter.list.and.body :  ( TYPEDEFname )_;
        constructor.conflicting.parameter.list.and.body :  ( TYPEDEFname )_type.qualifier.list ;
        constructor.conflicting.parameter.list.and.body :  ( TYPEDEFname )_constructor.init.list.opt compound.statement
        constructor.conflicting.parameter.list.and.body :  ( TYPEDEFname )_type.qualifier.list constructor.init.list.opt compound.statement
        simple.paren.typedef.declarator :  ( TYPEDEFname )_    (571)
        constructor.init.list.opt : _    (539)

        CONST  shift 63
        VOLATILE  shift 64
        :  shift 81
        ;  shift 1066
        {  reduce 539
        .  reduce 571

        type.qualifier.list  goto 1067
        type.qualifier  goto 46
        constructor.init.list  goto 1069
        constructor.init.list.opt  goto 1068


1065: shift/reduce conflict (shift 1102, red'n 359) on ;
state 1065
        member.conflict.paren.postfix.declaring.item :  TYPEDEFname ( TYPEDEFname postfixing.abstract.declarator )_member.pure.opt
        constructor.conflicting.typedef.declarator :  ( TYPEDEFname postfixing.abstract.declarator )_type.qualifier.list ;
        constructor.conflicting.typedef.declarator :  ( TYPEDEFname postfixing.abstract.declarator )_type.qualifier.list constructor.init.list.opt compound.statement
        constructor.conflicting.typedef.declarator :  ( TYPEDEFname postfixing.abstract.declarator )_;
        constructor.conflicting.typedef.declarator :  ( TYPEDEFname postfixing.abstract.declarator )_constructor.init.list.opt compound.statement
        member.pure.opt : _    (359)
        constructor.init.list.opt : _    (539)

        CONST  shift 63
        VOLATILE  shift 64
        :  shift 81
        =  shift 971
        ;  shift 1102
        {  reduce 539
        .  reduce 359

        type.qualifier.list  goto 1101
        type.qualifier  goto 46
        member.pure.opt  goto 1100
        constructor.init.list  goto 1069
        constructor.init.list.opt  goto 1103


1089: shift/reduce conflict (shift 1102, red'n 359) on ;
state 1089
        member.conflict.paren.postfix.declaring.item :  declaration.specifier ( TYPEDEFname postfixing.abstract.declarator )_member.pure.opt
        constructor.conflicting.typedef.declarator :  ( TYPEDEFname postfixing.abstract.declarator )_type.qualifier.list ;
        constructor.conflicting.typedef.declarator :  ( TYPEDEFname postfixing.abstract.declarator )_type.qualifier.list constructor.init.list.opt compound.statement
        constructor.conflicting.typedef.declarator :  ( TYPEDEFname postfixing.abstract.declarator )_;
        constructor.conflicting.typedef.declarator :  ( TYPEDEFname postfixing.abstract.declarator )_constructor.init.list.opt compound.statement
        member.pure.opt : _    (359)
        constructor.init.list.opt : _    (539)

        CONST  shift 63
        VOLATILE  shift 64
        :  shift 81
        =  shift 971
        ;  shift 1102
        {  reduce 539
        .  reduce 359

        type.qualifier.list  goto 1101
        type.qualifier  goto 46
        member.pure.opt  goto 1128
        constructor.init.list  goto 1069
        constructor.init.list.opt  goto 1103


123/127 terminals, 160/200 nonterminals
609/650 grammar rules, 1157/1200 states
25 shift/reduce, 7 reduce/reduce conflicts reported
243/350 working sets used
memory: states,etc. 13727/60000, parser 10871/12000
495/600 distinct lookahead sets
756 extra closures
7300 shift entries, 25 exceptions
1797 goto entries
4731 entries saved by goto default
Optimizer space used: input 18036/60000, output 8092/12000
8092 table entries, 3568 zero
maximum spread: 351, maximum offset: 1148
@@


1.3
log
@@*** empty log message ***
@@
text
@@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/RCS/grammar4.txt,v`; if test $1 -ne 63787
then
	echo ERROR: oxDistG1.04/grammars/c++/RCS/grammar4.txt,v checksum is $1 should be 63787
fi
set `wc -lwc <oxDistG1.04/grammars/c++/RCS/grammar4.txt,v`
if test $1$2$3 != 1697931369906
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/RCS/grammar4.txt,v are $* should be 1697 9313 69906
fi

chmod 755 oxDistG1.04/grammars/c++/RCS/grammar4.txt,v

if test -f oxDistG1.04/grammars/c++/RCS/skelgrph.c,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/RCS/skelgrph.c,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/RCS/skelgrph.c,v
	if test -f oxDistG1.04/grammars/c++/RCS/skelgrph.c,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/RCS/skelgrph.c,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/RCS/skelgrph.c,v
sed 's/^@//' >oxDistG1.04/grammars/c++/RCS/skelgrph.c,v <<'@EOF'
head     1.4;
access   ;
symbols  ;
locks    bischoff:1.4; strict;
comment  @ * @;


1.4
date     93.10.31.15.52.20;  author bischoff;  state Exp;
branches ;
next     1.3;

1.3
date     93.10.24.21.57.34;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.16.27.39;  author bischoff;  state Exp;
branches ;
next     1.1;

1.1
date     93.10.17.18.03.14;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@unpacked original from comp.compilers archive
@@


1.4
log
@@*** empty log message ***
@@
text
@@#include "defs.h"

/*  The three line banner used here should be replaced with a one line	*/
/*  #ident directive if the target C compiler supports #ident		*/
/*  directives.								*/
/*									*/
/*  If the skeleton is changed, the banner should be changed so that	*/
/*  the altered version can easily be distinguished from the original.	*/

char *banner[] =
{
    "#ifndef lint",
    "char yysccsid[] = \"@@(#)yaccpar	1.4 (Berkeley) 02/25/90 \\n\\",
    " Modified 5/2/90 by J. Roskind to support graphic debugging modes\";",
    "#endif",
    0
};


char *header[] =
{
    "#define yyclearin (yychar=(-1))",
    "#define yyerrok (yyerrflag=0)",
    "#ifndef YYSTACKSIZE",
    "#ifdef YYMAXDEPTH",
    "#define YYSTACKSIZE YYMAXDEPTH",
    "#else",
    "#define YYSTACKSIZE 300",
    "#endif",
    "#endif",
    "int yydebug;",
    "int yynerrs;",
    "int yyerrflag;",
    "int yychar;",
    "short *yyssp;",
    "YYSTYPE *yyvsp;",
    "YYSTYPE yyval;",
    "YYSTYPE yylval;",
    "#define yystacksize YYSTACKSIZE",
    "short yyss[YYSTACKSIZE];",
    "YYSTYPE yyvs[YYSTACKSIZE];",
    0
};


char *body[] =
{
    "#define YYABORT goto yyabort",
    "#define YYACCEPT goto yyaccept",
    "#define YYERROR goto yyerrlab",
    "#ifdef YYDEBUG",
    "#ifndef YYDEBUG_LEXER_TEXT /* pointer to the text isolated by the lexer*/",
    "#define YYDEBUG_LEXER_TEXT \"YYDEBUG_LEXER_TEXT not defined\"",
    "#endif",
    "#ifndef YYDEBUG_INDENT_STRING",
    "#define YYDEBUG_INDENT_STRING  \"|       \"",
    "#endif",
    "#ifndef YYDEBUG_REDUCE_STRING",
    "#define YYDEBUG_REDUCE_STRING  \"+-------\"",
    "#endif",
    "#ifndef YYDEBUG_INDENT",
    "YYDEBUG_INDENT(yyindent)",
    "int yyindent;",
    "{",
    "    while(yyindent-- > 0)",
    "        printf(\"%s\", YYDEBUG_INDENT_STRING);",
    "}",
    "#endif /* YYDEBUG_INDENT */",
    "#ifndef YYDEBUG_REDUCE",
    "YYDEBUG_REDUCE(yynew_state, yyrule_num, yyrule_string, yynew_indent, \\",
    "yyrhs_count)",
    "int yynew_state;",
    "int yyrule_num;",
    "char * yyrule_string;",
    "int yynew_indent;",
    "int yyrhs_count;",
    "{",
    "    if (1 < yyrhs_count)",
    "    {  /* draw the graphics for the reduction */",
    "        YYDEBUG_INDENT(yynew_indent);",
    "        while(1 < yyrhs_count--)",
    "            printf(\"%s\", YYDEBUG_REDUCE_STRING);",
    "        putchar('+'); /* left rotated L would look nice */",
    "        putchar('\\n');",
    "        YYDEBUG_INDENT(yynew_indent);",
    "        putchar('|'); /* down arrow would look nice */",
    "        putchar('\\n');",
    "    }",
    "    YYDEBUG_INDENT(yynew_indent);",
    "    /* Only print the resulting token name */",
    "    while (*yyrule_string && ' ' != *yyrule_string)",
    "        putchar(*yyrule_string++);",
    "    putchar('\\n');",
    "}",
    "#endif /* YYDEBUG_REDUCE */",
    "#ifndef YYDEBUG_SHIFT_LEXEME",
    "YYDEBUG_SHIFT_LEXEME(yyold_state, yynew_state, yytoken_string, yynew_indent)",
    "int yyold_state;",
    "int yynew_state;",
    "char * yytoken_string;",
    "int yynew_indent;",
    "{",
    "    YYDEBUG_INDENT(yynew_indent);",
    "    printf(\"%s <-- `%s'\\n\", yytoken_string, YYDEBUG_LEXER_TEXT);",
    "}",
    "#endif /*  YYDEBUG_SHIFT_LEXEME */",
    "#ifndef YYDEBUG_LOOK_AHEAD",
    "YYDEBUG_LOOK_AHEAD(yynew_state, yytoken_num, yytoken_string, yyindent)",
    "int yynew_state;",
    "int yytoken_num;",
    "char * yytoken_string;",
    "int yyindent;",
    "{",
    "    YYDEBUG_INDENT(yyindent);",
    "    printf(\"          .... look ahead at %s   `%s'\\n\",",
    "           yytoken_string,",
    "           (0 == yytoken_num)? \"\\0\": YYDEBUG_LEXER_TEXT);",
    "}",
    "#endif /* YYDEBUG_LOOK_AHEAD */",
    "#ifndef YYDEBUG_DISCARD_STATE",
    "YYDEBUG_DISCARD_STATE(yynew_state, yyindent)",
    "int yynew_state;",
    "int yyindent;",
    "{",
    "    if (0 < yyindent)",
    "    {  /* draw the graphics for the reduction */",
    "        YYDEBUG_INDENT(yyindent-1);",
    "        printf(\"%s\", YYDEBUG_REDUCE_STRING);",
    "        putchar('+'); /* left rotated L would look nice */",
    "        printf(\"  discarding state\\n\");",
    "        YYDEBUG_INDENT(yyindent-1);",
    "        putchar('|'); /* down arrow would look nice */",
    "        putchar('\\n');",
    "    }",
    "    else",
    "    {",
    "        if (0 == yyindent)",
    "            printf(\"discarding state\\n\");",
    "        else",
    "            printf(\"no more states to discard: parser will abort\\n\");",
    "    }",
    "}",
    "#endif /* YYDEBUG_DISCARD_STATE */",
    "#ifndef YYDEBUG_DISCARD_TOKEN",
    "YYDEBUG_DISCARD_TOKEN(yynew_state, yytoken_num, yytoken_string, yyindent)",
    "int yynew_state;",
    "int yytoken_num;",
    "char * yytoken_string;",
    "int yyindent;",
    "{",
    "    YYDEBUG_INDENT(yyindent);",
    "    printf(\"discarding token %s\\n\", yytoken_string);",
    "}",
    "#endif /* YYDEBUG_DISCARD_TOKEN */",
    "#ifndef YYDEBUG_SHIFT_ERROR_LEXEME",
    "YYDEBUG_SHIFT_ERROR_LEXEME(yyold_state, yynew_state, yyindent)",
    "int yyold_state;",
    "int yynew_state;",
    "int yyindent;",
    "{",
    "    YYDEBUG_INDENT(yyindent);",
    "    printf(\"error\\n\");",
    "}",
    "#endif /* YYDEBUG_SHIFT_ERROR_LEXEME */",
    "#endif /* YYDEBUG */",
    "int",
    "yyparse()",
    "{",
    "    register int yym, yyn, yystate;",
    "#if YYDEBUG",
    "    register char *yys;",
    "    extern char *getenv();",
    "",
    "    if (yys = getenv(\"YYDEBUG\"))",
    "    {",
    "        yyn = *yys;",
    "        if (yyn >= '0' && yyn <= '9')",
    "            yydebug = yyn - '0';",
    "    }",
    "#endif",
    "",
    "    yynerrs = 0;",
    "    yyerrflag = 0;",
    "    yychar = (-1);",
    "",
    "    yyssp = yyss;",
    "    yyvsp = yyvs;",
    "    *yyssp = yystate = 0;",
    "",
    "yyloop:",
    "    if (yyn = yydefred[yystate]) goto yyreduce;",
    "    if (yychar < 0)",
    "    {",
    "        if ((yychar = yylex()) < 0) yychar = 0;",
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            if (5 > yydebug)",
    "                printf(\"yydebug: state %d, reading %d (%s)\\n\", yystate,",
    "                        yychar, yys);",
    "            else",
    "                YYDEBUG_LOOK_AHEAD(yystate, yychar, yys, yyssp-yyss);",
    "        }",
    "#endif",
    "    }",
    "    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            if (5 > yydebug)",
    "                printf(\"yydebug: state %d, shifting to state %d\\n\",",
    "                        yystate, yytable[yyn]);",
    "            else",
    "                YYDEBUG_SHIFT_LEXEME(yystate, yytable[yyn], yys, yyssp-yyss);",
    "#endif",
    "        if (yyssp >= yyss + yystacksize - 1)",
    "        {",
    "            goto yyoverflow;",
    "        }",
    "        *++yyssp = yystate = yytable[yyn];",
    "        *++yyvsp = yylval;",
    "        yychar = (-1);",
    "        if (yyerrflag > 0)  --yyerrflag;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "        yyn = yytable[yyn];",
    "        goto yyreduce;",
    "    }",
    "    if (yyerrflag) goto yyinrecovery;",
    "#ifdef lint",
    "    goto yynewerror;",
    "#endif",
    "yynewerror:",
    "    yyerror(\"syntax error\");",
    "#ifdef lint",
    "    goto yyerrlab;",
    "#endif",
    "yyerrlab:",
    "    ++yynerrs;",
    "yyinrecovery:",
    "    if (yyerrflag < 3)",
    "    {",
    "        yyerrflag = 3;",
    "        for (;;)",
    "        {",
    "            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&",
    "                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    if (5 > yydebug)",
    "                        printf(\"yydebug: state %d, error recovery shifting\\",
    " to state %d\\n\", *yyssp, yytable[yyn]);",
    "                    else",
    "                        YYDEBUG_SHIFT_ERROR_LEXEME(*yyssp, yytable[yyn], yyssp-yyss);",
    "#endif",
    "                if (yyssp >= yyss + yystacksize - 1)",
    "                {",
    "                    goto yyoverflow;",
    "                }",
    "                *++yyssp = yystate = yytable[yyn];",
    "                *++yyvsp = yylval;",
    "                goto yyloop;",
    "            }",
    "            else",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    if (5 > yydebug)",
    "                        printf(\"yydebug: error recovery discarding state %d\
\\n\",",
    "                            *yyssp);",
    "                    else",
    "                        YYDEBUG_DISCARD_STATE(*yyssp, yyssp-yyss-1);",
    "#endif",
    "                if (yyssp <= yyss) goto yyabort;",
    "                --yyssp;",
    "                --yyvsp;",
    "            }",
    "        }",
    "    }",
    "    else",
    "    {",
    "        if (yychar == 0) goto yyabort;",
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",

    "            if (5 > yydebug)",
    "                printf(\"yydebug: state %d, error recovery discards token\
 %d (%s)\\n\",",
    "                    yystate, yychar, yys);",
    "            else ",
    "                YYDEBUG_DISCARD_TOKEN(yystate, yychar, yys, yyssp-yyss);",
    "        }",
    "#endif",
    "        yychar = (-1);",
    "        goto yyloop;",
    "    }",
    "yyreduce:",
    "    yym = yylen[yyn];",
    "    yyval = yyvsp[1-yym];",
    "#if YYDEBUG",
    "    if (yydebug)",
    "        if (5 > yydebug)",
    "            printf(\"yydebug: state %d, reducing by rule %d (%s)\\n\",",
    "                    yystate, yyn, yyrule[yyn]);",
    "        else",
    "            YYDEBUG_REDUCE(yystate, yyn, yyrule[yyn], yyssp-yyss-yym, yym);",
    "#endif",
    "    switch (yyn)",
    "    {",
    0
};


char *trailer[] =
{
    "    }",
    "    yyssp -= yym;",
    "    yystate = *yyssp;",
    "    yyvsp -= yym;",
    "    yym = yylhs[yyn];",
    "    if (yystate == 0 && yym == 0)",
    "    {",
    "#ifdef YYDEBUG",
    "        if (5 > yydebug)",
    "            printf(\"yydebug: after reduction, shifting from state 0 to\\",
    " state %d\\n\", YYFINAL);",
    "#endif",
    "        yystate = YYFINAL;",
    "        *++yyssp = YYFINAL;",
    "        *++yyvsp = yyval;",
    "        if (yychar < 0)",
    "        {",
    "            if ((yychar = yylex()) < 0) yychar = 0;",
    "#if YYDEBUG",
    "            if (yydebug)",
    "            {",
    "                yys = 0;",
    "                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "                if (!yys) yys = \"illegal-symbol\";",
    "                if (5 > yydebug)",
    "                    printf(\"yydebug: state %d, reading %d (%s)\\n\",",
    "                        YYFINAL, yychar, yys);",
    "                else",
    "                    YYDEBUG_LOOK_AHEAD(YYFINAL, yychar, yys, yyssp-yyss);",
    "            }",
    "#endif",
    "        }",
    "        if (yychar == 0) goto yyaccept;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)",
    "        yystate = yytable[yyn];",
    "    else",
    "        yystate = yydgoto[yym];",
    "#ifdef YYDEBUG",
    "    if (5 > yydebug)",
    "        printf(\"yydebug: after reduction, shifting from state %d \\",
    "to state %d\\n\", *yyssp, yystate);",
    "#endif",
    "    if (yyssp >= yyss + yystacksize - 1)",
    "    {",
    "        goto yyoverflow;",
    "    }",
    "    *++yyssp = yystate;",
    "    *++yyvsp = yyval;",
    "    goto yyloop;",
    "yyoverflow:",
    "    yyerror(\"yacc stack overflow\");",
    "yyabort:",
    "    return (1);",
    "yyaccept:",
    "    return (0);",
    "}",
    0
};


write_section(section)
char *section[];
{
    register int i;

    for (i = 0; section[i]; ++i)
    {
	++outline;
	fprintf(output_file, "%s\n", section[i]);
    }
}
@@


1.3
log
@@*** empty log message ***
@@
text
@@@


1.2
log
@@no change
@@
text
@@@


1.1
log
@@Initial revision
@@
text
@@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/RCS/skelgrph.c,v`; if test $1 -ne 50016
then
	echo ERROR: oxDistG1.04/grammars/c++/RCS/skelgrph.c,v checksum is $1 should be 50016
fi
set `wc -lwc <oxDistG1.04/grammars/c++/RCS/skelgrph.c,v`
if test $1$2$3 != 465144313356
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/RCS/skelgrph.c,v are $* should be 465 1443 13356
fi

chmod 755 oxDistG1.04/grammars/c++/RCS/skelgrph.c,v

if test -f oxDistG1.04/grammars/c++/RCS/README,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/RCS/README,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/RCS/README,v
	if test -f oxDistG1.04/grammars/c++/RCS/README,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/RCS/README,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/RCS/README,v
sed 's/^@//' >oxDistG1.04/grammars/c++/RCS/README,v <<'@EOF'
head     1.4;
access   ;
symbols  ;
locks    bischoff:1.4; strict;
comment  @# @;


1.4
date     93.10.31.15.51.58;  author bischoff;  state Exp;
branches ;
next     1.3;

1.3
date     93.10.24.21.36.58;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.16.24.18;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@README to accompany ox-adaptation of Jim Roskind's C++ parser.
@@


1.4
log
@@*** empty log message ***
@@
text
@@$Header: README,v 1.3 93/10/24 21:36:58 bischoff Exp $

The code in this directory originated as a Yacc/Lex specification
for a parser for the C++ language.  It came from an archive
mentioned in the comp.compilers monthly message.  It was built by
Jim Roskind.

Type `make docs' to unpack the documents and the source code.  This
checks the original files out of RCS.

This is an Ox-adaptation of Jim Roskinds's code.  None of the
original files have been changed.  They are Ox-ready as they are,
except that `cpp4.l' must be macro-expanded by the C preprocessor
`cpp' before being input to Ox.  `README' (this file) and `Makefile' 
have been added to what I took from the archive.  Pleae see Jim
Roskind's comments and policy statements in `freegrm4.txt' and
`grammar4.txt'.

Using `Makefile' and Ox to build `cplpl' results in a parser
that behaves in every way as the original Yacc/Lex parser, except
that it builds a `dummy' parse tree, (i.e., one without
attributes). For further information, see the Ox Tuturial
Introduction and the Ox User Reference Manual, which accompany
the Ox distribution.

Below the line of asterisks is the header of the shar script
taken from the original comp.compilers archive.

--Kurt Bischoff 10/17/93
***********************************************************************

#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 10/15/1990 19:12 UTC by johnl@@esegue
# Source directory /usr/johnl/c++grammar
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#  17792 -rw-rw-r-- freegrm4.txt
#  69254 -rw-rw-r-- grammar4.txt
#  25411 -rw-rw-r-- c4.y
#  15828 -rw-rw-r-- cpp4.l
#  70756 -rw-rw-r-- cpp4.y
#  12703 -rw-rw-r-- skelgrph.c
#
@@


1.3
log
@@*** empty log message ***
@@
text
@@d1 1
a1 1
$Header: README,v 1.2 93/10/17 16:24:18 bischoff Exp $
@@


1.2
log
@@*** empty log message ***
@@
text
@@d1 1
a1 1
$Header$
d7 3
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/RCS/README,v`; if test $1 -ne 49587
then
	echo ERROR: oxDistG1.04/grammars/c++/RCS/README,v checksum is $1 should be 49587
fi
set `wc -lwc <oxDistG1.04/grammars/c++/RCS/README,v`
if test $1$2$3 != 1084032602
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/RCS/README,v are $* should be 108 403 2602
fi

chmod 755 oxDistG1.04/grammars/c++/RCS/README,v

if test -f oxDistG1.04/grammars/c++/RCS/Makefile,v
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/RCS/Makefile,v\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/RCS/Makefile,v
	if test -f oxDistG1.04/grammars/c++/RCS/Makefile,v
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/RCS/Makefile,v, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/RCS/Makefile,v
sed 's/^@//' >oxDistG1.04/grammars/c++/RCS/Makefile,v <<'@EOF'
head     1.4;
access   ;
symbols  ;
locks    bischoff:1.4; strict;
comment  @# @;


1.4
date     93.10.31.15.52.02;  author bischoff;  state Exp;
branches ;
next     1.3;

1.3
date     93.10.24.21.37.07;  author bischoff;  state Exp;
branches ;
next     1.2;

1.2
date     93.10.17.16.25.10;  author bischoff;  state Exp;
branches ;
next     ;


desc
@@Makefile to cause Ox-generation of a dummy-parse-tree-building parser.
Preprocesses Jim Roskind's Yacc and Lex code for a C++ parser.
@@


1.4
log
@@*** empty log message ***
@@
text
@@# $Header: Makefile,v 1.3 93/10/24 21:37:07 bischoff Exp $

WF=c4.y cpp4.l cpp4.y freegrm4.txt grammar4.txt skelgrph.c

LEX=flex
YFLAGS=-dv
YMDEPS=-Ns1500 -Nm20000
OXFLAGS=-u 
CLIBS=-ll

# YACC=/usr/local/src/newsyn/syn/etc/berkeley/yacc/yacc
# OXFLAGS=-u -T
# CLIBS=-ll -lcurses -ltermcap

docs:
	co $(WF)

cplpl: y.tab.o lex.yy.o
	cc -o cplpl y.tab.o lex.yy.o $(CLIBS) 

oxout.y oxout.l: cpp4.y cpp4.l.exp
	ox $(OXFLAGS) cpp4.y cpp4.l.exp

cpp4.l.exp: cpp4.l y.tab.h
	cpp -C cpp4.l cpp4.l.exp

y.tab.c: oxout.y
	$(YACC) $(YFLAGS) $(YMDEPS) oxout.y

y.tab.h: cpp4.y
	$(YACC) $(YFLAGS) $(YMDEPS) cpp4.y ; rm y.tab.c

lex.yy.c: oxout.l
	$(LEX) oxout.l

lex.yy.o: lex.yy.c y.tab.h
	cc -c lex.yy.c

y.tab.o: y.tab.c
	cc -c y.tab.c

clean:
	rm oxout* y.output y.tab.h y.tab.c cpp4.l.exp lex.yy.c *.o cplpl

@@


1.3
log
@@*** empty log message ***
@@
text
@@d1 1
a1 1
# $Header: Makefile,v 1.2 93/10/17 16:25:10 bischoff Exp $
d15 1
a15 1
docs: $(WF)
@@


1.2
log
@@*** empty log message ***
@@
text
@@d1 1
a1 1
# $Header$
d3 2
d14 3
@@
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/RCS/Makefile,v`; if test $1 -ne 17800
then
	echo ERROR: oxDistG1.04/grammars/c++/RCS/Makefile,v checksum is $1 should be 17800
fi
set `wc -lwc <oxDistG1.04/grammars/c++/RCS/Makefile,v`
if test $1$2$3 != 1062221557
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/RCS/Makefile,v are $* should be 106 222 1557
fi

chmod 755 oxDistG1.04/grammars/c++/RCS/Makefile,v

chmod 755 oxDistG1.04/grammars/c++/RCS

if test -f oxDistG1.04/grammars/c++/README
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/README\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/README
	if test -f oxDistG1.04/grammars/c++/README
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/README, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/README
cat >oxDistG1.04/grammars/c++/README <<'@EOF'
$Header: README,v 1.4 93/10/31 15:51:58 bischoff Exp $

The code in this directory originated as a Yacc/Lex specification
for a parser for the C++ language.  It came from an archive
mentioned in the comp.compilers monthly message.  It was built by
Jim Roskind.

Type `make docs' to unpack the documents and the source code.  This
checks the original files out of RCS.

This is an Ox-adaptation of Jim Roskinds's code.  None of the
original files have been changed.  They are Ox-ready as they are,
except that `cpp4.l' must be macro-expanded by the C preprocessor
`cpp' before being input to Ox.  `README' (this file) and `Makefile' 
have been added to what I took from the archive.  Pleae see Jim
Roskind's comments and policy statements in `freegrm4.txt' and
`grammar4.txt'.

Using `Makefile' and Ox to build `cplpl' results in a parser
that behaves in every way as the original Yacc/Lex parser, except
that it builds a `dummy' parse tree, (i.e., one without
attributes). For further information, see the Ox Tuturial
Introduction and the Ox User Reference Manual, which accompany
the Ox distribution.

Below the line of asterisks is the header of the shar script
taken from the original comp.compilers archive.

--Kurt Bischoff 10/17/93
***********************************************************************

#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 10/15/1990 19:12 UTC by johnl@esegue
# Source directory /usr/johnl/c++grammar
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#  17792 -rw-rw-r-- freegrm4.txt
#  69254 -rw-rw-r-- grammar4.txt
#  25411 -rw-rw-r-- c4.y
#  15828 -rw-rw-r-- cpp4.l
#  70756 -rw-rw-r-- cpp4.y
#  12703 -rw-rw-r-- skelgrph.c
#
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/README`; if test $1 -ne 40718
then
	echo ERROR: oxDistG1.04/grammars/c++/README checksum is $1 should be 40718
fi
set `wc -lwc <oxDistG1.04/grammars/c++/README`
if test $1$2$3 != 512981954
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/README are $* should be 51 298 1954
fi

chmod 755 oxDistG1.04/grammars/c++/README

if test -f oxDistG1.04/grammars/c++/Makefile
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/Makefile\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/Makefile
	if test -f oxDistG1.04/grammars/c++/Makefile
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/Makefile, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/Makefile
cat >oxDistG1.04/grammars/c++/Makefile <<'@EOF'
# $Header: Makefile,v 1.4 93/10/31 15:52:02 bischoff Exp $

WF=c4.y cpp4.l cpp4.y freegrm4.txt grammar4.txt skelgrph.c

LEX=flex
YFLAGS=-dv
YMDEPS=-Ns1500 -Nm20000
OXFLAGS=-u 
CLIBS=-ll

# YACC=/usr/local/src/newsyn/syn/etc/berkeley/yacc/yacc
# OXFLAGS=-u -T
# CLIBS=-ll -lcurses -ltermcap

docs:
	co $(WF)

cplpl: y.tab.o lex.yy.o
	cc -o cplpl y.tab.o lex.yy.o $(CLIBS) 

oxout.y oxout.l: cpp4.y cpp4.l.exp
	ox $(OXFLAGS) cpp4.y cpp4.l.exp

cpp4.l.exp: cpp4.l y.tab.h
	cpp -C cpp4.l cpp4.l.exp

y.tab.c: oxout.y
	$(YACC) $(YFLAGS) $(YMDEPS) oxout.y

y.tab.h: cpp4.y
	$(YACC) $(YFLAGS) $(YMDEPS) cpp4.y ; rm y.tab.c

lex.yy.c: oxout.l
	$(LEX) oxout.l

lex.yy.o: lex.yy.c y.tab.h
	cc -c lex.yy.c

y.tab.o: y.tab.c
	cc -c y.tab.c

clean:
	rm oxout* y.output y.tab.h y.tab.c cpp4.l.exp lex.yy.c *.o cplpl

@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/Makefile`; if test $1 -ne 34686
then
	echo ERROR: oxDistG1.04/grammars/c++/Makefile checksum is $1 should be 34686
fi
set `wc -lwc <oxDistG1.04/grammars/c++/Makefile`
if test $1$2$3 != 4497803
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/Makefile are $* should be 44 97 803
fi

chmod 755 oxDistG1.04/grammars/c++/Makefile

echo mkdir - oxDistG1.04/grammars/c++/samples
mkdir oxDistG1.04/grammars/c++/samples

if test -f oxDistG1.04/grammars/c++/samples/hello.c
then
	echo Ok to overwrite existing file oxDistG1.04/grammars/c++/samples/hello.c\?
	read answer
	case "$answer" in
	[yY]*)	echo Proceeding;;
	*)	echo Aborting; exit 1;;
	esac
	rm -f oxDistG1.04/grammars/c++/samples/hello.c
	if test -f oxDistG1.04/grammars/c++/samples/hello.c
	then
		echo Error: could not remove oxDistG1.04/grammars/c++/samples/hello.c, aborting
		exit 1
	fi
fi
echo x - oxDistG1.04/grammars/c++/samples/hello.c
cat >oxDistG1.04/grammars/c++/samples/hello.c <<'@EOF'
main()
  {
   printf("hello, world\n");
  }
@EOF
set `sum $sumopt <oxDistG1.04/grammars/c++/samples/hello.c`; if test $1 -ne 47311
then
	echo ERROR: oxDistG1.04/grammars/c++/samples/hello.c checksum is $1 should be 47311
fi
set `wc -lwc <oxDistG1.04/grammars/c++/samples/hello.c`
if test $1$2$3 != 4544
then
	echo ERROR: wc results of oxDistG1.04/grammars/c++/samples/hello.c are $* should be 4 5 44
fi

chmod 755 oxDistG1.04/grammars/c++/samples/hello.c

chmod 755 oxDistG1.04/grammars/c++/samples

chmod 755 oxDistG1.04/grammars/c++

chmod 755 oxDistG1.04/grammars

chmod 755 oxDistG1.04

rm -f /tmp/unpack$$
exit 0
